{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/image/blog/79702-5d2b1c9e8970c3ea.jpeg","path":"image/blog/79702-5d2b1c9e8970c3ea.jpeg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168728769.jpg","path":"image/blog/imgFile1412168728769.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168834596.jpg","path":"image/blog/imgFile1412168834596.jpg","modified":0,"renderable":0},{"_id":"themes/fexo/source/css/styles.css","path":"css/styles.css","modified":0,"renderable":1},{"_id":"themes/fexo/source/css/styles.css.map","path":"css/styles.css.map","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","path":"fonts/calligraffitti-regular-webfont.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","path":"fonts/calligraffitti-regular-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","path":"fonts/calligraffitti-regular-webfont.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.svg","path":"fonts/fontello.svg","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.eot","path":"fonts/fontello.eot","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.ttf","path":"fonts/fontello.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/fonts/fontello.woff","path":"fonts/fontello.woff","modified":0,"renderable":1},{"_id":"themes/fexo/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/fexo/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"source/image/blog/79702-5660ac4cb51f6257.jpg","path":"image/blog/79702-5660ac4cb51f6257.jpg","modified":0,"renderable":0},{"_id":"themes/fexo/source/sass/styles.scss","path":"sass/styles.scss","modified":0,"renderable":1},{"_id":"source/image/blog/79702-8afbd2a4f48118bd.jpeg","path":"image/blog/79702-8afbd2a4f48118bd.jpeg","modified":0,"renderable":0},{"_id":"source/image/blog/79702-e7cf075365536286.jpeg","path":"image/blog/79702-e7cf075365536286.jpeg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168354773.jpg","path":"image/blog/imgFile1412168354773.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168608341.jpg","path":"image/blog/imgFile1412168608341.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168511771.jpg","path":"image/blog/imgFile1412168511771.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168755327.jpg","path":"image/blog/imgFile1412168755327.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168908105.jpg","path":"image/blog/imgFile1412168908105.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412172676130.jpg","path":"image/blog/imgFile1412172676130.jpg","modified":0,"renderable":0},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","path":"fonts/calligraffitti-regular-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/fexo/source/images/banboo.png","path":"images/banboo.png","modified":0,"renderable":1},{"_id":"source/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif","path":"image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif","modified":0,"renderable":0},{"_id":"source/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B531CE953267440FAA32A1DA644BFD68.png","path":"image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B531CE953267440FAA32A1DA644BFD68.png","modified":0,"renderable":0},{"_id":"source/image/blog/79702-d66ee9d1fd912b33.jpg","path":"image/blog/79702-d66ee9d1fd912b33.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168419938.jpg","path":"image/blog/imgFile1412168419938.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168441331.jpg","path":"image/blog/imgFile1412168441331.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168553899.jpg","path":"image/blog/imgFile1412168553899.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg","path":"image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png","path":"image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png","modified":0,"renderable":0},{"_id":"source/image/blog/memory-in-nodejs/V8的分代示意图.png","path":"image/blog/memory-in-nodejs/V8的分代示意图.png","modified":0,"renderable":0},{"_id":"source/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png","path":"image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png","modified":0,"renderable":0},{"_id":"source/image/blog/memory-in-nodejs/V8的堆内存示意图.png","path":"image/blog/memory-in-nodejs/V8的堆内存示意图.png","modified":0,"renderable":0},{"_id":"source/image/blog/memory-in-nodejs/V8的堆示意图.png","path":"image/blog/memory-in-nodejs/V8的堆示意图.png","modified":0,"renderable":0},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png","path":"image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png","modified":0,"renderable":0},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png","path":"image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png","modified":0,"renderable":0},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png","path":"image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png","modified":0,"renderable":0},{"_id":"source/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png","path":"image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png","path":"image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png","path":"image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png","path":"image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png","path":"image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png","modified":0,"renderable":0},{"_id":"source/image/blog/whatisAST/Python语法树.png","path":"image/blog/whatisAST/Python语法树.png","modified":0,"renderable":0},{"_id":"source/image/blog/whatisAST/javascript语法树.png","path":"image/blog/whatisAST/javascript语法树.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/3A60080FBC8767DB575C2D2919097613.png","path":"image/blog/understand-tcp-udp/3A60080FBC8767DB575C2D2919097613.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png","path":"image/blog/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png","path":"image/blog/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png","path":"image/blog/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png","path":"image/blog/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png","path":"image/blog/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png","path":"image/blog/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png","path":"image/blog/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/CFC6314E4B2FD039C450821D946E93E2.png","path":"image/blog/understand-tcp-udp/CFC6314E4B2FD039C450821D946E93E2.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/DB900F916ECD267746706FEA8DF682CD.png","path":"image/blog/understand-tcp-udp/DB900F916ECD267746706FEA8DF682CD.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png","path":"image/blog/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png","path":"image/blog/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png","modified":0,"renderable":0},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","path":"fonts/calligraffitti-regular-webfont.svg","modified":0,"renderable":1},{"_id":"source/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B415AA74BF5438CCEB2FEAEDD002B1BD.jpg","path":"image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B415AA74BF5438CCEB2FEAEDD002B1BD.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168592404.jpg","path":"image/blog/imgFile1412168592404.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168471850.jpg","path":"image/blog/imgFile1412168471850.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412168871884.jpg","path":"image/blog/imgFile1412168871884.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/whatisAST/表达式语法树比较.png","path":"image/blog/whatisAST/表达式语法树比较.png","modified":0,"renderable":0},{"_id":"source/image/blog/understand-tcp-udp/08EAF7F3E7FFCEF3E781385BF62BA2BC.png","path":"image/blog/understand-tcp-udp/08EAF7F3E7FFCEF3E781385BF62BA2BC.png","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg","path":"image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg","path":"image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/memory-in-nodejs/Chrome Profile.jpg","path":"image/blog/memory-in-nodejs/Chrome Profile.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg","path":"image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg","path":"image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412172691061.jpeg","path":"image/blog/imgFile1412172691061.jpeg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg","path":"image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg","path":"image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/imgFile1412172732788.jpg","path":"image/blog/imgFile1412172732788.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg","path":"image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif","path":"image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif","path":"image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif","path":"image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif","path":"image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif","modified":0,"renderable":0},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif","path":"image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif","modified":0,"renderable":0}],"Cache":[{"_id":"themes/fexo/.gitignore","hash":"32223fbe296f8e3026c689bad8f3dea9d0fcbb43","modified":1486047205000},{"_id":"themes/fexo/.csscomb.json","hash":"0bff596879c2556634b9a92abe5b1606dc77fd1c","modified":1486047205000},{"_id":"themes/fexo/LICENSE","hash":"db4cb5aef6072a96721b5428fdd999647c049d55","modified":1486047205000},{"_id":"themes/fexo/README.md","hash":"d581b3310a68611167707f40a7195d2b0ff85997","modified":1486047205000},{"_id":"themes/fexo/_config.yml","hash":"011f01fb78eb8e51c374c9063dca57cff8e859c6","modified":1486047205000},{"_id":"themes/fexo/gulpfile.js","hash":"56e96dcb5ede1bf49e1e0257065b4debecb1dbe1","modified":1486047205000},{"_id":"themes/fexo/package.json","hash":"e953428b355e27ea9fc1d2ff5eff7d6acf1b96aa","modified":1486047205000},{"_id":"source/about/index.md","hash":"507996d1aad09278bc94a499deecb92db633801e","modified":1486047205000},{"_id":"source/_posts/HTML-CSS-JS打造Windows桌面版《2048》.md","hash":"dee94acebd930cc55b7b2924df0b4fe5c6fb18b6","modified":1486047205000},{"_id":"source/_posts/JavaScript原型中的哲学思想.md","hash":"d3528c810e4334f70902f9750bfa80ff7c31462d","modified":1486047205000},{"_id":"source/_posts/NodeJS中被忽略的内存.md","hash":"9ef3835c397ba0d8a9e8c87cd0bcae59cd5d93a3","modified":1486047205000},{"_id":"source/_posts/Kissy-WaterFall-静态调用.md","hash":"ac3a9e0e3d0e0fa6d0d7df5581ce7445c228a3db","modified":1486047205000},{"_id":"source/_posts/Javascript那些书籍.md","hash":"873d4b34f8b7a7f895ed7010a5d376a68704b94e","modified":1486047205000},{"_id":"source/_posts/Kissy-WaterFall-实现手动加载数据.md","hash":"14f9833a7baaae37ba7934ab4bde63355e21077f","modified":1486047205000},{"_id":"source/_posts/SOAP-Web-Service的枢纽.md","hash":"d4a842ef9cb82cdb6304cc3c42428f4bdad3627a","modified":1486047205000},{"_id":"source/_posts/My-Nodejs-Tool-Kit.md","hash":"5730dbb1095736679fa5509b4fb2d02551e9d04f","modified":1486047205000},{"_id":"source/_posts/Session原理.md","hash":"a9df8f55cb4158cd31d3af0bfef240bc9a49540c","modified":1486047205000},{"_id":"source/_posts/iframe-在IE下透明背景.md","hash":"82c291f41aea36f74c3955461b232a073b200461","modified":1486047205000},{"_id":"source/_posts/do-you-konw-the-different-between-compiler-and-interpreter.md","hash":"5bd7712306a12045d959de1374b2980b92fbcde5","modified":1486047205000},{"_id":"source/_posts/jQuery动画反方向延伸.md","hash":"942e88d9e83c0b31ef096fbf8306ea7f4caba38e","modified":1486047205000},{"_id":"source/_posts/reconsidering-for-2017-Q1.md","hash":"9e64a99d0e5bf4b4156284df70e2f48dff564fe8","modified":1494755842000},{"_id":"source/_posts/the-memeye.md","hash":"6c3077ac5e2ef41632bbe50f7f69a52d2eba6e94","modified":1494755909000},{"_id":"source/_posts/gulp-base.md","hash":"5e2277106f77db2864251902ffe56a24938d68d3","modified":1488260997000},{"_id":"source/_posts/the-v8-what-javascripter-should-konw-of-v8-in-nodejs.md","hash":"26473dcc1fd98186636f38adb1f97e63b2da83f4","modified":1486047205000},{"_id":"source/_posts/keep-focus-and-efficiency.md","hash":"ce14907f8194a96cf1f8c7b2b07686e3efc4aa22","modified":1486047205000},{"_id":"source/_posts/「ES6笔记」 Babel.md","hash":"559e28d711d1245c68084ce696a5d6a303a6d605","modified":1486047205000},{"_id":"source/_posts/「理解HTTP」之常见的状态码.md","hash":"21e3c06da58fa2e100c37bb0f305847a5c2b54d7","modified":1486047205000},{"_id":"source/_posts/the-winter-and-summer-of-Meizu.md","hash":"f95e6035227f1a6b66b9de4d8b928551ea781cf4","modified":1486216978000},{"_id":"source/_posts/了解 Nginx 的基本概念.md","hash":"76355eb4e9ab3cc7a4bd768d74d3e3550e665483","modified":1486047205000},{"_id":"source/_posts/为什么使用Sails.md","hash":"f528e60f666322cc0df2db15fc8de105e4ff7a13","modified":1486047205000},{"_id":"source/_posts/二零一六年一月二十八日，于珠海.md","hash":"d6588ecae7b7cb865f56fcb191cb67fd527fc813","modified":1486047205000},{"_id":"source/_posts/下雨天的夜晚，特别容易失眠.md","hash":"f67460423c9b2ab5d74502a8fa6ebbdac52b8deb","modified":1486215376000},{"_id":"source/_posts/何为技术人的核心竞争力.md","hash":"f3292781c0f6e3e196f778fbefec87aac2a22a72","modified":1486047205000},{"_id":"source/_posts/何为语法树.md","hash":"b629f74fca54635d67352b77d5ea0948fbbedd22","modified":1486047205000},{"_id":"source/_posts/单点登录的三种实现方式.md","hash":"81a2a6242d3d2b5c2713765aae29fe0ea40e9d9b","modified":1486047205000},{"_id":"source/_posts/原生JavaScript实现拖拽效果.md","hash":"9be01fa3f5a736201a0eeacb074263cb13406848","modified":1486047205000},{"_id":"source/_posts/基于RESTful-API-怎么设计用户权限控制.md","hash":"7a4120ab1eebe44dbc3c691fbef3b6d61a2ae321","modified":1486047205000},{"_id":"source/_posts/在Nodejs中贯彻单元测试.md","hash":"d5ce2bbf935060c8d199b349a3a6b0e84e2c97c4","modified":1486047205000},{"_id":"source/_posts/打造高效个性Terminal（一）之 iTerm.md","hash":"92c787c476397ff0795d7945100dbb70d5476d5d","modified":1486047205000},{"_id":"source/_posts/打造高效个性Terminal（二）之 zsh.md","hash":"556065f6b5b36c9275bf521c9a0456755dfb05e2","modified":1486047205000},{"_id":"source/_posts/基于jQuery的2048游戏.md","hash":"17e4815abc52971f657237742e428bf60feecc3e","modified":1486047205000},{"_id":"source/_posts/如果你用GitHub，可以这样提高效率.md","hash":"0a024ee9e898c30063f3a8ca612bd94b6e83624a","modified":1486047205000},{"_id":"source/_posts/消息系统设计与实现「上篇」.md","hash":"c4d68767dd267b4bab39fc33ae2caf2389328a7f","modified":1486047205000},{"_id":"source/_posts/消息系统设计与实现「下篇」.md","hash":"e4837d02d38c22615890d7949091ddfb294aa309","modified":1486047205000},{"_id":"source/_posts/盘点国内的那些ROM.md","hash":"827e13996011e664e5a33b94e15e29227753704d","modified":1486047205000},{"_id":"source/_posts/登录那些事儿.md","hash":"d87aa0e310c4369db8a1f51f586b37a2bd4196fe","modified":1486047205000},{"_id":"source/_posts/理解 CORS (Cross-Origin Resource Sharing).md","hash":"1e0b978b71aef822fcbc383e29bb3a0a135d0fed","modified":1486047205000},{"_id":"source/category/index.md","hash":"838a0ba6b58f4def2b6b3c0d5841288f801bdb85","modified":1486047205000},{"_id":"source/_posts/读《重来》.md","hash":"899517e30f6b1728765618c3d0b5cae0d367d972","modified":1486047205000},{"_id":"source/link/index.md","hash":"70bd0de52901bac812f76d5510925361a7921d99","modified":1486047205000},{"_id":"source/_posts/那一夜独处.md","hash":"871f04ce82d32dafc6985e52aa232be4e87af245","modified":1486047205000},{"_id":"source/tag/index.md","hash":"bee4c19d66746750628e1e0ba397e6623a31d70a","modified":1486047205000},{"_id":"themes/fexo/languages/zh-TW.yml","hash":"6141b4c7a094c74bd9df7c08908d92b561c1a0c0","modified":1486047205000},{"_id":"themes/fexo/languages/default.yml","hash":"fd7397be7789b43c1c163ab4faf106318811c2a8","modified":1486047205000},{"_id":"themes/fexo/layout/archive.ejs","hash":"422e16d5764c2a4fced79d35b383427762c164ec","modified":1486047205000},{"_id":"themes/fexo/languages/no.yml","hash":"bf11017d77f64fbafb9c99ac219d076b20d53afc","modified":1486047205000},{"_id":"themes/fexo/languages/zh-CN.yml","hash":"751c74830d5609969f1fd6e7fa933ecd5756117a","modified":1486047205000},{"_id":"themes/fexo/layout/about.ejs","hash":"3c2434040bcf87bdda96a27cbc20e930ac1541c0","modified":1486047205000},{"_id":"themes/fexo/layout/index.ejs","hash":"9d33cd03e7a8adf8bbc124c248def36c15e681d0","modified":1486047205000},{"_id":"themes/fexo/layout/category.ejs","hash":"2c2581888efd1e6c0678e3826f411361f4c09c2d","modified":1486047205000},{"_id":"themes/fexo/layout/link.ejs","hash":"f5ca0c4e4827dbbaa4b482f37cebe5fd3dd4bb54","modified":1486047205000},{"_id":"themes/fexo/layout/layout.ejs","hash":"383a34e8ae4c366c5e4062a483a7505315d3f0de","modified":1486047205000},{"_id":"themes/fexo/layout/post.ejs","hash":"af8f0cf2a1eecd7fb0e2e9e3493169c9dd3e5177","modified":1486047205000},{"_id":"themes/fexo/layout/tag.ejs","hash":"26f81bacc2c895af05553a29b5698115b7ee0dd7","modified":1486047205000},{"_id":"source/image/blog/79702-5d2b1c9e8970c3ea.jpeg","hash":"7a32620c73edcce6e9c3163b7b0a9e27659701b4","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168728769.jpg","hash":"2b3e55629a2d38db708b2e2e26d085918738af95","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168834596.jpg","hash":"b65d6af4f2310c741a424f7944f6cf473d74f2e1","modified":1486047205000},{"_id":"source/image/blog/.DS_Store","hash":"e2284d1c7a057523858c0706cbb05f5666eccbe2","modified":1488435517000},{"_id":"themes/fexo/layout/_partial/article.ejs","hash":"24149a8733eafaff5531a362da84b85962a91bb8","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/duoshuo.ejs","hash":"b316efc4f4327ac2f4a59fefc643986b26852147","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/disqus.ejs","hash":"dd3f6f24f4309e29abedab07e64f96d4f19a3f04","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/baidu-analytics.ejs","hash":"c19e4abec19c23840fff7f8a51f4aefbb2b7e8ca","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/head.ejs","hash":"8742af81d895e7da09041313b8bfeb0c21944933","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/home.ejs","hash":"675c2ae2f54eb00a156eef941884f64106c3ed5c","modified":1486047205000},{"_id":"themes/fexo/source/css/styles.css","hash":"6bcf0b985e6fc5c65dbed8ddf2b583ad1625edf7","modified":1486047205000},{"_id":"themes/fexo/source/css/styles.css.map","hash":"8aca3e2dff7497e38a06f9c7e3acc8f56a9b092d","modified":1486047205000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","hash":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1486047205000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","hash":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1486047205000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","hash":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1486047205000},{"_id":"themes/fexo/source/fonts/fontello.svg","hash":"0f92b6502168f5a19a55f5634c77a97478afe287","modified":1486047205000},{"_id":"themes/fexo/source/fonts/fontello.eot","hash":"5bf6ba90293fc9b3fc2954e92c3295935921a875","modified":1486047205000},{"_id":"themes/fexo/source/fonts/fontello.ttf","hash":"daeed4d37b75df2c810cb2cb4d503f886e3fdd0d","modified":1486047205000},{"_id":"themes/fexo/source/fonts/fontello.woff","hash":"89064aff04e74c2ce0033eb9862b65a4ea6b12bf","modified":1486047205000},{"_id":"themes/fexo/source/images/avatar.jpg","hash":"b7b97c6861cc09185eb148c096c61a1b3da68e5a","modified":1486047205000},{"_id":"themes/fexo/source/sass/_base.scss","hash":"c99b5792c17d940d84fecaff1edc5f05aaa2ca11","modified":1486047205000},{"_id":"themes/fexo/source/sass/_animate.scss","hash":"8de97c948cb4b9c9b7a87c0f7332ed534c378e26","modified":1486047205000},{"_id":"themes/fexo/source/images/favicon.ico","hash":"1bc51dc506b463f57ce91d15e28eb09bc23d374f","modified":1486047205000},{"_id":"themes/fexo/source/sass/_common.scss","hash":"74335b48064cf751344ae115fc406971d4912648","modified":1486047205000},{"_id":"themes/fexo/source/sass/_highlight-js.scss","hash":"998498183d116a4b06e2cda618243d0157cff19d","modified":1486047205000},{"_id":"themes/fexo/source/sass/_normalize.scss","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1486047205000},{"_id":"themes/fexo/source/sass/_fontello.scss","hash":"5d4ec9a643b10be021f8cd4e01e240de37c97b6e","modified":1486047205000},{"_id":"themes/fexo/source/sass/_fonts.scss","hash":"56820bc0e20e82d6dfd09fc8329b71a287892916","modified":1486047205000},{"_id":"themes/fexo/source/sass/_variable.scss","hash":"9e54a44b85bc3324ea641a431229c377e7bfcb66","modified":1486047205000},{"_id":"themes/fexo/source/sass/_type.scss","hash":"0c749945e5d90f6c4aa5a6ea95d7e3ef853d1f3a","modified":1486047205000},{"_id":"source/image/blog/79702-5660ac4cb51f6257.jpg","hash":"ed6b1882f3dc96eeee24342ef49988ebf77c1260","modified":1486047205000},{"_id":"themes/fexo/source/sass/styles.scss","hash":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be","modified":1486047205000},{"_id":"source/image/blog/79702-8afbd2a4f48118bd.jpeg","hash":"c41894ff92fb004f06fb064c8cdfa19d6bb1058a","modified":1486047205000},{"_id":"source/image/blog/79702-e7cf075365536286.jpeg","hash":"0c9cb904120a6bed2e675da14db01331438bdea6","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168354773.jpg","hash":"615642e03176c66248336defa5cc735059fa63f2","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168608341.jpg","hash":"b7d21357f7f906d363ac5009baaa8748bc9c0c15","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168511771.jpg","hash":"3d7c8ce758c2f4452485dd1d757f29b8e0afdaf8","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168755327.jpg","hash":"b7d21357f7f906d363ac5009baaa8748bc9c0c15","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168908105.jpg","hash":"b3a7e2d223bab42c1e9892b15bb1cd2ca528fc62","modified":1486047205000},{"_id":"source/image/blog/imgFile1412172676130.jpg","hash":"340d6fbadcc15852645f0770f8379d6c8e500bdc","modified":1486047205000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","hash":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1486047205000},{"_id":"themes/fexo/source/images/banboo.png","hash":"46616d28714102881c0f0ee3e05ba4520d02c999","modified":1486047205000},{"_id":"themes/fexo/source/sass/pages/_tag.scss","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486047205000},{"_id":"source/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif","hash":"868e2fd30051c693bebd9dd91d3ceede24a2e863","modified":1486047205000},{"_id":"source/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B531CE953267440FAA32A1DA644BFD68.png","hash":"64055a621546c70e5fde53aae72e3bb7ca590dad","modified":1486047205000},{"_id":"source/image/blog/79702-d66ee9d1fd912b33.jpg","hash":"327ef3be9eaa9d570b2e279d6e2fb9f25106a82e","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168419938.jpg","hash":"b53e4c388cad1d47e9563e4e94132e5185a97057","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168441331.jpg","hash":"a102efc197f5f290516316323d00f760fb5bda21","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168553899.jpg","hash":"ecbc7f8cd2d4fd5458ed7a66572f8cc249c09334","modified":1486047205000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg","hash":"ede513572ec495a8e0c8ad4fa79e208b45f5d418","modified":1486047205000},{"_id":"source/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png","hash":"4e9b1da90be242224b1bce0e8a65cc685635c437","modified":1486047205000},{"_id":"source/image/blog/memory-in-nodejs/V8的分代示意图.png","hash":"52cc0c583bb3ea4211743f05d2dca50ab7424159","modified":1486047205000},{"_id":"source/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png","hash":"79a362733e7e457c848b2a8b71bac8087f0e3c26","modified":1486047205000},{"_id":"source/image/blog/memory-in-nodejs/V8的堆内存示意图.png","hash":"1018a600ec1dcd69a9db256c7f00ec2c129a2a3e","modified":1486047205000},{"_id":"source/image/blog/memory-in-nodejs/V8的堆示意图.png","hash":"8df2d5ba5621249d2a0b8ab4bc682a7e204f7ff2","modified":1486047205000},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png","hash":"5e539fd4304d709ee7fce494b858c9f5ac1d5f2d","modified":1486047205000},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png","hash":"26ab9b4670e1214b412d2e322f9fc7bba017acfd","modified":1486047205000},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png","hash":"4d9c4ab5fedcf04052fb584c0794743d70883e3e","modified":1486047205000},{"_id":"source/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png","hash":"17abe246eb6ae6523c0e9291fd5f2457f2230876","modified":1486047205000},{"_id":"source/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png","hash":"994b09ceb5f0561f8dcdcdf9d384ed723a193168","modified":1486047205000},{"_id":"source/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png","hash":"cc7d13236f9e12f09bf6a0f242def476eb3358fd","modified":1486047205000},{"_id":"source/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png","hash":"189efea61c3757dc42472b02ba6527757368d343","modified":1486047205000},{"_id":"source/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png","hash":"d6d5140d0d6c9449062ad0d13a17d8dc001adfe2","modified":1486047205000},{"_id":"source/image/blog/whatisAST/Python语法树.png","hash":"6a5d39718236537dd906ef57b361ce03828742c6","modified":1486047205000},{"_id":"source/image/blog/whatisAST/javascript语法树.png","hash":"b07f6f8231fc8aaedf41af1c89764d4b345eec65","modified":1486047205000},{"_id":"source/image/blog/understand-tcp-udp/3A60080FBC8767DB575C2D2919097613.png","hash":"4942e3b30f753701c5aca54af249cb686602547c","modified":1488435073000},{"_id":"source/image/blog/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png","hash":"db440a0bc227c77ecf57e954ff5c6c1994720939","modified":1488435073000},{"_id":"source/image/blog/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png","hash":"761afeaf9764913a4b253ff0876377824d72727e","modified":1488435073000},{"_id":"source/image/blog/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png","hash":"a10efa9e588a291542fef0c5a6b28e662ddd2d67","modified":1488435073000},{"_id":"source/image/blog/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png","hash":"82c360ada66472252f9cfcabea6e3cdb626e7340","modified":1488435073000},{"_id":"source/image/blog/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png","hash":"4f27ac7e3cf0d7dbf41c92fdd94dd6a22456be3f","modified":1488435073000},{"_id":"source/image/blog/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png","hash":"ba9b0df516e6fe14ccf9a78d983f50a4e164f2d0","modified":1488435073000},{"_id":"source/image/blog/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png","hash":"b487ebb98540d92ef33c9dab2a21d512ab003ca8","modified":1488435073000},{"_id":"source/image/blog/understand-tcp-udp/CFC6314E4B2FD039C450821D946E93E2.png","hash":"5c4171641dbbc785ece72a98cd83a19d6fdb31fd","modified":1488435073000},{"_id":"source/image/blog/understand-tcp-udp/DB900F916ECD267746706FEA8DF682CD.png","hash":"8d6e1b2004225d2bcb849a272921f5925ff8716b","modified":1488435073000},{"_id":"themes/fexo/layout/_partial/component/category-box.ejs","hash":"497bb978e6bc81a79cd2dc80fa355d57335f0b81","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/component/category.ejs","hash":"3c5ce7e2ae4c68525b1b18ba425f6b57cfb32b23","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/component/date.ejs","hash":"163fbd874481cb9e2b6da5282701a3fbaa4e367a","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/component/item-category-name.ejs","hash":"8ab52c9b5d5db1d3c1d343ecb405c4e15cd144ac","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/component/item-post.ejs","hash":"722e5dbde2d4683eea08f2af922358db45b253b1","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/component/item-tag.ejs","hash":"1b4c4e090c33ccfd44b531a5de9af16eec266512","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/component/item-year.ejs","hash":"9cfdc6ec2733bdb6eba301efbb5d126c032e4810","modified":1486047205000},{"_id":"source/image/blog/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png","hash":"6f8aeee9e1e2f15bd0c2b5a9595ad39f0752da42","modified":1488435073000},{"_id":"themes/fexo/layout/_partial/component/tag-box.ejs","hash":"33467eb5c760502eb75dcad63a4527a1f68deb95","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/component/pagination.ejs","hash":"ffbb548aee6e15cae924ee7f922f28b2403e8e45","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/component/page-header.ejs","hash":"33239c0e06a269a10404e613d8e531fe7fc1c479","modified":1486047205000},{"_id":"source/image/blog/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png","hash":"5bc7f4d044710583461481c6dc216b1ee972ce6d","modified":1488435073000},{"_id":"themes/fexo/layout/_partial/component/title.ejs","hash":"6ab4c0769db4507d7fe1ffee1e69f988309309ff","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/component/toolbox.ejs","hash":"dcd62744d191ac42bf3ed628b5b75318ece1c29d","modified":1486047205000},{"_id":"themes/fexo/layout/_partial/component/tag-list.ejs","hash":"8535c40b573744ced738b051383c0feca80eb0e9","modified":1486047205000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","hash":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_category-box.scss","hash":"d0acffc90a6d2a4cc831eb4a56817175bf11de5a","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_item-post.scss","hash":"2f9d1dbf812316212ac454df4ca8330fe18eb94e","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_item-category-name.scss","hash":"119840d160cd263b57e79e2099a81079d7eeee3d","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_index.scss","hash":"96c1843ece079e60dd22213a71fbc4c1b47481dc","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_list-post.scss","hash":"43564f6443385bf34e15672d1477d1c7560f5563","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_item-year.scss","hash":"12c147dd4ab9587cd622083c86c2f6cf07d8e26a","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_item-title.scss","hash":"cdaca2858abc9428ef01103a7fbea8f095d856aa","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_page-header.scss","hash":"ae1e49ab72f6967f39c1ac3dcf70aceb18947e15","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_pagination.scss","hash":"12c1880c518aee2e3ccf59661d01c308639f8a9e","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_tag-box.scss","hash":"734a42dc10cfc4997138d5550da090be1e0530b9","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_toc.scss","hash":"92e80e71409fafec3e628bdc9e7475238d714d71","modified":1486047205000},{"_id":"themes/fexo/source/sass/pages/_about.scss","hash":"b5b1d941525f6e14e7121ac73ba71dacbee68264","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_toolbox.scss","hash":"72b1dc1afe84d98bdb7f334b4155bbe795abd909","modified":1486047205000},{"_id":"themes/fexo/source/sass/component/_table.scss","hash":"4899fb31d1be8d5c9c397fcbcfc2ff0c5b2e7f7f","modified":1486047205000},{"_id":"themes/fexo/source/sass/pages/_archive.scss","hash":"fefd54282a42ebb68b711f1cfefa1f67abbde05b","modified":1486047205000},{"_id":"themes/fexo/source/sass/pages/_category.scss","hash":"d941753c053873213126e4d74bfa6439a3d41f30","modified":1486047205000},{"_id":"themes/fexo/source/sass/pages/_home.scss","hash":"1bdd6b412651ac52d472e8f4e40bebf06760e501","modified":1486047205000},{"_id":"themes/fexo/source/sass/pages/_index.scss","hash":"a27451e7332d29335f7c244516af884d4b23ac4c","modified":1486047205000},{"_id":"themes/fexo/source/sass/pages/_post.scss","hash":"aecb39ca01c046f667b72452523b1b901da75332","modified":1486047205000},{"_id":"themes/fexo/source/sass/pages/_link.scss","hash":"c58821e6c2ec26b6f135ec909c2cbd53d4a0a933","modified":1486047205000},{"_id":"source/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B415AA74BF5438CCEB2FEAEDD002B1BD.jpg","hash":"4a7b1bfe9c43fe6686c63c1c3ec564e5f35bc93a","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168592404.jpg","hash":"42332077b117269f80c6b67956f3be5fbae7381a","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168471850.jpg","hash":"3e80fe9317e3ffb83cacb0cb221997239b3e266b","modified":1486047205000},{"_id":"source/image/blog/imgFile1412168871884.jpg","hash":"99f1bca6f95282e7d3c8b5207b9abe56c3dc0df9","modified":1486047205000},{"_id":"source/image/blog/whatisAST/表达式语法树比较.png","hash":"b1bb37c84d0f5f4973f69462280ef5f445b84df6","modified":1486047205000},{"_id":"source/image/blog/understand-tcp-udp/08EAF7F3E7FFCEF3E781385BF62BA2BC.png","hash":"d73b8bac756532c4df7ed9d7083e4ac1cd50a378","modified":1488435073000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg","hash":"6a258996a300f1da8215fc59445d10ed22243843","modified":1486047205000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg","hash":"c066d3bf30b582c088ec0ff5c39d9d1b0c8ef520","modified":1486047205000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg","hash":"e808f11256c83a5f56aafa2b6dd8866aa39fd29f","modified":1486047205000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg","hash":"aaf5f88a18f3dc9554fd69ff3ecda8c277799c1c","modified":1486047205000},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg","hash":"78dbefd05cce7898df2da0b179d3535e185adee8","modified":1486215415000},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg","hash":"5d7f7f6e62f9a832af44afc4b89ae97775992a3f","modified":1486215415000},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg","hash":"ec96ec66b1c84e658e245be91110320f19555b5b","modified":1486215415000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg","hash":"ffb8ddfb41ea9a89b391c70a98fcf24883ef7d25","modified":1486047205000},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg","hash":"6ad1dd6ae6893416076b8577d5dfb1699a754905","modified":1486215415000},{"_id":"source/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg","hash":"815f173caef5df64955e7bc5eb06da1a0f5cdd34","modified":1486047205000},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg","hash":"a3ceddd956d7fcc0734608c2c07231b228f7b15b","modified":1486215415000},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg","hash":"4936bfbdf0d1e969f0c71de032b89d5df8439cd6","modified":1486215415000},{"_id":"source/image/blog/memory-in-nodejs/Chrome Profile.jpg","hash":"8b40dcb35047089cfefc0e6df2f4d0486d7057e0","modified":1486047205000},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg","hash":"d55dbe18ade80c0bba080f7aab3e1be07b36af43","modified":1486215415000},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg","hash":"cf15edd89c2d929a515b3ff0005a2515493ca79d","modified":1486215415000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg","hash":"f723e8e46b7d01983901afe6cf925b152a1ca18c","modified":1486047205000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg","hash":"7101047022342969f633dbadd4f6fe796e36add8","modified":1486047205000},{"_id":"source/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg","hash":"c03cfd4a333e24ebc1ff86fd313c711d7e92d963","modified":1486047205000},{"_id":"source/image/blog/imgFile1412172691061.jpeg","hash":"2cc9735fef8ed5fc27ea1348cdf4be3e6bb9e5b9","modified":1486047205000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg","hash":"498768a0462d7d20bcf2e9849b97c7e01c665151","modified":1486047205000},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg","hash":"4f4565e650b1ae3485c514a17cc3368a25bbfbdd","modified":1486215415000},{"_id":"source/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg","hash":"c241a425cf59f461b33f6cca7d99c13528d9f7a2","modified":1486215415000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg","hash":"d5181add5da735b87267fc1269a2b6dce5cae619","modified":1486047205000},{"_id":"source/image/blog/imgFile1412172732788.jpg","hash":"c9000526a5451475b95f060de359dfba87c7ff22","modified":1486047205000},{"_id":"source/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg","hash":"7e9f7eef4724b0497d522262e396360caad17234","modified":1486047205000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif","hash":"add32ba300895037b01b0906932ca7546897b954","modified":1486047205000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif","hash":"6968b32dc2c717a05db2102b10516fc3075c06ae","modified":1486047205000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif","hash":"3d2463493d7ba19f6222bce70c7f094e5e6fd319","modified":1486047205000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif","hash":"8e86ad70d0af226cd59667b7d0c419cf2a40d483","modified":1486047205000},{"_id":"source/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif","hash":"9c7256ff02cb93df14db78ce7a091b2c564a6261","modified":1486047205000},{"_id":"public/atom.xml","hash":"67b0f62c1b8eee0f8f09079032602ed6a8a4afdb","modified":1500129680657},{"_id":"public/about/index.html","hash":"39dcdd7acfa46f503cf22b2400fe6af1f694f6e9","modified":1494773700620},{"_id":"public/category/index.html","hash":"c74f2d860b7fac5892f0665a830eef72e024164f","modified":1500129681190},{"_id":"public/link/index.html","hash":"6e747d367b5143b9a39026e0b6d27b44ed1f15c7","modified":1494773700636},{"_id":"public/2016/08/30/何为技术人的核心竞争力/index.html","hash":"8e4ee71dee263f0b513505fc77100b989c64a8fd","modified":1494773700637},{"_id":"public/2016/08/11/打造高效个性Terminal（一）之 iTerm/index.html","hash":"c407c80d5e2e9bb373bfad503497a85e72156000","modified":1494773700637},{"_id":"public/2016/05/28/下雨天的夜晚，特别容易失眠/index.html","hash":"668fa1189d415bb96f648469aa3bb637eddf088c","modified":1494773700637},{"_id":"public/2016/01/28/二零一六年一月二十八日，于珠海/index.html","hash":"af62aeed4c8215f32cfb0274225d217101e517b8","modified":1494773700637},{"_id":"public/2016/01/15/如果你用GitHub，可以这样提高效率/index.html","hash":"86d523a8c4e8a0a1e74bb4c7d386b2241345ab57","modified":1494773700637},{"_id":"public/2015/12/30/那一夜独处/index.html","hash":"bb933e8b2a1278f6305fb9457bdc0cd0e6394d94","modified":1494773700637},{"_id":"public/2015/12/14/登录那些事儿/index.html","hash":"9be4f74327a346843fae8738ce315e332bcfba14","modified":1494773700637},{"_id":"public/2015/09/14/单点登录的三种实现方式/index.html","hash":"a2329cb1832e1d504825d91a541bb6e90a566b71","modified":1494773700637},{"_id":"public/2015/07/14/Session原理/index.html","hash":"82e6d514cb7725277b28a6444333c7c14727116e","modified":1494773700637},{"_id":"public/2015/01/12/SOAP-Web-Service的枢纽/index.html","hash":"4e9a11c1f5c815340ffe87846302b51b73b99ff8","modified":1494773700637},{"_id":"public/2014/07/19/HTML-CSS-JS打造Windows桌面版《2048》/index.html","hash":"21c8dcc73202cf277cf9d3d76d04b6f0215a2262","modified":1494773700637},{"_id":"public/2014/07/12/基于jQuery的2048游戏/index.html","hash":"49bfdd08a8250ea9574c3765b54f4d72b9c4ffaf","modified":1494773700637},{"_id":"public/2014/07/08/Javascript那些书籍/index.html","hash":"ace81449f31a3b341516fca71925e4f1f93b5d4b","modified":1494773700637},{"_id":"public/2013/08/07/iframe-在IE下透明背景/index.html","hash":"197ceead2a3e734e1c1327cd7624220b58c6e912","modified":1494773700637},{"_id":"public/2013/07/21/jQuery动画反方向延伸/index.html","hash":"a90e8052a72897e414c3b0d183bba97d525afc8a","modified":1494773700637},{"_id":"public/2013/03/07/Kissy-WaterFall-静态调用/index.html","hash":"5a6b0cd2e1c0f7e356d4f2cb194005b78d4e6d62","modified":1494773700637},{"_id":"public/archives/index.html","hash":"568b022b0b746aead3b9f6ab380c6544412d2954","modified":1500129681198},{"_id":"public/archives/2013/index.html","hash":"02e7df778001bf84a8a430eef082f2fd3a60730c","modified":1494773700638},{"_id":"public/archives/2013/03/index.html","hash":"938a1072f4f07c7d41c91f5546afbf34039be4da","modified":1494773700638},{"_id":"public/archives/2013/07/index.html","hash":"8d07b562c97db7e9fba42bd331c05884c988056a","modified":1494773700638},{"_id":"public/archives/2013/08/index.html","hash":"b2d3d14a9becdea6e7f36cd776397e84197ad76f","modified":1494773700638},{"_id":"public/archives/2014/index.html","hash":"d2e372dc4c87f9710cfbb2987c3646573b8b6647","modified":1494773700638},{"_id":"public/archives/2014/07/index.html","hash":"f5777f81e44c5feaa488eae2dd3ff6d2da31be58","modified":1494773700638},{"_id":"public/archives/2015/index.html","hash":"21d675a94506dcebfd29c9c66b51fe8b10aa4cdd","modified":1494773700638},{"_id":"public/archives/2015/01/index.html","hash":"01d8a08625f13646c15a48b258813337b42a0f50","modified":1494773700638},{"_id":"public/archives/2015/03/index.html","hash":"a02c1234d26b7b7b425cd6d6d5c3587ab0b3c457","modified":1494773700638},{"_id":"public/archives/2015/04/index.html","hash":"a09d45224c24b603e785094ce64f9c018ed8d598","modified":1494773700638},{"_id":"public/archives/2015/07/index.html","hash":"e66f812a9c442ba566910b4dd15ea4e8039789ce","modified":1494773700638},{"_id":"public/archives/2015/09/index.html","hash":"df623023cf012a3053b25bdc86b9a94fce1c0901","modified":1494773700638},{"_id":"public/archives/2015/10/index.html","hash":"c9c96a89803a0ed536b8d3a9f921823651bd2da7","modified":1494773700638},{"_id":"public/archives/2015/11/index.html","hash":"7b6e3e6457619118775dd93c001cbeeccb9b7b39","modified":1494773700638},{"_id":"public/archives/2015/12/index.html","hash":"f9120ae94d2c421a47998a190294335285bc0204","modified":1494773700638},{"_id":"public/archives/2016/index.html","hash":"ab06e4fcd61358aab860c1b0b09dc7a32c7f7c1a","modified":1500129681199},{"_id":"public/archives/2016/01/index.html","hash":"6c68a5d129046784bdf099bf1d645a0318824516","modified":1494773700638},{"_id":"public/archives/2016/03/index.html","hash":"4b9da10ee715c2b5b928b7fb546ad3140d061d33","modified":1494773700638},{"_id":"public/archives/2016/04/index.html","hash":"658b91bd530e5097c60edeef1cebff43847e3fc8","modified":1494773700638},{"_id":"public/archives/2016/05/index.html","hash":"be03deeb54541a0be414b5562734953e60eebeed","modified":1494773700638},{"_id":"public/archives/2016/06/index.html","hash":"bca99fc8d2fe6f3e75ffa7eff0557126f690325a","modified":1494773700638},{"_id":"public/archives/2016/07/index.html","hash":"97175f10ea98f4fe94d1f4ac968116efa2058405","modified":1494773700638},{"_id":"public/archives/2016/08/index.html","hash":"f72c4c6e08fca487ef8db21441cbd840fd585af2","modified":1500129681199},{"_id":"public/archives/2016/10/index.html","hash":"892903aefdb829fdf3b6a95fc57c6fe8f2786414","modified":1494773700638},{"_id":"public/archives/2016/11/index.html","hash":"6b2d68bf425660cb2b103eaa5e24bc4aa4ebf004","modified":1494773700638},{"_id":"public/archives/2017/index.html","hash":"1896f03b242552c223da2db1718a88d82077e8c1","modified":1500129681199},{"_id":"public/archives/2017/01/index.html","hash":"3092a3f618a981ac6275d133a4c44e2c2463d922","modified":1494773700638},{"_id":"public/archives/2017/02/index.html","hash":"733487741732342bc7bec7e0b92b92917c3f5e4e","modified":1494773700638},{"_id":"public/categories/搬砖码农/index.html","hash":"a875837a1c0fc7f02baa8a0706172c14e471ed62","modified":1500129681199},{"_id":"public/categories/人丑就要多读书/index.html","hash":"30eaa198fc54b6344dea2fd23b84bcba154d4939","modified":1500129681199},{"_id":"public/categories/三省吾身/index.html","hash":"fffdee48735555f0d583e6cc6037553448fa824e","modified":1500129681199},{"_id":"public/index.html","hash":"db08298699002315740c401a4f58d1870f46ce7e","modified":1494773700639},{"_id":"public/tag/index.html","hash":"f3be6fc26f68ede5b7b0d4704d1524900731c71e","modified":1500129681199},{"_id":"public/2017/02/28/gulp-base/index.html","hash":"385ef13f71b8f5d4c547f5a7b182195e47e1ab8c","modified":1494773700639},{"_id":"public/2017/01/25/the-winter-and-summer-of-Meizu/index.html","hash":"83715b306a66a70f3b5ad1b882b7002c3cf8cc62","modified":1494773700639},{"_id":"public/2016/11/27/keep-focus-and-efficiency/index.html","hash":"c380da163c0af587c255308494445d417185bc32","modified":1494773700639},{"_id":"public/2016/11/20/do-you-konw-the-different-between-compiler-and-interpreter/index.html","hash":"ba33a610d78f515f0cef0caea6d602ce65b2c022","modified":1494773700639},{"_id":"public/2016/11/08/the-v8-what-javascripter-should-konw-of-v8-in-nodejs/index.html","hash":"a790c2b4867b59277b9100b6d2953105d4e97a9b","modified":1494773700639},{"_id":"public/2016/10/14/了解 Nginx 的基本概念/index.html","hash":"2b5e04d11f04f56a9f6d21c39132fb18799c465e","modified":1494773700639},{"_id":"public/2016/08/11/打造高效个性Terminal（二）之 zsh/index.html","hash":"5ac06fcc46f05e4f5460630e6fa4a2b8c7a33fca","modified":1494773700639},{"_id":"public/2016/07/07/读《重来》/index.html","hash":"fea68d8f450ebc2afea1ce0134cd7bf46f90cc75","modified":1494773700639},{"_id":"public/2016/06/28/JavaScript原型中的哲学思想/index.html","hash":"a52e37a35f3a73a077fa353bbe0e781da61e5cd5","modified":1494773700639},{"_id":"public/2016/06/19/「ES6笔记」 Babel/index.html","hash":"f702fb08ee5481c0820ddb18150ac93b89f5c85f","modified":1494773700639},{"_id":"public/2016/05/22/「理解HTTP」之常见的状态码/index.html","hash":"3cfe6a9f994ac25b5d3daa615d64f86863b3cfe6","modified":1494773700639},{"_id":"public/2016/05/15/理解 CORS (Cross-Origin Resource Sharing)/index.html","hash":"04f234f4f2248980634899721bc66c8cd634fcfc","modified":1494773700639},{"_id":"public/2016/04/14/NodeJS中被忽略的内存/index.html","hash":"38c8a35c5562911531f9c32fe99d6424254f2294","modified":1494773700640},{"_id":"public/2016/03/15/何为语法树/index.html","hash":"437c6918100b8497de4d42428a02cd4aa25ddde2","modified":1494773700640},{"_id":"public/2015/11/15/消息系统设计与实现「下篇」/index.html","hash":"4aa2b1f965ae5d89242668d70f7476fb61d300be","modified":1494773700640},{"_id":"public/2015/10/14/消息系统设计与实现「上篇」/index.html","hash":"ebba91a29448f9c26312557dcfe53e5944027546","modified":1494773700640},{"_id":"public/2015/07/30/在Nodejs中贯彻单元测试/index.html","hash":"9552ed22eb45ce7498524642130be51711e4fb1d","modified":1494773700640},{"_id":"public/2015/04/25/为什么使用Sails/index.html","hash":"f072e9a4858cce51907ac2fba7f47de12542b8c9","modified":1494773700640},{"_id":"public/2015/03/29/基于RESTful-API-怎么设计用户权限控制/index.html","hash":"ff1f4e0f7803ce74c33ad14c34992c8d2f6d246c","modified":1494773700640},{"_id":"public/2015/03/03/盘点国内的那些ROM/index.html","hash":"fcf59168f7653b66baeff227b29417e237794561","modified":1494773700641},{"_id":"public/2015/01/29/My-Nodejs-Tool-Kit/index.html","hash":"b3a38c58a8c71c459f4cb71f18707af88f267e7a","modified":1494773700641},{"_id":"public/2014/07/12/原生JavaScript实现拖拽效果/index.html","hash":"e969afee9a9736ec197a975705ff569e11c6f52a","modified":1494773700641},{"_id":"public/2013/07/21/Kissy-WaterFall-实现手动加载数据/index.html","hash":"549b44b0ab20c22f8f7d4620e7119ac2432ff37f","modified":1494773700641},{"_id":"public/tags/HTML/index.html","hash":"8f9718a7ac31890062756e8efdd316190fdae42f","modified":1500129681199},{"_id":"public/tags/CSS/index.html","hash":"e74c9a8f393dc2e916ecbf3f8b6e524501437a1f","modified":1500129681199},{"_id":"public/tags/Javascript/index.html","hash":"56659254d26fd3748238edfa5947a784b1e6319b","modified":1500129681199},{"_id":"public/tags/node-webkit/index.html","hash":"1bea316c40ea2e794c28254099f3be284077a4c5","modified":1500129681199},{"_id":"public/tags/前端/index.html","hash":"6c0233e41f2fa1673555fe5987909e8cec4669f2","modified":1500129681199},{"_id":"public/tags/Nodejs/index.html","hash":"8261a0ec359e564bbbd90adf9e45bb21d7cc1eb4","modified":1500129681199},{"_id":"public/tags/内存/index.html","hash":"10def0b5a5c851fc35bb38d9f161eaa16bf05511","modified":1500129681199},{"_id":"public/tags/书籍/index.html","hash":"b6fdd9a9c5293fcfa2edbf6cb5f8d734c6d6e158","modified":1500129681199},{"_id":"public/tags/SOAP/index.html","hash":"1b8dbc693e4b8c1e0700d6739fdb4ee2053d7d69","modified":1500129681199},{"_id":"public/tags/Tool-Kit/index.html","hash":"cfde177202bae4b74b94dc0633c5c852f419aa68","modified":1500129681199},{"_id":"public/tags/session/index.html","hash":"dc52c6a4852545f4c893a8c2f63c3208d6913b76","modified":1500129681200},{"_id":"public/tags/cookie/index.html","hash":"07ef520b0e20b4cac2dfaab7b24b3f8cfc06062a","modified":1500129681200},{"_id":"public/tags/编译/index.html","hash":"54a28d8ab9878e3008d6e8bc9fe02d0b12c53199","modified":1500129681200},{"_id":"public/tags/解释/index.html","hash":"f121fe1b2272f0d787c2f820788fb09b3019dfec","modified":1500129681200},{"_id":"public/tags/前端构建/index.html","hash":"d3c19f64ff8d9a20b67fb88efa3305dfa01dc07f","modified":1500129681200},{"_id":"public/tags/v8/index.html","hash":"c154f84b18a2c4c988465055df13a9fc682773bd","modified":1500129681200},{"_id":"public/tags/NodeJS/index.html","hash":"34a564e11977161b839d8c9db61016a07579142b","modified":1500129681200},{"_id":"public/tags/babel/index.html","hash":"0438e52da5dd2044570b3bdb3e42da075fbbccc6","modified":1500129681200},{"_id":"public/tags/ES6/index.html","hash":"6ecb9a2635708116c76f4bc280ed2359660eb535","modified":1500129681200},{"_id":"public/tags/效率/index.html","hash":"8a824da47cbde4d0a170c0bea9597a748322299a","modified":1500129681202},{"_id":"public/tags/专注/index.html","hash":"75cbdf22cc43a5280228844f26f5d6607fc3ebce","modified":1500129681202},{"_id":"public/tags/http/index.html","hash":"2abede6fb830ef74abda0d85cc488fce99b55ca9","modified":1500129681202},{"_id":"public/tags/Nginx/index.html","hash":"50f325be5a562144c8ca041bfc967a5e93c235af","modified":1500129681203},{"_id":"public/tags/SailsJS/index.html","hash":"a614d97a407c9e1a18876eb44a074001f7bfa6af","modified":1500129681203},{"_id":"public/tags/语法树/index.html","hash":"5e739f94e37d907386f0fd2954df81a38b44c4eb","modified":1500129681203},{"_id":"public/tags/单点登录/index.html","hash":"2cd93f8674b5c0862f35c157cd6e8e8e77ee825b","modified":1500129681203},{"_id":"public/tags/架构/index.html","hash":"6ac344b95adee6281ae432b47bce388803817941","modified":1500129681203},{"_id":"public/tags/RESTful/index.html","hash":"7da49b3f890dbf986184746a736bc8cd66dcef02","modified":1500129681203},{"_id":"public/tags/权限系统/index.html","hash":"2f75f81ea8be31111968a297056badeeffe368ea","modified":1500129681203},{"_id":"public/tags/mocha/index.html","hash":"df2a40ea86c81d2cf63db14e1ec27be7f3e75211","modified":1500129681203},{"_id":"public/tags/unit-test/index.html","hash":"0fd309bb4aad80060507c3f205f6f928417b1677","modified":1500129681203},{"_id":"public/tags/消息系统/index.html","hash":"afdd936949f5ef174eb76ab85c970c8643cdba40","modified":1500129681203},{"_id":"public/tags/ROM/index.html","hash":"96845e360b3cc68204475d4e52a581fe0f3af5e7","modified":1500129681203},{"_id":"public/tags/cors/index.html","hash":"85c0697466ebf90da59621d409ed060db0fd8c17","modified":1500129681203},{"_id":"public/tags/读书笔记/index.html","hash":"fba30d8ebb27bd70983cac0b1f1697d68f69e23d","modified":1500129681203},{"_id":"public/2017/05/04/reconsidering-for-2017-Q1/index.html","hash":"51c794d14b60e7fda49ea0bbb4ce90f70163169f","modified":1494773700666},{"_id":"public/2017/03/17/the-memeye/index.html","hash":"441047bee40775b1248aa08f50a220383abd656b","modified":1494773700666},{"_id":"public/archives/2017/03/index.html","hash":"9f989a811cc64fc2518d9a3309add077723f2bc5","modified":1494773700666},{"_id":"public/archives/2017/05/index.html","hash":"823db525af0805e733688e4cdaefc68c24bbcf8b","modified":1495347684321},{"_id":"public/image/blog/79702-5d2b1c9e8970c3ea.jpeg","hash":"7a32620c73edcce6e9c3163b7b0a9e27659701b4","modified":1494773700677},{"_id":"public/image/blog/imgFile1412168728769.jpg","hash":"2b3e55629a2d38db708b2e2e26d085918738af95","modified":1494773700677},{"_id":"public/image/blog/imgFile1412168834596.jpg","hash":"b65d6af4f2310c741a424f7944f6cf473d74f2e1","modified":1494773700677},{"_id":"public/css/styles.css.map","hash":"8aca3e2dff7497e38a06f9c7e3acc8f56a9b092d","modified":1494773700677},{"_id":"public/fonts/fontello.svg","hash":"0f92b6502168f5a19a55f5634c77a97478afe287","modified":1494773700677},{"_id":"public/fonts/calligraffitti-regular-webfont.eot","hash":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1494773700677},{"_id":"public/fonts/calligraffitti-regular-webfont.woff","hash":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1494773700677},{"_id":"public/fonts/calligraffitti-regular-webfont.woff2","hash":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1494773700677},{"_id":"public/fonts/fontello.eot","hash":"5bf6ba90293fc9b3fc2954e92c3295935921a875","modified":1494773700677},{"_id":"public/fonts/fontello.ttf","hash":"daeed4d37b75df2c810cb2cb4d503f886e3fdd0d","modified":1494773700677},{"_id":"public/fonts/fontello.woff","hash":"89064aff04e74c2ce0033eb9862b65a4ea6b12bf","modified":1494773700678},{"_id":"public/images/avatar.jpg","hash":"b7b97c6861cc09185eb148c096c61a1b3da68e5a","modified":1494773700678},{"_id":"public/images/favicon.ico","hash":"1bc51dc506b463f57ce91d15e28eb09bc23d374f","modified":1494773700678},{"_id":"public/sass/styles.scss","hash":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be","modified":1494773700678},{"_id":"public/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif","hash":"868e2fd30051c693bebd9dd91d3ceede24a2e863","modified":1494773700678},{"_id":"public/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B531CE953267440FAA32A1DA644BFD68.png","hash":"64055a621546c70e5fde53aae72e3bb7ca590dad","modified":1494773700678},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg","hash":"ede513572ec495a8e0c8ad4fa79e208b45f5d418","modified":1494773700678},{"_id":"public/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png","hash":"4e9b1da90be242224b1bce0e8a65cc685635c437","modified":1494773700679},{"_id":"public/image/blog/memory-in-nodejs/V8的分代示意图.png","hash":"52cc0c583bb3ea4211743f05d2dca50ab7424159","modified":1494773700679},{"_id":"public/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png","hash":"79a362733e7e457c848b2a8b71bac8087f0e3c26","modified":1494773700679},{"_id":"public/image/blog/memory-in-nodejs/V8的堆内存示意图.png","hash":"1018a600ec1dcd69a9db256c7f00ec2c129a2a3e","modified":1494773700679},{"_id":"public/image/blog/memory-in-nodejs/V8的堆示意图.png","hash":"8df2d5ba5621249d2a0b8ab4bc682a7e204f7ff2","modified":1494773700679},{"_id":"public/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png","hash":"5e539fd4304d709ee7fce494b858c9f5ac1d5f2d","modified":1494773700679},{"_id":"public/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png","hash":"26ab9b4670e1214b412d2e322f9fc7bba017acfd","modified":1494773700679},{"_id":"public/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png","hash":"4d9c4ab5fedcf04052fb584c0794743d70883e3e","modified":1494773700679},{"_id":"public/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png","hash":"17abe246eb6ae6523c0e9291fd5f2457f2230876","modified":1494773700679},{"_id":"public/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png","hash":"994b09ceb5f0561f8dcdcdf9d384ed723a193168","modified":1494773700679},{"_id":"public/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png","hash":"cc7d13236f9e12f09bf6a0f242def476eb3358fd","modified":1494773700680},{"_id":"public/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png","hash":"189efea61c3757dc42472b02ba6527757368d343","modified":1494773700680},{"_id":"public/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png","hash":"d6d5140d0d6c9449062ad0d13a17d8dc001adfe2","modified":1494773700680},{"_id":"public/image/blog/whatisAST/Python语法树.png","hash":"6a5d39718236537dd906ef57b361ce03828742c6","modified":1494773700680},{"_id":"public/image/blog/whatisAST/javascript语法树.png","hash":"b07f6f8231fc8aaedf41af1c89764d4b345eec65","modified":1494773700680},{"_id":"public/image/blog/understand-tcp-udp/3A60080FBC8767DB575C2D2919097613.png","hash":"4942e3b30f753701c5aca54af249cb686602547c","modified":1494773700680},{"_id":"public/image/blog/understand-tcp-udp/3D9C291187835C3571A111952201B4FF.png","hash":"761afeaf9764913a4b253ff0876377824d72727e","modified":1494773700680},{"_id":"public/image/blog/understand-tcp-udp/46872611EB6C0874FE9E4C290E8F3FE9.png","hash":"db440a0bc227c77ecf57e954ff5c6c1994720939","modified":1494773700680},{"_id":"public/image/blog/understand-tcp-udp/4C22A2B58DB2F0B885A0DC50057D2768.png","hash":"a10efa9e588a291542fef0c5a6b28e662ddd2d67","modified":1494773700680},{"_id":"public/image/blog/understand-tcp-udp/686E3FC14C2DEF657C61ECBC16C9C954.png","hash":"82c360ada66472252f9cfcabea6e3cdb626e7340","modified":1494773700680},{"_id":"public/image/blog/understand-tcp-udp/6FCC9F4EDE80F784BD11ED9FA76FA375.png","hash":"ba9b0df516e6fe14ccf9a78d983f50a4e164f2d0","modified":1494773700680},{"_id":"public/image/blog/understand-tcp-udp/5DADDF7480F81837145468E2ADA6839F.png","hash":"4f27ac7e3cf0d7dbf41c92fdd94dd6a22456be3f","modified":1494773700680},{"_id":"public/image/blog/understand-tcp-udp/95A36446FAD21CC3DD086FA683942FFA.png","hash":"b487ebb98540d92ef33c9dab2a21d512ab003ca8","modified":1494773700681},{"_id":"public/image/blog/understand-tcp-udp/CFC6314E4B2FD039C450821D946E93E2.png","hash":"5c4171641dbbc785ece72a98cd83a19d6fdb31fd","modified":1494773700681},{"_id":"public/image/blog/understand-tcp-udp/F4B7AEDE41EE179676E79DEF2601D4A4.png","hash":"6f8aeee9e1e2f15bd0c2b5a9595ad39f0752da42","modified":1494773700681},{"_id":"public/image/blog/understand-tcp-udp/DB900F916ECD267746706FEA8DF682CD.png","hash":"8d6e1b2004225d2bcb849a272921f5925ff8716b","modified":1494773700681},{"_id":"public/image/blog/understand-tcp-udp/FCA43D210DF50C93E428DFD04FBBBF32.png","hash":"5bc7f4d044710583461481c6dc216b1ee972ce6d","modified":1494773700681},{"_id":"public/image/blog/79702-5660ac4cb51f6257.jpg","hash":"ed6b1882f3dc96eeee24342ef49988ebf77c1260","modified":1494773700698},{"_id":"public/image/blog/79702-8afbd2a4f48118bd.jpeg","hash":"c41894ff92fb004f06fb064c8cdfa19d6bb1058a","modified":1494773700698},{"_id":"public/image/blog/79702-e7cf075365536286.jpeg","hash":"0c9cb904120a6bed2e675da14db01331438bdea6","modified":1494773700698},{"_id":"public/image/blog/imgFile1412168608341.jpg","hash":"b7d21357f7f906d363ac5009baaa8748bc9c0c15","modified":1494773700698},{"_id":"public/image/blog/imgFile1412168354773.jpg","hash":"615642e03176c66248336defa5cc735059fa63f2","modified":1494773700698},{"_id":"public/image/blog/imgFile1412168511771.jpg","hash":"3d7c8ce758c2f4452485dd1d757f29b8e0afdaf8","modified":1494773700699},{"_id":"public/image/blog/imgFile1412168755327.jpg","hash":"b7d21357f7f906d363ac5009baaa8748bc9c0c15","modified":1494773700699},{"_id":"public/image/blog/imgFile1412168908105.jpg","hash":"b3a7e2d223bab42c1e9892b15bb1cd2ca528fc62","modified":1494773700699},{"_id":"public/image/blog/imgFile1412172676130.jpg","hash":"340d6fbadcc15852645f0770f8379d6c8e500bdc","modified":1494773700699},{"_id":"public/images/banboo.png","hash":"46616d28714102881c0f0ee3e05ba4520d02c999","modified":1494773700699},{"_id":"public/fonts/calligraffitti-regular-webfont.ttf","hash":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1494773700699},{"_id":"public/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/B415AA74BF5438CCEB2FEAEDD002B1BD.jpg","hash":"4a7b1bfe9c43fe6686c63c1c3ec564e5f35bc93a","modified":1494773700699},{"_id":"public/image/blog/whatisAST/表达式语法树比较.png","hash":"b1bb37c84d0f5f4973f69462280ef5f445b84df6","modified":1494773700699},{"_id":"public/image/blog/understand-tcp-udp/08EAF7F3E7FFCEF3E781385BF62BA2BC.png","hash":"d73b8bac756532c4df7ed9d7083e4ac1cd50a378","modified":1494773700699},{"_id":"public/css/styles.css","hash":"6bcf0b985e6fc5c65dbed8ddf2b583ad1625edf7","modified":1494773700716},{"_id":"public/image/blog/imgFile1412168419938.jpg","hash":"b53e4c388cad1d47e9563e4e94132e5185a97057","modified":1494773700716},{"_id":"public/image/blog/79702-d66ee9d1fd912b33.jpg","hash":"327ef3be9eaa9d570b2e279d6e2fb9f25106a82e","modified":1494773700717},{"_id":"public/image/blog/imgFile1412168441331.jpg","hash":"a102efc197f5f290516316323d00f760fb5bda21","modified":1494773700717},{"_id":"public/image/blog/imgFile1412168553899.jpg","hash":"ecbc7f8cd2d4fd5458ed7a66572f8cc249c09334","modified":1494773700717},{"_id":"public/fonts/calligraffitti-regular-webfont.svg","hash":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1494773700717},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg","hash":"6a258996a300f1da8215fc59445d10ed22243843","modified":1494773700717},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg","hash":"aaf5f88a18f3dc9554fd69ff3ecda8c277799c1c","modified":1494773700717},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg","hash":"e808f11256c83a5f56aafa2b6dd8866aa39fd29f","modified":1494773700717},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg","hash":"c066d3bf30b582c088ec0ff5c39d9d1b0c8ef520","modified":1494773700718},{"_id":"public/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg","hash":"5d7f7f6e62f9a832af44afc4b89ae97775992a3f","modified":1494773700718},{"_id":"public/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg","hash":"78dbefd05cce7898df2da0b179d3535e185adee8","modified":1494773700718},{"_id":"public/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg","hash":"ec96ec66b1c84e658e245be91110320f19555b5b","modified":1494773700718},{"_id":"public/image/blog/imgFile1412168592404.jpg","hash":"42332077b117269f80c6b67956f3be5fbae7381a","modified":1494773700727},{"_id":"public/image/blog/imgFile1412168471850.jpg","hash":"3e80fe9317e3ffb83cacb0cb221997239b3e266b","modified":1494773700727},{"_id":"public/image/blog/imgFile1412168871884.jpg","hash":"99f1bca6f95282e7d3c8b5207b9abe56c3dc0df9","modified":1494773700727},{"_id":"public/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg","hash":"6ad1dd6ae6893416076b8577d5dfb1699a754905","modified":1494773700728},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg","hash":"ffb8ddfb41ea9a89b391c70a98fcf24883ef7d25","modified":1494773700728},{"_id":"public/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg","hash":"815f173caef5df64955e7bc5eb06da1a0f5cdd34","modified":1494773700758},{"_id":"public/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg","hash":"a3ceddd956d7fcc0734608c2c07231b228f7b15b","modified":1494773700758},{"_id":"public/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg","hash":"4936bfbdf0d1e969f0c71de032b89d5df8439cd6","modified":1494773700759},{"_id":"public/image/blog/memory-in-nodejs/Chrome Profile.jpg","hash":"8b40dcb35047089cfefc0e6df2f4d0486d7057e0","modified":1494773700774},{"_id":"public/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg","hash":"d55dbe18ade80c0bba080f7aab3e1be07b36af43","modified":1494773700774},{"_id":"public/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg","hash":"cf15edd89c2d929a515b3ff0005a2515493ca79d","modified":1494773700775},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg","hash":"f723e8e46b7d01983901afe6cf925b152a1ca18c","modified":1494773700795},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg","hash":"7101047022342969f633dbadd4f6fe796e36add8","modified":1494773700795},{"_id":"public/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg","hash":"c03cfd4a333e24ebc1ff86fd313c711d7e92d963","modified":1494773700795},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg","hash":"498768a0462d7d20bcf2e9849b97c7e01c665151","modified":1494773700799},{"_id":"public/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg","hash":"4f4565e650b1ae3485c514a17cc3368a25bbfbdd","modified":1494773700799},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg","hash":"d5181add5da735b87267fc1269a2b6dce5cae619","modified":1494773700800},{"_id":"public/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg","hash":"c241a425cf59f461b33f6cca7d99c13528d9f7a2","modified":1494773700800},{"_id":"public/image/blog/imgFile1412172691061.jpeg","hash":"2cc9735fef8ed5fc27ea1348cdf4be3e6bb9e5b9","modified":1494773700804},{"_id":"public/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg","hash":"7e9f7eef4724b0497d522262e396360caad17234","modified":1494773700809},{"_id":"public/image/blog/imgFile1412172732788.jpg","hash":"c9000526a5451475b95f060de359dfba87c7ff22","modified":1494773700813},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif","hash":"add32ba300895037b01b0906932ca7546897b954","modified":1494773700828},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif","hash":"6968b32dc2c717a05db2102b10516fc3075c06ae","modified":1494773700834},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif","hash":"3d2463493d7ba19f6222bce70c7f094e5e6fd319","modified":1494773700843},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif","hash":"8e86ad70d0af226cd59667b7d0c419cf2a40d483","modified":1494773700856},{"_id":"public/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif","hash":"9c7256ff02cb93df14db78ce7a091b2c564a6261","modified":1494773700870},{"_id":"source/_posts/talk-about-pixel-and-rpx.md","hash":"1c2b78aca8f04fe23dff66c28a548c0ad25ae39c","modified":1495369766000},{"_id":"public/2017/05/21/talk-about-pixel-and-rpx/index.html","hash":"dceb2f408d90025fe5a86beba41b6f74aed527b8","modified":1495369779657},{"_id":"source/_posts/understand-this-of-javascript.md","hash":"01a4e60b37fa28e0e938787b39e79a5d08405072","modified":1500129666000},{"_id":"public/tags/javascript/index.html","hash":"8af1220cbcf39c4a0c7c0d59a31467701ad430aa","modified":1500129681203},{"_id":"public/archives/2017/07/index.html","hash":"0abc91950bead7c8cd6bf35d7e96a3cd428bc869","modified":1500129681206},{"_id":"public/2017/07/15/understand-this-of-javascript/index.html","hash":"a20351af97d93d0d6088ef2f45b88b1189b31277","modified":1500129681206}],"Category":[{"name":"搬砖码农","_id":"cj2otnwp3000415hla2del9if"},{"name":"人丑就要多读书","_id":"cj2otnwpj000m15hldae35rnx"},{"name":"三省吾身","_id":"cj2otnwpu001315hlw8em19vw"}],"Data":[],"Page":[{"title":"about","layout":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ncomments: false\n---","date":"2017-02-02T14:53:25.000Z","updated":"2017-02-02T14:53:25.000Z","path":"about/index.html","_id":"cj2otnwp1000115hlhu2q0tp2","content":"","excerpt":"","more":""},{"title":"category","layout":"category","comments":0,"_content":"","source":"category/index.md","raw":"---\ntitle: category\nlayout: category\ncomments: false\n---","date":"2017-02-02T14:53:25.000Z","updated":"2017-02-02T14:53:25.000Z","path":"category/index.html","_id":"cj2otnwp3000315hlsx3g9wgu","content":"","excerpt":"","more":""},{"title":"link","layout":"link","comments":0,"_content":"","source":"link/index.md","raw":"---\ntitle: link\nlayout: link\ncomments: false\n---","date":"2017-02-02T14:53:25.000Z","updated":"2017-02-02T14:53:25.000Z","path":"link/index.html","_id":"cj2otnwp7000715hlskclvzxm","content":"","excerpt":"","more":""},{"title":"tag","layout":"tag","comments":0,"_content":"","source":"tag/index.md","raw":"---\ntitle: tag\nlayout: tag\ncomments: false\n---","date":"2017-02-02T14:53:25.000Z","updated":"2017-02-02T14:53:25.000Z","path":"tag/index.html","_id":"cj2otnwpa000915hly4s3f677","content":"","excerpt":"","more":""}],"Post":[{"title":"HTML-CSS-JS打造Windows桌面版《2048》","date":"2014-07-19T08:10:49.000Z","_content":"\n![头图](/image/blog/imgFile1412168354773.jpg)\n\n# 前言    \n\n受益于Node的问世，Javascript终于能够挣脱浏览器这个条条框框的盒子。于是，Javascript能够开发服务器应用了。既然Javascript能够运行在操作系统中，那是否也能使用Javascript像C/C++开发那些个桌面应用呢。\n在Google一番之后，果然已经有高人实现了这个想法了。\n\nNode-WebKit，把浏览器的布局引擎WebKit和Node.js结合了在一起。WebKit负责处理HTML5 UI相关的部分，而Node.js负责本地的API接口，比如文件系统，网络，设备等等。\n一个需要特别提醒的，Node-WebKit的开发维护者正是国内的王文睿大大，中国人啊，很自豪有木有！！但是项目文档好想没有中文版的，只是英文版的，这也许是要和国际接轨的原因吧。\n\n项目地址：[https://github.com/rogerwang/node-webkit](https://github.com/rogerwang/node-webkit)\n\n话不多说，我们撸起袖子，开始尝试一下使用前端技术开发桌面应用的乐趣吧。\n\n\n\n# Windows桌面版《2048》\n\n## Step 1 ：准备材料\n\n1、node-webkit(本文使用v0.8.6-win版本):\n[node-webkit-v0.8.6-win-ia32.zip](http://dl.node-webkit.org/v0.8.6/node-webkit-v0.8.6-win-ia32.zip)\n\n2、基于jQuery实现的2048游戏：\nhttp://huang-jerryc/（原文地址）\nhttps://github.com/JerryC8080/My2048（下载地址）\n\nnode-webkit的其他版本，在项目地址（https://github.com/rogerwang/node-webkit）可以下载得到，不同操作系统是不同版本的。\n基于jQuery实现的2048游戏，是我之前做的一个小玩意，而这一次就完美移植到Windows桌面，哇嘎嘎嘎。\n\nnode-webkit下载并解压之后，如下：\n![解压后](/image/blog/imgFile1412168419938.jpg)\n\n```\n文件说明：\nnw.pak           --核心Javascript库\nincudt.dll       --网络库\nffmpegsumo.dll   --媒体库，为<video>、<audio>或者其他媒体功能提供支持\nlibEGL.dll、\nlibGLESv2.dll、\nD3DCompiler_43.dll、\nd3dx9_43.dll     --该四个dll，为WebGL、GPU、DirectX提供支持\n```\n\n基于jQuery实现的2048游戏下载并解压之后，如下：\n![解压后](/image/blog/imgFile1412168441331.jpg)\n\n## Step 2  ： 编写package.json文件\n\n在《2048》游戏的目录，新建一个package.json文件，输入内容：\nHTML 代码片段\n\n\n```json\n{\n  \"name\": \"MyDemo\",\n  \"main\": \"index.html\",\n  \"window\": {\n    \"toolbar\": false,\n    \"resizable\": false,\n    \"width\": 660,\n    \"height\": 800\n  }\n}\n```\n![](/image/blog/imgFile1412168471850.jpg)\n\n\n复制代码保存代码提示：\n1. 编写代码可使用Emmet语法，即Zen coding语法 \n2. 当代码框处于激活状态下按 CTRL+F11 键可全屏!\n\n\n## Step 3  ：压缩源程序\n\n我们使用压缩工具，把已经编写好的../My2048-master目录里面的内容压缩。\n压缩需要注意的两点：\n1. 压缩格式要为zip；\n2. 文件后缀名要为.nw；\n\n如图：\n![enter image description here](/image/blog/imgFile1412168511771.jpg)\n\n压缩完成\n![enter image description here](/image/blog/imgFile1412168553899.jpg)\n\n## Step 4  ：预览\n\n把压缩好的 My2048-master.nw 文件复制到node-webkit目录：\n![enter image description here](/image/blog/imgFile1412168592404.jpg)\n\n运行cmd，\n移动到node-webkit所在的目录： cd + node-webkit所在的路径\n运行命令：nw My2048-master.nw\n![enter image description here](/image/blog/imgFile1412168834596.jpg)\n\n便能看到预览效果了\n![enter image description here](/image/blog/imgFile1412168728769.jpg)\n\n## Step 5   ：生成exe执行文件\n\n依然在node-webkit的目录下\n运行命令：\n`copy /b nw.exe+My2048-master.nw My2048.exe`\n![enter image description here](/image/blog/imgFile1412168755327.jpg)\n\nOK，我们可以看到node-webkit目录下多了一个My2048.exe的执行文件，我们点解它运行看看效果：\n![enter image description here](/image/blog/imgFile1412168871884.jpg)\n\n![enter image description here](/image/blog/imgFile1412168728769.jpg)\n\n\n## Step 6  ： 打包程序\n\n如果想把这个程序发给朋友，除了.exe文件之外，还需要包括另外两个必要的文件:\n- **icudt.dll**(必要网络库)\n- **nw.pak**(核心javascript库)\n\n这两个是最基本的文件，如果程序还包含了其他功能，还需要包含相对应的dll文件，各个文件功能说明文章开始已经说明了。\n\n所以，我们得到了最基本的发布版了：\n![enter image description here](/image/blog/imgFile1412168908105.jpg)\n","source":"_posts/HTML-CSS-JS打造Windows桌面版《2048》.md","raw":"---\ntitle: HTML-CSS-JS打造Windows桌面版《2048》\ncategory: 搬砖码农\ndate: 2014-07-19 16:10:49\ntags:\n- HTML\n- CSS\n- Javascript\n- node webkit\n---\n\n![头图](/image/blog/imgFile1412168354773.jpg)\n\n# 前言    \n\n受益于Node的问世，Javascript终于能够挣脱浏览器这个条条框框的盒子。于是，Javascript能够开发服务器应用了。既然Javascript能够运行在操作系统中，那是否也能使用Javascript像C/C++开发那些个桌面应用呢。\n在Google一番之后，果然已经有高人实现了这个想法了。\n\nNode-WebKit，把浏览器的布局引擎WebKit和Node.js结合了在一起。WebKit负责处理HTML5 UI相关的部分，而Node.js负责本地的API接口，比如文件系统，网络，设备等等。\n一个需要特别提醒的，Node-WebKit的开发维护者正是国内的王文睿大大，中国人啊，很自豪有木有！！但是项目文档好想没有中文版的，只是英文版的，这也许是要和国际接轨的原因吧。\n\n项目地址：[https://github.com/rogerwang/node-webkit](https://github.com/rogerwang/node-webkit)\n\n话不多说，我们撸起袖子，开始尝试一下使用前端技术开发桌面应用的乐趣吧。\n\n\n\n# Windows桌面版《2048》\n\n## Step 1 ：准备材料\n\n1、node-webkit(本文使用v0.8.6-win版本):\n[node-webkit-v0.8.6-win-ia32.zip](http://dl.node-webkit.org/v0.8.6/node-webkit-v0.8.6-win-ia32.zip)\n\n2、基于jQuery实现的2048游戏：\nhttp://huang-jerryc/（原文地址）\nhttps://github.com/JerryC8080/My2048（下载地址）\n\nnode-webkit的其他版本，在项目地址（https://github.com/rogerwang/node-webkit）可以下载得到，不同操作系统是不同版本的。\n基于jQuery实现的2048游戏，是我之前做的一个小玩意，而这一次就完美移植到Windows桌面，哇嘎嘎嘎。\n\nnode-webkit下载并解压之后，如下：\n![解压后](/image/blog/imgFile1412168419938.jpg)\n\n```\n文件说明：\nnw.pak           --核心Javascript库\nincudt.dll       --网络库\nffmpegsumo.dll   --媒体库，为<video>、<audio>或者其他媒体功能提供支持\nlibEGL.dll、\nlibGLESv2.dll、\nD3DCompiler_43.dll、\nd3dx9_43.dll     --该四个dll，为WebGL、GPU、DirectX提供支持\n```\n\n基于jQuery实现的2048游戏下载并解压之后，如下：\n![解压后](/image/blog/imgFile1412168441331.jpg)\n\n## Step 2  ： 编写package.json文件\n\n在《2048》游戏的目录，新建一个package.json文件，输入内容：\nHTML 代码片段\n\n\n```json\n{\n  \"name\": \"MyDemo\",\n  \"main\": \"index.html\",\n  \"window\": {\n    \"toolbar\": false,\n    \"resizable\": false,\n    \"width\": 660,\n    \"height\": 800\n  }\n}\n```\n![](/image/blog/imgFile1412168471850.jpg)\n\n\n复制代码保存代码提示：\n1. 编写代码可使用Emmet语法，即Zen coding语法 \n2. 当代码框处于激活状态下按 CTRL+F11 键可全屏!\n\n\n## Step 3  ：压缩源程序\n\n我们使用压缩工具，把已经编写好的../My2048-master目录里面的内容压缩。\n压缩需要注意的两点：\n1. 压缩格式要为zip；\n2. 文件后缀名要为.nw；\n\n如图：\n![enter image description here](/image/blog/imgFile1412168511771.jpg)\n\n压缩完成\n![enter image description here](/image/blog/imgFile1412168553899.jpg)\n\n## Step 4  ：预览\n\n把压缩好的 My2048-master.nw 文件复制到node-webkit目录：\n![enter image description here](/image/blog/imgFile1412168592404.jpg)\n\n运行cmd，\n移动到node-webkit所在的目录： cd + node-webkit所在的路径\n运行命令：nw My2048-master.nw\n![enter image description here](/image/blog/imgFile1412168834596.jpg)\n\n便能看到预览效果了\n![enter image description here](/image/blog/imgFile1412168728769.jpg)\n\n## Step 5   ：生成exe执行文件\n\n依然在node-webkit的目录下\n运行命令：\n`copy /b nw.exe+My2048-master.nw My2048.exe`\n![enter image description here](/image/blog/imgFile1412168755327.jpg)\n\nOK，我们可以看到node-webkit目录下多了一个My2048.exe的执行文件，我们点解它运行看看效果：\n![enter image description here](/image/blog/imgFile1412168871884.jpg)\n\n![enter image description here](/image/blog/imgFile1412168728769.jpg)\n\n\n## Step 6  ： 打包程序\n\n如果想把这个程序发给朋友，除了.exe文件之外，还需要包括另外两个必要的文件:\n- **icudt.dll**(必要网络库)\n- **nw.pak**(核心javascript库)\n\n这两个是最基本的文件，如果程序还包含了其他功能，还需要包含相对应的dll文件，各个文件功能说明文章开始已经说明了。\n\n所以，我们得到了最基本的发布版了：\n![enter image description here](/image/blog/imgFile1412168908105.jpg)\n","slug":"HTML-CSS-JS打造Windows桌面版《2048》","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwox000015hl2u8zcx2g","content":"<p><img src=\"/image/blog/imgFile1412168354773.jpg\" alt=\"头图\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>受益于Node的问世，Javascript终于能够挣脱浏览器这个条条框框的盒子。于是，Javascript能够开发服务器应用了。既然Javascript能够运行在操作系统中，那是否也能使用Javascript像C/C++开发那些个桌面应用呢。<br>在Google一番之后，果然已经有高人实现了这个想法了。</p>\n<p>Node-WebKit，把浏览器的布局引擎WebKit和Node.js结合了在一起。WebKit负责处理HTML5 UI相关的部分，而Node.js负责本地的API接口，比如文件系统，网络，设备等等。<br>一个需要特别提醒的，Node-WebKit的开发维护者正是国内的王文睿大大，中国人啊，很自豪有木有！！但是项目文档好想没有中文版的，只是英文版的，这也许是要和国际接轨的原因吧。</p>\n<p>项目地址：<a href=\"https://github.com/rogerwang/node-webkit\" target=\"_blank\" rel=\"external\">https://github.com/rogerwang/node-webkit</a></p>\n<p>话不多说，我们撸起袖子，开始尝试一下使用前端技术开发桌面应用的乐趣吧。</p>\n<h1 id=\"Windows桌面版《2048》\"><a href=\"#Windows桌面版《2048》\" class=\"headerlink\" title=\"Windows桌面版《2048》\"></a>Windows桌面版《2048》</h1><h2 id=\"Step-1-：准备材料\"><a href=\"#Step-1-：准备材料\" class=\"headerlink\" title=\"Step 1 ：准备材料\"></a>Step 1 ：准备材料</h2><p>1、node-webkit(本文使用v0.8.6-win版本):<br><a href=\"http://dl.node-webkit.org/v0.8.6/node-webkit-v0.8.6-win-ia32.zip\" target=\"_blank\" rel=\"external\">node-webkit-v0.8.6-win-ia32.zip</a></p>\n<p>2、基于jQuery实现的2048游戏：<br><a href=\"http://huang-jerryc/（原文地址）\" target=\"_blank\" rel=\"external\">http://huang-jerryc/（原文地址）</a><br><a href=\"https://github.com/JerryC8080/My2048（下载地址）\" target=\"_blank\" rel=\"external\">https://github.com/JerryC8080/My2048（下载地址）</a></p>\n<p>node-webkit的其他版本，在项目地址（<a href=\"https://github.com/rogerwang/node-webkit）可以下载得到，不同操作系统是不同版本的。\" target=\"_blank\" rel=\"external\">https://github.com/rogerwang/node-webkit）可以下载得到，不同操作系统是不同版本的。</a><br>基于jQuery实现的2048游戏，是我之前做的一个小玩意，而这一次就完美移植到Windows桌面，哇嘎嘎嘎。</p>\n<p>node-webkit下载并解压之后，如下：<br><img src=\"/image/blog/imgFile1412168419938.jpg\" alt=\"解压后\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">文件说明：</div><div class=\"line\">nw.pak           --核心Javascript库</div><div class=\"line\">incudt.dll       --网络库</div><div class=\"line\">ffmpegsumo.dll   --媒体库，为&lt;video&gt;、&lt;audio&gt;或者其他媒体功能提供支持</div><div class=\"line\">libEGL.dll、</div><div class=\"line\">libGLESv2.dll、</div><div class=\"line\">D3DCompiler_43.dll、</div><div class=\"line\">d3dx9_43.dll     --该四个dll，为WebGL、GPU、DirectX提供支持</div></pre></td></tr></table></figure>\n<p>基于jQuery实现的2048游戏下载并解压之后，如下：<br><img src=\"/image/blog/imgFile1412168441331.jpg\" alt=\"解压后\"></p>\n<h2 id=\"Step-2-：-编写package-json文件\"><a href=\"#Step-2-：-编写package-json文件\" class=\"headerlink\" title=\"Step 2  ： 编写package.json文件\"></a>Step 2  ： 编写package.json文件</h2><p>在《2048》游戏的目录，新建一个package.json文件，输入内容：<br>HTML 代码片段</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"MyDemo\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"main\"</span>: <span class=\"string\">\"index.html\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"window\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"toolbar\"</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">\"resizable\"</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">\"width\"</span>: <span class=\"number\">660</span>,</div><div class=\"line\">    <span class=\"attr\">\"height\"</span>: <span class=\"number\">800</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"/image/blog/imgFile1412168471850.jpg\" alt=\"\"></p>\n<p>复制代码保存代码提示：</p>\n<ol>\n<li>编写代码可使用Emmet语法，即Zen coding语法 </li>\n<li>当代码框处于激活状态下按 CTRL+F11 键可全屏!</li>\n</ol>\n<h2 id=\"Step-3-：压缩源程序\"><a href=\"#Step-3-：压缩源程序\" class=\"headerlink\" title=\"Step 3  ：压缩源程序\"></a>Step 3  ：压缩源程序</h2><p>我们使用压缩工具，把已经编写好的../My2048-master目录里面的内容压缩。<br>压缩需要注意的两点：</p>\n<ol>\n<li>压缩格式要为zip；</li>\n<li>文件后缀名要为.nw；</li>\n</ol>\n<p>如图：<br><img src=\"/image/blog/imgFile1412168511771.jpg\" alt=\"enter image description here\"></p>\n<p>压缩完成<br><img src=\"/image/blog/imgFile1412168553899.jpg\" alt=\"enter image description here\"></p>\n<h2 id=\"Step-4-：预览\"><a href=\"#Step-4-：预览\" class=\"headerlink\" title=\"Step 4  ：预览\"></a>Step 4  ：预览</h2><p>把压缩好的 My2048-master.nw 文件复制到node-webkit目录：<br><img src=\"/image/blog/imgFile1412168592404.jpg\" alt=\"enter image description here\"></p>\n<p>运行cmd，<br>移动到node-webkit所在的目录： cd + node-webkit所在的路径<br>运行命令：nw My2048-master.nw<br><img src=\"/image/blog/imgFile1412168834596.jpg\" alt=\"enter image description here\"></p>\n<p>便能看到预览效果了<br><img src=\"/image/blog/imgFile1412168728769.jpg\" alt=\"enter image description here\"></p>\n<h2 id=\"Step-5-：生成exe执行文件\"><a href=\"#Step-5-：生成exe执行文件\" class=\"headerlink\" title=\"Step 5   ：生成exe执行文件\"></a>Step 5   ：生成exe执行文件</h2><p>依然在node-webkit的目录下<br>运行命令：<br><code>copy /b nw.exe+My2048-master.nw My2048.exe</code><br><img src=\"/image/blog/imgFile1412168755327.jpg\" alt=\"enter image description here\"></p>\n<p>OK，我们可以看到node-webkit目录下多了一个My2048.exe的执行文件，我们点解它运行看看效果：<br><img src=\"/image/blog/imgFile1412168871884.jpg\" alt=\"enter image description here\"></p>\n<p><img src=\"/image/blog/imgFile1412168728769.jpg\" alt=\"enter image description here\"></p>\n<h2 id=\"Step-6-：-打包程序\"><a href=\"#Step-6-：-打包程序\" class=\"headerlink\" title=\"Step 6  ： 打包程序\"></a>Step 6  ： 打包程序</h2><p>如果想把这个程序发给朋友，除了.exe文件之外，还需要包括另外两个必要的文件:</p>\n<ul>\n<li><strong>icudt.dll</strong>(必要网络库)</li>\n<li><strong>nw.pak</strong>(核心javascript库)</li>\n</ul>\n<p>这两个是最基本的文件，如果程序还包含了其他功能，还需要包含相对应的dll文件，各个文件功能说明文章开始已经说明了。</p>\n<p>所以，我们得到了最基本的发布版了：<br><img src=\"/image/blog/imgFile1412168908105.jpg\" alt=\"enter image description here\"></p>\n","excerpt":"","more":"<p><img src=\"/image/blog/imgFile1412168354773.jpg\" alt=\"头图\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>受益于Node的问世，Javascript终于能够挣脱浏览器这个条条框框的盒子。于是，Javascript能够开发服务器应用了。既然Javascript能够运行在操作系统中，那是否也能使用Javascript像C/C++开发那些个桌面应用呢。<br>在Google一番之后，果然已经有高人实现了这个想法了。</p>\n<p>Node-WebKit，把浏览器的布局引擎WebKit和Node.js结合了在一起。WebKit负责处理HTML5 UI相关的部分，而Node.js负责本地的API接口，比如文件系统，网络，设备等等。<br>一个需要特别提醒的，Node-WebKit的开发维护者正是国内的王文睿大大，中国人啊，很自豪有木有！！但是项目文档好想没有中文版的，只是英文版的，这也许是要和国际接轨的原因吧。</p>\n<p>项目地址：<a href=\"https://github.com/rogerwang/node-webkit\">https://github.com/rogerwang/node-webkit</a></p>\n<p>话不多说，我们撸起袖子，开始尝试一下使用前端技术开发桌面应用的乐趣吧。</p>\n<h1 id=\"Windows桌面版《2048》\"><a href=\"#Windows桌面版《2048》\" class=\"headerlink\" title=\"Windows桌面版《2048》\"></a>Windows桌面版《2048》</h1><h2 id=\"Step-1-：准备材料\"><a href=\"#Step-1-：准备材料\" class=\"headerlink\" title=\"Step 1 ：准备材料\"></a>Step 1 ：准备材料</h2><p>1、node-webkit(本文使用v0.8.6-win版本):<br><a href=\"http://dl.node-webkit.org/v0.8.6/node-webkit-v0.8.6-win-ia32.zip\">node-webkit-v0.8.6-win-ia32.zip</a></p>\n<p>2、基于jQuery实现的2048游戏：<br><a href=\"http://huang-jerryc/（原文地址）\">http://huang-jerryc/（原文地址）</a><br><a href=\"https://github.com/JerryC8080/My2048（下载地址）\">https://github.com/JerryC8080/My2048（下载地址）</a></p>\n<p>node-webkit的其他版本，在项目地址（<a href=\"https://github.com/rogerwang/node-webkit）可以下载得到，不同操作系统是不同版本的。\">https://github.com/rogerwang/node-webkit）可以下载得到，不同操作系统是不同版本的。</a><br>基于jQuery实现的2048游戏，是我之前做的一个小玩意，而这一次就完美移植到Windows桌面，哇嘎嘎嘎。</p>\n<p>node-webkit下载并解压之后，如下：<br><img src=\"/image/blog/imgFile1412168419938.jpg\" alt=\"解压后\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">文件说明：</div><div class=\"line\">nw.pak           --核心Javascript库</div><div class=\"line\">incudt.dll       --网络库</div><div class=\"line\">ffmpegsumo.dll   --媒体库，为&lt;video&gt;、&lt;audio&gt;或者其他媒体功能提供支持</div><div class=\"line\">libEGL.dll、</div><div class=\"line\">libGLESv2.dll、</div><div class=\"line\">D3DCompiler_43.dll、</div><div class=\"line\">d3dx9_43.dll     --该四个dll，为WebGL、GPU、DirectX提供支持</div></pre></td></tr></table></figure>\n<p>基于jQuery实现的2048游戏下载并解压之后，如下：<br><img src=\"/image/blog/imgFile1412168441331.jpg\" alt=\"解压后\"></p>\n<h2 id=\"Step-2-：-编写package-json文件\"><a href=\"#Step-2-：-编写package-json文件\" class=\"headerlink\" title=\"Step 2  ： 编写package.json文件\"></a>Step 2  ： 编写package.json文件</h2><p>在《2048》游戏的目录，新建一个package.json文件，输入内容：<br>HTML 代码片段</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"MyDemo\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"main\"</span>: <span class=\"string\">\"index.html\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"window\"</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">\"toolbar\"</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">\"resizable\"</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">\"width\"</span>: <span class=\"number\">660</span>,</div><div class=\"line\">    <span class=\"attr\">\"height\"</span>: <span class=\"number\">800</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"/image/blog/imgFile1412168471850.jpg\" alt=\"\"></p>\n<p>复制代码保存代码提示：</p>\n<ol>\n<li>编写代码可使用Emmet语法，即Zen coding语法 </li>\n<li>当代码框处于激活状态下按 CTRL+F11 键可全屏!</li>\n</ol>\n<h2 id=\"Step-3-：压缩源程序\"><a href=\"#Step-3-：压缩源程序\" class=\"headerlink\" title=\"Step 3  ：压缩源程序\"></a>Step 3  ：压缩源程序</h2><p>我们使用压缩工具，把已经编写好的../My2048-master目录里面的内容压缩。<br>压缩需要注意的两点：</p>\n<ol>\n<li>压缩格式要为zip；</li>\n<li>文件后缀名要为.nw；</li>\n</ol>\n<p>如图：<br><img src=\"/image/blog/imgFile1412168511771.jpg\" alt=\"enter image description here\"></p>\n<p>压缩完成<br><img src=\"/image/blog/imgFile1412168553899.jpg\" alt=\"enter image description here\"></p>\n<h2 id=\"Step-4-：预览\"><a href=\"#Step-4-：预览\" class=\"headerlink\" title=\"Step 4  ：预览\"></a>Step 4  ：预览</h2><p>把压缩好的 My2048-master.nw 文件复制到node-webkit目录：<br><img src=\"/image/blog/imgFile1412168592404.jpg\" alt=\"enter image description here\"></p>\n<p>运行cmd，<br>移动到node-webkit所在的目录： cd + node-webkit所在的路径<br>运行命令：nw My2048-master.nw<br><img src=\"/image/blog/imgFile1412168834596.jpg\" alt=\"enter image description here\"></p>\n<p>便能看到预览效果了<br><img src=\"/image/blog/imgFile1412168728769.jpg\" alt=\"enter image description here\"></p>\n<h2 id=\"Step-5-：生成exe执行文件\"><a href=\"#Step-5-：生成exe执行文件\" class=\"headerlink\" title=\"Step 5   ：生成exe执行文件\"></a>Step 5   ：生成exe执行文件</h2><p>依然在node-webkit的目录下<br>运行命令：<br><code>copy /b nw.exe+My2048-master.nw My2048.exe</code><br><img src=\"/image/blog/imgFile1412168755327.jpg\" alt=\"enter image description here\"></p>\n<p>OK，我们可以看到node-webkit目录下多了一个My2048.exe的执行文件，我们点解它运行看看效果：<br><img src=\"/image/blog/imgFile1412168871884.jpg\" alt=\"enter image description here\"></p>\n<p><img src=\"/image/blog/imgFile1412168728769.jpg\" alt=\"enter image description here\"></p>\n<h2 id=\"Step-6-：-打包程序\"><a href=\"#Step-6-：-打包程序\" class=\"headerlink\" title=\"Step 6  ： 打包程序\"></a>Step 6  ： 打包程序</h2><p>如果想把这个程序发给朋友，除了.exe文件之外，还需要包括另外两个必要的文件:</p>\n<ul>\n<li><strong>icudt.dll</strong>(必要网络库)</li>\n<li><strong>nw.pak</strong>(核心javascript库)</li>\n</ul>\n<p>这两个是最基本的文件，如果程序还包含了其他功能，还需要包含相对应的dll文件，各个文件功能说明文章开始已经说明了。</p>\n<p>所以，我们得到了最基本的发布版了：<br><img src=\"/image/blog/imgFile1412168908105.jpg\" alt=\"enter image description here\"></p>\n"},{"title":"Javascript 原型中的哲学思想","date":"2016-06-28T15:12:00.000Z","_content":"\n\n记得当年初试前端的时候，学习JavaScript过程中，原型问题一直让我疑惑许久，那时候捧着那本著名的红皮书，看到有关原型的讲解时，总是心存疑虑。\n当在JavaScript世界中走过不少旅程之后，再次萌发起研究这部分知识的欲望，翻阅了不少书籍和资料，才搞懂`__proto__`和`prototype`的概念。\n故以作此笔记，日后忘了可以回来看看。\n如果你看的过程中觉得理解有些困难，把例子在代码中跑一跑，亲手试一试也许能解决不少疑惑。\n\n# 一切皆为对象\n\n> 殊不知，JavaScript的世界中的对象，追根溯源来自于一个 null\n\n「一切皆为对象」，这句着实是一手好营销，易记，易上口，印象深刻。\n万物初生时，一个`null`对象，凭空而生，接着`Object`、`Function`学着`null`的模样塑造了自己，并且它们彼此之间喜结连理，提供了`prototype`和`constructor`，一个给子孙提供了基因，一个则制造万千子子孙孙。\n在JavaScript中，`null`也是作为一个对象存在，基于它继承的子子孙孙，当属对象。\n乍一看，`null`像是上帝,而`Object`和`Function`犹如JavaScript世界中的**亚当**与**夏娃**。\n\n\n# 原型指针 `__proto__`\n\n在JavaScript中，每个对象都拥有一个原型对象，而指向该原型对象的内部指针则是`__proto__`,通过它可以从中继承原型对象的属性，原型是JavaScript中的基因链接，有了这个，才能知道这个对象的祖祖辈辈。从对象中的`__proto__`可以访问到他所继承的原型对象。\n\n```javascript\nvar a = new Array();\na.__proto__ === Array.prototype // true\n```\n\n上面代码中，创建了一个Array的实例`a`，该实例的原型指向了`Array.prototype`。\n`Array.prototype`本身也是一个对象，也有继承的原型:\n\n```javascript\na.__proto__.__proto__ === Object.prototype  // true\n// 等同于 Array.prototype.__proto__ === Object.prototype\n```\n\n这就说了明了，Array本身也是继承自Object的，那么Object的原型指向的是谁呢？\n\n```javascript\na.__proto__.__proto__.__proto__ === null  // true\n// 等同于 Object.prototype.__proto__ === null\n```\n\n![prototype.png](/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png)\n\n所以说，JavaScript中的对象，追根溯源都是来自一个**null**对象。佛曰：**万物皆空**，善哉善哉。\n\n除了使用`.__proto__`方式访问对象的原型，还可以通过`Object.getPrototypeOf`方法来获取对象的原型，以及通过`Object.setPrototypeOf`方法来重写对象的原型\n。\n值得注意的是，按照语言标准，`__proto__`属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用`Object.getPrototypeof`和`Object.setPrototypeOf`，进行原型对象的读写操作。\n这里用`__proto__`属性来描述对象中的原型，是因为这样来得更加形象，且容易理解。\n\n# 原型对象 `prototype`\n函数作为JavaScript中的一等公民，它既是函数又是对象，函数的原型指向的是`Function.prototype`\n\n```javascript\nvar Foo = function() {}\nFoo.__proto__ === Function.prototype // true\n```\n\n函数实例除了拥有`__proto__`属性之外，还拥有`prototype`属性。\n通过该函数构造的新的实例对象，其原型指针`__proto__`会指向该函数的`prototype`属性。\n\n```javascript\nvar a = new Foo();\na.__proto__ === Foo.prototype; // true\n```\n\n而函数的`prototype`属性，本身是一个由`Object`构造的实例对象。\n\n```javascript\nFoo.prototype.__proto__ === Object.prototype; // true\n```\n\n`prototype`属性很特殊，它还有一个隐式的`constructor`，指向了构造函数本身。\n\n\n```javascript\nFoo.prototype.constructor === Foo; // true\na.constructor === Foo; // true\na.constructor === Foo.prototype.constructor; // true\n```\n\n![prototype2.png](/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png)\n\n# 原型链\n\n## 概念\n原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。\n每个构造函数都有一个原型对象(`prototype`)，原型对象都包含一个指向构造函数的指针(`constructor`)，而实例都包含一个指向原型对象的内部指针(`__proto__`)。\n那么，假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。\n如此层层递进，就构造了实例与原型的链条，这就是**原型链**的基本概念。\n\n## 意义\n“原型链”的作用在于，当读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。以此类推，如果直到最顶层的Object.prototype还是找不到，则返回undefine\n\n# 亲子鉴定\n在JavaScript中，也存在鉴定亲子之间DNA关系的方法：\n1. **instanceof**\n  运算符返回一个布尔值，表示一个对象是否由某个构造函数创建。\n2. **Object.isPrototypeOf()**\n  只要某个对象处在原型链上，isProtypeOf都返回true\n\n```javascript\nvar Bar = function() {}\nvar b = new Bar();\nb instanceof Bar // true\nBar.prototype.isPrototypeOf(b) // true\nObject.prototype.isPrototypeOf(Bar) // true\n```\n要注意，实例`b`的原型是`Bar.prototype`而不是`Bar`\n\n# 一张历史悠久的图\n![jsobj_full.jpg](/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg)\n\n这是一张描述了`Object`、`Function`以及一个函数实例`Foo`他们之间原型之间联系。如果理解了上面的概念，这张图是不难读懂。\n\n从上图中，能看到一个有趣的地方。\n`Function.prototype.__proto__` 指向了 `Object.prototype`，这说明`Function.prototype` 是一个 `Object`实例，那么应当是先有的`Object`再有`Function`。\n但是`Object.prototype.constructor.__proto__` 又指向了 `Function.prototype`。这样看来，没有`Function`，`Object`也不能创建实例。\n这就产生了一种类「先有鸡还是先有蛋」的经典问题，到底是先有的`Object`还是先有的`Function`呢？\n这么哲学向的问题，留给你思考了。\n我只是感慨：\n**越往JavaScript的深处探索，越发觉得这一门语言很哲学。**\n\n# 先有鸡还是先有蛋？\n> update on 2017/01/05\n\n时隔半年，偶尔翻开这篇文章。    \n对于这个问题，又有了新的思考。    \n愿意跟能看到这里的你来分享一下。\n\n我们可以先把 `Object.prototype` 和 `Function.prototype` 这两个拎出来看，因为他们本身就是一个实例对象。\n为方便理解，我们改一下名字，避免和 Object 和 Function 的强关联，分别叫：`Op` 和 `Fp`\n\n那么就有这样的原型链存在了 \n\n![先有鸡还是先有蛋](/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png)\n\n我再描述一下上面的原型链，先有 null , 再有了 Op , 然后再有了 Fp ，然后以 Fp 为原型的两个构造函数 (Object, Function) 出现了。    \n而作为构造函数，需要有个 prototype 属性用来作为以该构造函数创造的实例的继承。    \n所以Object.prototype = Op, Function.prototype = Fp。","source":"_posts/JavaScript原型中的哲学思想.md","raw":"---\ntitle: Javascript 原型中的哲学思想\ndate: 2016-06-28 23:12:00\ntags:\n- Javascript\ncategory: 搬砖码农\n---\n\n\n记得当年初试前端的时候，学习JavaScript过程中，原型问题一直让我疑惑许久，那时候捧着那本著名的红皮书，看到有关原型的讲解时，总是心存疑虑。\n当在JavaScript世界中走过不少旅程之后，再次萌发起研究这部分知识的欲望，翻阅了不少书籍和资料，才搞懂`__proto__`和`prototype`的概念。\n故以作此笔记，日后忘了可以回来看看。\n如果你看的过程中觉得理解有些困难，把例子在代码中跑一跑，亲手试一试也许能解决不少疑惑。\n\n# 一切皆为对象\n\n> 殊不知，JavaScript的世界中的对象，追根溯源来自于一个 null\n\n「一切皆为对象」，这句着实是一手好营销，易记，易上口，印象深刻。\n万物初生时，一个`null`对象，凭空而生，接着`Object`、`Function`学着`null`的模样塑造了自己，并且它们彼此之间喜结连理，提供了`prototype`和`constructor`，一个给子孙提供了基因，一个则制造万千子子孙孙。\n在JavaScript中，`null`也是作为一个对象存在，基于它继承的子子孙孙，当属对象。\n乍一看，`null`像是上帝,而`Object`和`Function`犹如JavaScript世界中的**亚当**与**夏娃**。\n\n\n# 原型指针 `__proto__`\n\n在JavaScript中，每个对象都拥有一个原型对象，而指向该原型对象的内部指针则是`__proto__`,通过它可以从中继承原型对象的属性，原型是JavaScript中的基因链接，有了这个，才能知道这个对象的祖祖辈辈。从对象中的`__proto__`可以访问到他所继承的原型对象。\n\n```javascript\nvar a = new Array();\na.__proto__ === Array.prototype // true\n```\n\n上面代码中，创建了一个Array的实例`a`，该实例的原型指向了`Array.prototype`。\n`Array.prototype`本身也是一个对象，也有继承的原型:\n\n```javascript\na.__proto__.__proto__ === Object.prototype  // true\n// 等同于 Array.prototype.__proto__ === Object.prototype\n```\n\n这就说了明了，Array本身也是继承自Object的，那么Object的原型指向的是谁呢？\n\n```javascript\na.__proto__.__proto__.__proto__ === null  // true\n// 等同于 Object.prototype.__proto__ === null\n```\n\n![prototype.png](/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png)\n\n所以说，JavaScript中的对象，追根溯源都是来自一个**null**对象。佛曰：**万物皆空**，善哉善哉。\n\n除了使用`.__proto__`方式访问对象的原型，还可以通过`Object.getPrototypeOf`方法来获取对象的原型，以及通过`Object.setPrototypeOf`方法来重写对象的原型\n。\n值得注意的是，按照语言标准，`__proto__`属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用`Object.getPrototypeof`和`Object.setPrototypeOf`，进行原型对象的读写操作。\n这里用`__proto__`属性来描述对象中的原型，是因为这样来得更加形象，且容易理解。\n\n# 原型对象 `prototype`\n函数作为JavaScript中的一等公民，它既是函数又是对象，函数的原型指向的是`Function.prototype`\n\n```javascript\nvar Foo = function() {}\nFoo.__proto__ === Function.prototype // true\n```\n\n函数实例除了拥有`__proto__`属性之外，还拥有`prototype`属性。\n通过该函数构造的新的实例对象，其原型指针`__proto__`会指向该函数的`prototype`属性。\n\n```javascript\nvar a = new Foo();\na.__proto__ === Foo.prototype; // true\n```\n\n而函数的`prototype`属性，本身是一个由`Object`构造的实例对象。\n\n```javascript\nFoo.prototype.__proto__ === Object.prototype; // true\n```\n\n`prototype`属性很特殊，它还有一个隐式的`constructor`，指向了构造函数本身。\n\n\n```javascript\nFoo.prototype.constructor === Foo; // true\na.constructor === Foo; // true\na.constructor === Foo.prototype.constructor; // true\n```\n\n![prototype2.png](/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png)\n\n# 原型链\n\n## 概念\n原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。\n每个构造函数都有一个原型对象(`prototype`)，原型对象都包含一个指向构造函数的指针(`constructor`)，而实例都包含一个指向原型对象的内部指针(`__proto__`)。\n那么，假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。\n如此层层递进，就构造了实例与原型的链条，这就是**原型链**的基本概念。\n\n## 意义\n“原型链”的作用在于，当读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。以此类推，如果直到最顶层的Object.prototype还是找不到，则返回undefine\n\n# 亲子鉴定\n在JavaScript中，也存在鉴定亲子之间DNA关系的方法：\n1. **instanceof**\n  运算符返回一个布尔值，表示一个对象是否由某个构造函数创建。\n2. **Object.isPrototypeOf()**\n  只要某个对象处在原型链上，isProtypeOf都返回true\n\n```javascript\nvar Bar = function() {}\nvar b = new Bar();\nb instanceof Bar // true\nBar.prototype.isPrototypeOf(b) // true\nObject.prototype.isPrototypeOf(Bar) // true\n```\n要注意，实例`b`的原型是`Bar.prototype`而不是`Bar`\n\n# 一张历史悠久的图\n![jsobj_full.jpg](/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg)\n\n这是一张描述了`Object`、`Function`以及一个函数实例`Foo`他们之间原型之间联系。如果理解了上面的概念，这张图是不难读懂。\n\n从上图中，能看到一个有趣的地方。\n`Function.prototype.__proto__` 指向了 `Object.prototype`，这说明`Function.prototype` 是一个 `Object`实例，那么应当是先有的`Object`再有`Function`。\n但是`Object.prototype.constructor.__proto__` 又指向了 `Function.prototype`。这样看来，没有`Function`，`Object`也不能创建实例。\n这就产生了一种类「先有鸡还是先有蛋」的经典问题，到底是先有的`Object`还是先有的`Function`呢？\n这么哲学向的问题，留给你思考了。\n我只是感慨：\n**越往JavaScript的深处探索，越发觉得这一门语言很哲学。**\n\n# 先有鸡还是先有蛋？\n> update on 2017/01/05\n\n时隔半年，偶尔翻开这篇文章。    \n对于这个问题，又有了新的思考。    \n愿意跟能看到这里的你来分享一下。\n\n我们可以先把 `Object.prototype` 和 `Function.prototype` 这两个拎出来看，因为他们本身就是一个实例对象。\n为方便理解，我们改一下名字，避免和 Object 和 Function 的强关联，分别叫：`Op` 和 `Fp`\n\n那么就有这样的原型链存在了 \n\n![先有鸡还是先有蛋](/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png)\n\n我再描述一下上面的原型链，先有 null , 再有了 Op , 然后再有了 Fp ，然后以 Fp 为原型的两个构造函数 (Object, Function) 出现了。    \n而作为构造函数，需要有个 prototype 属性用来作为以该构造函数创造的实例的继承。    \n所以Object.prototype = Op, Function.prototype = Fp。","slug":"JavaScript原型中的哲学思想","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwp1000215hl433625yg","content":"<p>记得当年初试前端的时候，学习JavaScript过程中，原型问题一直让我疑惑许久，那时候捧着那本著名的红皮书，看到有关原型的讲解时，总是心存疑虑。<br>当在JavaScript世界中走过不少旅程之后，再次萌发起研究这部分知识的欲望，翻阅了不少书籍和资料，才搞懂<code>__proto__</code>和<code>prototype</code>的概念。<br>故以作此笔记，日后忘了可以回来看看。<br>如果你看的过程中觉得理解有些困难，把例子在代码中跑一跑，亲手试一试也许能解决不少疑惑。</p>\n<h1 id=\"一切皆为对象\"><a href=\"#一切皆为对象\" class=\"headerlink\" title=\"一切皆为对象\"></a>一切皆为对象</h1><blockquote>\n<p>殊不知，JavaScript的世界中的对象，追根溯源来自于一个 null</p>\n</blockquote>\n<p>「一切皆为对象」，这句着实是一手好营销，易记，易上口，印象深刻。<br>万物初生时，一个<code>null</code>对象，凭空而生，接着<code>Object</code>、<code>Function</code>学着<code>null</code>的模样塑造了自己，并且它们彼此之间喜结连理，提供了<code>prototype</code>和<code>constructor</code>，一个给子孙提供了基因，一个则制造万千子子孙孙。<br>在JavaScript中，<code>null</code>也是作为一个对象存在，基于它继承的子子孙孙，当属对象。<br>乍一看，<code>null</code>像是上帝,而<code>Object</code>和<code>Function</code>犹如JavaScript世界中的<strong>亚当</strong>与<strong>夏娃</strong>。</p>\n<h1 id=\"原型指针-proto\"><a href=\"#原型指针-proto\" class=\"headerlink\" title=\"原型指针 __proto__\"></a>原型指针 <code>__proto__</code></h1><p>在JavaScript中，每个对象都拥有一个原型对象，而指向该原型对象的内部指针则是<code>__proto__</code>,通过它可以从中继承原型对象的属性，原型是JavaScript中的基因链接，有了这个，才能知道这个对象的祖祖辈辈。从对象中的<code>__proto__</code>可以访问到他所继承的原型对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\">a.__proto__ === <span class=\"built_in\">Array</span>.prototype <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，创建了一个Array的实例<code>a</code>，该实例的原型指向了<code>Array.prototype</code>。<br><code>Array.prototype</code>本身也是一个对象，也有继承的原型:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">a.__proto__.__proto__ === <span class=\"built_in\">Object</span>.prototype  <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"comment\">// 等同于 Array.prototype.__proto__ === Object.prototype</span></div></pre></td></tr></table></figure>\n<p>这就说了明了，Array本身也是继承自Object的，那么Object的原型指向的是谁呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">a.__proto__.__proto__.__proto__ === <span class=\"literal\">null</span>  <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"comment\">// 等同于 Object.prototype.__proto__ === null</span></div></pre></td></tr></table></figure>\n<p><img src=\"/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png\" alt=\"prototype.png\"></p>\n<p>所以说，JavaScript中的对象，追根溯源都是来自一个<strong>null</strong>对象。佛曰：<strong>万物皆空</strong>，善哉善哉。</p>\n<p>除了使用<code>.__proto__</code>方式访问对象的原型，还可以通过<code>Object.getPrototypeOf</code>方法来获取对象的原型，以及通过<code>Object.setPrototypeOf</code>方法来重写对象的原型<br>。<br>值得注意的是，按照语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeof</code>和<code>Object.setPrototypeOf</code>，进行原型对象的读写操作。<br>这里用<code>__proto__</code>属性来描述对象中的原型，是因为这样来得更加形象，且容易理解。</p>\n<h1 id=\"原型对象-prototype\"><a href=\"#原型对象-prototype\" class=\"headerlink\" title=\"原型对象 prototype\"></a>原型对象 <code>prototype</code></h1><p>函数作为JavaScript中的一等公民，它既是函数又是对象，函数的原型指向的是<code>Function.prototype</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">Foo.__proto__ === <span class=\"built_in\">Function</span>.prototype <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>函数实例除了拥有<code>__proto__</code>属性之外，还拥有<code>prototype</code>属性。<br>通过该函数构造的新的实例对象，其原型指针<code>__proto__</code>会指向该函数的<code>prototype</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Foo();</div><div class=\"line\">a.__proto__ === Foo.prototype; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>而函数的<code>prototype</code>属性，本身是一个由<code>Object</code>构造的实例对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Foo.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><code>prototype</code>属性很特殊，它还有一个隐式的<code>constructor</code>，指向了构造函数本身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Foo.prototype.constructor === Foo; <span class=\"comment\">// true</span></div><div class=\"line\">a.constructor === Foo; <span class=\"comment\">// true</span></div><div class=\"line\">a.constructor === Foo.prototype.constructor; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><img src=\"/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png\" alt=\"prototype2.png\"></p>\n<h1 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<br>每个构造函数都有一个原型对象(<code>prototype</code>)，原型对象都包含一个指向构造函数的指针(<code>constructor</code>)，而实例都包含一个指向原型对象的内部指针(<code>__proto__</code>)。<br>那么，假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。<br>如此层层递进，就构造了实例与原型的链条，这就是<strong>原型链</strong>的基本概念。</p>\n<h2 id=\"意义\"><a href=\"#意义\" class=\"headerlink\" title=\"意义\"></a>意义</h2><p>“原型链”的作用在于，当读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。以此类推，如果直到最顶层的Object.prototype还是找不到，则返回undefine</p>\n<h1 id=\"亲子鉴定\"><a href=\"#亲子鉴定\" class=\"headerlink\" title=\"亲子鉴定\"></a>亲子鉴定</h1><p>在JavaScript中，也存在鉴定亲子之间DNA关系的方法：</p>\n<ol>\n<li><strong>instanceof</strong><br>运算符返回一个布尔值，表示一个对象是否由某个构造函数创建。</li>\n<li><strong>Object.isPrototypeOf()</strong><br>只要某个对象处在原型链上，isProtypeOf都返回true</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Bar();</div><div class=\"line\">b <span class=\"keyword\">instanceof</span> Bar <span class=\"comment\">// true</span></div><div class=\"line\">Bar.prototype.isPrototypeOf(b) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.prototype.isPrototypeOf(Bar) <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>要注意，实例<code>b</code>的原型是<code>Bar.prototype</code>而不是<code>Bar</code></p>\n<h1 id=\"一张历史悠久的图\"><a href=\"#一张历史悠久的图\" class=\"headerlink\" title=\"一张历史悠久的图\"></a>一张历史悠久的图</h1><p><img src=\"/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg\" alt=\"jsobj_full.jpg\"></p>\n<p>这是一张描述了<code>Object</code>、<code>Function</code>以及一个函数实例<code>Foo</code>他们之间原型之间联系。如果理解了上面的概念，这张图是不难读懂。</p>\n<p>从上图中，能看到一个有趣的地方。<br><code>Function.prototype.__proto__</code> 指向了 <code>Object.prototype</code>，这说明<code>Function.prototype</code> 是一个 <code>Object</code>实例，那么应当是先有的<code>Object</code>再有<code>Function</code>。<br>但是<code>Object.prototype.constructor.__proto__</code> 又指向了 <code>Function.prototype</code>。这样看来，没有<code>Function</code>，<code>Object</code>也不能创建实例。<br>这就产生了一种类「先有鸡还是先有蛋」的经典问题，到底是先有的<code>Object</code>还是先有的<code>Function</code>呢？<br>这么哲学向的问题，留给你思考了。<br>我只是感慨：<br><strong>越往JavaScript的深处探索，越发觉得这一门语言很哲学。</strong></p>\n<h1 id=\"先有鸡还是先有蛋？\"><a href=\"#先有鸡还是先有蛋？\" class=\"headerlink\" title=\"先有鸡还是先有蛋？\"></a>先有鸡还是先有蛋？</h1><blockquote>\n<p>update on 2017/01/05</p>\n</blockquote>\n<p>时隔半年，偶尔翻开这篇文章。<br>对于这个问题，又有了新的思考。<br>愿意跟能看到这里的你来分享一下。</p>\n<p>我们可以先把 <code>Object.prototype</code> 和 <code>Function.prototype</code> 这两个拎出来看，因为他们本身就是一个实例对象。<br>为方便理解，我们改一下名字，避免和 Object 和 Function 的强关联，分别叫：<code>Op</code> 和 <code>Fp</code></p>\n<p>那么就有这样的原型链存在了 </p>\n<p><img src=\"/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png\" alt=\"先有鸡还是先有蛋\"></p>\n<p>我再描述一下上面的原型链，先有 null , 再有了 Op , 然后再有了 Fp ，然后以 Fp 为原型的两个构造函数 (Object, Function) 出现了。<br>而作为构造函数，需要有个 prototype 属性用来作为以该构造函数创造的实例的继承。<br>所以Object.prototype = Op, Function.prototype = Fp。</p>\n","excerpt":"","more":"<p>记得当年初试前端的时候，学习JavaScript过程中，原型问题一直让我疑惑许久，那时候捧着那本著名的红皮书，看到有关原型的讲解时，总是心存疑虑。<br>当在JavaScript世界中走过不少旅程之后，再次萌发起研究这部分知识的欲望，翻阅了不少书籍和资料，才搞懂<code>__proto__</code>和<code>prototype</code>的概念。<br>故以作此笔记，日后忘了可以回来看看。<br>如果你看的过程中觉得理解有些困难，把例子在代码中跑一跑，亲手试一试也许能解决不少疑惑。</p>\n<h1 id=\"一切皆为对象\"><a href=\"#一切皆为对象\" class=\"headerlink\" title=\"一切皆为对象\"></a>一切皆为对象</h1><blockquote>\n<p>殊不知，JavaScript的世界中的对象，追根溯源来自于一个 null</p>\n</blockquote>\n<p>「一切皆为对象」，这句着实是一手好营销，易记，易上口，印象深刻。<br>万物初生时，一个<code>null</code>对象，凭空而生，接着<code>Object</code>、<code>Function</code>学着<code>null</code>的模样塑造了自己，并且它们彼此之间喜结连理，提供了<code>prototype</code>和<code>constructor</code>，一个给子孙提供了基因，一个则制造万千子子孙孙。<br>在JavaScript中，<code>null</code>也是作为一个对象存在，基于它继承的子子孙孙，当属对象。<br>乍一看，<code>null</code>像是上帝,而<code>Object</code>和<code>Function</code>犹如JavaScript世界中的<strong>亚当</strong>与<strong>夏娃</strong>。</p>\n<h1 id=\"原型指针-proto\"><a href=\"#原型指针-proto\" class=\"headerlink\" title=\"原型指针 __proto__\"></a>原型指针 <code>__proto__</code></h1><p>在JavaScript中，每个对象都拥有一个原型对象，而指向该原型对象的内部指针则是<code>__proto__</code>,通过它可以从中继承原型对象的属性，原型是JavaScript中的基因链接，有了这个，才能知道这个对象的祖祖辈辈。从对象中的<code>__proto__</code>可以访问到他所继承的原型对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\">a.__proto__ === <span class=\"built_in\">Array</span>.prototype <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，创建了一个Array的实例<code>a</code>，该实例的原型指向了<code>Array.prototype</code>。<br><code>Array.prototype</code>本身也是一个对象，也有继承的原型:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">a.__proto__.__proto__ === <span class=\"built_in\">Object</span>.prototype  <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"comment\">// 等同于 Array.prototype.__proto__ === Object.prototype</span></div></pre></td></tr></table></figure>\n<p>这就说了明了，Array本身也是继承自Object的，那么Object的原型指向的是谁呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">a.__proto__.__proto__.__proto__ === <span class=\"literal\">null</span>  <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"comment\">// 等同于 Object.prototype.__proto__ === null</span></div></pre></td></tr></table></figure>\n<p><img src=\"/image/blog/philosophy-though-of-javascript-proto/F155FDADCE01F99F7E10F5323F7CADEE.png\" alt=\"prototype.png\"></p>\n<p>所以说，JavaScript中的对象，追根溯源都是来自一个<strong>null</strong>对象。佛曰：<strong>万物皆空</strong>，善哉善哉。</p>\n<p>除了使用<code>.__proto__</code>方式访问对象的原型，还可以通过<code>Object.getPrototypeOf</code>方法来获取对象的原型，以及通过<code>Object.setPrototypeOf</code>方法来重写对象的原型<br>。<br>值得注意的是，按照语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeof</code>和<code>Object.setPrototypeOf</code>，进行原型对象的读写操作。<br>这里用<code>__proto__</code>属性来描述对象中的原型，是因为这样来得更加形象，且容易理解。</p>\n<h1 id=\"原型对象-prototype\"><a href=\"#原型对象-prototype\" class=\"headerlink\" title=\"原型对象 prototype\"></a>原型对象 <code>prototype</code></h1><p>函数作为JavaScript中的一等公民，它既是函数又是对象，函数的原型指向的是<code>Function.prototype</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">Foo.__proto__ === <span class=\"built_in\">Function</span>.prototype <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>函数实例除了拥有<code>__proto__</code>属性之外，还拥有<code>prototype</code>属性。<br>通过该函数构造的新的实例对象，其原型指针<code>__proto__</code>会指向该函数的<code>prototype</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Foo();</div><div class=\"line\">a.__proto__ === Foo.prototype; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>而函数的<code>prototype</code>属性，本身是一个由<code>Object</code>构造的实例对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Foo.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><code>prototype</code>属性很特殊，它还有一个隐式的<code>constructor</code>，指向了构造函数本身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Foo.prototype.constructor === Foo; <span class=\"comment\">// true</span></div><div class=\"line\">a.constructor === Foo; <span class=\"comment\">// true</span></div><div class=\"line\">a.constructor === Foo.prototype.constructor; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><img src=\"/image/blog/philosophy-though-of-javascript-proto/56AF39C33A5154A2178E9A82E53D2C11.png\" alt=\"prototype2.png\"></p>\n<h1 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<br>每个构造函数都有一个原型对象(<code>prototype</code>)，原型对象都包含一个指向构造函数的指针(<code>constructor</code>)，而实例都包含一个指向原型对象的内部指针(<code>__proto__</code>)。<br>那么，假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。<br>如此层层递进，就构造了实例与原型的链条，这就是<strong>原型链</strong>的基本概念。</p>\n<h2 id=\"意义\"><a href=\"#意义\" class=\"headerlink\" title=\"意义\"></a>意义</h2><p>“原型链”的作用在于，当读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。以此类推，如果直到最顶层的Object.prototype还是找不到，则返回undefine</p>\n<h1 id=\"亲子鉴定\"><a href=\"#亲子鉴定\" class=\"headerlink\" title=\"亲子鉴定\"></a>亲子鉴定</h1><p>在JavaScript中，也存在鉴定亲子之间DNA关系的方法：</p>\n<ol>\n<li><strong>instanceof</strong><br>运算符返回一个布尔值，表示一个对象是否由某个构造函数创建。</li>\n<li><strong>Object.isPrototypeOf()</strong><br>只要某个对象处在原型链上，isProtypeOf都返回true</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Bar();</div><div class=\"line\">b <span class=\"keyword\">instanceof</span> Bar <span class=\"comment\">// true</span></div><div class=\"line\">Bar.prototype.isPrototypeOf(b) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.prototype.isPrototypeOf(Bar) <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>要注意，实例<code>b</code>的原型是<code>Bar.prototype</code>而不是<code>Bar</code></p>\n<h1 id=\"一张历史悠久的图\"><a href=\"#一张历史悠久的图\" class=\"headerlink\" title=\"一张历史悠久的图\"></a>一张历史悠久的图</h1><p><img src=\"/image/blog/philosophy-though-of-javascript-proto/289FC3BDCB0425AA1C9F0DC5EBA1079F.jpg\" alt=\"jsobj_full.jpg\"></p>\n<p>这是一张描述了<code>Object</code>、<code>Function</code>以及一个函数实例<code>Foo</code>他们之间原型之间联系。如果理解了上面的概念，这张图是不难读懂。</p>\n<p>从上图中，能看到一个有趣的地方。<br><code>Function.prototype.__proto__</code> 指向了 <code>Object.prototype</code>，这说明<code>Function.prototype</code> 是一个 <code>Object</code>实例，那么应当是先有的<code>Object</code>再有<code>Function</code>。<br>但是<code>Object.prototype.constructor.__proto__</code> 又指向了 <code>Function.prototype</code>。这样看来，没有<code>Function</code>，<code>Object</code>也不能创建实例。<br>这就产生了一种类「先有鸡还是先有蛋」的经典问题，到底是先有的<code>Object</code>还是先有的<code>Function</code>呢？<br>这么哲学向的问题，留给你思考了。<br>我只是感慨：<br><strong>越往JavaScript的深处探索，越发觉得这一门语言很哲学。</strong></p>\n<h1 id=\"先有鸡还是先有蛋？\"><a href=\"#先有鸡还是先有蛋？\" class=\"headerlink\" title=\"先有鸡还是先有蛋？\"></a>先有鸡还是先有蛋？</h1><blockquote>\n<p>update on 2017/01/05</p>\n</blockquote>\n<p>时隔半年，偶尔翻开这篇文章。<br>对于这个问题，又有了新的思考。<br>愿意跟能看到这里的你来分享一下。</p>\n<p>我们可以先把 <code>Object.prototype</code> 和 <code>Function.prototype</code> 这两个拎出来看，因为他们本身就是一个实例对象。<br>为方便理解，我们改一下名字，避免和 Object 和 Function 的强关联，分别叫：<code>Op</code> 和 <code>Fp</code></p>\n<p>那么就有这样的原型链存在了 </p>\n<p><img src=\"/image/blog/philosophy-though-of-javascript-proto/object-or-function-first.png\" alt=\"先有鸡还是先有蛋\"></p>\n<p>我再描述一下上面的原型链，先有 null , 再有了 Op , 然后再有了 Fp ，然后以 Fp 为原型的两个构造函数 (Object, Function) 出现了。<br>而作为构造函数，需要有个 prototype 属性用来作为以该构造函数创造的实例的继承。<br>所以Object.prototype = Op, Function.prototype = Fp。</p>\n"},{"title":"NodeJS中被忽略的内存","date":"2016-04-14T12:19:02.000Z","_content":"\n> 如朴灵说过，Node对内存泄露十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用奔溃。\n\n虽然从很久以前就知道内存问题是不容忽视的，但是日常开发的时候并没有碰到性能上的瓶颈，直到最近做了一个百万PV级的营销项目，由于访问量，并发量都达到了一个量级。一些细小的、平时没注意到的问题被放大，这才映入眼帘，开始注意到了内存问题。殊不知Node对内存的泄露是如此的敏感。\n为此，赶紧去补习了一下V8中的内存处理机制。\n那么，V8中的内存机制是怎么样的？\n\n## V8的内存机制\n\n### 内存的限制\n\nNode中并不像其他后端语言中，对内存的使用没有多少限制。在Node中使用内存，只能使用到系统的一部分内存，64位系统下约为1.4GB，32位系统下约为0.7GB。这归咎于Node使用了本来运行在浏览器的V8引擎。\n\nV8引擎的设计之初只是运行在浏览器中，而在浏览器的一般应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。\n\n虽然服务端操作大内存也不是常见的需求，但是万一有这样的需求，还是可以解除限制的。\n在启动node程序的时候，可以传递两个参数来调整内存限制的大小。\n\n```\nnode --max-nex-space-size=1024 app.js // 单位为KB\nnode --max-old-space-size=2000 app.js // 单位为MB\n```\n\n这两条命令分别对应Node内存堆中的「新生代」和「老生代」\n\n### 不受内存限制的特例\n\n在Node中，使用Buffer可以读取超过V8内存限制的大文件。原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制。这在于Node并不同于浏览器的应用场景。在浏览器中，JavaScript直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流，操作字符串远远不能满足传输的性能需求。\n\n### 内存的分配\n\n> 一切JavaScript对象都用堆来存储\n\n当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的对空闲内存不够分配新的对象，讲继续申请堆内存，直到堆的大小超过V8的限制为止。\n\n![V8的堆示意图](/image/blog/memory-in-nodejs/V8的堆示意图.png)\n\n## V8的垃圾回收机制\n\n### 分代式垃圾回收\n\nV8的垃圾回收策略主要基于「分代式垃圾回收机制」，基于这个机制，V8把内存分为「新生代(New Space)」和 「老生代 (Old Space)」。\n新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。\n前面提及到的`--max-old-space-size`命令就是设置老生代内存空间的最大值，而`--max-new-space-size`命令则可以设置新生代内存空间的大小。\n\n![V8的分代示意图](/image/blog/memory-in-nodejs/V8的分代示意图.png)\n\n#### 为什么要分成新老两代？\n\n垃圾回收算法有很多种，但是并没有一种是胜任所有的场景，在实际的应用中，需要根据对象的生存周期长短不一，而使用不同的算法，已达到最好的效果。在V8中，按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同的内存施以更高效的算法。\n\n### 新生代中的垃圾回收\n\n在新生代中，主要通过**Scavenge**算法进行垃圾回收。\n\n#### Scavenge\n\n在Scavenge算法中，它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另外一个处于闲置状态。处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。当我们分配对象时，先是从From空间中分配。当开始进行垃圾回收时，会检查From空间中存活的对象，这些存活的对象会被复制到To空间中，而非存活的对象占用的空间会被释放。完成复制后，From空间和To空间角色互换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。\n\n![V8的堆内存示意图](/image/blog/memory-in-nodejs/V8的堆内存示意图.png)\n\n##### 在新生代中的对象怎样才能到老生代中？\n\n在新生代存活周期长的对象会被移动到老生代中，主要符合两个条件中的一个：\n\n**1. 对象是否经历过Scavenge回收。**\n对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果已经经历过了，则将该对象从From空间中复制到老生代空间中。\n\n**2. To空间的内存占比超过25%限制。**\n当对象从From空间复制到To空间时，如果To空间已经使用超过25%，则这个对象直接复制到老生代中。这么做的原因在于这次Scavenge回收完成后，这个To空间会变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。\n\n### 老生代中的垃圾回收\n\n对于老生代的对象，由于存活对象占比较大比重，使用Scavenge算法显然不科学。一来复制的对象太多会导致效率问题，二来需要浪费多一倍的空间。所以，V8在老生代中主要采用「Mark-Sweep」算法与「Mark-Compact」算法相结合的方式进行垃圾回收。\n\n#### Mark-Sweep\n\nMark-Sweep是标记清除的意思，分为标记和清除两个阶段。在标记阶段遍历堆中的所有对象，并标记存活的对象，在随后的清除阶段中，只清除标记之外的对象。\n\n![Mark-Sweep在老生代空间中标记后的示意图](/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png)\n\n但是Mark-Sweep有一个很严重的问题，就是进行一次标记清除回收之后，内存会变得碎片化。如果需要分配一个大对象，这时候就无法完成分配了。这时候就该Mark-Compact出场了。\n\n#### Mark-Compact\n\nMark-Compact是标记整理的意思，是在Mark-Sweep基础上演变而来。Mark-Compact在标记存活对象之后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。\n\n![Mark-Compact完成标记并移动存活对象后的示意图](/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png)\n\n#### Incremental Marking\n\n鉴于Node单线程的特性，V8每次垃圾回收的时候，都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复应用逻辑，被称为「全停顿」。在分代垃圾回收中，一次小垃圾回收只收集新生代，且存活对象也相对较少，即使全停顿也没有多大的影响。但是在老生代中，存活对象较多，垃圾回收的标记、清理、整理都需要长时间的停顿，这样会严重影响到系统的性能。\n所以「增量标记 (Incrememtal Marking)」被提出来。它从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，拆分为许多小「步进」，每做完一「步进」就让JavaScript应用逻辑执行一小会，垃圾回收与应用逻辑这样交替执行直到标记阶段完成。\n\n## 内存泄露排查的工具\n\n### [node-heapdump](https://github.com/bnoordhuis/node-heapdump)\n\n它允许对V8堆内存抓取快照，用于事后分析。\n在程序中引入\n\n```javascript\nvar heapdump = require(\"node-heapdump\");\n```\n\n之后可以通过向服务器发送SIGUSR2信号，让node-heapdump抓拍一份堆内存的快照：\n\n```\n$ kill -USR2 <pid>\n```\n\n这份抓拍的快照会默认存放在文件目录下，这是一份大JSON文件，可以通过Chrome的开发者工具打开查看。\n\n![Chrome Profile](/image/blog/memory-in-nodejs/Chrome Profile.jpg)\n\n### [node-memwatch](https://github.com/lloyd/node-memwatch)\n\n> 需要注意，node-memwatch只是支持到node v0.12.x为止，当使用更高的版本的时候，就会安装不上，这时候可以使用[node-watch-next](https://github.com/marcominetti/node-memwatch) 替代，一摸一样的API。\n\n不同于node-heapdump，它提供了两个事件监听器，用来提供内存泄露的以及垃圾回收的信息：\n\n1. **stats事件**：每次进行全堆回收时，会触发改时间，传递内存的统计信息\n2. **leak事件**：经过五次垃圾回收之后，内存仍没有被释放的对象，会触发leak事件，传递相关的信息。\n\n### [node-profiler](https://profiler.alinode.aliyun.com/)\n\nnode-profiler 是 alinode团队出品的一个与node-heapdump类似的抓取内存堆快照的工具，不同的是，node-profiler的实现不一样，使用起来更便捷。附上他们的教程：[如何使用Node Profiler](https://github.com/ali-sdk/node-profiler/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Node-Profiler)\n\n### [alinode](https://alinode.aliyun.com/)\n\nalinode官方如似说：\n\n> alinode 是阿里云出品的 Node.js 应用服务解决方案，是一套基于社区 Node 改进的运行时环境和服务平台。在社区的基础上我们内建了强大的支持功能，帮助开发者迅速洞见性能细节，快速定位疑难杂症，直探问题根源。\n\n## 以上内容参考自\n\n[A tour of V8: Garbage Collection](http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)\n[V8 之旅： 垃圾回收器](http://newhtml.net/v8-garbage-collection/)\n[《深入浅出Node.js》](https://book.douban.com/subject/25768396/)\n","source":"_posts/NodeJS中被忽略的内存.md","raw":"---\ntitle: NodeJS中被忽略的内存\ncategory: 搬砖码农\ndate: 2016-04-14 20:19:02\ntags:\n- 前端\n- Nodejs\n- 内存\n---\n\n> 如朴灵说过，Node对内存泄露十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用奔溃。\n\n虽然从很久以前就知道内存问题是不容忽视的，但是日常开发的时候并没有碰到性能上的瓶颈，直到最近做了一个百万PV级的营销项目，由于访问量，并发量都达到了一个量级。一些细小的、平时没注意到的问题被放大，这才映入眼帘，开始注意到了内存问题。殊不知Node对内存的泄露是如此的敏感。\n为此，赶紧去补习了一下V8中的内存处理机制。\n那么，V8中的内存机制是怎么样的？\n\n## V8的内存机制\n\n### 内存的限制\n\nNode中并不像其他后端语言中，对内存的使用没有多少限制。在Node中使用内存，只能使用到系统的一部分内存，64位系统下约为1.4GB，32位系统下约为0.7GB。这归咎于Node使用了本来运行在浏览器的V8引擎。\n\nV8引擎的设计之初只是运行在浏览器中，而在浏览器的一般应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。\n\n虽然服务端操作大内存也不是常见的需求，但是万一有这样的需求，还是可以解除限制的。\n在启动node程序的时候，可以传递两个参数来调整内存限制的大小。\n\n```\nnode --max-nex-space-size=1024 app.js // 单位为KB\nnode --max-old-space-size=2000 app.js // 单位为MB\n```\n\n这两条命令分别对应Node内存堆中的「新生代」和「老生代」\n\n### 不受内存限制的特例\n\n在Node中，使用Buffer可以读取超过V8内存限制的大文件。原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制。这在于Node并不同于浏览器的应用场景。在浏览器中，JavaScript直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流，操作字符串远远不能满足传输的性能需求。\n\n### 内存的分配\n\n> 一切JavaScript对象都用堆来存储\n\n当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的对空闲内存不够分配新的对象，讲继续申请堆内存，直到堆的大小超过V8的限制为止。\n\n![V8的堆示意图](/image/blog/memory-in-nodejs/V8的堆示意图.png)\n\n## V8的垃圾回收机制\n\n### 分代式垃圾回收\n\nV8的垃圾回收策略主要基于「分代式垃圾回收机制」，基于这个机制，V8把内存分为「新生代(New Space)」和 「老生代 (Old Space)」。\n新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。\n前面提及到的`--max-old-space-size`命令就是设置老生代内存空间的最大值，而`--max-new-space-size`命令则可以设置新生代内存空间的大小。\n\n![V8的分代示意图](/image/blog/memory-in-nodejs/V8的分代示意图.png)\n\n#### 为什么要分成新老两代？\n\n垃圾回收算法有很多种，但是并没有一种是胜任所有的场景，在实际的应用中，需要根据对象的生存周期长短不一，而使用不同的算法，已达到最好的效果。在V8中，按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同的内存施以更高效的算法。\n\n### 新生代中的垃圾回收\n\n在新生代中，主要通过**Scavenge**算法进行垃圾回收。\n\n#### Scavenge\n\n在Scavenge算法中，它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另外一个处于闲置状态。处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。当我们分配对象时，先是从From空间中分配。当开始进行垃圾回收时，会检查From空间中存活的对象，这些存活的对象会被复制到To空间中，而非存活的对象占用的空间会被释放。完成复制后，From空间和To空间角色互换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。\n\n![V8的堆内存示意图](/image/blog/memory-in-nodejs/V8的堆内存示意图.png)\n\n##### 在新生代中的对象怎样才能到老生代中？\n\n在新生代存活周期长的对象会被移动到老生代中，主要符合两个条件中的一个：\n\n**1. 对象是否经历过Scavenge回收。**\n对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果已经经历过了，则将该对象从From空间中复制到老生代空间中。\n\n**2. To空间的内存占比超过25%限制。**\n当对象从From空间复制到To空间时，如果To空间已经使用超过25%，则这个对象直接复制到老生代中。这么做的原因在于这次Scavenge回收完成后，这个To空间会变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。\n\n### 老生代中的垃圾回收\n\n对于老生代的对象，由于存活对象占比较大比重，使用Scavenge算法显然不科学。一来复制的对象太多会导致效率问题，二来需要浪费多一倍的空间。所以，V8在老生代中主要采用「Mark-Sweep」算法与「Mark-Compact」算法相结合的方式进行垃圾回收。\n\n#### Mark-Sweep\n\nMark-Sweep是标记清除的意思，分为标记和清除两个阶段。在标记阶段遍历堆中的所有对象，并标记存活的对象，在随后的清除阶段中，只清除标记之外的对象。\n\n![Mark-Sweep在老生代空间中标记后的示意图](/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png)\n\n但是Mark-Sweep有一个很严重的问题，就是进行一次标记清除回收之后，内存会变得碎片化。如果需要分配一个大对象，这时候就无法完成分配了。这时候就该Mark-Compact出场了。\n\n#### Mark-Compact\n\nMark-Compact是标记整理的意思，是在Mark-Sweep基础上演变而来。Mark-Compact在标记存活对象之后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。\n\n![Mark-Compact完成标记并移动存活对象后的示意图](/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png)\n\n#### Incremental Marking\n\n鉴于Node单线程的特性，V8每次垃圾回收的时候，都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复应用逻辑，被称为「全停顿」。在分代垃圾回收中，一次小垃圾回收只收集新生代，且存活对象也相对较少，即使全停顿也没有多大的影响。但是在老生代中，存活对象较多，垃圾回收的标记、清理、整理都需要长时间的停顿，这样会严重影响到系统的性能。\n所以「增量标记 (Incrememtal Marking)」被提出来。它从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，拆分为许多小「步进」，每做完一「步进」就让JavaScript应用逻辑执行一小会，垃圾回收与应用逻辑这样交替执行直到标记阶段完成。\n\n## 内存泄露排查的工具\n\n### [node-heapdump](https://github.com/bnoordhuis/node-heapdump)\n\n它允许对V8堆内存抓取快照，用于事后分析。\n在程序中引入\n\n```javascript\nvar heapdump = require(\"node-heapdump\");\n```\n\n之后可以通过向服务器发送SIGUSR2信号，让node-heapdump抓拍一份堆内存的快照：\n\n```\n$ kill -USR2 <pid>\n```\n\n这份抓拍的快照会默认存放在文件目录下，这是一份大JSON文件，可以通过Chrome的开发者工具打开查看。\n\n![Chrome Profile](/image/blog/memory-in-nodejs/Chrome Profile.jpg)\n\n### [node-memwatch](https://github.com/lloyd/node-memwatch)\n\n> 需要注意，node-memwatch只是支持到node v0.12.x为止，当使用更高的版本的时候，就会安装不上，这时候可以使用[node-watch-next](https://github.com/marcominetti/node-memwatch) 替代，一摸一样的API。\n\n不同于node-heapdump，它提供了两个事件监听器，用来提供内存泄露的以及垃圾回收的信息：\n\n1. **stats事件**：每次进行全堆回收时，会触发改时间，传递内存的统计信息\n2. **leak事件**：经过五次垃圾回收之后，内存仍没有被释放的对象，会触发leak事件，传递相关的信息。\n\n### [node-profiler](https://profiler.alinode.aliyun.com/)\n\nnode-profiler 是 alinode团队出品的一个与node-heapdump类似的抓取内存堆快照的工具，不同的是，node-profiler的实现不一样，使用起来更便捷。附上他们的教程：[如何使用Node Profiler](https://github.com/ali-sdk/node-profiler/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Node-Profiler)\n\n### [alinode](https://alinode.aliyun.com/)\n\nalinode官方如似说：\n\n> alinode 是阿里云出品的 Node.js 应用服务解决方案，是一套基于社区 Node 改进的运行时环境和服务平台。在社区的基础上我们内建了强大的支持功能，帮助开发者迅速洞见性能细节，快速定位疑难杂症，直探问题根源。\n\n## 以上内容参考自\n\n[A tour of V8: Garbage Collection](http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)\n[V8 之旅： 垃圾回收器](http://newhtml.net/v8-garbage-collection/)\n[《深入浅出Node.js》](https://book.douban.com/subject/25768396/)\n","slug":"NodeJS中被忽略的内存","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwp6000615hlqmqzfqdj","content":"<blockquote>\n<p>如朴灵说过，Node对内存泄露十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用奔溃。</p>\n</blockquote>\n<p>虽然从很久以前就知道内存问题是不容忽视的，但是日常开发的时候并没有碰到性能上的瓶颈，直到最近做了一个百万PV级的营销项目，由于访问量，并发量都达到了一个量级。一些细小的、平时没注意到的问题被放大，这才映入眼帘，开始注意到了内存问题。殊不知Node对内存的泄露是如此的敏感。<br>为此，赶紧去补习了一下V8中的内存处理机制。<br>那么，V8中的内存机制是怎么样的？</p>\n<h2 id=\"V8的内存机制\"><a href=\"#V8的内存机制\" class=\"headerlink\" title=\"V8的内存机制\"></a>V8的内存机制</h2><h3 id=\"内存的限制\"><a href=\"#内存的限制\" class=\"headerlink\" title=\"内存的限制\"></a>内存的限制</h3><p>Node中并不像其他后端语言中，对内存的使用没有多少限制。在Node中使用内存，只能使用到系统的一部分内存，64位系统下约为1.4GB，32位系统下约为0.7GB。这归咎于Node使用了本来运行在浏览器的V8引擎。</p>\n<p>V8引擎的设计之初只是运行在浏览器中，而在浏览器的一般应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。</p>\n<p>虽然服务端操作大内存也不是常见的需求，但是万一有这样的需求，还是可以解除限制的。<br>在启动node程序的时候，可以传递两个参数来调整内存限制的大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">node --max-nex-space-size=1024 app.js // 单位为KB</div><div class=\"line\">node --max-old-space-size=2000 app.js // 单位为MB</div></pre></td></tr></table></figure>\n<p>这两条命令分别对应Node内存堆中的「新生代」和「老生代」</p>\n<h3 id=\"不受内存限制的特例\"><a href=\"#不受内存限制的特例\" class=\"headerlink\" title=\"不受内存限制的特例\"></a>不受内存限制的特例</h3><p>在Node中，使用Buffer可以读取超过V8内存限制的大文件。原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制。这在于Node并不同于浏览器的应用场景。在浏览器中，JavaScript直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流，操作字符串远远不能满足传输的性能需求。</p>\n<h3 id=\"内存的分配\"><a href=\"#内存的分配\" class=\"headerlink\" title=\"内存的分配\"></a>内存的分配</h3><blockquote>\n<p>一切JavaScript对象都用堆来存储</p>\n</blockquote>\n<p>当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的对空闲内存不够分配新的对象，讲继续申请堆内存，直到堆的大小超过V8的限制为止。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/V8的堆示意图.png\" alt=\"V8的堆示意图\"></p>\n<h2 id=\"V8的垃圾回收机制\"><a href=\"#V8的垃圾回收机制\" class=\"headerlink\" title=\"V8的垃圾回收机制\"></a>V8的垃圾回收机制</h2><h3 id=\"分代式垃圾回收\"><a href=\"#分代式垃圾回收\" class=\"headerlink\" title=\"分代式垃圾回收\"></a>分代式垃圾回收</h3><p>V8的垃圾回收策略主要基于「分代式垃圾回收机制」，基于这个机制，V8把内存分为「新生代(New Space)」和 「老生代 (Old Space)」。<br>新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。<br>前面提及到的<code>--max-old-space-size</code>命令就是设置老生代内存空间的最大值，而<code>--max-new-space-size</code>命令则可以设置新生代内存空间的大小。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/V8的分代示意图.png\" alt=\"V8的分代示意图\"></p>\n<h4 id=\"为什么要分成新老两代？\"><a href=\"#为什么要分成新老两代？\" class=\"headerlink\" title=\"为什么要分成新老两代？\"></a>为什么要分成新老两代？</h4><p>垃圾回收算法有很多种，但是并没有一种是胜任所有的场景，在实际的应用中，需要根据对象的生存周期长短不一，而使用不同的算法，已达到最好的效果。在V8中，按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同的内存施以更高效的算法。</p>\n<h3 id=\"新生代中的垃圾回收\"><a href=\"#新生代中的垃圾回收\" class=\"headerlink\" title=\"新生代中的垃圾回收\"></a>新生代中的垃圾回收</h3><p>在新生代中，主要通过<strong>Scavenge</strong>算法进行垃圾回收。</p>\n<h4 id=\"Scavenge\"><a href=\"#Scavenge\" class=\"headerlink\" title=\"Scavenge\"></a>Scavenge</h4><p>在Scavenge算法中，它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另外一个处于闲置状态。处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。当我们分配对象时，先是从From空间中分配。当开始进行垃圾回收时，会检查From空间中存活的对象，这些存活的对象会被复制到To空间中，而非存活的对象占用的空间会被释放。完成复制后，From空间和To空间角色互换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/V8的堆内存示意图.png\" alt=\"V8的堆内存示意图\"></p>\n<h5 id=\"在新生代中的对象怎样才能到老生代中？\"><a href=\"#在新生代中的对象怎样才能到老生代中？\" class=\"headerlink\" title=\"在新生代中的对象怎样才能到老生代中？\"></a>在新生代中的对象怎样才能到老生代中？</h5><p>在新生代存活周期长的对象会被移动到老生代中，主要符合两个条件中的一个：</p>\n<p><strong>1. 对象是否经历过Scavenge回收。</strong><br>对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果已经经历过了，则将该对象从From空间中复制到老生代空间中。</p>\n<p><strong>2. To空间的内存占比超过25%限制。</strong><br>当对象从From空间复制到To空间时，如果To空间已经使用超过25%，则这个对象直接复制到老生代中。这么做的原因在于这次Scavenge回收完成后，这个To空间会变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</p>\n<h3 id=\"老生代中的垃圾回收\"><a href=\"#老生代中的垃圾回收\" class=\"headerlink\" title=\"老生代中的垃圾回收\"></a>老生代中的垃圾回收</h3><p>对于老生代的对象，由于存活对象占比较大比重，使用Scavenge算法显然不科学。一来复制的对象太多会导致效率问题，二来需要浪费多一倍的空间。所以，V8在老生代中主要采用「Mark-Sweep」算法与「Mark-Compact」算法相结合的方式进行垃圾回收。</p>\n<h4 id=\"Mark-Sweep\"><a href=\"#Mark-Sweep\" class=\"headerlink\" title=\"Mark-Sweep\"></a>Mark-Sweep</h4><p>Mark-Sweep是标记清除的意思，分为标记和清除两个阶段。在标记阶段遍历堆中的所有对象，并标记存活的对象，在随后的清除阶段中，只清除标记之外的对象。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png\" alt=\"Mark-Sweep在老生代空间中标记后的示意图\"></p>\n<p>但是Mark-Sweep有一个很严重的问题，就是进行一次标记清除回收之后，内存会变得碎片化。如果需要分配一个大对象，这时候就无法完成分配了。这时候就该Mark-Compact出场了。</p>\n<h4 id=\"Mark-Compact\"><a href=\"#Mark-Compact\" class=\"headerlink\" title=\"Mark-Compact\"></a>Mark-Compact</h4><p>Mark-Compact是标记整理的意思，是在Mark-Sweep基础上演变而来。Mark-Compact在标记存活对象之后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png\" alt=\"Mark-Compact完成标记并移动存活对象后的示意图\"></p>\n<h4 id=\"Incremental-Marking\"><a href=\"#Incremental-Marking\" class=\"headerlink\" title=\"Incremental Marking\"></a>Incremental Marking</h4><p>鉴于Node单线程的特性，V8每次垃圾回收的时候，都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复应用逻辑，被称为「全停顿」。在分代垃圾回收中，一次小垃圾回收只收集新生代，且存活对象也相对较少，即使全停顿也没有多大的影响。但是在老生代中，存活对象较多，垃圾回收的标记、清理、整理都需要长时间的停顿，这样会严重影响到系统的性能。<br>所以「增量标记 (Incrememtal Marking)」被提出来。它从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，拆分为许多小「步进」，每做完一「步进」就让JavaScript应用逻辑执行一小会，垃圾回收与应用逻辑这样交替执行直到标记阶段完成。</p>\n<h2 id=\"内存泄露排查的工具\"><a href=\"#内存泄露排查的工具\" class=\"headerlink\" title=\"内存泄露排查的工具\"></a>内存泄露排查的工具</h2><h3 id=\"node-heapdump\"><a href=\"#node-heapdump\" class=\"headerlink\" title=\"node-heapdump\"></a><a href=\"https://github.com/bnoordhuis/node-heapdump\" target=\"_blank\" rel=\"external\">node-heapdump</a></h3><p>它允许对V8堆内存抓取快照，用于事后分析。<br>在程序中引入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> heapdump = <span class=\"built_in\">require</span>(<span class=\"string\">\"node-heapdump\"</span>);</div></pre></td></tr></table></figure>\n<p>之后可以通过向服务器发送SIGUSR2信号，让node-heapdump抓拍一份堆内存的快照：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ kill -USR2 &lt;pid&gt;</div></pre></td></tr></table></figure>\n<p>这份抓拍的快照会默认存放在文件目录下，这是一份大JSON文件，可以通过Chrome的开发者工具打开查看。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/Chrome Profile.jpg\" alt=\"Chrome Profile\"></p>\n<h3 id=\"node-memwatch\"><a href=\"#node-memwatch\" class=\"headerlink\" title=\"node-memwatch\"></a><a href=\"https://github.com/lloyd/node-memwatch\" target=\"_blank\" rel=\"external\">node-memwatch</a></h3><blockquote>\n<p>需要注意，node-memwatch只是支持到node v0.12.x为止，当使用更高的版本的时候，就会安装不上，这时候可以使用<a href=\"https://github.com/marcominetti/node-memwatch\" target=\"_blank\" rel=\"external\">node-watch-next</a> 替代，一摸一样的API。</p>\n</blockquote>\n<p>不同于node-heapdump，它提供了两个事件监听器，用来提供内存泄露的以及垃圾回收的信息：</p>\n<ol>\n<li><strong>stats事件</strong>：每次进行全堆回收时，会触发改时间，传递内存的统计信息</li>\n<li><strong>leak事件</strong>：经过五次垃圾回收之后，内存仍没有被释放的对象，会触发leak事件，传递相关的信息。</li>\n</ol>\n<h3 id=\"node-profiler\"><a href=\"#node-profiler\" class=\"headerlink\" title=\"node-profiler\"></a><a href=\"https://profiler.alinode.aliyun.com/\" target=\"_blank\" rel=\"external\">node-profiler</a></h3><p>node-profiler 是 alinode团队出品的一个与node-heapdump类似的抓取内存堆快照的工具，不同的是，node-profiler的实现不一样，使用起来更便捷。附上他们的教程：<a href=\"https://github.com/ali-sdk/node-profiler/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Node-Profiler\" target=\"_blank\" rel=\"external\">如何使用Node Profiler</a></p>\n<h3 id=\"alinode\"><a href=\"#alinode\" class=\"headerlink\" title=\"alinode\"></a><a href=\"https://alinode.aliyun.com/\" target=\"_blank\" rel=\"external\">alinode</a></h3><p>alinode官方如似说：</p>\n<blockquote>\n<p>alinode 是阿里云出品的 Node.js 应用服务解决方案，是一套基于社区 Node 改进的运行时环境和服务平台。在社区的基础上我们内建了强大的支持功能，帮助开发者迅速洞见性能细节，快速定位疑难杂症，直探问题根源。</p>\n</blockquote>\n<h2 id=\"以上内容参考自\"><a href=\"#以上内容参考自\" class=\"headerlink\" title=\"以上内容参考自\"></a>以上内容参考自</h2><p><a href=\"http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection\" target=\"_blank\" rel=\"external\">A tour of V8: Garbage Collection</a><br><a href=\"http://newhtml.net/v8-garbage-collection/\" target=\"_blank\" rel=\"external\">V8 之旅： 垃圾回收器</a><br><a href=\"https://book.douban.com/subject/25768396/\" target=\"_blank\" rel=\"external\">《深入浅出Node.js》</a></p>\n","excerpt":"","more":"<blockquote>\n<p>如朴灵说过，Node对内存泄露十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用奔溃。</p>\n</blockquote>\n<p>虽然从很久以前就知道内存问题是不容忽视的，但是日常开发的时候并没有碰到性能上的瓶颈，直到最近做了一个百万PV级的营销项目，由于访问量，并发量都达到了一个量级。一些细小的、平时没注意到的问题被放大，这才映入眼帘，开始注意到了内存问题。殊不知Node对内存的泄露是如此的敏感。<br>为此，赶紧去补习了一下V8中的内存处理机制。<br>那么，V8中的内存机制是怎么样的？</p>\n<h2 id=\"V8的内存机制\"><a href=\"#V8的内存机制\" class=\"headerlink\" title=\"V8的内存机制\"></a>V8的内存机制</h2><h3 id=\"内存的限制\"><a href=\"#内存的限制\" class=\"headerlink\" title=\"内存的限制\"></a>内存的限制</h3><p>Node中并不像其他后端语言中，对内存的使用没有多少限制。在Node中使用内存，只能使用到系统的一部分内存，64位系统下约为1.4GB，32位系统下约为0.7GB。这归咎于Node使用了本来运行在浏览器的V8引擎。</p>\n<p>V8引擎的设计之初只是运行在浏览器中，而在浏览器的一般应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。</p>\n<p>虽然服务端操作大内存也不是常见的需求，但是万一有这样的需求，还是可以解除限制的。<br>在启动node程序的时候，可以传递两个参数来调整内存限制的大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">node --max-nex-space-size=1024 app.js // 单位为KB</div><div class=\"line\">node --max-old-space-size=2000 app.js // 单位为MB</div></pre></td></tr></table></figure>\n<p>这两条命令分别对应Node内存堆中的「新生代」和「老生代」</p>\n<h3 id=\"不受内存限制的特例\"><a href=\"#不受内存限制的特例\" class=\"headerlink\" title=\"不受内存限制的特例\"></a>不受内存限制的特例</h3><p>在Node中，使用Buffer可以读取超过V8内存限制的大文件。原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制。这在于Node并不同于浏览器的应用场景。在浏览器中，JavaScript直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流，操作字符串远远不能满足传输的性能需求。</p>\n<h3 id=\"内存的分配\"><a href=\"#内存的分配\" class=\"headerlink\" title=\"内存的分配\"></a>内存的分配</h3><blockquote>\n<p>一切JavaScript对象都用堆来存储</p>\n</blockquote>\n<p>当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的对空闲内存不够分配新的对象，讲继续申请堆内存，直到堆的大小超过V8的限制为止。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/V8的堆示意图.png\" alt=\"V8的堆示意图\"></p>\n<h2 id=\"V8的垃圾回收机制\"><a href=\"#V8的垃圾回收机制\" class=\"headerlink\" title=\"V8的垃圾回收机制\"></a>V8的垃圾回收机制</h2><h3 id=\"分代式垃圾回收\"><a href=\"#分代式垃圾回收\" class=\"headerlink\" title=\"分代式垃圾回收\"></a>分代式垃圾回收</h3><p>V8的垃圾回收策略主要基于「分代式垃圾回收机制」，基于这个机制，V8把内存分为「新生代(New Space)」和 「老生代 (Old Space)」。<br>新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。<br>前面提及到的<code>--max-old-space-size</code>命令就是设置老生代内存空间的最大值，而<code>--max-new-space-size</code>命令则可以设置新生代内存空间的大小。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/V8的分代示意图.png\" alt=\"V8的分代示意图\"></p>\n<h4 id=\"为什么要分成新老两代？\"><a href=\"#为什么要分成新老两代？\" class=\"headerlink\" title=\"为什么要分成新老两代？\"></a>为什么要分成新老两代？</h4><p>垃圾回收算法有很多种，但是并没有一种是胜任所有的场景，在实际的应用中，需要根据对象的生存周期长短不一，而使用不同的算法，已达到最好的效果。在V8中，按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同的内存施以更高效的算法。</p>\n<h3 id=\"新生代中的垃圾回收\"><a href=\"#新生代中的垃圾回收\" class=\"headerlink\" title=\"新生代中的垃圾回收\"></a>新生代中的垃圾回收</h3><p>在新生代中，主要通过<strong>Scavenge</strong>算法进行垃圾回收。</p>\n<h4 id=\"Scavenge\"><a href=\"#Scavenge\" class=\"headerlink\" title=\"Scavenge\"></a>Scavenge</h4><p>在Scavenge算法中，它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另外一个处于闲置状态。处于使用状态的semispace称为From空间，处于闲置状态的semispace称为To空间。当我们分配对象时，先是从From空间中分配。当开始进行垃圾回收时，会检查From空间中存活的对象，这些存活的对象会被复制到To空间中，而非存活的对象占用的空间会被释放。完成复制后，From空间和To空间角色互换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/V8的堆内存示意图.png\" alt=\"V8的堆内存示意图\"></p>\n<h5 id=\"在新生代中的对象怎样才能到老生代中？\"><a href=\"#在新生代中的对象怎样才能到老生代中？\" class=\"headerlink\" title=\"在新生代中的对象怎样才能到老生代中？\"></a>在新生代中的对象怎样才能到老生代中？</h5><p>在新生代存活周期长的对象会被移动到老生代中，主要符合两个条件中的一个：</p>\n<p><strong>1. 对象是否经历过Scavenge回收。</strong><br>对象从From空间中复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果已经经历过了，则将该对象从From空间中复制到老生代空间中。</p>\n<p><strong>2. To空间的内存占比超过25%限制。</strong><br>当对象从From空间复制到To空间时，如果To空间已经使用超过25%，则这个对象直接复制到老生代中。这么做的原因在于这次Scavenge回收完成后，这个To空间会变成From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</p>\n<h3 id=\"老生代中的垃圾回收\"><a href=\"#老生代中的垃圾回收\" class=\"headerlink\" title=\"老生代中的垃圾回收\"></a>老生代中的垃圾回收</h3><p>对于老生代的对象，由于存活对象占比较大比重，使用Scavenge算法显然不科学。一来复制的对象太多会导致效率问题，二来需要浪费多一倍的空间。所以，V8在老生代中主要采用「Mark-Sweep」算法与「Mark-Compact」算法相结合的方式进行垃圾回收。</p>\n<h4 id=\"Mark-Sweep\"><a href=\"#Mark-Sweep\" class=\"headerlink\" title=\"Mark-Sweep\"></a>Mark-Sweep</h4><p>Mark-Sweep是标记清除的意思，分为标记和清除两个阶段。在标记阶段遍历堆中的所有对象，并标记存活的对象，在随后的清除阶段中，只清除标记之外的对象。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/Mark-Sweep在老生代空间中标记后的示意图.png\" alt=\"Mark-Sweep在老生代空间中标记后的示意图\"></p>\n<p>但是Mark-Sweep有一个很严重的问题，就是进行一次标记清除回收之后，内存会变得碎片化。如果需要分配一个大对象，这时候就无法完成分配了。这时候就该Mark-Compact出场了。</p>\n<h4 id=\"Mark-Compact\"><a href=\"#Mark-Compact\" class=\"headerlink\" title=\"Mark-Compact\"></a>Mark-Compact</h4><p>Mark-Compact是标记整理的意思，是在Mark-Sweep基础上演变而来。Mark-Compact在标记存活对象之后，在整理过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/Mark-Compact完成标记并移动存活对象后的示意图.png\" alt=\"Mark-Compact完成标记并移动存活对象后的示意图\"></p>\n<h4 id=\"Incremental-Marking\"><a href=\"#Incremental-Marking\" class=\"headerlink\" title=\"Incremental Marking\"></a>Incremental Marking</h4><p>鉴于Node单线程的特性，V8每次垃圾回收的时候，都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复应用逻辑，被称为「全停顿」。在分代垃圾回收中，一次小垃圾回收只收集新生代，且存活对象也相对较少，即使全停顿也没有多大的影响。但是在老生代中，存活对象较多，垃圾回收的标记、清理、整理都需要长时间的停顿，这样会严重影响到系统的性能。<br>所以「增量标记 (Incrememtal Marking)」被提出来。它从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，拆分为许多小「步进」，每做完一「步进」就让JavaScript应用逻辑执行一小会，垃圾回收与应用逻辑这样交替执行直到标记阶段完成。</p>\n<h2 id=\"内存泄露排查的工具\"><a href=\"#内存泄露排查的工具\" class=\"headerlink\" title=\"内存泄露排查的工具\"></a>内存泄露排查的工具</h2><h3 id=\"node-heapdump\"><a href=\"#node-heapdump\" class=\"headerlink\" title=\"node-heapdump\"></a><a href=\"https://github.com/bnoordhuis/node-heapdump\">node-heapdump</a></h3><p>它允许对V8堆内存抓取快照，用于事后分析。<br>在程序中引入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> heapdump = <span class=\"built_in\">require</span>(<span class=\"string\">\"node-heapdump\"</span>);</div></pre></td></tr></table></figure>\n<p>之后可以通过向服务器发送SIGUSR2信号，让node-heapdump抓拍一份堆内存的快照：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ kill -USR2 &lt;pid&gt;</div></pre></td></tr></table></figure>\n<p>这份抓拍的快照会默认存放在文件目录下，这是一份大JSON文件，可以通过Chrome的开发者工具打开查看。</p>\n<p><img src=\"/image/blog/memory-in-nodejs/Chrome Profile.jpg\" alt=\"Chrome Profile\"></p>\n<h3 id=\"node-memwatch\"><a href=\"#node-memwatch\" class=\"headerlink\" title=\"node-memwatch\"></a><a href=\"https://github.com/lloyd/node-memwatch\">node-memwatch</a></h3><blockquote>\n<p>需要注意，node-memwatch只是支持到node v0.12.x为止，当使用更高的版本的时候，就会安装不上，这时候可以使用<a href=\"https://github.com/marcominetti/node-memwatch\">node-watch-next</a> 替代，一摸一样的API。</p>\n</blockquote>\n<p>不同于node-heapdump，它提供了两个事件监听器，用来提供内存泄露的以及垃圾回收的信息：</p>\n<ol>\n<li><strong>stats事件</strong>：每次进行全堆回收时，会触发改时间，传递内存的统计信息</li>\n<li><strong>leak事件</strong>：经过五次垃圾回收之后，内存仍没有被释放的对象，会触发leak事件，传递相关的信息。</li>\n</ol>\n<h3 id=\"node-profiler\"><a href=\"#node-profiler\" class=\"headerlink\" title=\"node-profiler\"></a><a href=\"https://profiler.alinode.aliyun.com/\">node-profiler</a></h3><p>node-profiler 是 alinode团队出品的一个与node-heapdump类似的抓取内存堆快照的工具，不同的是，node-profiler的实现不一样，使用起来更便捷。附上他们的教程：<a href=\"https://github.com/ali-sdk/node-profiler/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Node-Profiler\">如何使用Node Profiler</a></p>\n<h3 id=\"alinode\"><a href=\"#alinode\" class=\"headerlink\" title=\"alinode\"></a><a href=\"https://alinode.aliyun.com/\">alinode</a></h3><p>alinode官方如似说：</p>\n<blockquote>\n<p>alinode 是阿里云出品的 Node.js 应用服务解决方案，是一套基于社区 Node 改进的运行时环境和服务平台。在社区的基础上我们内建了强大的支持功能，帮助开发者迅速洞见性能细节，快速定位疑难杂症，直探问题根源。</p>\n</blockquote>\n<h2 id=\"以上内容参考自\"><a href=\"#以上内容参考自\" class=\"headerlink\" title=\"以上内容参考自\"></a>以上内容参考自</h2><p><a href=\"http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection\">A tour of V8: Garbage Collection</a><br><a href=\"http://newhtml.net/v8-garbage-collection/\">V8 之旅： 垃圾回收器</a><br><a href=\"https://book.douban.com/subject/25768396/\">《深入浅出Node.js》</a></p>\n"},{"title":"Kissy WaterFall 静态调用","date":"2013-03-07T04:04:24.000Z","_content":"\n需要用到的JS\n\n```HTML\n<script src=\"kissy.js\"></script>\n<script src=\"base.js\"></script>\n<script src=\"loader.js\"></script>\n<script src=\"waterfall.js\"></script>\n```\n\n需要设置的CSS样式\n\n```HTML\n<style>\n    .ks-waterfall {\n        position: absolute;\n        width: 192px;\n        overflow: hidden;\n        padding: 15px;\n        border: 2px solid #ddd;\n        margin-bottom: 20px;\n        text-align: center;\n        left:-9999px;\n        top:-9999px;\n    }\n</style>\n```\n\nHTML关键代码\n\n```HTML\n<div id='container' style=\"position: relative;\">\n    <!-- 重复的数据块 -->\n    <div class=\"ks-waterfall\"><img src=\"http://farm7.static.flickr.com/6072/6128820646_75d4f4f26d_m.jpg\" width=\"192\" height=\"113\">\n        <div class=\"title\">untitled</div>\n    </div>\n</div>\n```\n\n最后调用WaterFall的内嵌脚本\n\n```javascript\nKISSY.use(\"waterfall\", function (S, Waterfall) {\n    new Waterfall({\n        container: \"#container\",    //节点容器\n        minColCount: 2,             //最小列数\n        colWidth: 235               //每列的宽度\n    });\n});\n```\n","source":"_posts/Kissy-WaterFall-静态调用.md","raw":"---\ntitle: Kissy WaterFall 静态调用\ncategory: 搬砖码农\ndate: 2013-03-07 12:04:24\ntags:\n- 前端\n---\n\n需要用到的JS\n\n```HTML\n<script src=\"kissy.js\"></script>\n<script src=\"base.js\"></script>\n<script src=\"loader.js\"></script>\n<script src=\"waterfall.js\"></script>\n```\n\n需要设置的CSS样式\n\n```HTML\n<style>\n    .ks-waterfall {\n        position: absolute;\n        width: 192px;\n        overflow: hidden;\n        padding: 15px;\n        border: 2px solid #ddd;\n        margin-bottom: 20px;\n        text-align: center;\n        left:-9999px;\n        top:-9999px;\n    }\n</style>\n```\n\nHTML关键代码\n\n```HTML\n<div id='container' style=\"position: relative;\">\n    <!-- 重复的数据块 -->\n    <div class=\"ks-waterfall\"><img src=\"http://farm7.static.flickr.com/6072/6128820646_75d4f4f26d_m.jpg\" width=\"192\" height=\"113\">\n        <div class=\"title\">untitled</div>\n    </div>\n</div>\n```\n\n最后调用WaterFall的内嵌脚本\n\n```javascript\nKISSY.use(\"waterfall\", function (S, Waterfall) {\n    new Waterfall({\n        container: \"#container\",    //节点容器\n        minColCount: 2,             //最小列数\n        colWidth: 235               //每列的宽度\n    });\n});\n```\n","slug":"Kissy-WaterFall-静态调用","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwp9000815hl5lf9kjo2","content":"<p>需要用到的JS</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"kissy.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"base.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"loader.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"waterfall.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>需要设置的CSS样式</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">    .ks-waterfall &#123;</div><div class=\"line\">        position: absolute;</div><div class=\"line\">        width: 192px;</div><div class=\"line\">        overflow: hidden;</div><div class=\"line\">        padding: 15px;</div><div class=\"line\">        border: 2px solid #ddd;</div><div class=\"line\">        margin-bottom: 20px;</div><div class=\"line\">        text-align: center;</div><div class=\"line\">        left:-9999px;</div><div class=\"line\">        top:-9999px;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>HTML关键代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">'container'</span> <span class=\"attr\">style</span>=<span class=\"string\">\"position: relative;\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 重复的数据块 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ks-waterfall\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://farm7.static.flickr.com/6072/6128820646_75d4f4f26d_m.jpg\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"192\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"113\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"title\"</span>&gt;</span>untitled<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>最后调用WaterFall的内嵌脚本</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">KISSY.use(<span class=\"string\">\"waterfall\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">S, Waterfall</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">new</span> Waterfall(&#123;</div><div class=\"line\">        <span class=\"attr\">container</span>: <span class=\"string\">\"#container\"</span>,    <span class=\"comment\">//节点容器</span></div><div class=\"line\">        minColCount: <span class=\"number\">2</span>,             <span class=\"comment\">//最小列数</span></div><div class=\"line\">        colWidth: <span class=\"number\">235</span>               <span class=\"comment\">//每列的宽度</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>需要用到的JS</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"kissy.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"base.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"loader.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"waterfall.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>需要设置的CSS样式</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></div><div class=\"line\">    .ks-waterfall &#123;</div><div class=\"line\">        position: absolute;</div><div class=\"line\">        width: 192px;</div><div class=\"line\">        overflow: hidden;</div><div class=\"line\">        padding: 15px;</div><div class=\"line\">        border: 2px solid #ddd;</div><div class=\"line\">        margin-bottom: 20px;</div><div class=\"line\">        text-align: center;</div><div class=\"line\">        left:-9999px;</div><div class=\"line\">        top:-9999px;</div><div class=\"line\">    &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>HTML关键代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">'container'</span> <span class=\"attr\">style</span>=<span class=\"string\">\"position: relative;\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 重复的数据块 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ks-waterfall\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://farm7.static.flickr.com/6072/6128820646_75d4f4f26d_m.jpg\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"192\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"113\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"title\"</span>&gt;</span>untitled<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>最后调用WaterFall的内嵌脚本</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">KISSY.use(<span class=\"string\">\"waterfall\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">S, Waterfall</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">new</span> Waterfall(&#123;</div><div class=\"line\">        <span class=\"attr\">container</span>: <span class=\"string\">\"#container\"</span>,    <span class=\"comment\">//节点容器</span></div><div class=\"line\">        minColCount: <span class=\"number\">2</span>,             <span class=\"comment\">//最小列数</span></div><div class=\"line\">        colWidth: <span class=\"number\">235</span>               <span class=\"comment\">//每列的宽度</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n"},{"title":"Javascript那些书籍","date":"2014-07-08T12:50:07.000Z","_content":"\n转眼间已是准大四生了，在身边的小伙伴们纷纷参加各小中大企业的暑期实习的时候，我却因为某原因回家乡宅一两个月咯。\n\n人间有那么一句言论：程序员不持续学习是没出息滴。\n\n人生也何尝不是这样，立志在前端发过发热的我，列了一些关于Javascript的书单，回家好好填补一下那些个知识的漏洞。\n\n![javascript那些书籍](http://img.blog.csdn.net/20140708204644093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmx1ZXN1bjg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)","source":"_posts/Javascript那些书籍.md","raw":"---\ntitle: Javascript那些书籍\ndate: 2014-07-08 20:50:07\ntags:\n- 书籍\n- Javascript\ncategory: 人丑就要多读书\n---\n\n转眼间已是准大四生了，在身边的小伙伴们纷纷参加各小中大企业的暑期实习的时候，我却因为某原因回家乡宅一两个月咯。\n\n人间有那么一句言论：程序员不持续学习是没出息滴。\n\n人生也何尝不是这样，立志在前端发过发热的我，列了一些关于Javascript的书单，回家好好填补一下那些个知识的漏洞。\n\n![javascript那些书籍](http://img.blog.csdn.net/20140708204644093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmx1ZXN1bjg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)","slug":"Javascript那些书籍","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwpc000a15hlpfgc67om","content":"<p>转眼间已是准大四生了，在身边的小伙伴们纷纷参加各小中大企业的暑期实习的时候，我却因为某原因回家乡宅一两个月咯。</p>\n<p>人间有那么一句言论：程序员不持续学习是没出息滴。</p>\n<p>人生也何尝不是这样，立志在前端发过发热的我，列了一些关于Javascript的书单，回家好好填补一下那些个知识的漏洞。</p>\n<p><img src=\"http://img.blog.csdn.net/20140708204644093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmx1ZXN1bjg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"javascript那些书籍\"></p>\n","excerpt":"","more":"<p>转眼间已是准大四生了，在身边的小伙伴们纷纷参加各小中大企业的暑期实习的时候，我却因为某原因回家乡宅一两个月咯。</p>\n<p>人间有那么一句言论：程序员不持续学习是没出息滴。</p>\n<p>人生也何尝不是这样，立志在前端发过发热的我，列了一些关于Javascript的书单，回家好好填补一下那些个知识的漏洞。</p>\n<p><img src=\"http://img.blog.csdn.net/20140708204644093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmx1ZXN1bjg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"javascript那些书籍\"></p>\n"},{"title":"Kissy WaterFall 实现手动加载数据","date":"2013-07-21T04:41:06.000Z","_content":"\n## 前言\n由于Kissy WaterFall默认是监听滚动事件来实现数据动态加载的，但是有一些情况要用到手动加载数据。以下是使用Kissy WaterFall实现手动加载数据的方法。\n\n最终实现效果：点击”逛更多的商店“会动态加载数据\n\n\n## 步骤：\n\n1. 当一页数据加载完成后停止监听滚动事件\n\n```javascript\n//加载一页数据完成后触发的事件\nwaterfall.on('addComplete', function () {\n    S.log('after add complete!');\n\twaterfall.pause();\n});\n```\n\n2. 为按钮绑定重启监听滚动事件\n\n```javascript\n//加载更多按钮\n$(\"#button_container_more\").on('click',function(){\t\n\twaterfall.resunme();\n});\n```\n\n3. 附录\n\n> waterfall.pause()与water.resunme()的说明（从官网上转载的）\n> pause()函数和resunme()函数属于插件里的waterfall.loader对象的\n> resunme() ：继续开始监控scroll事件（随时可能会动态加载）\n> pause() ：停止监控scroll事件（停止动态加载）\n\n参考网址：http://docs.kissyui.com/docs/html/api/component/waterfall/loader.html#waterfall.Waterfall.prototype.pause\n\n\n\n\n出现问题：按照以上来完成的话，当点击”加载更多“按钮时，只是启动了滚动监听。意思就是，要加载数据，一要点击按钮，二要再次滚动鼠标。这样的用户体验很差。\n\n解决办法：修改按钮动作：new一个waterfall.loader，重新赋值waterfall对象，再重新绑定addComplete事件。\n代码如下：\n\n```javascript\n\t$(\"#button_container_more\").on('click',function(){\t\n\t\twaterfall = new Waterfall.Loader({\n\t\t\tcontainer:\"#ColumnContainer\",\n\t\t\tload:function (success, end) {\n\t\t\t\t$('#loadingPins').show();\n\t\t\t\t$('.loader').hide();\n\t\t\t\tS.ajax({\n\t\t\t\t\tdata:{\n\t\t\t\t\t\t'method':'flickr.photos.search',\n\t\t\t\t\t\t'api_key':'5d93c2e473e39e9307e86d4a01381266',\n\t\t\t\t\t\t'tags':'rose',\n\t\t\t\t\t\t'page':nextpage,\n\t\t\t\t\t\t'per_page':20,\n\t\t\t\t\t\t'format':'json'\n\t\t\t\t\t},\n\t\t\t\t\turl:'http://api.flickr.com/services/rest/',\n\t\t\t\t\tdataType:\"jsonp\",\n\t\t\t\t\tjsonp:\"jsoncallback\",\n\t\t\t\t\tsuccess:function (d) {\n\t\t\t\t\t\t// 如果数据错误, 则立即结束\n\t\t\t\t\t\tif (d.stat !== 'ok') {\n\t\t\t\t\t\t\talert('load data error!');\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 如果到最后一页了, 也结束加载\n\t\t\t\t\t\tnextpage = d.photos.page + 1;\n\t\t\t\t\t\tif (nextpage > d.photos.pages) {\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 拼装每页数据\n\t\t\t\t\t\tvar items = [];\n\t\t\t\t\t\tS.each(d.photos.photo, function (item) {\n\t\t\t\t\t\t\t/*所用到的字段：\n\t\t\t\t\t\t\t**price\n\t\t\t\t\t\t\t**height\n\t\t\t\t\t\t\t**collection\n\t\t\t\t\t\t\t**title\n\t\t\t\t\t\t\t**src\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\titem.height = Math.round(Math.random() * (300 - 180) + 180); // fake height\t\n\t\t\t\t\t\t\titem.collection = 10;\t//测试用\n\t\t\t\t\t\t\titem.price = 1800;\t\t//测试用\n\t\t\t\t\t\t\titems.push(S.substitute(tpl,item));\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsuccess(items);\n\t\t\t\t\t},\n\t\t\t\t\tcomplete:function () {\n\t\t\t\t\t\t$('#loadingPins').hide();\n\t\t\t\t\t\t$('.loader').show();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tminColCount:2,\n\t\t\tcolWidth:175\n\t\t\t//align:'left' // right, center (default)\n\t\t});\n\t\twaterfall.on('addComplete', function () {\n        \tS.log('after add complete!');\n\t\t\twaterfall.pause();\n    \t});\t\t\n\t});\n```\n\n最终整个脚本文件：\n\n```javascript\nKISSY.use(\"waterfall,ajax,node,button\", function (S, Waterfall, io,  Node, Button) {\n    var $ = Node.all;\n    var tpl = $('#tpl').html(),\n\tnextpage = 1,\n\twaterfall = new Waterfall.Loader({\n\t\tcontainer:\"#ColumnContainer\",\n\t\tload:function (success, end) {\n\t\t\t$('#loadingPins').show();\n\t\t\tS.ajax({\n\t\t\t\tdata:{\n\t\t\t\t\t'method':'flickr.photos.search',\n\t\t\t\t\t'api_key':'5d93c2e473e39e9307e86d4a01381266',\n\t\t\t\t\t'tags':'rose',\n\t\t\t\t\t'page':nextpage,\n\t\t\t\t\t'per_page':20,\n\t\t\t\t\t'format':'json'\n\t\t\t\t},\n\t\t\t\turl:'http://api.flickr.com/services/rest/',\n\t\t\t\tdataType:\"jsonp\",\n\t\t\t\tjsonp:\"jsoncallback\",\n\t\t\t\tsuccess:function (d) {\n\t\t\t\t\t// 如果数据错误, 则立即结束\n\t\t\t\t\tif (d.stat !== 'ok') {\n\t\t\t\t\t\talert('load data error!');\n\t\t\t\t\t\tend();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// 如果到最后一页了, 也结束加载\n\t\t\t\t\tnextpage = d.photos.page + 1;\n\t\t\t\t\tif (nextpage > d.photos.pages) {\n\t\t\t\t\t\tend();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// 拼装每页数据\n\t\t\t\t\tvar items = [];\n\t\t\t\t\tS.each(d.photos.photo, function (item) {\n\t\t\t\t\t\t/*所用到的字段：\n\t\t\t\t\t\t**price\n\t\t\t\t\t\t**height\n\t\t\t\t\t\t**collection\n\t\t\t\t\t\t**title\n\t\t\t\t\t\t**src\n\t\t\t\t\t\t*/\n\t\t\t\t\t\titem.height = Math.round(Math.random() * (300 - 180) + 180); // fake height\t\n\t\t\t\t\t\titem.collection = 10;\t//测试用\n\t\t\t\t\t\titem.price = 1800;\t\t//测试用\n\t\t\t\t\t\titems.push(S.substitute(tpl,item));\n\t\t\t\t\t});\n\t\t\t\t\tsuccess(items);\n\t\t\t\t},\n\t\t\t\tcomplete:function () {\n\t\t\t\t\t$('#loadingPins').hide();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tminColCount:2,\n\t\tcolWidth:175\n\t\t//align:'left' // right, center (default)\n\t});\n    waterfall.on('adjustComplete', function () {\n        S.log('after adjust complete!');\n    });\n\t//加载一页数据完成后触发的事件\n    waterfall.on('addComplete', function () {\n        S.log('after add complete!');\n\t\twaterfall.pause();\n    });\n    // scrollTo\n    $('#BackToTop').on('click', function (e) {\n        e.halt();\n        e.preventDefault();\n        $(window).stop();\n        $(window).animate({\n            scrollTop:0\n        }, 1, \"easeOut\");\n    });\n\t//加载更多按钮\n\t$(\"#button_container_more\").on('click',function(){\t\n\t\twaterfall = new Waterfall.Loader({\n\t\t\tcontainer:\"#ColumnContainer\",\n\t\t\tload:function (success, end) {\n\t\t\t\t$('#loadingPins').show();\n\t\t\t\t$('.loader').hide();\n\t\t\t\tS.ajax({\n\t\t\t\t\tdata:{\n\t\t\t\t\t\t'method':'flickr.photos.search',\n\t\t\t\t\t\t'api_key':'5d93c2e473e39e9307e86d4a01381266',\n\t\t\t\t\t\t'tags':'rose',\n\t\t\t\t\t\t'page':nextpage,\n\t\t\t\t\t\t'per_page':20,\n\t\t\t\t\t\t'format':'json'\n\t\t\t\t\t},\n\t\t\t\t\turl:'http://api.flickr.com/services/rest/',\n\t\t\t\t\tdataType:\"jsonp\",\n\t\t\t\t\tjsonp:\"jsoncallback\",\n\t\t\t\t\tsuccess:function (d) {\n\t\t\t\t\t\t// 如果数据错误, 则立即结束\n\t\t\t\t\t\tif (d.stat !== 'ok') {\n\t\t\t\t\t\t\talert('load data error!');\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 如果到最后一页了, 也结束加载\n\t\t\t\t\t\tnextpage = d.photos.page + 1;\n\t\t\t\t\t\tif (nextpage > d.photos.pages) {\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 拼装每页数据\n\t\t\t\t\t\tvar items = [];\n\t\t\t\t\t\tS.each(d.photos.photo, function (item) {\n\t\t\t\t\t\t\t/*所用到的字段：\n\t\t\t\t\t\t\t**price\n\t\t\t\t\t\t\t**height\n\t\t\t\t\t\t\t**collection\n\t\t\t\t\t\t\t**title\n\t\t\t\t\t\t\t**src\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\titem.height = Math.round(Math.random() * (300 - 180) + 180); // fake height\t\n\t\t\t\t\t\t\titem.collection = 10;\t//测试用\n\t\t\t\t\t\t\titem.price = 1800;\t\t//测试用\n\t\t\t\t\t\t\titems.push(S.substitute(tpl,item));\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsuccess(items);\n\t\t\t\t\t},\n\t\t\t\t\tcomplete:function () {\n\t\t\t\t\t\t$('#loadingPins').hide();\n\t\t\t\t\t\t$('.loader').show();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tminColCount:2,\n\t\t\tcolWidth:175\n\t\t\t//align:'left' // right, center (default)\n\t\t});\n\t\twaterfall.on('addComplete', function () {\n        \tS.log('after add complete!');\n\t\t\twaterfall.pause();\n    \t});\t\t\n\t});\n\t\n\t//收藏按钮功能\n\tvar collect;\n\t$('#ColumnContainer').delegate(\"mouseover\", \".collect\", function (event) {\n\t\tvar w = $(event.currentTarget).children(\"span\");\n\t\tvar text = w.text();\n\t\tif(text >= 0){\n\t\t\tcollect = text;\n\t\t}\n\t\t\n\t\tw.replaceWith(\"<span class='collects'>收藏</span>\");\n\t\t//w.css(\"text-indent\",\"3px\");\n\t});\n\t\n\t$('#ColumnContainer').delegate(\"mouseout\", \".collect\", function (event) {\n\t\tvar w = $(event.currentTarget).children(\"span\");\n\t\tw.replaceWith(\"<span class='collectionAmount'>\"+collect+\"</span>\");\n\t\t//w.css(\"text-indent\",\"13px\");\n\t});\n});\n```","source":"_posts/Kissy-WaterFall-实现手动加载数据.md","raw":"---\ntitle: Kissy WaterFall 实现手动加载数据\ncategory: 搬砖码农\ndate: 2013-07-21 12:41:06\ntags:\n- 前端\n---\n\n## 前言\n由于Kissy WaterFall默认是监听滚动事件来实现数据动态加载的，但是有一些情况要用到手动加载数据。以下是使用Kissy WaterFall实现手动加载数据的方法。\n\n最终实现效果：点击”逛更多的商店“会动态加载数据\n\n\n## 步骤：\n\n1. 当一页数据加载完成后停止监听滚动事件\n\n```javascript\n//加载一页数据完成后触发的事件\nwaterfall.on('addComplete', function () {\n    S.log('after add complete!');\n\twaterfall.pause();\n});\n```\n\n2. 为按钮绑定重启监听滚动事件\n\n```javascript\n//加载更多按钮\n$(\"#button_container_more\").on('click',function(){\t\n\twaterfall.resunme();\n});\n```\n\n3. 附录\n\n> waterfall.pause()与water.resunme()的说明（从官网上转载的）\n> pause()函数和resunme()函数属于插件里的waterfall.loader对象的\n> resunme() ：继续开始监控scroll事件（随时可能会动态加载）\n> pause() ：停止监控scroll事件（停止动态加载）\n\n参考网址：http://docs.kissyui.com/docs/html/api/component/waterfall/loader.html#waterfall.Waterfall.prototype.pause\n\n\n\n\n出现问题：按照以上来完成的话，当点击”加载更多“按钮时，只是启动了滚动监听。意思就是，要加载数据，一要点击按钮，二要再次滚动鼠标。这样的用户体验很差。\n\n解决办法：修改按钮动作：new一个waterfall.loader，重新赋值waterfall对象，再重新绑定addComplete事件。\n代码如下：\n\n```javascript\n\t$(\"#button_container_more\").on('click',function(){\t\n\t\twaterfall = new Waterfall.Loader({\n\t\t\tcontainer:\"#ColumnContainer\",\n\t\t\tload:function (success, end) {\n\t\t\t\t$('#loadingPins').show();\n\t\t\t\t$('.loader').hide();\n\t\t\t\tS.ajax({\n\t\t\t\t\tdata:{\n\t\t\t\t\t\t'method':'flickr.photos.search',\n\t\t\t\t\t\t'api_key':'5d93c2e473e39e9307e86d4a01381266',\n\t\t\t\t\t\t'tags':'rose',\n\t\t\t\t\t\t'page':nextpage,\n\t\t\t\t\t\t'per_page':20,\n\t\t\t\t\t\t'format':'json'\n\t\t\t\t\t},\n\t\t\t\t\turl:'http://api.flickr.com/services/rest/',\n\t\t\t\t\tdataType:\"jsonp\",\n\t\t\t\t\tjsonp:\"jsoncallback\",\n\t\t\t\t\tsuccess:function (d) {\n\t\t\t\t\t\t// 如果数据错误, 则立即结束\n\t\t\t\t\t\tif (d.stat !== 'ok') {\n\t\t\t\t\t\t\talert('load data error!');\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 如果到最后一页了, 也结束加载\n\t\t\t\t\t\tnextpage = d.photos.page + 1;\n\t\t\t\t\t\tif (nextpage > d.photos.pages) {\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 拼装每页数据\n\t\t\t\t\t\tvar items = [];\n\t\t\t\t\t\tS.each(d.photos.photo, function (item) {\n\t\t\t\t\t\t\t/*所用到的字段：\n\t\t\t\t\t\t\t**price\n\t\t\t\t\t\t\t**height\n\t\t\t\t\t\t\t**collection\n\t\t\t\t\t\t\t**title\n\t\t\t\t\t\t\t**src\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\titem.height = Math.round(Math.random() * (300 - 180) + 180); // fake height\t\n\t\t\t\t\t\t\titem.collection = 10;\t//测试用\n\t\t\t\t\t\t\titem.price = 1800;\t\t//测试用\n\t\t\t\t\t\t\titems.push(S.substitute(tpl,item));\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsuccess(items);\n\t\t\t\t\t},\n\t\t\t\t\tcomplete:function () {\n\t\t\t\t\t\t$('#loadingPins').hide();\n\t\t\t\t\t\t$('.loader').show();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tminColCount:2,\n\t\t\tcolWidth:175\n\t\t\t//align:'left' // right, center (default)\n\t\t});\n\t\twaterfall.on('addComplete', function () {\n        \tS.log('after add complete!');\n\t\t\twaterfall.pause();\n    \t});\t\t\n\t});\n```\n\n最终整个脚本文件：\n\n```javascript\nKISSY.use(\"waterfall,ajax,node,button\", function (S, Waterfall, io,  Node, Button) {\n    var $ = Node.all;\n    var tpl = $('#tpl').html(),\n\tnextpage = 1,\n\twaterfall = new Waterfall.Loader({\n\t\tcontainer:\"#ColumnContainer\",\n\t\tload:function (success, end) {\n\t\t\t$('#loadingPins').show();\n\t\t\tS.ajax({\n\t\t\t\tdata:{\n\t\t\t\t\t'method':'flickr.photos.search',\n\t\t\t\t\t'api_key':'5d93c2e473e39e9307e86d4a01381266',\n\t\t\t\t\t'tags':'rose',\n\t\t\t\t\t'page':nextpage,\n\t\t\t\t\t'per_page':20,\n\t\t\t\t\t'format':'json'\n\t\t\t\t},\n\t\t\t\turl:'http://api.flickr.com/services/rest/',\n\t\t\t\tdataType:\"jsonp\",\n\t\t\t\tjsonp:\"jsoncallback\",\n\t\t\t\tsuccess:function (d) {\n\t\t\t\t\t// 如果数据错误, 则立即结束\n\t\t\t\t\tif (d.stat !== 'ok') {\n\t\t\t\t\t\talert('load data error!');\n\t\t\t\t\t\tend();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// 如果到最后一页了, 也结束加载\n\t\t\t\t\tnextpage = d.photos.page + 1;\n\t\t\t\t\tif (nextpage > d.photos.pages) {\n\t\t\t\t\t\tend();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// 拼装每页数据\n\t\t\t\t\tvar items = [];\n\t\t\t\t\tS.each(d.photos.photo, function (item) {\n\t\t\t\t\t\t/*所用到的字段：\n\t\t\t\t\t\t**price\n\t\t\t\t\t\t**height\n\t\t\t\t\t\t**collection\n\t\t\t\t\t\t**title\n\t\t\t\t\t\t**src\n\t\t\t\t\t\t*/\n\t\t\t\t\t\titem.height = Math.round(Math.random() * (300 - 180) + 180); // fake height\t\n\t\t\t\t\t\titem.collection = 10;\t//测试用\n\t\t\t\t\t\titem.price = 1800;\t\t//测试用\n\t\t\t\t\t\titems.push(S.substitute(tpl,item));\n\t\t\t\t\t});\n\t\t\t\t\tsuccess(items);\n\t\t\t\t},\n\t\t\t\tcomplete:function () {\n\t\t\t\t\t$('#loadingPins').hide();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tminColCount:2,\n\t\tcolWidth:175\n\t\t//align:'left' // right, center (default)\n\t});\n    waterfall.on('adjustComplete', function () {\n        S.log('after adjust complete!');\n    });\n\t//加载一页数据完成后触发的事件\n    waterfall.on('addComplete', function () {\n        S.log('after add complete!');\n\t\twaterfall.pause();\n    });\n    // scrollTo\n    $('#BackToTop').on('click', function (e) {\n        e.halt();\n        e.preventDefault();\n        $(window).stop();\n        $(window).animate({\n            scrollTop:0\n        }, 1, \"easeOut\");\n    });\n\t//加载更多按钮\n\t$(\"#button_container_more\").on('click',function(){\t\n\t\twaterfall = new Waterfall.Loader({\n\t\t\tcontainer:\"#ColumnContainer\",\n\t\t\tload:function (success, end) {\n\t\t\t\t$('#loadingPins').show();\n\t\t\t\t$('.loader').hide();\n\t\t\t\tS.ajax({\n\t\t\t\t\tdata:{\n\t\t\t\t\t\t'method':'flickr.photos.search',\n\t\t\t\t\t\t'api_key':'5d93c2e473e39e9307e86d4a01381266',\n\t\t\t\t\t\t'tags':'rose',\n\t\t\t\t\t\t'page':nextpage,\n\t\t\t\t\t\t'per_page':20,\n\t\t\t\t\t\t'format':'json'\n\t\t\t\t\t},\n\t\t\t\t\turl:'http://api.flickr.com/services/rest/',\n\t\t\t\t\tdataType:\"jsonp\",\n\t\t\t\t\tjsonp:\"jsoncallback\",\n\t\t\t\t\tsuccess:function (d) {\n\t\t\t\t\t\t// 如果数据错误, 则立即结束\n\t\t\t\t\t\tif (d.stat !== 'ok') {\n\t\t\t\t\t\t\talert('load data error!');\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 如果到最后一页了, 也结束加载\n\t\t\t\t\t\tnextpage = d.photos.page + 1;\n\t\t\t\t\t\tif (nextpage > d.photos.pages) {\n\t\t\t\t\t\t\tend();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 拼装每页数据\n\t\t\t\t\t\tvar items = [];\n\t\t\t\t\t\tS.each(d.photos.photo, function (item) {\n\t\t\t\t\t\t\t/*所用到的字段：\n\t\t\t\t\t\t\t**price\n\t\t\t\t\t\t\t**height\n\t\t\t\t\t\t\t**collection\n\t\t\t\t\t\t\t**title\n\t\t\t\t\t\t\t**src\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\titem.height = Math.round(Math.random() * (300 - 180) + 180); // fake height\t\n\t\t\t\t\t\t\titem.collection = 10;\t//测试用\n\t\t\t\t\t\t\titem.price = 1800;\t\t//测试用\n\t\t\t\t\t\t\titems.push(S.substitute(tpl,item));\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsuccess(items);\n\t\t\t\t\t},\n\t\t\t\t\tcomplete:function () {\n\t\t\t\t\t\t$('#loadingPins').hide();\n\t\t\t\t\t\t$('.loader').show();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tminColCount:2,\n\t\t\tcolWidth:175\n\t\t\t//align:'left' // right, center (default)\n\t\t});\n\t\twaterfall.on('addComplete', function () {\n        \tS.log('after add complete!');\n\t\t\twaterfall.pause();\n    \t});\t\t\n\t});\n\t\n\t//收藏按钮功能\n\tvar collect;\n\t$('#ColumnContainer').delegate(\"mouseover\", \".collect\", function (event) {\n\t\tvar w = $(event.currentTarget).children(\"span\");\n\t\tvar text = w.text();\n\t\tif(text >= 0){\n\t\t\tcollect = text;\n\t\t}\n\t\t\n\t\tw.replaceWith(\"<span class='collects'>收藏</span>\");\n\t\t//w.css(\"text-indent\",\"3px\");\n\t});\n\t\n\t$('#ColumnContainer').delegate(\"mouseout\", \".collect\", function (event) {\n\t\tvar w = $(event.currentTarget).children(\"span\");\n\t\tw.replaceWith(\"<span class='collectionAmount'>\"+collect+\"</span>\");\n\t\t//w.css(\"text-indent\",\"13px\");\n\t});\n});\n```","slug":"Kissy-WaterFall-实现手动加载数据","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwpf000d15hlunfoh66h","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于Kissy WaterFall默认是监听滚动事件来实现数据动态加载的，但是有一些情况要用到手动加载数据。以下是使用Kissy WaterFall实现手动加载数据的方法。</p>\n<p>最终实现效果：点击”逛更多的商店“会动态加载数据</p>\n<h2 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h2><ol>\n<li>当一页数据加载完成后停止监听滚动事件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//加载一页数据完成后触发的事件</span></div><div class=\"line\">waterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    S.log(<span class=\"string\">'after add complete!'</span>);</div><div class=\"line\">\twaterfall.pause();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ol>\n<li>为按钮绑定重启监听滚动事件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//加载更多按钮</span></div><div class=\"line\">$(<span class=\"string\">\"#button_container_more\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;\t</div><div class=\"line\">\twaterfall.resunme();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ol>\n<li>附录</li>\n</ol>\n<blockquote>\n<p>waterfall.pause()与water.resunme()的说明（从官网上转载的）<br>pause()函数和resunme()函数属于插件里的waterfall.loader对象的<br>resunme() ：继续开始监控scroll事件（随时可能会动态加载）<br>pause() ：停止监控scroll事件（停止动态加载）</p>\n</blockquote>\n<p>参考网址：<a href=\"http://docs.kissyui.com/docs/html/api/component/waterfall/loader.html#waterfall.Waterfall.prototype.pause\" target=\"_blank\" rel=\"external\">http://docs.kissyui.com/docs/html/api/component/waterfall/loader.html#waterfall.Waterfall.prototype.pause</a></p>\n<p>出现问题：按照以上来完成的话，当点击”加载更多“按钮时，只是启动了滚动监听。意思就是，要加载数据，一要点击按钮，二要再次滚动鼠标。这样的用户体验很差。</p>\n<p>解决办法：修改按钮动作：new一个waterfall.loader，重新赋值waterfall对象，再重新绑定addComplete事件。<br>代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">\"#button_container_more\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;\t</div><div class=\"line\">\twaterfall = <span class=\"keyword\">new</span> Waterfall.Loader(&#123;</div><div class=\"line\">\t\t<span class=\"attr\">container</span>:<span class=\"string\">\"#ColumnContainer\"</span>,</div><div class=\"line\">\t\t<span class=\"attr\">load</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">success, end</span>) </span>&#123;</div><div class=\"line\">\t\t\t$(<span class=\"string\">'#loadingPins'</span>).show();</div><div class=\"line\">\t\t\t$(<span class=\"string\">'.loader'</span>).hide();</div><div class=\"line\">\t\t\tS.ajax(&#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">data</span>:&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'method'</span>:<span class=\"string\">'flickr.photos.search'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'api_key'</span>:<span class=\"string\">'5d93c2e473e39e9307e86d4a01381266'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'tags'</span>:<span class=\"string\">'rose'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'page'</span>:nextpage,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'per_page'</span>:<span class=\"number\">20</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span></div><div class=\"line\">\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">url</span>:<span class=\"string\">'http://api.flickr.com/services/rest/'</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">jsonp</span>:<span class=\"string\">\"jsoncallback\"</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果数据错误, 则立即结束</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (d.stat !== <span class=\"string\">'ok'</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\talert(<span class=\"string\">'load data error!'</span>);</div><div class=\"line\">\t\t\t\t\t\tend();</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果到最后一页了, 也结束加载</span></div><div class=\"line\">\t\t\t\t\tnextpage = d.photos.page + <span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (nextpage &gt; d.photos.pages) &#123;</div><div class=\"line\">\t\t\t\t\t\tend();</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 拼装每页数据</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> items = [];</div><div class=\"line\">\t\t\t\t\tS.each(d.photos.photo, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">/*所用到的字段：</span></div><div class=\"line\">\t\t\t\t\t\t**price</div><div class=\"line\">\t\t\t\t\t\t**height</div><div class=\"line\">\t\t\t\t\t\t**collection</div><div class=\"line\">\t\t\t\t\t\t**title</div><div class=\"line\">\t\t\t\t\t\t**src</div><div class=\"line\">\t\t\t\t\t\t*/</div><div class=\"line\">\t\t\t\t\t\titem.height = <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Math</span>.random() * (<span class=\"number\">300</span> - <span class=\"number\">180</span>) + <span class=\"number\">180</span>); <span class=\"comment\">// fake height\t</span></div><div class=\"line\">\t\t\t\t\t\titem.collection = <span class=\"number\">10</span>;\t<span class=\"comment\">//测试用</span></div><div class=\"line\">\t\t\t\t\t\titem.price = <span class=\"number\">1800</span>;\t\t<span class=\"comment\">//测试用</span></div><div class=\"line\">\t\t\t\t\t\titems.push(S.substitute(tpl,item));</div><div class=\"line\">\t\t\t\t\t&#125;);</div><div class=\"line\">\t\t\t\t\tsuccess(items);</div><div class=\"line\">\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">complete</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).hide();</div><div class=\"line\">\t\t\t\t\t$(<span class=\"string\">'.loader'</span>).show();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">minColCount</span>:<span class=\"number\">2</span>,</div><div class=\"line\">\t\t<span class=\"attr\">colWidth</span>:<span class=\"number\">175</span></div><div class=\"line\">\t\t<span class=\"comment\">//align:'left' // right, center (default)</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\">\twaterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">       \tS.log(<span class=\"string\">'after add complete!'</span>);</div><div class=\"line\">\t\twaterfall.pause();</div><div class=\"line\">   \t&#125;);\t\t</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>最终整个脚本文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div></pre></td><td class=\"code\"><pre><div class=\"line\">KISSY.use(<span class=\"string\">\"waterfall,ajax,node,button\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">S, Waterfall, io,  Node, Button</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> $ = Node.all;</div><div class=\"line\">    <span class=\"keyword\">var</span> tpl = $(<span class=\"string\">'#tpl'</span>).html(),</div><div class=\"line\">\tnextpage = <span class=\"number\">1</span>,</div><div class=\"line\">\twaterfall = <span class=\"keyword\">new</span> Waterfall.Loader(&#123;</div><div class=\"line\">\t\t<span class=\"attr\">container</span>:<span class=\"string\">\"#ColumnContainer\"</span>,</div><div class=\"line\">\t\t<span class=\"attr\">load</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">success, end</span>) </span>&#123;</div><div class=\"line\">\t\t\t$(<span class=\"string\">'#loadingPins'</span>).show();</div><div class=\"line\">\t\t\tS.ajax(&#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">data</span>:&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'method'</span>:<span class=\"string\">'flickr.photos.search'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'api_key'</span>:<span class=\"string\">'5d93c2e473e39e9307e86d4a01381266'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'tags'</span>:<span class=\"string\">'rose'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'page'</span>:nextpage,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'per_page'</span>:<span class=\"number\">20</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span></div><div class=\"line\">\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">url</span>:<span class=\"string\">'http://api.flickr.com/services/rest/'</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">jsonp</span>:<span class=\"string\">\"jsoncallback\"</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果数据错误, 则立即结束</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (d.stat !== <span class=\"string\">'ok'</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\talert(<span class=\"string\">'load data error!'</span>);</div><div class=\"line\">\t\t\t\t\t\tend();</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果到最后一页了, 也结束加载</span></div><div class=\"line\">\t\t\t\t\tnextpage = d.photos.page + <span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (nextpage &gt; d.photos.pages) &#123;</div><div class=\"line\">\t\t\t\t\t\tend();</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 拼装每页数据</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> items = [];</div><div class=\"line\">\t\t\t\t\tS.each(d.photos.photo, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">/*所用到的字段：</span></div><div class=\"line\">\t\t\t\t\t\t**price</div><div class=\"line\">\t\t\t\t\t\t**height</div><div class=\"line\">\t\t\t\t\t\t**collection</div><div class=\"line\">\t\t\t\t\t\t**title</div><div class=\"line\">\t\t\t\t\t\t**src</div><div class=\"line\">\t\t\t\t\t\t*/</div><div class=\"line\">\t\t\t\t\t\titem.height = <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Math</span>.random() * (<span class=\"number\">300</span> - <span class=\"number\">180</span>) + <span class=\"number\">180</span>); <span class=\"comment\">// fake height\t</span></div><div class=\"line\">\t\t\t\t\t\titem.collection = <span class=\"number\">10</span>;\t<span class=\"comment\">//测试用</span></div><div class=\"line\">\t\t\t\t\t\titem.price = <span class=\"number\">1800</span>;\t\t<span class=\"comment\">//测试用</span></div><div class=\"line\">\t\t\t\t\t\titems.push(S.substitute(tpl,item));</div><div class=\"line\">\t\t\t\t\t&#125;);</div><div class=\"line\">\t\t\t\t\tsuccess(items);</div><div class=\"line\">\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">complete</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).hide();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">minColCount</span>:<span class=\"number\">2</span>,</div><div class=\"line\">\t\t<span class=\"attr\">colWidth</span>:<span class=\"number\">175</span></div><div class=\"line\">\t\t<span class=\"comment\">//align:'left' // right, center (default)</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\">    waterfall.on(<span class=\"string\">'adjustComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        S.log(<span class=\"string\">'after adjust complete!'</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">\t<span class=\"comment\">//加载一页数据完成后触发的事件</span></div><div class=\"line\">    waterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        S.log(<span class=\"string\">'after add complete!'</span>);</div><div class=\"line\">\t\twaterfall.pause();</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"comment\">// scrollTo</span></div><div class=\"line\">    $(<span class=\"string\">'#BackToTop'</span>).on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">        e.halt();</div><div class=\"line\">        e.preventDefault();</div><div class=\"line\">        $(<span class=\"built_in\">window</span>).stop();</div><div class=\"line\">        $(<span class=\"built_in\">window</span>).animate(&#123;</div><div class=\"line\">            <span class=\"attr\">scrollTop</span>:<span class=\"number\">0</span></div><div class=\"line\">        &#125;, <span class=\"number\">1</span>, <span class=\"string\">\"easeOut\"</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">\t<span class=\"comment\">//加载更多按钮</span></div><div class=\"line\">\t$(<span class=\"string\">\"#button_container_more\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;\t</div><div class=\"line\">\t\twaterfall = <span class=\"keyword\">new</span> Waterfall.Loader(&#123;</div><div class=\"line\">\t\t\t<span class=\"attr\">container</span>:<span class=\"string\">\"#ColumnContainer\"</span>,</div><div class=\"line\">\t\t\t<span class=\"attr\">load</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">success, end</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).show();</div><div class=\"line\">\t\t\t\t$(<span class=\"string\">'.loader'</span>).hide();</div><div class=\"line\">\t\t\t\tS.ajax(&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"attr\">data</span>:&#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"string\">'method'</span>:<span class=\"string\">'flickr.photos.search'</span>,</div><div class=\"line\">\t\t\t\t\t\t<span class=\"string\">'api_key'</span>:<span class=\"string\">'5d93c2e473e39e9307e86d4a01381266'</span>,</div><div class=\"line\">\t\t\t\t\t\t<span class=\"string\">'tags'</span>:<span class=\"string\">'rose'</span>,</div><div class=\"line\">\t\t\t\t\t\t<span class=\"string\">'page'</span>:nextpage,</div><div class=\"line\">\t\t\t\t\t\t<span class=\"string\">'per_page'</span>:<span class=\"number\">20</span>,</div><div class=\"line\">\t\t\t\t\t\t<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span></div><div class=\"line\">\t\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t\t<span class=\"attr\">url</span>:<span class=\"string\">'http://api.flickr.com/services/rest/'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"attr\">jsonp</span>:<span class=\"string\">\"jsoncallback\"</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 如果数据错误, 则立即结束</span></div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (d.stat !== <span class=\"string\">'ok'</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\t\talert(<span class=\"string\">'load data error!'</span>);</div><div class=\"line\">\t\t\t\t\t\t\tend();</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 如果到最后一页了, 也结束加载</span></div><div class=\"line\">\t\t\t\t\t\tnextpage = d.photos.page + <span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (nextpage &gt; d.photos.pages) &#123;</div><div class=\"line\">\t\t\t\t\t\t\tend();</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 拼装每页数据</span></div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">var</span> items = [];</div><div class=\"line\">\t\t\t\t\t\tS.each(d.photos.photo, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">/*所用到的字段：</span></div><div class=\"line\">\t\t\t\t\t\t\t**price</div><div class=\"line\">\t\t\t\t\t\t\t**height</div><div class=\"line\">\t\t\t\t\t\t\t**collection</div><div class=\"line\">\t\t\t\t\t\t\t**title</div><div class=\"line\">\t\t\t\t\t\t\t**src</div><div class=\"line\">\t\t\t\t\t\t\t*/</div><div class=\"line\">\t\t\t\t\t\t\titem.height = <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Math</span>.random() * (<span class=\"number\">300</span> - <span class=\"number\">180</span>) + <span class=\"number\">180</span>); <span class=\"comment\">// fake height\t</span></div><div class=\"line\">\t\t\t\t\t\t\titem.collection = <span class=\"number\">10</span>;\t<span class=\"comment\">//测试用</span></div><div class=\"line\">\t\t\t\t\t\t\titem.price = <span class=\"number\">1800</span>;\t\t<span class=\"comment\">//测试用</span></div><div class=\"line\">\t\t\t\t\t\t\titems.push(S.substitute(tpl,item));</div><div class=\"line\">\t\t\t\t\t\t&#125;);</div><div class=\"line\">\t\t\t\t\t\tsuccess(items);</div><div class=\"line\">\t\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t\t<span class=\"attr\">complete</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).hide();</div><div class=\"line\">\t\t\t\t\t\t$(<span class=\"string\">'.loader'</span>).show();</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;);</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\t<span class=\"attr\">minColCount</span>:<span class=\"number\">2</span>,</div><div class=\"line\">\t\t\t<span class=\"attr\">colWidth</span>:<span class=\"number\">175</span></div><div class=\"line\">\t\t\t<span class=\"comment\">//align:'left' // right, center (default)</span></div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\twaterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        \tS.log(<span class=\"string\">'after add complete!'</span>);</div><div class=\"line\">\t\t\twaterfall.pause();</div><div class=\"line\">    \t&#125;);\t\t</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">//收藏按钮功能</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> collect;</div><div class=\"line\">\t$(<span class=\"string\">'#ColumnContainer'</span>).delegate(<span class=\"string\">\"mouseover\"</span>, <span class=\"string\">\".collect\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> w = $(event.currentTarget).children(<span class=\"string\">\"span\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> text = w.text();</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(text &gt;= <span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t\tcollect = text;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tw.replaceWith(<span class=\"string\">\"&lt;span class='collects'&gt;收藏&lt;/span&gt;\"</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//w.css(\"text-indent\",\"3px\");</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">\t$(<span class=\"string\">'#ColumnContainer'</span>).delegate(<span class=\"string\">\"mouseout\"</span>, <span class=\"string\">\".collect\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> w = $(event.currentTarget).children(<span class=\"string\">\"span\"</span>);</div><div class=\"line\">\t\tw.replaceWith(<span class=\"string\">\"&lt;span class='collectionAmount'&gt;\"</span>+collect+<span class=\"string\">\"&lt;/span&gt;\"</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//w.css(\"text-indent\",\"13px\");</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于Kissy WaterFall默认是监听滚动事件来实现数据动态加载的，但是有一些情况要用到手动加载数据。以下是使用Kissy WaterFall实现手动加载数据的方法。</p>\n<p>最终实现效果：点击”逛更多的商店“会动态加载数据</p>\n<h2 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h2><ol>\n<li>当一页数据加载完成后停止监听滚动事件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//加载一页数据完成后触发的事件</span></div><div class=\"line\">waterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    S.log(<span class=\"string\">'after add complete!'</span>);</div><div class=\"line\">\twaterfall.pause();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ol>\n<li>为按钮绑定重启监听滚动事件</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//加载更多按钮</span></div><div class=\"line\">$(<span class=\"string\">\"#button_container_more\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;\t</div><div class=\"line\">\twaterfall.resunme();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<ol>\n<li>附录</li>\n</ol>\n<blockquote>\n<p>waterfall.pause()与water.resunme()的说明（从官网上转载的）<br>pause()函数和resunme()函数属于插件里的waterfall.loader对象的<br>resunme() ：继续开始监控scroll事件（随时可能会动态加载）<br>pause() ：停止监控scroll事件（停止动态加载）</p>\n</blockquote>\n<p>参考网址：<a href=\"http://docs.kissyui.com/docs/html/api/component/waterfall/loader.html#waterfall.Waterfall.prototype.pause\">http://docs.kissyui.com/docs/html/api/component/waterfall/loader.html#waterfall.Waterfall.prototype.pause</a></p>\n<p>出现问题：按照以上来完成的话，当点击”加载更多“按钮时，只是启动了滚动监听。意思就是，要加载数据，一要点击按钮，二要再次滚动鼠标。这样的用户体验很差。</p>\n<p>解决办法：修改按钮动作：new一个waterfall.loader，重新赋值waterfall对象，再重新绑定addComplete事件。<br>代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">\"#button_container_more\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;\t</div><div class=\"line\">\twaterfall = <span class=\"keyword\">new</span> Waterfall.Loader(&#123;</div><div class=\"line\">\t\t<span class=\"attr\">container</span>:<span class=\"string\">\"#ColumnContainer\"</span>,</div><div class=\"line\">\t\t<span class=\"attr\">load</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">success, end</span>) </span>&#123;</div><div class=\"line\">\t\t\t$(<span class=\"string\">'#loadingPins'</span>).show();</div><div class=\"line\">\t\t\t$(<span class=\"string\">'.loader'</span>).hide();</div><div class=\"line\">\t\t\tS.ajax(&#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">data</span>:&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'method'</span>:<span class=\"string\">'flickr.photos.search'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'api_key'</span>:<span class=\"string\">'5d93c2e473e39e9307e86d4a01381266'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'tags'</span>:<span class=\"string\">'rose'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'page'</span>:nextpage,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'per_page'</span>:<span class=\"number\">20</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span></div><div class=\"line\">\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">url</span>:<span class=\"string\">'http://api.flickr.com/services/rest/'</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">jsonp</span>:<span class=\"string\">\"jsoncallback\"</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果数据错误, 则立即结束</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (d.stat !== <span class=\"string\">'ok'</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\talert(<span class=\"string\">'load data error!'</span>);</div><div class=\"line\">\t\t\t\t\t\tend();</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果到最后一页了, 也结束加载</span></div><div class=\"line\">\t\t\t\t\tnextpage = d.photos.page + <span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (nextpage &gt; d.photos.pages) &#123;</div><div class=\"line\">\t\t\t\t\t\tend();</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 拼装每页数据</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> items = [];</div><div class=\"line\">\t\t\t\t\tS.each(d.photos.photo, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">/*所用到的字段：</div><div class=\"line\">\t\t\t\t\t\t**price</div><div class=\"line\">\t\t\t\t\t\t**height</div><div class=\"line\">\t\t\t\t\t\t**collection</div><div class=\"line\">\t\t\t\t\t\t**title</div><div class=\"line\">\t\t\t\t\t\t**src</div><div class=\"line\">\t\t\t\t\t\t*/</span></div><div class=\"line\">\t\t\t\t\t\titem.height = <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Math</span>.random() * (<span class=\"number\">300</span> - <span class=\"number\">180</span>) + <span class=\"number\">180</span>); <span class=\"comment\">// fake height\t</span></div><div class=\"line\">\t\t\t\t\t\titem.collection = <span class=\"number\">10</span>;\t<span class=\"comment\">//测试用</span></div><div class=\"line\">\t\t\t\t\t\titem.price = <span class=\"number\">1800</span>;\t\t<span class=\"comment\">//测试用</span></div><div class=\"line\">\t\t\t\t\t\titems.push(S.substitute(tpl,item));</div><div class=\"line\">\t\t\t\t\t&#125;);</div><div class=\"line\">\t\t\t\t\tsuccess(items);</div><div class=\"line\">\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">complete</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).hide();</div><div class=\"line\">\t\t\t\t\t$(<span class=\"string\">'.loader'</span>).show();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">minColCount</span>:<span class=\"number\">2</span>,</div><div class=\"line\">\t\t<span class=\"attr\">colWidth</span>:<span class=\"number\">175</span></div><div class=\"line\">\t\t<span class=\"comment\">//align:'left' // right, center (default)</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\">\twaterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">       \tS.log(<span class=\"string\">'after add complete!'</span>);</div><div class=\"line\">\t\twaterfall.pause();</div><div class=\"line\">   \t&#125;);\t\t</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>最终整个脚本文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div></pre></td><td class=\"code\"><pre><div class=\"line\">KISSY.use(<span class=\"string\">\"waterfall,ajax,node,button\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">S, Waterfall, io,  Node, Button</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> $ = Node.all;</div><div class=\"line\">    <span class=\"keyword\">var</span> tpl = $(<span class=\"string\">'#tpl'</span>).html(),</div><div class=\"line\">\tnextpage = <span class=\"number\">1</span>,</div><div class=\"line\">\twaterfall = <span class=\"keyword\">new</span> Waterfall.Loader(&#123;</div><div class=\"line\">\t\t<span class=\"attr\">container</span>:<span class=\"string\">\"#ColumnContainer\"</span>,</div><div class=\"line\">\t\t<span class=\"attr\">load</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">success, end</span>) </span>&#123;</div><div class=\"line\">\t\t\t$(<span class=\"string\">'#loadingPins'</span>).show();</div><div class=\"line\">\t\t\tS.ajax(&#123;</div><div class=\"line\">\t\t\t\t<span class=\"attr\">data</span>:&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'method'</span>:<span class=\"string\">'flickr.photos.search'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'api_key'</span>:<span class=\"string\">'5d93c2e473e39e9307e86d4a01381266'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'tags'</span>:<span class=\"string\">'rose'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'page'</span>:nextpage,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'per_page'</span>:<span class=\"number\">20</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span></div><div class=\"line\">\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">url</span>:<span class=\"string\">'http://api.flickr.com/services/rest/'</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">jsonp</span>:<span class=\"string\">\"jsoncallback\"</span>,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果数据错误, 则立即结束</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (d.stat !== <span class=\"string\">'ok'</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\talert(<span class=\"string\">'load data error!'</span>);</div><div class=\"line\">\t\t\t\t\t\tend();</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果到最后一页了, 也结束加载</span></div><div class=\"line\">\t\t\t\t\tnextpage = d.photos.page + <span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (nextpage &gt; d.photos.pages) &#123;</div><div class=\"line\">\t\t\t\t\t\tend();</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 拼装每页数据</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> items = [];</div><div class=\"line\">\t\t\t\t\tS.each(d.photos.photo, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">/*所用到的字段：</div><div class=\"line\">\t\t\t\t\t\t**price</div><div class=\"line\">\t\t\t\t\t\t**height</div><div class=\"line\">\t\t\t\t\t\t**collection</div><div class=\"line\">\t\t\t\t\t\t**title</div><div class=\"line\">\t\t\t\t\t\t**src</div><div class=\"line\">\t\t\t\t\t\t*/</span></div><div class=\"line\">\t\t\t\t\t\titem.height = <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Math</span>.random() * (<span class=\"number\">300</span> - <span class=\"number\">180</span>) + <span class=\"number\">180</span>); <span class=\"comment\">// fake height\t</span></div><div class=\"line\">\t\t\t\t\t\titem.collection = <span class=\"number\">10</span>;\t<span class=\"comment\">//测试用</span></div><div class=\"line\">\t\t\t\t\t\titem.price = <span class=\"number\">1800</span>;\t\t<span class=\"comment\">//测试用</span></div><div class=\"line\">\t\t\t\t\t\titems.push(S.substitute(tpl,item));</div><div class=\"line\">\t\t\t\t\t&#125;);</div><div class=\"line\">\t\t\t\t\tsuccess(items);</div><div class=\"line\">\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t<span class=\"attr\">complete</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).hide();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"attr\">minColCount</span>:<span class=\"number\">2</span>,</div><div class=\"line\">\t\t<span class=\"attr\">colWidth</span>:<span class=\"number\">175</span></div><div class=\"line\">\t\t<span class=\"comment\">//align:'left' // right, center (default)</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\">    waterfall.on(<span class=\"string\">'adjustComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        S.log(<span class=\"string\">'after adjust complete!'</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">\t<span class=\"comment\">//加载一页数据完成后触发的事件</span></div><div class=\"line\">    waterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        S.log(<span class=\"string\">'after add complete!'</span>);</div><div class=\"line\">\t\twaterfall.pause();</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"comment\">// scrollTo</span></div><div class=\"line\">    $(<span class=\"string\">'#BackToTop'</span>).on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">        e.halt();</div><div class=\"line\">        e.preventDefault();</div><div class=\"line\">        $(<span class=\"built_in\">window</span>).stop();</div><div class=\"line\">        $(<span class=\"built_in\">window</span>).animate(&#123;</div><div class=\"line\">            <span class=\"attr\">scrollTop</span>:<span class=\"number\">0</span></div><div class=\"line\">        &#125;, <span class=\"number\">1</span>, <span class=\"string\">\"easeOut\"</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">\t<span class=\"comment\">//加载更多按钮</span></div><div class=\"line\">\t$(<span class=\"string\">\"#button_container_more\"</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;\t</div><div class=\"line\">\t\twaterfall = <span class=\"keyword\">new</span> Waterfall.Loader(&#123;</div><div class=\"line\">\t\t\t<span class=\"attr\">container</span>:<span class=\"string\">\"#ColumnContainer\"</span>,</div><div class=\"line\">\t\t\t<span class=\"attr\">load</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">success, end</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).show();</div><div class=\"line\">\t\t\t\t$(<span class=\"string\">'.loader'</span>).hide();</div><div class=\"line\">\t\t\t\tS.ajax(&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"attr\">data</span>:&#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"string\">'method'</span>:<span class=\"string\">'flickr.photos.search'</span>,</div><div class=\"line\">\t\t\t\t\t\t<span class=\"string\">'api_key'</span>:<span class=\"string\">'5d93c2e473e39e9307e86d4a01381266'</span>,</div><div class=\"line\">\t\t\t\t\t\t<span class=\"string\">'tags'</span>:<span class=\"string\">'rose'</span>,</div><div class=\"line\">\t\t\t\t\t\t<span class=\"string\">'page'</span>:nextpage,</div><div class=\"line\">\t\t\t\t\t\t<span class=\"string\">'per_page'</span>:<span class=\"number\">20</span>,</div><div class=\"line\">\t\t\t\t\t\t<span class=\"string\">'format'</span>:<span class=\"string\">'json'</span></div><div class=\"line\">\t\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t\t<span class=\"attr\">url</span>:<span class=\"string\">'http://api.flickr.com/services/rest/'</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"attr\">dataType</span>:<span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"attr\">jsonp</span>:<span class=\"string\">\"jsoncallback\"</span>,</div><div class=\"line\">\t\t\t\t\t<span class=\"attr\">success</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">d</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 如果数据错误, 则立即结束</span></div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (d.stat !== <span class=\"string\">'ok'</span>) &#123;</div><div class=\"line\">\t\t\t\t\t\t\talert(<span class=\"string\">'load data error!'</span>);</div><div class=\"line\">\t\t\t\t\t\t\tend();</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 如果到最后一页了, 也结束加载</span></div><div class=\"line\">\t\t\t\t\t\tnextpage = d.photos.page + <span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (nextpage &gt; d.photos.pages) &#123;</div><div class=\"line\">\t\t\t\t\t\t\tend();</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 拼装每页数据</span></div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">var</span> items = [];</div><div class=\"line\">\t\t\t\t\t\tS.each(d.photos.photo, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"comment\">/*所用到的字段：</div><div class=\"line\">\t\t\t\t\t\t\t**price</div><div class=\"line\">\t\t\t\t\t\t\t**height</div><div class=\"line\">\t\t\t\t\t\t\t**collection</div><div class=\"line\">\t\t\t\t\t\t\t**title</div><div class=\"line\">\t\t\t\t\t\t\t**src</div><div class=\"line\">\t\t\t\t\t\t\t*/</span></div><div class=\"line\">\t\t\t\t\t\t\titem.height = <span class=\"built_in\">Math</span>.round(<span class=\"built_in\">Math</span>.random() * (<span class=\"number\">300</span> - <span class=\"number\">180</span>) + <span class=\"number\">180</span>); <span class=\"comment\">// fake height\t</span></div><div class=\"line\">\t\t\t\t\t\t\titem.collection = <span class=\"number\">10</span>;\t<span class=\"comment\">//测试用</span></div><div class=\"line\">\t\t\t\t\t\t\titem.price = <span class=\"number\">1800</span>;\t\t<span class=\"comment\">//测试用</span></div><div class=\"line\">\t\t\t\t\t\t\titems.push(S.substitute(tpl,item));</div><div class=\"line\">\t\t\t\t\t\t&#125;);</div><div class=\"line\">\t\t\t\t\t\tsuccess(items);</div><div class=\"line\">\t\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t\t<span class=\"attr\">complete</span>:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t\t\t\t$(<span class=\"string\">'#loadingPins'</span>).hide();</div><div class=\"line\">\t\t\t\t\t\t$(<span class=\"string\">'.loader'</span>).show();</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;);</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\t<span class=\"attr\">minColCount</span>:<span class=\"number\">2</span>,</div><div class=\"line\">\t\t\t<span class=\"attr\">colWidth</span>:<span class=\"number\">175</span></div><div class=\"line\">\t\t\t<span class=\"comment\">//align:'left' // right, center (default)</span></div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\twaterfall.on(<span class=\"string\">'addComplete'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        \tS.log(<span class=\"string\">'after add complete!'</span>);</div><div class=\"line\">\t\t\twaterfall.pause();</div><div class=\"line\">    \t&#125;);\t\t</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">//收藏按钮功能</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> collect;</div><div class=\"line\">\t$(<span class=\"string\">'#ColumnContainer'</span>).delegate(<span class=\"string\">\"mouseover\"</span>, <span class=\"string\">\".collect\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> w = $(event.currentTarget).children(<span class=\"string\">\"span\"</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> text = w.text();</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(text &gt;= <span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t\tcollect = text;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tw.replaceWith(<span class=\"string\">\"&lt;span class='collects'&gt;收藏&lt;/span&gt;\"</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//w.css(\"text-indent\",\"3px\");</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">\t$(<span class=\"string\">'#ColumnContainer'</span>).delegate(<span class=\"string\">\"mouseout\"</span>, <span class=\"string\">\".collect\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> w = $(event.currentTarget).children(<span class=\"string\">\"span\"</span>);</div><div class=\"line\">\t\tw.replaceWith(<span class=\"string\">\"&lt;span class='collectionAmount'&gt;\"</span>+collect+<span class=\"string\">\"&lt;/span&gt;\"</span>);</div><div class=\"line\">\t\t<span class=\"comment\">//w.css(\"text-indent\",\"13px\");</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>"},{"title":"SOAP，WebService的枢纽","date":"2015-01-11T16:02:38.000Z","_content":"\n## 前言\n\n前两天，室友给我发了一套代码......\n\n![](/image/blog/79702-e7cf075365536286.jpeg)\n![](/image/blog/79702-e7cf075365536286.jpeg)\n\n一段对话下来，我心中多个疑问：SOAP是什么？node调用java接口？\n\n一向懒散的我，不知为何却对些问题有点兴趣，平常我们处理不同应用程序之间的通讯，都是以RESTful API的方式的，基于HTTP协议，互相传输JSON格式的数据以达到程序间的交流。现在却有一个称SOAP的东东，可以直接调用程序的接口？\n\n## SOAP，何方妖孽？\n\n*   SOAP（Simple Object Access Protocol 简单对象访问协议）\n*   SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。\n*   SOAP 独立于平台、语言，且简单和可扩展\n\n## SOAP 怎么来的？\n\n此标准由IBM、Microsoft、UserLand和DevelopMentor在1998年共同提出，并得到IBM，莲花（Lotus），康柏（Compaq）等公司的支持，于2000年提交给万维网联盟（World Wide Web Consortium；W3C），目前SOAP 1.1版是业界共同的标准，属于第二代的XML协定（第一代具主要代表性的技术为XML-RPC以及WDDX）。\n\n## SOAP 的 好搭档：WSDL、Web Service\n\n为了能了解SOAP的做的事，你首先需要了解和SOAP一同工作的两个同事。\n\n**Web Service** 是一套应用程序的组件，也可以说是对外接口，它使用SOAP这一套标准，提供公共服务给别的程序调用。\n\n**WSDL** 是基于XML语言的，用来描述web service的消息格式和协议细节，以及如何访问它们。它的全称是：Web Service Description Language web服务描述语言。\n\n## SOAP是怎么工作的？\n\n在了解了SOAP、WSDL、Web Service的定义之后，我们就来窥探一下它们三个是怎么P的？\n\n**假设**现在有两个应用程序，分别用两种语言进行开发的，一个是用nodejs开发的程序，一个是用java开发的程序。而java程序其中有一个方法(getUser)可以查询数据库中的某用户的信息。那么在nodejs程序请求java程序的(getUser)方法获取某用户信息的流程是怎么走的？\n\n我在应用程序的层面上解释一下这个流程，\n\n请看下图，然后我再对每一个步骤说明：\n\n![](/image/blog/79702-5d2b1c9e8970c3ea.jpeg)\n\n首先java程序会把`getUser()`做成Web Service，然后要提供对这个service的描述文档，那便是WSDL文件。nodejs程序要调用的方法以及参数的信息都存放在遵循了SOAP标准的WSDL文件中，所以要访问远端的web service，必须先获得对方提供的WSDL。\n\n步骤一：nodejs程序通过http请求，获取到java程序提供的WSDL文件。nodejs程序得到这个WSDL文件之后，就会对它进行解析，得知java程序提供了`getUser()`，而且也知道这个方法需要的参数是`string`类型的且变量名`userUUID`。\n\n步骤二：在nodejs程序知道java程序有`getUser()`这个方法之后，它通过http请求，发送SOAP信息到java程序，java程序得到这个SOAP信息之后，进行解析，知道了nodejs程序需要请求`getUser()`方法，且提供了所需要的参数。\n\n步骤三：java程序对nodejs的请求进行逻辑处理，查询数据库，然后把结果翻译成SOAP信息，再通过http协议发送到nodejs程序。\n\n本例中，nodejs程序和java程序沟通的SOAP实例：\n\nSOAP 请求：\n\n    POST /InStock HTTP/1.1\n    Host: www.example.org\n    Content-Type: application/soap+xml; charset=utf-8\n    Content-Length: nnn\n\n    <?xml version=\"1.0\"?>\n    <soap:Envelope\n    xmlns:soap=\"http://www.w3.org/2001/12/soap-envelope\"\n    soap:encodingStyle=\"http://www.w3.org/2001/12/soap-encoding\">\n\n      <soap:Body xmlns:m=\"http://www.example.org/stock\">\n        <m:getUser>\n          <m:userUUID>123456789</m:userUUID>\n        </m:getUser>\n      </soap:Body>\n\n    </soap:Envelope>`</pre>\n\n    SOAP 响应：\n\n    <pre>`HTTP/1.1 200 OK\n    Content-Type: application/soap+xml; charset=utf-8\n    Content-Length: nnn\n\n    <?xml version=\"1.0\"?>\n    <soap:Envelope\n    xmlns:soap=\"http://www.w3.org/2001/12/soap-envelope\"\n    soap:encodingStyle=\"http://www.w3.org/2001/12/soap-encoding\">\n\n      <soap:Body xmlns:m=\"http://www.example.org/stock\">\n        <m:getUserResponse>\n          <m:userName>JerryC</m:userName>\n        </m:getUserResponse>\n      </soap:Body>\n\n    </soap:Envelope>\n\n综上，程序之间的调用，无论进行请求还是返回结果，每一次都需要构造一则SOAP信息，固然SOAP便是程序之间沟通的语言。\n\n## node开发中的soap\n\n我是一名nodejs开发者，知道有这么一种程序之间交流信息的协议之后，很自然就想知道用nodejs怎么使用这个协议。\n\nnodejs针对SOAP也有不少的第三方模块：\n\n*   [node-soap](https://github.com/milewise/node-soap)\n*   [douche](https://github.com/kr1sp1n/douche)\n*   [soapjs](https://github.com/jmoyers/soapjs)\n....\n[更多nodejs的SOAP第三方模块](https://nodejsmodules.org/tags/soap)\n\n其中，node-soap是最受欢迎的(根据github上star数量)，也是我最喜欢的。\n\n##### 本文写作参考：\n\n[http://www.w3school.com.cn/soap/index.asp](http://www.w3school.com.cn/soap/index.asp)\n[http://zh.wikipedia.org/wiki/SOAP](http://zh.wikipedia.org/wiki/SOAP)\n","source":"_posts/SOAP-Web-Service的枢纽.md","raw":"---\ntitle: SOAP，WebService的枢纽\ndate: 2015-01-12 00:02:38\ntags:\n- Nodejs\n- Javascript\n- SOAP\ncategory: 搬砖码农\n---\n\n## 前言\n\n前两天，室友给我发了一套代码......\n\n![](/image/blog/79702-e7cf075365536286.jpeg)\n![](/image/blog/79702-e7cf075365536286.jpeg)\n\n一段对话下来，我心中多个疑问：SOAP是什么？node调用java接口？\n\n一向懒散的我，不知为何却对些问题有点兴趣，平常我们处理不同应用程序之间的通讯，都是以RESTful API的方式的，基于HTTP协议，互相传输JSON格式的数据以达到程序间的交流。现在却有一个称SOAP的东东，可以直接调用程序的接口？\n\n## SOAP，何方妖孽？\n\n*   SOAP（Simple Object Access Protocol 简单对象访问协议）\n*   SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。\n*   SOAP 独立于平台、语言，且简单和可扩展\n\n## SOAP 怎么来的？\n\n此标准由IBM、Microsoft、UserLand和DevelopMentor在1998年共同提出，并得到IBM，莲花（Lotus），康柏（Compaq）等公司的支持，于2000年提交给万维网联盟（World Wide Web Consortium；W3C），目前SOAP 1.1版是业界共同的标准，属于第二代的XML协定（第一代具主要代表性的技术为XML-RPC以及WDDX）。\n\n## SOAP 的 好搭档：WSDL、Web Service\n\n为了能了解SOAP的做的事，你首先需要了解和SOAP一同工作的两个同事。\n\n**Web Service** 是一套应用程序的组件，也可以说是对外接口，它使用SOAP这一套标准，提供公共服务给别的程序调用。\n\n**WSDL** 是基于XML语言的，用来描述web service的消息格式和协议细节，以及如何访问它们。它的全称是：Web Service Description Language web服务描述语言。\n\n## SOAP是怎么工作的？\n\n在了解了SOAP、WSDL、Web Service的定义之后，我们就来窥探一下它们三个是怎么P的？\n\n**假设**现在有两个应用程序，分别用两种语言进行开发的，一个是用nodejs开发的程序，一个是用java开发的程序。而java程序其中有一个方法(getUser)可以查询数据库中的某用户的信息。那么在nodejs程序请求java程序的(getUser)方法获取某用户信息的流程是怎么走的？\n\n我在应用程序的层面上解释一下这个流程，\n\n请看下图，然后我再对每一个步骤说明：\n\n![](/image/blog/79702-5d2b1c9e8970c3ea.jpeg)\n\n首先java程序会把`getUser()`做成Web Service，然后要提供对这个service的描述文档，那便是WSDL文件。nodejs程序要调用的方法以及参数的信息都存放在遵循了SOAP标准的WSDL文件中，所以要访问远端的web service，必须先获得对方提供的WSDL。\n\n步骤一：nodejs程序通过http请求，获取到java程序提供的WSDL文件。nodejs程序得到这个WSDL文件之后，就会对它进行解析，得知java程序提供了`getUser()`，而且也知道这个方法需要的参数是`string`类型的且变量名`userUUID`。\n\n步骤二：在nodejs程序知道java程序有`getUser()`这个方法之后，它通过http请求，发送SOAP信息到java程序，java程序得到这个SOAP信息之后，进行解析，知道了nodejs程序需要请求`getUser()`方法，且提供了所需要的参数。\n\n步骤三：java程序对nodejs的请求进行逻辑处理，查询数据库，然后把结果翻译成SOAP信息，再通过http协议发送到nodejs程序。\n\n本例中，nodejs程序和java程序沟通的SOAP实例：\n\nSOAP 请求：\n\n    POST /InStock HTTP/1.1\n    Host: www.example.org\n    Content-Type: application/soap+xml; charset=utf-8\n    Content-Length: nnn\n\n    <?xml version=\"1.0\"?>\n    <soap:Envelope\n    xmlns:soap=\"http://www.w3.org/2001/12/soap-envelope\"\n    soap:encodingStyle=\"http://www.w3.org/2001/12/soap-encoding\">\n\n      <soap:Body xmlns:m=\"http://www.example.org/stock\">\n        <m:getUser>\n          <m:userUUID>123456789</m:userUUID>\n        </m:getUser>\n      </soap:Body>\n\n    </soap:Envelope>`</pre>\n\n    SOAP 响应：\n\n    <pre>`HTTP/1.1 200 OK\n    Content-Type: application/soap+xml; charset=utf-8\n    Content-Length: nnn\n\n    <?xml version=\"1.0\"?>\n    <soap:Envelope\n    xmlns:soap=\"http://www.w3.org/2001/12/soap-envelope\"\n    soap:encodingStyle=\"http://www.w3.org/2001/12/soap-encoding\">\n\n      <soap:Body xmlns:m=\"http://www.example.org/stock\">\n        <m:getUserResponse>\n          <m:userName>JerryC</m:userName>\n        </m:getUserResponse>\n      </soap:Body>\n\n    </soap:Envelope>\n\n综上，程序之间的调用，无论进行请求还是返回结果，每一次都需要构造一则SOAP信息，固然SOAP便是程序之间沟通的语言。\n\n## node开发中的soap\n\n我是一名nodejs开发者，知道有这么一种程序之间交流信息的协议之后，很自然就想知道用nodejs怎么使用这个协议。\n\nnodejs针对SOAP也有不少的第三方模块：\n\n*   [node-soap](https://github.com/milewise/node-soap)\n*   [douche](https://github.com/kr1sp1n/douche)\n*   [soapjs](https://github.com/jmoyers/soapjs)\n....\n[更多nodejs的SOAP第三方模块](https://nodejsmodules.org/tags/soap)\n\n其中，node-soap是最受欢迎的(根据github上star数量)，也是我最喜欢的。\n\n##### 本文写作参考：\n\n[http://www.w3school.com.cn/soap/index.asp](http://www.w3school.com.cn/soap/index.asp)\n[http://zh.wikipedia.org/wiki/SOAP](http://zh.wikipedia.org/wiki/SOAP)\n","slug":"SOAP-Web-Service的枢纽","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwpg000f15hlccmghe2f","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前两天，室友给我发了一套代码……</p>\n<p><img src=\"/image/blog/79702-e7cf075365536286.jpeg\" alt=\"\"><br><img src=\"/image/blog/79702-e7cf075365536286.jpeg\" alt=\"\"></p>\n<p>一段对话下来，我心中多个疑问：SOAP是什么？node调用java接口？</p>\n<p>一向懒散的我，不知为何却对些问题有点兴趣，平常我们处理不同应用程序之间的通讯，都是以RESTful API的方式的，基于HTTP协议，互相传输JSON格式的数据以达到程序间的交流。现在却有一个称SOAP的东东，可以直接调用程序的接口？</p>\n<h2 id=\"SOAP，何方妖孽？\"><a href=\"#SOAP，何方妖孽？\" class=\"headerlink\" title=\"SOAP，何方妖孽？\"></a>SOAP，何方妖孽？</h2><ul>\n<li>SOAP（Simple Object Access Protocol 简单对象访问协议）</li>\n<li>SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。</li>\n<li>SOAP 独立于平台、语言，且简单和可扩展</li>\n</ul>\n<h2 id=\"SOAP-怎么来的？\"><a href=\"#SOAP-怎么来的？\" class=\"headerlink\" title=\"SOAP 怎么来的？\"></a>SOAP 怎么来的？</h2><p>此标准由IBM、Microsoft、UserLand和DevelopMentor在1998年共同提出，并得到IBM，莲花（Lotus），康柏（Compaq）等公司的支持，于2000年提交给万维网联盟（World Wide Web Consortium；W3C），目前SOAP 1.1版是业界共同的标准，属于第二代的XML协定（第一代具主要代表性的技术为XML-RPC以及WDDX）。</p>\n<h2 id=\"SOAP-的-好搭档：WSDL、Web-Service\"><a href=\"#SOAP-的-好搭档：WSDL、Web-Service\" class=\"headerlink\" title=\"SOAP 的 好搭档：WSDL、Web Service\"></a>SOAP 的 好搭档：WSDL、Web Service</h2><p>为了能了解SOAP的做的事，你首先需要了解和SOAP一同工作的两个同事。</p>\n<p><strong>Web Service</strong> 是一套应用程序的组件，也可以说是对外接口，它使用SOAP这一套标准，提供公共服务给别的程序调用。</p>\n<p><strong>WSDL</strong> 是基于XML语言的，用来描述web service的消息格式和协议细节，以及如何访问它们。它的全称是：Web Service Description Language web服务描述语言。</p>\n<h2 id=\"SOAP是怎么工作的？\"><a href=\"#SOAP是怎么工作的？\" class=\"headerlink\" title=\"SOAP是怎么工作的？\"></a>SOAP是怎么工作的？</h2><p>在了解了SOAP、WSDL、Web Service的定义之后，我们就来窥探一下它们三个是怎么P的？</p>\n<p><strong>假设</strong>现在有两个应用程序，分别用两种语言进行开发的，一个是用nodejs开发的程序，一个是用java开发的程序。而java程序其中有一个方法(getUser)可以查询数据库中的某用户的信息。那么在nodejs程序请求java程序的(getUser)方法获取某用户信息的流程是怎么走的？</p>\n<p>我在应用程序的层面上解释一下这个流程，</p>\n<p>请看下图，然后我再对每一个步骤说明：</p>\n<p><img src=\"/image/blog/79702-5d2b1c9e8970c3ea.jpeg\" alt=\"\"></p>\n<p>首先java程序会把<code>getUser()</code>做成Web Service，然后要提供对这个service的描述文档，那便是WSDL文件。nodejs程序要调用的方法以及参数的信息都存放在遵循了SOAP标准的WSDL文件中，所以要访问远端的web service，必须先获得对方提供的WSDL。</p>\n<p>步骤一：nodejs程序通过http请求，获取到java程序提供的WSDL文件。nodejs程序得到这个WSDL文件之后，就会对它进行解析，得知java程序提供了<code>getUser()</code>，而且也知道这个方法需要的参数是<code>string</code>类型的且变量名<code>userUUID</code>。</p>\n<p>步骤二：在nodejs程序知道java程序有<code>getUser()</code>这个方法之后，它通过http请求，发送SOAP信息到java程序，java程序得到这个SOAP信息之后，进行解析，知道了nodejs程序需要请求<code>getUser()</code>方法，且提供了所需要的参数。</p>\n<p>步骤三：java程序对nodejs的请求进行逻辑处理，查询数据库，然后把结果翻译成SOAP信息，再通过http协议发送到nodejs程序。</p>\n<p>本例中，nodejs程序和java程序沟通的SOAP实例：</p>\n<p>SOAP 请求：</p>\n<pre><code>POST /InStock HTTP/1.1\nHost: www.example.org\nContent-Type: application/soap+xml; charset=utf-8\nContent-Length: nnn\n\n&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;soap:Envelope\nxmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;\nsoap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;\n\n  &lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;\n    &lt;m:getUser&gt;\n      &lt;m:userUUID&gt;123456789&lt;/m:userUUID&gt;\n    &lt;/m:getUser&gt;\n  &lt;/soap:Body&gt;\n\n&lt;/soap:Envelope&gt;`&lt;/pre&gt;\n\nSOAP 响应：\n\n&lt;pre&gt;`HTTP/1.1 200 OK\nContent-Type: application/soap+xml; charset=utf-8\nContent-Length: nnn\n\n&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;soap:Envelope\nxmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;\nsoap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;\n\n  &lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;\n    &lt;m:getUserResponse&gt;\n      &lt;m:userName&gt;JerryC&lt;/m:userName&gt;\n    &lt;/m:getUserResponse&gt;\n  &lt;/soap:Body&gt;\n\n&lt;/soap:Envelope&gt;\n</code></pre><p>综上，程序之间的调用，无论进行请求还是返回结果，每一次都需要构造一则SOAP信息，固然SOAP便是程序之间沟通的语言。</p>\n<h2 id=\"node开发中的soap\"><a href=\"#node开发中的soap\" class=\"headerlink\" title=\"node开发中的soap\"></a>node开发中的soap</h2><p>我是一名nodejs开发者，知道有这么一种程序之间交流信息的协议之后，很自然就想知道用nodejs怎么使用这个协议。</p>\n<p>nodejs针对SOAP也有不少的第三方模块：</p>\n<ul>\n<li><a href=\"https://github.com/milewise/node-soap\" target=\"_blank\" rel=\"external\">node-soap</a></li>\n<li><a href=\"https://github.com/kr1sp1n/douche\" target=\"_blank\" rel=\"external\">douche</a></li>\n<li><a href=\"https://github.com/jmoyers/soapjs\" target=\"_blank\" rel=\"external\">soapjs</a><br>….<br><a href=\"https://nodejsmodules.org/tags/soap\" target=\"_blank\" rel=\"external\">更多nodejs的SOAP第三方模块</a></li>\n</ul>\n<p>其中，node-soap是最受欢迎的(根据github上star数量)，也是我最喜欢的。</p>\n<h5 id=\"本文写作参考：\"><a href=\"#本文写作参考：\" class=\"headerlink\" title=\"本文写作参考：\"></a>本文写作参考：</h5><p><a href=\"http://www.w3school.com.cn/soap/index.asp\" target=\"_blank\" rel=\"external\">http://www.w3school.com.cn/soap/index.asp</a><br><a href=\"http://zh.wikipedia.org/wiki/SOAP\" target=\"_blank\" rel=\"external\">http://zh.wikipedia.org/wiki/SOAP</a></p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前两天，室友给我发了一套代码……</p>\n<p><img src=\"/image/blog/79702-e7cf075365536286.jpeg\" alt=\"\"><br><img src=\"/image/blog/79702-e7cf075365536286.jpeg\" alt=\"\"></p>\n<p>一段对话下来，我心中多个疑问：SOAP是什么？node调用java接口？</p>\n<p>一向懒散的我，不知为何却对些问题有点兴趣，平常我们处理不同应用程序之间的通讯，都是以RESTful API的方式的，基于HTTP协议，互相传输JSON格式的数据以达到程序间的交流。现在却有一个称SOAP的东东，可以直接调用程序的接口？</p>\n<h2 id=\"SOAP，何方妖孽？\"><a href=\"#SOAP，何方妖孽？\" class=\"headerlink\" title=\"SOAP，何方妖孽？\"></a>SOAP，何方妖孽？</h2><ul>\n<li>SOAP（Simple Object Access Protocol 简单对象访问协议）</li>\n<li>SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。</li>\n<li>SOAP 独立于平台、语言，且简单和可扩展</li>\n</ul>\n<h2 id=\"SOAP-怎么来的？\"><a href=\"#SOAP-怎么来的？\" class=\"headerlink\" title=\"SOAP 怎么来的？\"></a>SOAP 怎么来的？</h2><p>此标准由IBM、Microsoft、UserLand和DevelopMentor在1998年共同提出，并得到IBM，莲花（Lotus），康柏（Compaq）等公司的支持，于2000年提交给万维网联盟（World Wide Web Consortium；W3C），目前SOAP 1.1版是业界共同的标准，属于第二代的XML协定（第一代具主要代表性的技术为XML-RPC以及WDDX）。</p>\n<h2 id=\"SOAP-的-好搭档：WSDL、Web-Service\"><a href=\"#SOAP-的-好搭档：WSDL、Web-Service\" class=\"headerlink\" title=\"SOAP 的 好搭档：WSDL、Web Service\"></a>SOAP 的 好搭档：WSDL、Web Service</h2><p>为了能了解SOAP的做的事，你首先需要了解和SOAP一同工作的两个同事。</p>\n<p><strong>Web Service</strong> 是一套应用程序的组件，也可以说是对外接口，它使用SOAP这一套标准，提供公共服务给别的程序调用。</p>\n<p><strong>WSDL</strong> 是基于XML语言的，用来描述web service的消息格式和协议细节，以及如何访问它们。它的全称是：Web Service Description Language web服务描述语言。</p>\n<h2 id=\"SOAP是怎么工作的？\"><a href=\"#SOAP是怎么工作的？\" class=\"headerlink\" title=\"SOAP是怎么工作的？\"></a>SOAP是怎么工作的？</h2><p>在了解了SOAP、WSDL、Web Service的定义之后，我们就来窥探一下它们三个是怎么P的？</p>\n<p><strong>假设</strong>现在有两个应用程序，分别用两种语言进行开发的，一个是用nodejs开发的程序，一个是用java开发的程序。而java程序其中有一个方法(getUser)可以查询数据库中的某用户的信息。那么在nodejs程序请求java程序的(getUser)方法获取某用户信息的流程是怎么走的？</p>\n<p>我在应用程序的层面上解释一下这个流程，</p>\n<p>请看下图，然后我再对每一个步骤说明：</p>\n<p><img src=\"/image/blog/79702-5d2b1c9e8970c3ea.jpeg\" alt=\"\"></p>\n<p>首先java程序会把<code>getUser()</code>做成Web Service，然后要提供对这个service的描述文档，那便是WSDL文件。nodejs程序要调用的方法以及参数的信息都存放在遵循了SOAP标准的WSDL文件中，所以要访问远端的web service，必须先获得对方提供的WSDL。</p>\n<p>步骤一：nodejs程序通过http请求，获取到java程序提供的WSDL文件。nodejs程序得到这个WSDL文件之后，就会对它进行解析，得知java程序提供了<code>getUser()</code>，而且也知道这个方法需要的参数是<code>string</code>类型的且变量名<code>userUUID</code>。</p>\n<p>步骤二：在nodejs程序知道java程序有<code>getUser()</code>这个方法之后，它通过http请求，发送SOAP信息到java程序，java程序得到这个SOAP信息之后，进行解析，知道了nodejs程序需要请求<code>getUser()</code>方法，且提供了所需要的参数。</p>\n<p>步骤三：java程序对nodejs的请求进行逻辑处理，查询数据库，然后把结果翻译成SOAP信息，再通过http协议发送到nodejs程序。</p>\n<p>本例中，nodejs程序和java程序沟通的SOAP实例：</p>\n<p>SOAP 请求：</p>\n<pre><code>POST /InStock HTTP/1.1\nHost: www.example.org\nContent-Type: application/soap+xml; charset=utf-8\nContent-Length: nnn\n\n&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;soap:Envelope\nxmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;\nsoap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;\n\n  &lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;\n    &lt;m:getUser&gt;\n      &lt;m:userUUID&gt;123456789&lt;/m:userUUID&gt;\n    &lt;/m:getUser&gt;\n  &lt;/soap:Body&gt;\n\n&lt;/soap:Envelope&gt;`&lt;/pre&gt;\n\nSOAP 响应：\n\n&lt;pre&gt;`HTTP/1.1 200 OK\nContent-Type: application/soap+xml; charset=utf-8\nContent-Length: nnn\n\n&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;soap:Envelope\nxmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;\nsoap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;\n\n  &lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;\n    &lt;m:getUserResponse&gt;\n      &lt;m:userName&gt;JerryC&lt;/m:userName&gt;\n    &lt;/m:getUserResponse&gt;\n  &lt;/soap:Body&gt;\n\n&lt;/soap:Envelope&gt;\n</code></pre><p>综上，程序之间的调用，无论进行请求还是返回结果，每一次都需要构造一则SOAP信息，固然SOAP便是程序之间沟通的语言。</p>\n<h2 id=\"node开发中的soap\"><a href=\"#node开发中的soap\" class=\"headerlink\" title=\"node开发中的soap\"></a>node开发中的soap</h2><p>我是一名nodejs开发者，知道有这么一种程序之间交流信息的协议之后，很自然就想知道用nodejs怎么使用这个协议。</p>\n<p>nodejs针对SOAP也有不少的第三方模块：</p>\n<ul>\n<li><a href=\"https://github.com/milewise/node-soap\">node-soap</a></li>\n<li><a href=\"https://github.com/kr1sp1n/douche\">douche</a></li>\n<li><a href=\"https://github.com/jmoyers/soapjs\">soapjs</a><br>….<br><a href=\"https://nodejsmodules.org/tags/soap\">更多nodejs的SOAP第三方模块</a></li>\n</ul>\n<p>其中，node-soap是最受欢迎的(根据github上star数量)，也是我最喜欢的。</p>\n<h5 id=\"本文写作参考：\"><a href=\"#本文写作参考：\" class=\"headerlink\" title=\"本文写作参考：\"></a>本文写作参考：</h5><p><a href=\"http://www.w3school.com.cn/soap/index.asp\">http://www.w3school.com.cn/soap/index.asp</a><br><a href=\"http://zh.wikipedia.org/wiki/SOAP\">http://zh.wikipedia.org/wiki/SOAP</a></p>\n"},{"title":"My Nodejs Tool Kit","date":"2015-01-29T11:06:30.000Z","_content":"\n\n## [Cheerio](https://github.com/cheeriojs/cheerio)\n> Fast, flexible, and lean implementation of core jQuery designed specifically for the server.\n\nCheerio，说它是服务器端的jQuery一点也不为过，在github上也是大受欢迎，star数达4500有余，至目前为止，已经有923次commit。它兼容jQuery绝大部分的库，以至于你只需要一句`$ = require('cheerio').load(YOUR_HTML_CONTENT);`，便可以像在前端用jQuery一样的舒畅，愉快。\nBy the way，和Cheerio类似的框架还有：[jsdom](https://github.com/tmpvar/jsdom)，一个受欢迎程度略低于Cheerio，但是它有2,147多的commit，可见维护者之诚意。\n\n## [Waterline](https://github.com/balderdashy/waterline)\n>An adapter-based ORM for Node.js with support for mysql, mongo, postgres, redis, and more\n\nWaterline是从Sails框架衍生出来的Nodejs平台下的ORM，除了支持常见的mysql、mongodb，还支持PostgreSQL、Redis、Memory、Disk等等 \n\n## [Bookshelf](https://github.com/tgriesser/bookshelf)\n>A Node.js ORM for PostgreSQL, MySQL and SQLite3 in the style of Backbone.js\n\n与Waterline类似，但作为同类产品且被Ghost选择标配之一的Bookshelf必然有它的特别之处，仍待君细细品来。\n\n## [Node-Soap](https://github.com/vpulim/node-soap)\n> A SOAP client and server for node.js.\n\n对于REST，大家必然熟悉，就算不熟悉，也是久仰其大名，或者是略有耳闻。REST简单而直观，把HTTP协议利用到了极限，在这种思想指导下，它甚至用HTTP请求的头信息来指明资源的表示形式，用HTTP的错误机制来返回访问资源的错误。但在R.T. Fielding博士在他的论文里提出REST之前，又是谁来承担Web Service这份差使呢？\nSOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。它基于 XML 格式，在绝大多数情况下，使用HTTP协议传输WSDL请求。\n而node-soap模块，则允许在node环境中，接入其他程序语言 (诸如 ASP.net、Java 等) 开发的WebService。也能够在node中开发基于SOAP的WebService供其他程序调用。\n当然，在大多数情况下，过去SOAP能做的事，REST也是能做到的，且REST更加优雅，简单。以我的水平，我也是想不清楚SOAP依然存在的必然性，但是有那么一句话：「存在，就是合理的」。既然，它存在，也有人用到，那么在合作开发中和SOAP相遇也是有可能性的，相信那是我们的缘分。\n如果你有兴趣，听一下我和SOAP邂逅的故事：[SOAP，Web service的枢纽](http://www.jianshu.com/p/5443f90e36de)\n\n## [Passport](https://github.com/jaredhanson/passport)\n> Simple, unobtrusive authentication for Node.js.\n\n如果你的站点想快速建立passport-user结构的用户系统，且能够简单的接入流行的第三方登录，用passport就没错了。它不但提供了本站登录的解决方案，还有一大堆第三方登录的策略，见:[Strategies](https://github.com/jaredhanson/passport/wiki/Strategies#providers)\n如果你用Sails的话，这里还有一个承接Sails和passport的模块：[sails-generate-auth](https://github.com/kasperisager/sails-generate-auth)\n\n## [Bluebird](https://github.com/petkaantonov/bluebird)\n> Bluebird is a full featured promise library with unmatched performance.\n\nJavascript 的世界有一种痛叫「callback hell」，中文翻译过来叫「回调地狱」，如果能承受得了她带来的痛楚，且继续爱着她，这是「真爱」。Promise的概念，能够让你与javascript好好爱的深沉。\n实现Promise的库有很多，我知道的有：\n* Q\n* when\n* bluebird\n* jQuery的deferred\n* javascript自带的Promise（一些高级浏览器内置的Promise对象）\n\n其中，我用的比较顺手的当属bluebird，它也是时下最优秀博客系统Ghost的标配之一。\n如果你想深入了解Promise的概念，可以点这里：[Promises: The Sync Problem](http://blog.getify.com/promises-part-1/)\n如果你想珍惜时间，珍惜生命，这里有中文版：[深入理解Promise五部曲](http://segmentfault.com/blog/kk_470661)\n\n## [Lodash](https://github.com/lodash/lodash)\n> A JavaScript utility library delivering consistency, modularity, performance, & extras.\n\n我想称它为Javascript的瑞士军刀，或者是一个蓝色工具箱。lodash提供了一系列相当不错的跟函数式编程相关的方法。函数式编程就像搭积木一样，像_.identity、_.partial、_.compose、splat、unsplat等都是职责单一的函数。别看它们简单，把它们当作积木看待，它们释放的是无尽的活力。 越是简单的东西，蕴藏的越是更为无限的可能性。\n\n## [Node.bcrypt.js](https://github.com/ncb000gt/node.bcrypt.js)\n> bcrypt for NodeJs\n\nbcrypt，是一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。然而，所提供的所有字符都具有十分重要的意义。密码越强大，您的数据就越安全。而node.bcrypt.js则是披上Nodejs斗篷的bcrypt，它的62.2%是C++代码，而Javascript代码只有30.3%。\n\n## [Moment](https://github.com/moment/moment)\n> Parse, validate, manipulate, and display dates in javascript.\n\nMoment是一个轻量级用于处理日期的工具，除了对日期进行格式化以外，你还能够对日期进行操作，验证，解析。其在github的star数有1.9W+，比众所周知的Express(github star是1.7w+)还多一点。这么优秀的框架实在是相见恨晚。\n\n## [Skipper](https://github.com/balderdashy/skipper)\n> Streaming multi-uploads for Sails/Express - supports disk, S3, gridfs, and custom file adapters\n\nSkipper是一款Sails衍生的处理多文件上传的组件，支持上传文件到本地或者远端服务器，如果默认adapter没有你需要的服务，你还能够自定义一套adapter满足你的需求。就像我为了把文件上传到又拍云而定制了的adapter： [skipper-upyun](https://github.com/JerryC8080/skipper-upyun)\n\n## [Node-fs-extra](https://github.com/jprichardson/node-fs-extra)\n> Node.js: extra methods for the fs object.\n\nNode-fs-extra提供了一些额外的fs没有的函数，如果Nodejs自带的fs模块，还不能满足你在进行文件操作的使用，或者用着不顺心。不妨来node-fs-extra找一下有没有你想要的解决方案。\n\n## [Mocha](https://github.com/mochajs/mocha)\n> mocha - simple, flexible, fun javascript test framework for node.js & the browser. (BDD, TDD, QUnit styles via interfaces)\n\nNodejs单元测试哪家强？   \nmocha，mocha，似魔鬼的步伐~~yo!\n\n## [Should](https://github.com/tj/should.js)\n> BDD style assertions for node.js -- test framework agnostic\n\nBDD风格的断言模块，旨在让编程像说白话（至少在测试断言上）。\n\n## [Supertest](https://github.com/tj/supertest)\n> Super-agent driven library for testing node.js HTTP servers using a fluent API\n\n如果测试的时候，需要HTTP请求呢？找Supertest吧，和Should同一个作者，TJ大神，你值得信赖。\n\n## [PM2](https://github.com/Unitech/PM2)\n> Production process manager for Node.JS applications. Perfectly designed for microservice architecture.\n\nNodejs单线程的特性，意味着，如果你的某一行代码阻塞了，你的整个程序都会崩溃。人非圣贤，孰能无过，没有人能保证自己的写的代码永无BUG（难道要在文件头加上无BUG神兽？）。在生产环境下，如果程序挂了怎么办？让它自动重启呗。\nPM2就是一款解决这种问题的工具，当然，作为一个进程管理器，它的作用不仅仅如此。\n\n## [Markdown-js](https://github.com/evilstreak/markdown-js)\n>A Markdown parser for javascript\n\nMarkdown时下越来越受欢迎了，实质上markdown最终是转换成HTML格式才能显示于网页的。而markdown-js则是把markdown格式的文本转化成HTML格式的工具。但是，如果从HTML格式的文本转化成Markdown格式的文本呢？markdown-js好像不支持，那就用[to-markdown](https://github.com/domchristie/to-markdown)吧。\n\n## 后话\n本文的描述及用语，仅基于本人目前的水平而写，难免有所局限和措辞不当之处。如果有BUG或者不当之处，欢迎指出与吐槽。\n\n\n","source":"_posts/My-Nodejs-Tool-Kit.md","raw":"---\ntitle: My Nodejs Tool Kit\ndate: 2015-01-29 19:06:30\ntags: \n- Nodejs\n- Javascript\n- Tool Kit\ncategory: 搬砖码农\n---\n\n\n## [Cheerio](https://github.com/cheeriojs/cheerio)\n> Fast, flexible, and lean implementation of core jQuery designed specifically for the server.\n\nCheerio，说它是服务器端的jQuery一点也不为过，在github上也是大受欢迎，star数达4500有余，至目前为止，已经有923次commit。它兼容jQuery绝大部分的库，以至于你只需要一句`$ = require('cheerio').load(YOUR_HTML_CONTENT);`，便可以像在前端用jQuery一样的舒畅，愉快。\nBy the way，和Cheerio类似的框架还有：[jsdom](https://github.com/tmpvar/jsdom)，一个受欢迎程度略低于Cheerio，但是它有2,147多的commit，可见维护者之诚意。\n\n## [Waterline](https://github.com/balderdashy/waterline)\n>An adapter-based ORM for Node.js with support for mysql, mongo, postgres, redis, and more\n\nWaterline是从Sails框架衍生出来的Nodejs平台下的ORM，除了支持常见的mysql、mongodb，还支持PostgreSQL、Redis、Memory、Disk等等 \n\n## [Bookshelf](https://github.com/tgriesser/bookshelf)\n>A Node.js ORM for PostgreSQL, MySQL and SQLite3 in the style of Backbone.js\n\n与Waterline类似，但作为同类产品且被Ghost选择标配之一的Bookshelf必然有它的特别之处，仍待君细细品来。\n\n## [Node-Soap](https://github.com/vpulim/node-soap)\n> A SOAP client and server for node.js.\n\n对于REST，大家必然熟悉，就算不熟悉，也是久仰其大名，或者是略有耳闻。REST简单而直观，把HTTP协议利用到了极限，在这种思想指导下，它甚至用HTTP请求的头信息来指明资源的表示形式，用HTTP的错误机制来返回访问资源的错误。但在R.T. Fielding博士在他的论文里提出REST之前，又是谁来承担Web Service这份差使呢？\nSOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。它基于 XML 格式，在绝大多数情况下，使用HTTP协议传输WSDL请求。\n而node-soap模块，则允许在node环境中，接入其他程序语言 (诸如 ASP.net、Java 等) 开发的WebService。也能够在node中开发基于SOAP的WebService供其他程序调用。\n当然，在大多数情况下，过去SOAP能做的事，REST也是能做到的，且REST更加优雅，简单。以我的水平，我也是想不清楚SOAP依然存在的必然性，但是有那么一句话：「存在，就是合理的」。既然，它存在，也有人用到，那么在合作开发中和SOAP相遇也是有可能性的，相信那是我们的缘分。\n如果你有兴趣，听一下我和SOAP邂逅的故事：[SOAP，Web service的枢纽](http://www.jianshu.com/p/5443f90e36de)\n\n## [Passport](https://github.com/jaredhanson/passport)\n> Simple, unobtrusive authentication for Node.js.\n\n如果你的站点想快速建立passport-user结构的用户系统，且能够简单的接入流行的第三方登录，用passport就没错了。它不但提供了本站登录的解决方案，还有一大堆第三方登录的策略，见:[Strategies](https://github.com/jaredhanson/passport/wiki/Strategies#providers)\n如果你用Sails的话，这里还有一个承接Sails和passport的模块：[sails-generate-auth](https://github.com/kasperisager/sails-generate-auth)\n\n## [Bluebird](https://github.com/petkaantonov/bluebird)\n> Bluebird is a full featured promise library with unmatched performance.\n\nJavascript 的世界有一种痛叫「callback hell」，中文翻译过来叫「回调地狱」，如果能承受得了她带来的痛楚，且继续爱着她，这是「真爱」。Promise的概念，能够让你与javascript好好爱的深沉。\n实现Promise的库有很多，我知道的有：\n* Q\n* when\n* bluebird\n* jQuery的deferred\n* javascript自带的Promise（一些高级浏览器内置的Promise对象）\n\n其中，我用的比较顺手的当属bluebird，它也是时下最优秀博客系统Ghost的标配之一。\n如果你想深入了解Promise的概念，可以点这里：[Promises: The Sync Problem](http://blog.getify.com/promises-part-1/)\n如果你想珍惜时间，珍惜生命，这里有中文版：[深入理解Promise五部曲](http://segmentfault.com/blog/kk_470661)\n\n## [Lodash](https://github.com/lodash/lodash)\n> A JavaScript utility library delivering consistency, modularity, performance, & extras.\n\n我想称它为Javascript的瑞士军刀，或者是一个蓝色工具箱。lodash提供了一系列相当不错的跟函数式编程相关的方法。函数式编程就像搭积木一样，像_.identity、_.partial、_.compose、splat、unsplat等都是职责单一的函数。别看它们简单，把它们当作积木看待，它们释放的是无尽的活力。 越是简单的东西，蕴藏的越是更为无限的可能性。\n\n## [Node.bcrypt.js](https://github.com/ncb000gt/node.bcrypt.js)\n> bcrypt for NodeJs\n\nbcrypt，是一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。然而，所提供的所有字符都具有十分重要的意义。密码越强大，您的数据就越安全。而node.bcrypt.js则是披上Nodejs斗篷的bcrypt，它的62.2%是C++代码，而Javascript代码只有30.3%。\n\n## [Moment](https://github.com/moment/moment)\n> Parse, validate, manipulate, and display dates in javascript.\n\nMoment是一个轻量级用于处理日期的工具，除了对日期进行格式化以外，你还能够对日期进行操作，验证，解析。其在github的star数有1.9W+，比众所周知的Express(github star是1.7w+)还多一点。这么优秀的框架实在是相见恨晚。\n\n## [Skipper](https://github.com/balderdashy/skipper)\n> Streaming multi-uploads for Sails/Express - supports disk, S3, gridfs, and custom file adapters\n\nSkipper是一款Sails衍生的处理多文件上传的组件，支持上传文件到本地或者远端服务器，如果默认adapter没有你需要的服务，你还能够自定义一套adapter满足你的需求。就像我为了把文件上传到又拍云而定制了的adapter： [skipper-upyun](https://github.com/JerryC8080/skipper-upyun)\n\n## [Node-fs-extra](https://github.com/jprichardson/node-fs-extra)\n> Node.js: extra methods for the fs object.\n\nNode-fs-extra提供了一些额外的fs没有的函数，如果Nodejs自带的fs模块，还不能满足你在进行文件操作的使用，或者用着不顺心。不妨来node-fs-extra找一下有没有你想要的解决方案。\n\n## [Mocha](https://github.com/mochajs/mocha)\n> mocha - simple, flexible, fun javascript test framework for node.js & the browser. (BDD, TDD, QUnit styles via interfaces)\n\nNodejs单元测试哪家强？   \nmocha，mocha，似魔鬼的步伐~~yo!\n\n## [Should](https://github.com/tj/should.js)\n> BDD style assertions for node.js -- test framework agnostic\n\nBDD风格的断言模块，旨在让编程像说白话（至少在测试断言上）。\n\n## [Supertest](https://github.com/tj/supertest)\n> Super-agent driven library for testing node.js HTTP servers using a fluent API\n\n如果测试的时候，需要HTTP请求呢？找Supertest吧，和Should同一个作者，TJ大神，你值得信赖。\n\n## [PM2](https://github.com/Unitech/PM2)\n> Production process manager for Node.JS applications. Perfectly designed for microservice architecture.\n\nNodejs单线程的特性，意味着，如果你的某一行代码阻塞了，你的整个程序都会崩溃。人非圣贤，孰能无过，没有人能保证自己的写的代码永无BUG（难道要在文件头加上无BUG神兽？）。在生产环境下，如果程序挂了怎么办？让它自动重启呗。\nPM2就是一款解决这种问题的工具，当然，作为一个进程管理器，它的作用不仅仅如此。\n\n## [Markdown-js](https://github.com/evilstreak/markdown-js)\n>A Markdown parser for javascript\n\nMarkdown时下越来越受欢迎了，实质上markdown最终是转换成HTML格式才能显示于网页的。而markdown-js则是把markdown格式的文本转化成HTML格式的工具。但是，如果从HTML格式的文本转化成Markdown格式的文本呢？markdown-js好像不支持，那就用[to-markdown](https://github.com/domchristie/to-markdown)吧。\n\n## 后话\n本文的描述及用语，仅基于本人目前的水平而写，难免有所局限和措辞不当之处。如果有BUG或者不当之处，欢迎指出与吐槽。\n\n\n","slug":"My-Nodejs-Tool-Kit","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwpi000j15hl6uf80wp4","content":"<h2 id=\"Cheerio\"><a href=\"#Cheerio\" class=\"headerlink\" title=\"Cheerio\"></a><a href=\"https://github.com/cheeriojs/cheerio\" target=\"_blank\" rel=\"external\">Cheerio</a></h2><blockquote>\n<p>Fast, flexible, and lean implementation of core jQuery designed specifically for the server.</p>\n</blockquote>\n<p>Cheerio，说它是服务器端的jQuery一点也不为过，在github上也是大受欢迎，star数达4500有余，至目前为止，已经有923次commit。它兼容jQuery绝大部分的库，以至于你只需要一句<code>$ = require(&#39;cheerio&#39;).load(YOUR_HTML_CONTENT);</code>，便可以像在前端用jQuery一样的舒畅，愉快。<br>By the way，和Cheerio类似的框架还有：<a href=\"https://github.com/tmpvar/jsdom\" target=\"_blank\" rel=\"external\">jsdom</a>，一个受欢迎程度略低于Cheerio，但是它有2,147多的commit，可见维护者之诚意。</p>\n<h2 id=\"Waterline\"><a href=\"#Waterline\" class=\"headerlink\" title=\"Waterline\"></a><a href=\"https://github.com/balderdashy/waterline\" target=\"_blank\" rel=\"external\">Waterline</a></h2><blockquote>\n<p>An adapter-based ORM for Node.js with support for mysql, mongo, postgres, redis, and more</p>\n</blockquote>\n<p>Waterline是从Sails框架衍生出来的Nodejs平台下的ORM，除了支持常见的mysql、mongodb，还支持PostgreSQL、Redis、Memory、Disk等等 </p>\n<h2 id=\"Bookshelf\"><a href=\"#Bookshelf\" class=\"headerlink\" title=\"Bookshelf\"></a><a href=\"https://github.com/tgriesser/bookshelf\" target=\"_blank\" rel=\"external\">Bookshelf</a></h2><blockquote>\n<p>A Node.js ORM for PostgreSQL, MySQL and SQLite3 in the style of Backbone.js</p>\n</blockquote>\n<p>与Waterline类似，但作为同类产品且被Ghost选择标配之一的Bookshelf必然有它的特别之处，仍待君细细品来。</p>\n<h2 id=\"Node-Soap\"><a href=\"#Node-Soap\" class=\"headerlink\" title=\"Node-Soap\"></a><a href=\"https://github.com/vpulim/node-soap\" target=\"_blank\" rel=\"external\">Node-Soap</a></h2><blockquote>\n<p>A SOAP client and server for node.js.</p>\n</blockquote>\n<p>对于REST，大家必然熟悉，就算不熟悉，也是久仰其大名，或者是略有耳闻。REST简单而直观，把HTTP协议利用到了极限，在这种思想指导下，它甚至用HTTP请求的头信息来指明资源的表示形式，用HTTP的错误机制来返回访问资源的错误。但在R.T. Fielding博士在他的论文里提出REST之前，又是谁来承担Web Service这份差使呢？<br>SOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。它基于 XML 格式，在绝大多数情况下，使用HTTP协议传输WSDL请求。<br>而node-soap模块，则允许在node环境中，接入其他程序语言 (诸如 ASP.net、Java 等) 开发的WebService。也能够在node中开发基于SOAP的WebService供其他程序调用。<br>当然，在大多数情况下，过去SOAP能做的事，REST也是能做到的，且REST更加优雅，简单。以我的水平，我也是想不清楚SOAP依然存在的必然性，但是有那么一句话：「存在，就是合理的」。既然，它存在，也有人用到，那么在合作开发中和SOAP相遇也是有可能性的，相信那是我们的缘分。<br>如果你有兴趣，听一下我和SOAP邂逅的故事：<a href=\"http://www.jianshu.com/p/5443f90e36de\" target=\"_blank\" rel=\"external\">SOAP，Web service的枢纽</a></p>\n<h2 id=\"Passport\"><a href=\"#Passport\" class=\"headerlink\" title=\"Passport\"></a><a href=\"https://github.com/jaredhanson/passport\" target=\"_blank\" rel=\"external\">Passport</a></h2><blockquote>\n<p>Simple, unobtrusive authentication for Node.js.</p>\n</blockquote>\n<p>如果你的站点想快速建立passport-user结构的用户系统，且能够简单的接入流行的第三方登录，用passport就没错了。它不但提供了本站登录的解决方案，还有一大堆第三方登录的策略，见:<a href=\"https://github.com/jaredhanson/passport/wiki/Strategies#providers\" target=\"_blank\" rel=\"external\">Strategies</a><br>如果你用Sails的话，这里还有一个承接Sails和passport的模块：<a href=\"https://github.com/kasperisager/sails-generate-auth\" target=\"_blank\" rel=\"external\">sails-generate-auth</a></p>\n<h2 id=\"Bluebird\"><a href=\"#Bluebird\" class=\"headerlink\" title=\"Bluebird\"></a><a href=\"https://github.com/petkaantonov/bluebird\" target=\"_blank\" rel=\"external\">Bluebird</a></h2><blockquote>\n<p>Bluebird is a full featured promise library with unmatched performance.</p>\n</blockquote>\n<p>Javascript 的世界有一种痛叫「callback hell」，中文翻译过来叫「回调地狱」，如果能承受得了她带来的痛楚，且继续爱着她，这是「真爱」。Promise的概念，能够让你与javascript好好爱的深沉。<br>实现Promise的库有很多，我知道的有：</p>\n<ul>\n<li>Q</li>\n<li>when</li>\n<li>bluebird</li>\n<li>jQuery的deferred</li>\n<li>javascript自带的Promise（一些高级浏览器内置的Promise对象）</li>\n</ul>\n<p>其中，我用的比较顺手的当属bluebird，它也是时下最优秀博客系统Ghost的标配之一。<br>如果你想深入了解Promise的概念，可以点这里：<a href=\"http://blog.getify.com/promises-part-1/\" target=\"_blank\" rel=\"external\">Promises: The Sync Problem</a><br>如果你想珍惜时间，珍惜生命，这里有中文版：<a href=\"http://segmentfault.com/blog/kk_470661\" target=\"_blank\" rel=\"external\">深入理解Promise五部曲</a></p>\n<h2 id=\"Lodash\"><a href=\"#Lodash\" class=\"headerlink\" title=\"Lodash\"></a><a href=\"https://github.com/lodash/lodash\" target=\"_blank\" rel=\"external\">Lodash</a></h2><blockquote>\n<p>A JavaScript utility library delivering consistency, modularity, performance, &amp; extras.</p>\n</blockquote>\n<p>我想称它为Javascript的瑞士军刀，或者是一个蓝色工具箱。lodash提供了一系列相当不错的跟函数式编程相关的方法。函数式编程就像搭积木一样，像<em>.identity、</em>.partial、_.compose、splat、unsplat等都是职责单一的函数。别看它们简单，把它们当作积木看待，它们释放的是无尽的活力。 越是简单的东西，蕴藏的越是更为无限的可能性。</p>\n<h2 id=\"Node-bcrypt-js\"><a href=\"#Node-bcrypt-js\" class=\"headerlink\" title=\"Node.bcrypt.js\"></a><a href=\"https://github.com/ncb000gt/node.bcrypt.js\" target=\"_blank\" rel=\"external\">Node.bcrypt.js</a></h2><blockquote>\n<p>bcrypt for NodeJs</p>\n</blockquote>\n<p>bcrypt，是一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。然而，所提供的所有字符都具有十分重要的意义。密码越强大，您的数据就越安全。而node.bcrypt.js则是披上Nodejs斗篷的bcrypt，它的62.2%是C++代码，而Javascript代码只有30.3%。</p>\n<h2 id=\"Moment\"><a href=\"#Moment\" class=\"headerlink\" title=\"Moment\"></a><a href=\"https://github.com/moment/moment\" target=\"_blank\" rel=\"external\">Moment</a></h2><blockquote>\n<p>Parse, validate, manipulate, and display dates in javascript.</p>\n</blockquote>\n<p>Moment是一个轻量级用于处理日期的工具，除了对日期进行格式化以外，你还能够对日期进行操作，验证，解析。其在github的star数有1.9W+，比众所周知的Express(github star是1.7w+)还多一点。这么优秀的框架实在是相见恨晚。</p>\n<h2 id=\"Skipper\"><a href=\"#Skipper\" class=\"headerlink\" title=\"Skipper\"></a><a href=\"https://github.com/balderdashy/skipper\" target=\"_blank\" rel=\"external\">Skipper</a></h2><blockquote>\n<p>Streaming multi-uploads for Sails/Express - supports disk, S3, gridfs, and custom file adapters</p>\n</blockquote>\n<p>Skipper是一款Sails衍生的处理多文件上传的组件，支持上传文件到本地或者远端服务器，如果默认adapter没有你需要的服务，你还能够自定义一套adapter满足你的需求。就像我为了把文件上传到又拍云而定制了的adapter： <a href=\"https://github.com/JerryC8080/skipper-upyun\" target=\"_blank\" rel=\"external\">skipper-upyun</a></p>\n<h2 id=\"Node-fs-extra\"><a href=\"#Node-fs-extra\" class=\"headerlink\" title=\"Node-fs-extra\"></a><a href=\"https://github.com/jprichardson/node-fs-extra\" target=\"_blank\" rel=\"external\">Node-fs-extra</a></h2><blockquote>\n<p>Node.js: extra methods for the fs object.</p>\n</blockquote>\n<p>Node-fs-extra提供了一些额外的fs没有的函数，如果Nodejs自带的fs模块，还不能满足你在进行文件操作的使用，或者用着不顺心。不妨来node-fs-extra找一下有没有你想要的解决方案。</p>\n<h2 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a><a href=\"https://github.com/mochajs/mocha\" target=\"_blank\" rel=\"external\">Mocha</a></h2><blockquote>\n<p>mocha - simple, flexible, fun javascript test framework for node.js &amp; the browser. (BDD, TDD, QUnit styles via interfaces)</p>\n</blockquote>\n<p>Nodejs单元测试哪家强？<br>mocha，mocha，似魔鬼的步伐~~yo!</p>\n<h2 id=\"Should\"><a href=\"#Should\" class=\"headerlink\" title=\"Should\"></a><a href=\"https://github.com/tj/should.js\" target=\"_blank\" rel=\"external\">Should</a></h2><blockquote>\n<p>BDD style assertions for node.js – test framework agnostic</p>\n</blockquote>\n<p>BDD风格的断言模块，旨在让编程像说白话（至少在测试断言上）。</p>\n<h2 id=\"Supertest\"><a href=\"#Supertest\" class=\"headerlink\" title=\"Supertest\"></a><a href=\"https://github.com/tj/supertest\" target=\"_blank\" rel=\"external\">Supertest</a></h2><blockquote>\n<p>Super-agent driven library for testing node.js HTTP servers using a fluent API</p>\n</blockquote>\n<p>如果测试的时候，需要HTTP请求呢？找Supertest吧，和Should同一个作者，TJ大神，你值得信赖。</p>\n<h2 id=\"PM2\"><a href=\"#PM2\" class=\"headerlink\" title=\"PM2\"></a><a href=\"https://github.com/Unitech/PM2\" target=\"_blank\" rel=\"external\">PM2</a></h2><blockquote>\n<p>Production process manager for Node.JS applications. Perfectly designed for microservice architecture.</p>\n</blockquote>\n<p>Nodejs单线程的特性，意味着，如果你的某一行代码阻塞了，你的整个程序都会崩溃。人非圣贤，孰能无过，没有人能保证自己的写的代码永无BUG（难道要在文件头加上无BUG神兽？）。在生产环境下，如果程序挂了怎么办？让它自动重启呗。<br>PM2就是一款解决这种问题的工具，当然，作为一个进程管理器，它的作用不仅仅如此。</p>\n<h2 id=\"Markdown-js\"><a href=\"#Markdown-js\" class=\"headerlink\" title=\"Markdown-js\"></a><a href=\"https://github.com/evilstreak/markdown-js\" target=\"_blank\" rel=\"external\">Markdown-js</a></h2><blockquote>\n<p>A Markdown parser for javascript</p>\n</blockquote>\n<p>Markdown时下越来越受欢迎了，实质上markdown最终是转换成HTML格式才能显示于网页的。而markdown-js则是把markdown格式的文本转化成HTML格式的工具。但是，如果从HTML格式的文本转化成Markdown格式的文本呢？markdown-js好像不支持，那就用<a href=\"https://github.com/domchristie/to-markdown\" target=\"_blank\" rel=\"external\">to-markdown</a>吧。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>本文的描述及用语，仅基于本人目前的水平而写，难免有所局限和措辞不当之处。如果有BUG或者不当之处，欢迎指出与吐槽。</p>\n","excerpt":"","more":"<h2 id=\"Cheerio\"><a href=\"#Cheerio\" class=\"headerlink\" title=\"Cheerio\"></a><a href=\"https://github.com/cheeriojs/cheerio\">Cheerio</a></h2><blockquote>\n<p>Fast, flexible, and lean implementation of core jQuery designed specifically for the server.</p>\n</blockquote>\n<p>Cheerio，说它是服务器端的jQuery一点也不为过，在github上也是大受欢迎，star数达4500有余，至目前为止，已经有923次commit。它兼容jQuery绝大部分的库，以至于你只需要一句<code>$ = require(&#39;cheerio&#39;).load(YOUR_HTML_CONTENT);</code>，便可以像在前端用jQuery一样的舒畅，愉快。<br>By the way，和Cheerio类似的框架还有：<a href=\"https://github.com/tmpvar/jsdom\">jsdom</a>，一个受欢迎程度略低于Cheerio，但是它有2,147多的commit，可见维护者之诚意。</p>\n<h2 id=\"Waterline\"><a href=\"#Waterline\" class=\"headerlink\" title=\"Waterline\"></a><a href=\"https://github.com/balderdashy/waterline\">Waterline</a></h2><blockquote>\n<p>An adapter-based ORM for Node.js with support for mysql, mongo, postgres, redis, and more</p>\n</blockquote>\n<p>Waterline是从Sails框架衍生出来的Nodejs平台下的ORM，除了支持常见的mysql、mongodb，还支持PostgreSQL、Redis、Memory、Disk等等 </p>\n<h2 id=\"Bookshelf\"><a href=\"#Bookshelf\" class=\"headerlink\" title=\"Bookshelf\"></a><a href=\"https://github.com/tgriesser/bookshelf\">Bookshelf</a></h2><blockquote>\n<p>A Node.js ORM for PostgreSQL, MySQL and SQLite3 in the style of Backbone.js</p>\n</blockquote>\n<p>与Waterline类似，但作为同类产品且被Ghost选择标配之一的Bookshelf必然有它的特别之处，仍待君细细品来。</p>\n<h2 id=\"Node-Soap\"><a href=\"#Node-Soap\" class=\"headerlink\" title=\"Node-Soap\"></a><a href=\"https://github.com/vpulim/node-soap\">Node-Soap</a></h2><blockquote>\n<p>A SOAP client and server for node.js.</p>\n</blockquote>\n<p>对于REST，大家必然熟悉，就算不熟悉，也是久仰其大名，或者是略有耳闻。REST简单而直观，把HTTP协议利用到了极限，在这种思想指导下，它甚至用HTTP请求的头信息来指明资源的表示形式，用HTTP的错误机制来返回访问资源的错误。但在R.T. Fielding博士在他的论文里提出REST之前，又是谁来承担Web Service这份差使呢？<br>SOAP (Simple Object Access Protocol) 顾名思义，是一个严格定义的信息交换协议，用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。它基于 XML 格式，在绝大多数情况下，使用HTTP协议传输WSDL请求。<br>而node-soap模块，则允许在node环境中，接入其他程序语言 (诸如 ASP.net、Java 等) 开发的WebService。也能够在node中开发基于SOAP的WebService供其他程序调用。<br>当然，在大多数情况下，过去SOAP能做的事，REST也是能做到的，且REST更加优雅，简单。以我的水平，我也是想不清楚SOAP依然存在的必然性，但是有那么一句话：「存在，就是合理的」。既然，它存在，也有人用到，那么在合作开发中和SOAP相遇也是有可能性的，相信那是我们的缘分。<br>如果你有兴趣，听一下我和SOAP邂逅的故事：<a href=\"http://www.jianshu.com/p/5443f90e36de\">SOAP，Web service的枢纽</a></p>\n<h2 id=\"Passport\"><a href=\"#Passport\" class=\"headerlink\" title=\"Passport\"></a><a href=\"https://github.com/jaredhanson/passport\">Passport</a></h2><blockquote>\n<p>Simple, unobtrusive authentication for Node.js.</p>\n</blockquote>\n<p>如果你的站点想快速建立passport-user结构的用户系统，且能够简单的接入流行的第三方登录，用passport就没错了。它不但提供了本站登录的解决方案，还有一大堆第三方登录的策略，见:<a href=\"https://github.com/jaredhanson/passport/wiki/Strategies#providers\">Strategies</a><br>如果你用Sails的话，这里还有一个承接Sails和passport的模块：<a href=\"https://github.com/kasperisager/sails-generate-auth\">sails-generate-auth</a></p>\n<h2 id=\"Bluebird\"><a href=\"#Bluebird\" class=\"headerlink\" title=\"Bluebird\"></a><a href=\"https://github.com/petkaantonov/bluebird\">Bluebird</a></h2><blockquote>\n<p>Bluebird is a full featured promise library with unmatched performance.</p>\n</blockquote>\n<p>Javascript 的世界有一种痛叫「callback hell」，中文翻译过来叫「回调地狱」，如果能承受得了她带来的痛楚，且继续爱着她，这是「真爱」。Promise的概念，能够让你与javascript好好爱的深沉。<br>实现Promise的库有很多，我知道的有：</p>\n<ul>\n<li>Q</li>\n<li>when</li>\n<li>bluebird</li>\n<li>jQuery的deferred</li>\n<li>javascript自带的Promise（一些高级浏览器内置的Promise对象）</li>\n</ul>\n<p>其中，我用的比较顺手的当属bluebird，它也是时下最优秀博客系统Ghost的标配之一。<br>如果你想深入了解Promise的概念，可以点这里：<a href=\"http://blog.getify.com/promises-part-1/\">Promises: The Sync Problem</a><br>如果你想珍惜时间，珍惜生命，这里有中文版：<a href=\"http://segmentfault.com/blog/kk_470661\">深入理解Promise五部曲</a></p>\n<h2 id=\"Lodash\"><a href=\"#Lodash\" class=\"headerlink\" title=\"Lodash\"></a><a href=\"https://github.com/lodash/lodash\">Lodash</a></h2><blockquote>\n<p>A JavaScript utility library delivering consistency, modularity, performance, &amp; extras.</p>\n</blockquote>\n<p>我想称它为Javascript的瑞士军刀，或者是一个蓝色工具箱。lodash提供了一系列相当不错的跟函数式编程相关的方法。函数式编程就像搭积木一样，像<em>.identity、</em>.partial、_.compose、splat、unsplat等都是职责单一的函数。别看它们简单，把它们当作积木看待，它们释放的是无尽的活力。 越是简单的东西，蕴藏的越是更为无限的可能性。</p>\n<h2 id=\"Node-bcrypt-js\"><a href=\"#Node-bcrypt-js\" class=\"headerlink\" title=\"Node.bcrypt.js\"></a><a href=\"https://github.com/ncb000gt/node.bcrypt.js\">Node.bcrypt.js</a></h2><blockquote>\n<p>bcrypt for NodeJs</p>\n</blockquote>\n<p>bcrypt，是一个跨平台的文件加密工具。由它加密的文件可在所有支持的操作系统和处理器上进行转移。它的口令必须是8至56个字符，并将在内部被转化为448位的密钥。然而，所提供的所有字符都具有十分重要的意义。密码越强大，您的数据就越安全。而node.bcrypt.js则是披上Nodejs斗篷的bcrypt，它的62.2%是C++代码，而Javascript代码只有30.3%。</p>\n<h2 id=\"Moment\"><a href=\"#Moment\" class=\"headerlink\" title=\"Moment\"></a><a href=\"https://github.com/moment/moment\">Moment</a></h2><blockquote>\n<p>Parse, validate, manipulate, and display dates in javascript.</p>\n</blockquote>\n<p>Moment是一个轻量级用于处理日期的工具，除了对日期进行格式化以外，你还能够对日期进行操作，验证，解析。其在github的star数有1.9W+，比众所周知的Express(github star是1.7w+)还多一点。这么优秀的框架实在是相见恨晚。</p>\n<h2 id=\"Skipper\"><a href=\"#Skipper\" class=\"headerlink\" title=\"Skipper\"></a><a href=\"https://github.com/balderdashy/skipper\">Skipper</a></h2><blockquote>\n<p>Streaming multi-uploads for Sails/Express - supports disk, S3, gridfs, and custom file adapters</p>\n</blockquote>\n<p>Skipper是一款Sails衍生的处理多文件上传的组件，支持上传文件到本地或者远端服务器，如果默认adapter没有你需要的服务，你还能够自定义一套adapter满足你的需求。就像我为了把文件上传到又拍云而定制了的adapter： <a href=\"https://github.com/JerryC8080/skipper-upyun\">skipper-upyun</a></p>\n<h2 id=\"Node-fs-extra\"><a href=\"#Node-fs-extra\" class=\"headerlink\" title=\"Node-fs-extra\"></a><a href=\"https://github.com/jprichardson/node-fs-extra\">Node-fs-extra</a></h2><blockquote>\n<p>Node.js: extra methods for the fs object.</p>\n</blockquote>\n<p>Node-fs-extra提供了一些额外的fs没有的函数，如果Nodejs自带的fs模块，还不能满足你在进行文件操作的使用，或者用着不顺心。不妨来node-fs-extra找一下有没有你想要的解决方案。</p>\n<h2 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a><a href=\"https://github.com/mochajs/mocha\">Mocha</a></h2><blockquote>\n<p>mocha - simple, flexible, fun javascript test framework for node.js &amp; the browser. (BDD, TDD, QUnit styles via interfaces)</p>\n</blockquote>\n<p>Nodejs单元测试哪家强？<br>mocha，mocha，似魔鬼的步伐~~yo!</p>\n<h2 id=\"Should\"><a href=\"#Should\" class=\"headerlink\" title=\"Should\"></a><a href=\"https://github.com/tj/should.js\">Should</a></h2><blockquote>\n<p>BDD style assertions for node.js – test framework agnostic</p>\n</blockquote>\n<p>BDD风格的断言模块，旨在让编程像说白话（至少在测试断言上）。</p>\n<h2 id=\"Supertest\"><a href=\"#Supertest\" class=\"headerlink\" title=\"Supertest\"></a><a href=\"https://github.com/tj/supertest\">Supertest</a></h2><blockquote>\n<p>Super-agent driven library for testing node.js HTTP servers using a fluent API</p>\n</blockquote>\n<p>如果测试的时候，需要HTTP请求呢？找Supertest吧，和Should同一个作者，TJ大神，你值得信赖。</p>\n<h2 id=\"PM2\"><a href=\"#PM2\" class=\"headerlink\" title=\"PM2\"></a><a href=\"https://github.com/Unitech/PM2\">PM2</a></h2><blockquote>\n<p>Production process manager for Node.JS applications. Perfectly designed for microservice architecture.</p>\n</blockquote>\n<p>Nodejs单线程的特性，意味着，如果你的某一行代码阻塞了，你的整个程序都会崩溃。人非圣贤，孰能无过，没有人能保证自己的写的代码永无BUG（难道要在文件头加上无BUG神兽？）。在生产环境下，如果程序挂了怎么办？让它自动重启呗。<br>PM2就是一款解决这种问题的工具，当然，作为一个进程管理器，它的作用不仅仅如此。</p>\n<h2 id=\"Markdown-js\"><a href=\"#Markdown-js\" class=\"headerlink\" title=\"Markdown-js\"></a><a href=\"https://github.com/evilstreak/markdown-js\">Markdown-js</a></h2><blockquote>\n<p>A Markdown parser for javascript</p>\n</blockquote>\n<p>Markdown时下越来越受欢迎了，实质上markdown最终是转换成HTML格式才能显示于网页的。而markdown-js则是把markdown格式的文本转化成HTML格式的工具。但是，如果从HTML格式的文本转化成Markdown格式的文本呢？markdown-js好像不支持，那就用<a href=\"https://github.com/domchristie/to-markdown\">to-markdown</a>吧。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>本文的描述及用语，仅基于本人目前的水平而写，难免有所局限和措辞不当之处。如果有BUG或者不当之处，欢迎指出与吐槽。</p>\n"},{"title":"Session原理","date":"2015-07-14T15:22:25.000Z","_content":"\n## 无状态的 HTTP 协议\n还记得每当入门一门 Web 端语言的进行服务器端开发的时候，仅次于「Hello World」的 demo 就是「登录功能」了。实现登录功能很简单，验证客户端发送过来的账户和密码，如果通过验证就把用户塞进 session 中，然后在后续的访问中，只需检测 session 是否有这个用户就能知道用户是否登录了。Session 的中文翻译为：「会话」，只属于某一个客户端和某一个服务器端沟通的工具。但，计算机网络老师又说了，HTTP 协议是无状态的，怎么能记录用户的登录状态呢？\n鉴于 HTTP 是无状态协议，之前已认证成功的用户状态是无法通过协议层面保存下来的，既，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他和其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。\n\n## 利用 Cookie 管理 Session\n\n![Session 管理及 Cookie 状态管理](/image/blog/79702-5660ac4cb51f6257.jpg)\n\n* 步骤 1：客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。\n\n* 步骤 2：服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份验证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID。\n\n* 步骤 3：客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。\n\n## 为 Cookie 服务的 HTTP 首部字段\n> \n* Set-Cookie\n* Cookie\n\n#### Set-Cookie\n服务器管理状态使用到的字段，用于响应首部\n一则响应首部的 Set-Cookie 字段：\n```\nSet-Cookie: status=enable; expires= Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;\n```\nSet-Cookie 字段的属性：\n\n| 属性 | 说明 |\n| ----|-----|\n|NAME=VALUE | 赋予 Cookie 的名称和其值（必须项）|\n|expires=DATE | Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）|\n|path=PATH | 将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的目录）|\n|domain=域名 | 作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）|\n| Secure | 仅在 HTTPS 安全通信时才会发送 Cookie|\n|HttpOnly| 加以限制，使 Cookie 不能被 Javascript 脚本访问\n\n#### Cookie\n首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。\n\n","source":"_posts/Session原理.md","raw":"---\ntitle: Session原理\ncategory: 搬砖码农\ndate: 2015-07-14 23:22:25\ntags: \n- session\n- cookie\n---\n\n## 无状态的 HTTP 协议\n还记得每当入门一门 Web 端语言的进行服务器端开发的时候，仅次于「Hello World」的 demo 就是「登录功能」了。实现登录功能很简单，验证客户端发送过来的账户和密码，如果通过验证就把用户塞进 session 中，然后在后续的访问中，只需检测 session 是否有这个用户就能知道用户是否登录了。Session 的中文翻译为：「会话」，只属于某一个客户端和某一个服务器端沟通的工具。但，计算机网络老师又说了，HTTP 协议是无状态的，怎么能记录用户的登录状态呢？\n鉴于 HTTP 是无状态协议，之前已认证成功的用户状态是无法通过协议层面保存下来的，既，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他和其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。\n\n## 利用 Cookie 管理 Session\n\n![Session 管理及 Cookie 状态管理](/image/blog/79702-5660ac4cb51f6257.jpg)\n\n* 步骤 1：客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。\n\n* 步骤 2：服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份验证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID。\n\n* 步骤 3：客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。\n\n## 为 Cookie 服务的 HTTP 首部字段\n> \n* Set-Cookie\n* Cookie\n\n#### Set-Cookie\n服务器管理状态使用到的字段，用于响应首部\n一则响应首部的 Set-Cookie 字段：\n```\nSet-Cookie: status=enable; expires= Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;\n```\nSet-Cookie 字段的属性：\n\n| 属性 | 说明 |\n| ----|-----|\n|NAME=VALUE | 赋予 Cookie 的名称和其值（必须项）|\n|expires=DATE | Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）|\n|path=PATH | 将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的目录）|\n|domain=域名 | 作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）|\n| Secure | 仅在 HTTPS 安全通信时才会发送 Cookie|\n|HttpOnly| 加以限制，使 Cookie 不能被 Javascript 脚本访问\n\n#### Cookie\n首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。\n\n","slug":"Session原理","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwpj000l15hljf5uqez2","content":"<h2 id=\"无状态的-HTTP-协议\"><a href=\"#无状态的-HTTP-协议\" class=\"headerlink\" title=\"无状态的 HTTP 协议\"></a>无状态的 HTTP 协议</h2><p>还记得每当入门一门 Web 端语言的进行服务器端开发的时候，仅次于「Hello World」的 demo 就是「登录功能」了。实现登录功能很简单，验证客户端发送过来的账户和密码，如果通过验证就把用户塞进 session 中，然后在后续的访问中，只需检测 session 是否有这个用户就能知道用户是否登录了。Session 的中文翻译为：「会话」，只属于某一个客户端和某一个服务器端沟通的工具。但，计算机网络老师又说了，HTTP 协议是无状态的，怎么能记录用户的登录状态呢？<br>鉴于 HTTP 是无状态协议，之前已认证成功的用户状态是无法通过协议层面保存下来的，既，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他和其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。</p>\n<h2 id=\"利用-Cookie-管理-Session\"><a href=\"#利用-Cookie-管理-Session\" class=\"headerlink\" title=\"利用 Cookie 管理 Session\"></a>利用 Cookie 管理 Session</h2><p><img src=\"/image/blog/79702-5660ac4cb51f6257.jpg\" alt=\"Session 管理及 Cookie 状态管理\"></p>\n<ul>\n<li><p>步骤 1：客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。</p>\n</li>\n<li><p>步骤 2：服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份验证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID。</p>\n</li>\n<li><p>步骤 3：客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</p>\n</li>\n</ul>\n<h2 id=\"为-Cookie-服务的-HTTP-首部字段\"><a href=\"#为-Cookie-服务的-HTTP-首部字段\" class=\"headerlink\" title=\"为 Cookie 服务的 HTTP 首部字段\"></a>为 Cookie 服务的 HTTP 首部字段</h2><blockquote>\n<ul>\n<li>Set-Cookie</li>\n<li>Cookie</li>\n</ul>\n</blockquote>\n<h4 id=\"Set-Cookie\"><a href=\"#Set-Cookie\" class=\"headerlink\" title=\"Set-Cookie\"></a>Set-Cookie</h4><p>服务器管理状态使用到的字段，用于响应首部<br>一则响应首部的 Set-Cookie 字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Set-Cookie: status=enable; expires= Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;</div></pre></td></tr></table></figure></p>\n<p>Set-Cookie 字段的属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NAME=VALUE</td>\n<td>赋予 Cookie 的名称和其值（必须项）</td>\n</tr>\n<tr>\n<td>expires=DATE</td>\n<td>Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td>\n</tr>\n<tr>\n<td>path=PATH</td>\n<td>将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的目录）</td>\n</tr>\n<tr>\n<td>domain=域名</td>\n<td>作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）</td>\n</tr>\n<tr>\n<td>Secure</td>\n<td>仅在 HTTPS 安全通信时才会发送 Cookie</td>\n</tr>\n<tr>\n<td>HttpOnly</td>\n<td>加以限制，使 Cookie 不能被 Javascript 脚本访问</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p>\n","excerpt":"","more":"<h2 id=\"无状态的-HTTP-协议\"><a href=\"#无状态的-HTTP-协议\" class=\"headerlink\" title=\"无状态的 HTTP 协议\"></a>无状态的 HTTP 协议</h2><p>还记得每当入门一门 Web 端语言的进行服务器端开发的时候，仅次于「Hello World」的 demo 就是「登录功能」了。实现登录功能很简单，验证客户端发送过来的账户和密码，如果通过验证就把用户塞进 session 中，然后在后续的访问中，只需检测 session 是否有这个用户就能知道用户是否登录了。Session 的中文翻译为：「会话」，只属于某一个客户端和某一个服务器端沟通的工具。但，计算机网络老师又说了，HTTP 协议是无状态的，怎么能记录用户的登录状态呢？<br>鉴于 HTTP 是无状态协议，之前已认证成功的用户状态是无法通过协议层面保存下来的，既，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他和其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。</p>\n<h2 id=\"利用-Cookie-管理-Session\"><a href=\"#利用-Cookie-管理-Session\" class=\"headerlink\" title=\"利用 Cookie 管理 Session\"></a>利用 Cookie 管理 Session</h2><p><img src=\"/image/blog/79702-5660ac4cb51f6257.jpg\" alt=\"Session 管理及 Cookie 状态管理\"></p>\n<ul>\n<li><p>步骤 1：客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。</p>\n</li>\n<li><p>步骤 2：服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份验证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID。</p>\n</li>\n<li><p>步骤 3：客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</p>\n</li>\n</ul>\n<h2 id=\"为-Cookie-服务的-HTTP-首部字段\"><a href=\"#为-Cookie-服务的-HTTP-首部字段\" class=\"headerlink\" title=\"为 Cookie 服务的 HTTP 首部字段\"></a>为 Cookie 服务的 HTTP 首部字段</h2><blockquote>\n<ul>\n<li>Set-Cookie</li>\n<li>Cookie</li>\n</ul>\n</blockquote>\n<h4 id=\"Set-Cookie\"><a href=\"#Set-Cookie\" class=\"headerlink\" title=\"Set-Cookie\"></a>Set-Cookie</h4><p>服务器管理状态使用到的字段，用于响应首部<br>一则响应首部的 Set-Cookie 字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Set-Cookie: status=enable; expires= Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;</div></pre></td></tr></table></figure></p>\n<p>Set-Cookie 字段的属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NAME=VALUE</td>\n<td>赋予 Cookie 的名称和其值（必须项）</td>\n</tr>\n<tr>\n<td>expires=DATE</td>\n<td>Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td>\n</tr>\n<tr>\n<td>path=PATH</td>\n<td>将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的目录）</td>\n</tr>\n<tr>\n<td>domain=域名</td>\n<td>作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）</td>\n</tr>\n<tr>\n<td>Secure</td>\n<td>仅在 HTTPS 安全通信时才会发送 Cookie</td>\n</tr>\n<tr>\n<td>HttpOnly</td>\n<td>加以限制，使 Cookie 不能被 Javascript 脚本访问</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p>\n"},{"title":"iframe-在IE下透明背景","date":"2013-08-07T05:05:02.000Z","_content":"\niframe 在其他主流浏览器下，默认背景是透明的。但是在IE下要通过设置iframe属性来实现背景透明化。\n代码如下：\n\n```HTML\nframeborder   //边框属性\nallowtransparency  //透明背景属性\nscrolling  //滚动条属性\n\n<iframe frameborder=\"no\" allowtransparency=\"true\" scrolling=\"no\" src=\"text-test1.html\"></iframe>    \n\n```\n","source":"_posts/iframe-在IE下透明背景.md","raw":"---\ntitle: iframe-在IE下透明背景\ncategory: 搬砖码农\ndate: 2013-08-07 13:05:02\ntags:\n- 前端\n---\n\niframe 在其他主流浏览器下，默认背景是透明的。但是在IE下要通过设置iframe属性来实现背景透明化。\n代码如下：\n\n```HTML\nframeborder   //边框属性\nallowtransparency  //透明背景属性\nscrolling  //滚动条属性\n\n<iframe frameborder=\"no\" allowtransparency=\"true\" scrolling=\"no\" src=\"text-test1.html\"></iframe>    \n\n```\n","slug":"iframe-在IE下透明背景","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwpk000p15hlf6h0ez8g","content":"<p>iframe 在其他主流浏览器下，默认背景是透明的。但是在IE下要通过设置iframe属性来实现背景透明化。<br>代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">frameborder   //边框属性</div><div class=\"line\">allowtransparency  //透明背景属性</div><div class=\"line\">scrolling  //滚动条属性</div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">allowtransparency</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">scrolling</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"text-test1.html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>iframe 在其他主流浏览器下，默认背景是透明的。但是在IE下要通过设置iframe属性来实现背景透明化。<br>代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">frameborder   //边框属性</div><div class=\"line\">allowtransparency  //透明背景属性</div><div class=\"line\">scrolling  //滚动条属性</div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">allowtransparency</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">scrolling</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"text-test1.html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></div></pre></td></tr></table></figure>\n"},{"title":"你知道「编译」与「解释」的区别吗？","date":"2016-11-19T16:03:00.000Z","_content":"\n最近在看一些编译过程的知识点，看的比较多的是英文文献。\n在这之间经常遇到的两个单词让我着实迷惑：Compiler, Interpreter\n中文翻译分别是：编译器，解释器。\n\n如果有人问我们「你知道什么是编译器么？」，\n我们很有可能首先蔑视一下这个人，然后说：「知道啊，不就编译编程语言的程序嘛！」\n要是别人再追问一句「那你知道解释器么？」，\n这时候很有可能也会说「知道啊。」，但是很难再带有蔑视的语气了。\n要是再问一句「那么编译器和解释器的区别是什么啊？」，\n「呃......」\n\n那么到底什么是「编译器」，什么是「解释器」？\n虽然对于两个词，我们很「耳熟」，但是「能详」么？\n似乎我们并没有认真对待这两个词汇。\n\n# 什么是编译器\n摘自 [Wiki Compiler](https://www.wikiwand.com/en/Compiler) 一段\n>A compiler is a computer program (or a set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language), with the latter often having a binary form known as object code. The most common reason for converting source code is to create an executable program.\n\n大概意思：\n> 编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码(object code)。这个转换的过程通常的目的是生成可执行的程序。\n\n编译器的产出是「另外一种代码」，然后这些代码等着被别人拿来执行，如果还不能直接被执行，那么还需要再编译或解释一遍，再交由计算机硬件执行。\n编译器，往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。\n\n# 什么是解释器\n摘自 [Wiki Interpreter](#) 一段\n> In computer science, an interpreter is a computer program that directly executes, i.e. performs, instructions written in a programming or scripting language, without previously compiling them into a machine language program. An interpreter generally uses one of the following strategies for program execution:\n1. parse the source code and perform its behavior directly.\n2. translate source code into some efficient intermediate representation and immediately execute this.\n3. explicitly execute stored precompiled code made by a compiler which is part of the interpreter system.\n\n大概意思：\n> 在计算机科学中，解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码**预编译**成机器码。一个解释器，通常会用以下的姿势来执行程序代码：\n1. 分析源代码，并且直接执行。\n2. 把源代码翻译成相对更加高效率的中间码，然后立即执行它。\n3. 执行由解释器内部的编译器预编译后保存的代码\n\n可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。\n不同类型的解释器，黑盒子里面的构造不一样，有些还会集成编译器，缓存编译结果，用来提高执行效率（例如 Chrome V8 也是这么做的）。\n解释器通常是工作在「运行时」，并且对于我们输入的源码，是一行一行的解释然后执行，然后返回结果。\n\n# 分两个维度比较一下\n\n## 表现 Behavior \n* **编译器**把源代码转换成其他的更低级的代码(例如二进制码、机器码)，但是不会执行它。\n* **解释器**会读取源代码，并且直接生成指令让计算机硬件执行，不会输出另外一种代码。\n  \n## 性能 Performance\n* **编译器**会事先用比较多的时间把整个程序的源代码编译成另外一种代码，后者往往较前者更加接近机器码，所以执行的效率会更加高。时间是消耗在预编译的过程中。\n* **解释器**会一行一行的读取源代码，解释，然后立即执行。这中间往往使用相对简单的词法分析、语法分析，压缩解释的时间，最后生成机器码，交由硬件执行。解释器适合比较低级的语言。但是相对于预编译好的代码，效率往往会更低。如何减少解释的次数和复杂性，是提高解释器效率的难题。\n\n# 关于代码，需要知道的几个概念\n\n在看了不少不多关于「编译和解释」的文章之后，我发现下面的词汇是大量出现的。\n知道这些词汇代表的意思，以及对应的层次，能够更好地看懂别人所要表达的意思。\n\n## 高级语言代码 High-Level Code\n高级语言代码，自然是指由高级编程语言编写代码，对计算机的细节有更高层次的抽象。\n相对于低级编程语言（low-level programming language）更接近自然语言（人类的语言）。\n集成一系列的自动工具（垃圾回收，内存管理等），会让程序员延长寿命，更快乐的编写出更简洁，更易读的程序代码。\n\n## 低级语言代码 Low-Level Code \n低级语言代码，指由低级编程语言编写的代码，相对高级语言，少了更多的抽象概念，更加接近于汇编或者机器指令。\n但是这也意味着代码的可移植性很差。\n\n在我看来，高与低，只是一组相对词而已。\n越高级的语言，性能、自由度越不及低级语言。\n但是在抽象、可读可写性、可移植性越比低级语言优秀。\n在以前的年代，C/C++语言相对汇编语言，机器指令来说，肯定是高级语言。\n而到了今天，我们更多人对C语言偏向认知为「低级语言」。\n或许未来世界的开发者，看我们现在所熟悉的Java、PHP、Python、ECMAScript等等，都是「low」到爆的语言。\n\n## 汇编语言 Assembly Language\n汇编语言作为一门低级语言，对应于计算机或者其他可编程的硬件。\n它和计算机的体系结构以及机器指令是强关联的。\n换句话说，就是不同的汇编语言代码对应特定的硬件，所以不用谈可移植性了。\n相对于需要编译和解释的高级语言代码来说，汇编代码只需要翻译成机器码就可以执行了。\n所以汇编语言也往往被称作象征性机器码(symbolic machine code)\n\n## 字节码 Byte Code \n字节码严格来说不算是编程语言，而是高级编程语言为了种种需求（可移植性、可传输性、预编译等）而产生的中间码（Intermediate Code）。\n它是由一堆指令集组成的代码，例如在`javac`编译过后的java源码产生的就是字节码。\n源码在编译的过程中，是需要进行「词法分析 → 语法分析 → 生成目标代码」等过程的，在预编译的过程中，就完成这部分工作，生成字节码。\n然后在后面交由解释器（这里通常指编程语言的虚拟机）解释执行，省去前面预编译的开销。\n\n## 机器码 Machine Code\n机器码是一组可以直接被CPU执行的指令集，\n每一条指令都代表一个特定的任务，或者是加载，或者是跳转，亦或是计算操作等等。\n所有可以直接被CPU执行的程序，都是由这么一系列的指令组成的。\n机器码可是看作是编译过程中，最低级的代码，因外再往下就是交由硬件来执行了。\n当然机器码也是可以被编辑的，但是以人类难以看懂的姿势存在，可读性非常差。\n\n# 从熟悉的编程语言的角度来看看\n\n![从熟悉的编程语言的角度来看](/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif)\n\n从左往右看，\n1. 以 Java 为例，我们在文本编译器写好了 Java 代码，交由「编译器」编译成 Java Bytecode。然后 Bytecode 交由 JVM 来执行，这时候 JVM 充当了「解释器」的角色，在解释 Bytecode 成 Machine Code 的同时执行它，返回结果。\n2. 以 [BASIC](https://www.wikiwand.com/zh/BASIC) 语言（早期的可以由计算机直译的语言） 为例，通过文本编译器编写好，不用经历「编译」的过程，就可以直接交由操作系统内部来进行「解释」然后执行。\n3. 以 C 语言为例，我们在文本编译器编写好源代码，然后运行 `gcc hello.c` 编译出 `hello.out` 文件，该文件由一系列的机器指令组成的机器码，可以直接交由硬件来执行。\n\n# 抽象看本质：人与计算机之间的鸿沟\n无论是最近在看《暗时间》的作者刘未鹏，还是前一段时间听《以产品思维写文章》讲座的阿禅，还是其他的很多聪明的人。\n他们都强调「抽象看本质」的能力，能从事物本身抽象出共通属性，看待本质。\n这也是很多人所说的「跳出这个框框再看」的思维方式。\n\n无论是「编译 Compile」还是「解释 Interpret」。\n本质还是**「人与计算机的交流形式」**，人的语言最终转换成机器语言。\n一句 「Hello World」，经过一些列的「编译」和「解释」，最终转换成一系列包含机器指令的那些0和1，机器傻傻执行完之后，告诉你结果。\n\n就这么一个过程，我们就需要很多的翻译官。\n有些翻译官可以做到同声传译（解释），有些翻译官却只能把我们的意图记下来再全部翻译（编译）给计算机。\n而往往一个翻译官能力有限，也只能把你的语言，翻译成另外一种低级点的语言，再由另外懂这个语言的翻译官来翻译更接近计算机能读得懂的语言。\n\n![人类和计算机的鸿沟.png](/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B531CE953267440FAA32A1DA644BFD68.png)\n\n# 一句话描述「编译」与「解释」？\n不如这张图来得直接：\n\n![一句话描述编译与解释](/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B415AA74BF5438CCEB2FEAEDD002B1BD.jpg)\n\n**编译 Compile**：把整个程序源代码翻译成另外一种代码，然后等待被执行，发生在运行之前，产物是「另一份代码」。\n**解释 Interpret**：把程序源代码一行一行的读懂然后执行，发生在运行时，产物是「运行结果」。\n\n# 参考\nhttp://stackoverflow.com/questions/2377273/how-does-an-interpreter-compiler-work\nhttps://www.wikiwand.com/en/Interpreter_(computing)\nhttps://www.wikiwand.com/en/Compiler\nhttps://www.wikiwand.com/en/Machine_code\nhttps://www.wikiwand.com/en/High-level_programming_language\nhttps://www.wikiwand.com/en/Low-level_programming_language\nhttps://www.wikiwand.com/en/Bytecode\n\n","source":"_posts/do-you-konw-the-different-between-compiler-and-interpreter.md","raw":"---\ntitle: 你知道「编译」与「解释」的区别吗？\ndate: 2016-11-20 00:03:00\ntags:\n- 编译\n- 解释\ncategory: 搬砖码农\n---\n\n最近在看一些编译过程的知识点，看的比较多的是英文文献。\n在这之间经常遇到的两个单词让我着实迷惑：Compiler, Interpreter\n中文翻译分别是：编译器，解释器。\n\n如果有人问我们「你知道什么是编译器么？」，\n我们很有可能首先蔑视一下这个人，然后说：「知道啊，不就编译编程语言的程序嘛！」\n要是别人再追问一句「那你知道解释器么？」，\n这时候很有可能也会说「知道啊。」，但是很难再带有蔑视的语气了。\n要是再问一句「那么编译器和解释器的区别是什么啊？」，\n「呃......」\n\n那么到底什么是「编译器」，什么是「解释器」？\n虽然对于两个词，我们很「耳熟」，但是「能详」么？\n似乎我们并没有认真对待这两个词汇。\n\n# 什么是编译器\n摘自 [Wiki Compiler](https://www.wikiwand.com/en/Compiler) 一段\n>A compiler is a computer program (or a set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language), with the latter often having a binary form known as object code. The most common reason for converting source code is to create an executable program.\n\n大概意思：\n> 编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码(object code)。这个转换的过程通常的目的是生成可执行的程序。\n\n编译器的产出是「另外一种代码」，然后这些代码等着被别人拿来执行，如果还不能直接被执行，那么还需要再编译或解释一遍，再交由计算机硬件执行。\n编译器，往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。\n\n# 什么是解释器\n摘自 [Wiki Interpreter](#) 一段\n> In computer science, an interpreter is a computer program that directly executes, i.e. performs, instructions written in a programming or scripting language, without previously compiling them into a machine language program. An interpreter generally uses one of the following strategies for program execution:\n1. parse the source code and perform its behavior directly.\n2. translate source code into some efficient intermediate representation and immediately execute this.\n3. explicitly execute stored precompiled code made by a compiler which is part of the interpreter system.\n\n大概意思：\n> 在计算机科学中，解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码**预编译**成机器码。一个解释器，通常会用以下的姿势来执行程序代码：\n1. 分析源代码，并且直接执行。\n2. 把源代码翻译成相对更加高效率的中间码，然后立即执行它。\n3. 执行由解释器内部的编译器预编译后保存的代码\n\n可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。\n不同类型的解释器，黑盒子里面的构造不一样，有些还会集成编译器，缓存编译结果，用来提高执行效率（例如 Chrome V8 也是这么做的）。\n解释器通常是工作在「运行时」，并且对于我们输入的源码，是一行一行的解释然后执行，然后返回结果。\n\n# 分两个维度比较一下\n\n## 表现 Behavior \n* **编译器**把源代码转换成其他的更低级的代码(例如二进制码、机器码)，但是不会执行它。\n* **解释器**会读取源代码，并且直接生成指令让计算机硬件执行，不会输出另外一种代码。\n  \n## 性能 Performance\n* **编译器**会事先用比较多的时间把整个程序的源代码编译成另外一种代码，后者往往较前者更加接近机器码，所以执行的效率会更加高。时间是消耗在预编译的过程中。\n* **解释器**会一行一行的读取源代码，解释，然后立即执行。这中间往往使用相对简单的词法分析、语法分析，压缩解释的时间，最后生成机器码，交由硬件执行。解释器适合比较低级的语言。但是相对于预编译好的代码，效率往往会更低。如何减少解释的次数和复杂性，是提高解释器效率的难题。\n\n# 关于代码，需要知道的几个概念\n\n在看了不少不多关于「编译和解释」的文章之后，我发现下面的词汇是大量出现的。\n知道这些词汇代表的意思，以及对应的层次，能够更好地看懂别人所要表达的意思。\n\n## 高级语言代码 High-Level Code\n高级语言代码，自然是指由高级编程语言编写代码，对计算机的细节有更高层次的抽象。\n相对于低级编程语言（low-level programming language）更接近自然语言（人类的语言）。\n集成一系列的自动工具（垃圾回收，内存管理等），会让程序员延长寿命，更快乐的编写出更简洁，更易读的程序代码。\n\n## 低级语言代码 Low-Level Code \n低级语言代码，指由低级编程语言编写的代码，相对高级语言，少了更多的抽象概念，更加接近于汇编或者机器指令。\n但是这也意味着代码的可移植性很差。\n\n在我看来，高与低，只是一组相对词而已。\n越高级的语言，性能、自由度越不及低级语言。\n但是在抽象、可读可写性、可移植性越比低级语言优秀。\n在以前的年代，C/C++语言相对汇编语言，机器指令来说，肯定是高级语言。\n而到了今天，我们更多人对C语言偏向认知为「低级语言」。\n或许未来世界的开发者，看我们现在所熟悉的Java、PHP、Python、ECMAScript等等，都是「low」到爆的语言。\n\n## 汇编语言 Assembly Language\n汇编语言作为一门低级语言，对应于计算机或者其他可编程的硬件。\n它和计算机的体系结构以及机器指令是强关联的。\n换句话说，就是不同的汇编语言代码对应特定的硬件，所以不用谈可移植性了。\n相对于需要编译和解释的高级语言代码来说，汇编代码只需要翻译成机器码就可以执行了。\n所以汇编语言也往往被称作象征性机器码(symbolic machine code)\n\n## 字节码 Byte Code \n字节码严格来说不算是编程语言，而是高级编程语言为了种种需求（可移植性、可传输性、预编译等）而产生的中间码（Intermediate Code）。\n它是由一堆指令集组成的代码，例如在`javac`编译过后的java源码产生的就是字节码。\n源码在编译的过程中，是需要进行「词法分析 → 语法分析 → 生成目标代码」等过程的，在预编译的过程中，就完成这部分工作，生成字节码。\n然后在后面交由解释器（这里通常指编程语言的虚拟机）解释执行，省去前面预编译的开销。\n\n## 机器码 Machine Code\n机器码是一组可以直接被CPU执行的指令集，\n每一条指令都代表一个特定的任务，或者是加载，或者是跳转，亦或是计算操作等等。\n所有可以直接被CPU执行的程序，都是由这么一系列的指令组成的。\n机器码可是看作是编译过程中，最低级的代码，因外再往下就是交由硬件来执行了。\n当然机器码也是可以被编辑的，但是以人类难以看懂的姿势存在，可读性非常差。\n\n# 从熟悉的编程语言的角度来看看\n\n![从熟悉的编程语言的角度来看](/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif)\n\n从左往右看，\n1. 以 Java 为例，我们在文本编译器写好了 Java 代码，交由「编译器」编译成 Java Bytecode。然后 Bytecode 交由 JVM 来执行，这时候 JVM 充当了「解释器」的角色，在解释 Bytecode 成 Machine Code 的同时执行它，返回结果。\n2. 以 [BASIC](https://www.wikiwand.com/zh/BASIC) 语言（早期的可以由计算机直译的语言） 为例，通过文本编译器编写好，不用经历「编译」的过程，就可以直接交由操作系统内部来进行「解释」然后执行。\n3. 以 C 语言为例，我们在文本编译器编写好源代码，然后运行 `gcc hello.c` 编译出 `hello.out` 文件，该文件由一系列的机器指令组成的机器码，可以直接交由硬件来执行。\n\n# 抽象看本质：人与计算机之间的鸿沟\n无论是最近在看《暗时间》的作者刘未鹏，还是前一段时间听《以产品思维写文章》讲座的阿禅，还是其他的很多聪明的人。\n他们都强调「抽象看本质」的能力，能从事物本身抽象出共通属性，看待本质。\n这也是很多人所说的「跳出这个框框再看」的思维方式。\n\n无论是「编译 Compile」还是「解释 Interpret」。\n本质还是**「人与计算机的交流形式」**，人的语言最终转换成机器语言。\n一句 「Hello World」，经过一些列的「编译」和「解释」，最终转换成一系列包含机器指令的那些0和1，机器傻傻执行完之后，告诉你结果。\n\n就这么一个过程，我们就需要很多的翻译官。\n有些翻译官可以做到同声传译（解释），有些翻译官却只能把我们的意图记下来再全部翻译（编译）给计算机。\n而往往一个翻译官能力有限，也只能把你的语言，翻译成另外一种低级点的语言，再由另外懂这个语言的翻译官来翻译更接近计算机能读得懂的语言。\n\n![人类和计算机的鸿沟.png](/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B531CE953267440FAA32A1DA644BFD68.png)\n\n# 一句话描述「编译」与「解释」？\n不如这张图来得直接：\n\n![一句话描述编译与解释](/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B415AA74BF5438CCEB2FEAEDD002B1BD.jpg)\n\n**编译 Compile**：把整个程序源代码翻译成另外一种代码，然后等待被执行，发生在运行之前，产物是「另一份代码」。\n**解释 Interpret**：把程序源代码一行一行的读懂然后执行，发生在运行时，产物是「运行结果」。\n\n# 参考\nhttp://stackoverflow.com/questions/2377273/how-does-an-interpreter-compiler-work\nhttps://www.wikiwand.com/en/Interpreter_(computing)\nhttps://www.wikiwand.com/en/Compiler\nhttps://www.wikiwand.com/en/Machine_code\nhttps://www.wikiwand.com/en/High-level_programming_language\nhttps://www.wikiwand.com/en/Low-level_programming_language\nhttps://www.wikiwand.com/en/Bytecode\n\n","slug":"do-you-konw-the-different-between-compiler-and-interpreter","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwpn000r15hl5c4qi0vu","content":"<p>最近在看一些编译过程的知识点，看的比较多的是英文文献。<br>在这之间经常遇到的两个单词让我着实迷惑：Compiler, Interpreter<br>中文翻译分别是：编译器，解释器。</p>\n<p>如果有人问我们「你知道什么是编译器么？」，<br>我们很有可能首先蔑视一下这个人，然后说：「知道啊，不就编译编程语言的程序嘛！」<br>要是别人再追问一句「那你知道解释器么？」，<br>这时候很有可能也会说「知道啊。」，但是很难再带有蔑视的语气了。<br>要是再问一句「那么编译器和解释器的区别是什么啊？」，<br>「呃……」</p>\n<p>那么到底什么是「编译器」，什么是「解释器」？<br>虽然对于两个词，我们很「耳熟」，但是「能详」么？<br>似乎我们并没有认真对待这两个词汇。</p>\n<h1 id=\"什么是编译器\"><a href=\"#什么是编译器\" class=\"headerlink\" title=\"什么是编译器\"></a>什么是编译器</h1><p>摘自 <a href=\"https://www.wikiwand.com/en/Compiler\" target=\"_blank\" rel=\"external\">Wiki Compiler</a> 一段</p>\n<blockquote>\n<p>A compiler is a computer program (or a set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language), with the latter often having a binary form known as object code. The most common reason for converting source code is to create an executable program.</p>\n</blockquote>\n<p>大概意思：</p>\n<blockquote>\n<p>编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码(object code)。这个转换的过程通常的目的是生成可执行的程序。</p>\n</blockquote>\n<p>编译器的产出是「另外一种代码」，然后这些代码等着被别人拿来执行，如果还不能直接被执行，那么还需要再编译或解释一遍，再交由计算机硬件执行。<br>编译器，往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。</p>\n<h1 id=\"什么是解释器\"><a href=\"#什么是解释器\" class=\"headerlink\" title=\"什么是解释器\"></a>什么是解释器</h1><p>摘自 <a href=\"#\">Wiki Interpreter</a> 一段</p>\n<blockquote>\n<p>In computer science, an interpreter is a computer program that directly executes, i.e. performs, instructions written in a programming or scripting language, without previously compiling them into a machine language program. An interpreter generally uses one of the following strategies for program execution:</p>\n<ol>\n<li>parse the source code and perform its behavior directly.</li>\n<li>translate source code into some efficient intermediate representation and immediately execute this.</li>\n<li>explicitly execute stored precompiled code made by a compiler which is part of the interpreter system.</li>\n</ol>\n</blockquote>\n<p>大概意思：</p>\n<blockquote>\n<p>在计算机科学中，解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码<strong>预编译</strong>成机器码。一个解释器，通常会用以下的姿势来执行程序代码：</p>\n<ol>\n<li>分析源代码，并且直接执行。</li>\n<li>把源代码翻译成相对更加高效率的中间码，然后立即执行它。</li>\n<li>执行由解释器内部的编译器预编译后保存的代码</li>\n</ol>\n</blockquote>\n<p>可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。<br>不同类型的解释器，黑盒子里面的构造不一样，有些还会集成编译器，缓存编译结果，用来提高执行效率（例如 Chrome V8 也是这么做的）。<br>解释器通常是工作在「运行时」，并且对于我们输入的源码，是一行一行的解释然后执行，然后返回结果。</p>\n<h1 id=\"分两个维度比较一下\"><a href=\"#分两个维度比较一下\" class=\"headerlink\" title=\"分两个维度比较一下\"></a>分两个维度比较一下</h1><h2 id=\"表现-Behavior\"><a href=\"#表现-Behavior\" class=\"headerlink\" title=\"表现 Behavior\"></a>表现 Behavior</h2><ul>\n<li><strong>编译器</strong>把源代码转换成其他的更低级的代码(例如二进制码、机器码)，但是不会执行它。</li>\n<li><strong>解释器</strong>会读取源代码，并且直接生成指令让计算机硬件执行，不会输出另外一种代码。</li>\n</ul>\n<h2 id=\"性能-Performance\"><a href=\"#性能-Performance\" class=\"headerlink\" title=\"性能 Performance\"></a>性能 Performance</h2><ul>\n<li><strong>编译器</strong>会事先用比较多的时间把整个程序的源代码编译成另外一种代码，后者往往较前者更加接近机器码，所以执行的效率会更加高。时间是消耗在预编译的过程中。</li>\n<li><strong>解释器</strong>会一行一行的读取源代码，解释，然后立即执行。这中间往往使用相对简单的词法分析、语法分析，压缩解释的时间，最后生成机器码，交由硬件执行。解释器适合比较低级的语言。但是相对于预编译好的代码，效率往往会更低。如何减少解释的次数和复杂性，是提高解释器效率的难题。</li>\n</ul>\n<h1 id=\"关于代码，需要知道的几个概念\"><a href=\"#关于代码，需要知道的几个概念\" class=\"headerlink\" title=\"关于代码，需要知道的几个概念\"></a>关于代码，需要知道的几个概念</h1><p>在看了不少不多关于「编译和解释」的文章之后，我发现下面的词汇是大量出现的。<br>知道这些词汇代表的意思，以及对应的层次，能够更好地看懂别人所要表达的意思。</p>\n<h2 id=\"高级语言代码-High-Level-Code\"><a href=\"#高级语言代码-High-Level-Code\" class=\"headerlink\" title=\"高级语言代码 High-Level Code\"></a>高级语言代码 High-Level Code</h2><p>高级语言代码，自然是指由高级编程语言编写代码，对计算机的细节有更高层次的抽象。<br>相对于低级编程语言（low-level programming language）更接近自然语言（人类的语言）。<br>集成一系列的自动工具（垃圾回收，内存管理等），会让程序员延长寿命，更快乐的编写出更简洁，更易读的程序代码。</p>\n<h2 id=\"低级语言代码-Low-Level-Code\"><a href=\"#低级语言代码-Low-Level-Code\" class=\"headerlink\" title=\"低级语言代码 Low-Level Code\"></a>低级语言代码 Low-Level Code</h2><p>低级语言代码，指由低级编程语言编写的代码，相对高级语言，少了更多的抽象概念，更加接近于汇编或者机器指令。<br>但是这也意味着代码的可移植性很差。</p>\n<p>在我看来，高与低，只是一组相对词而已。<br>越高级的语言，性能、自由度越不及低级语言。<br>但是在抽象、可读可写性、可移植性越比低级语言优秀。<br>在以前的年代，C/C++语言相对汇编语言，机器指令来说，肯定是高级语言。<br>而到了今天，我们更多人对C语言偏向认知为「低级语言」。<br>或许未来世界的开发者，看我们现在所熟悉的Java、PHP、Python、ECMAScript等等，都是「low」到爆的语言。</p>\n<h2 id=\"汇编语言-Assembly-Language\"><a href=\"#汇编语言-Assembly-Language\" class=\"headerlink\" title=\"汇编语言 Assembly Language\"></a>汇编语言 Assembly Language</h2><p>汇编语言作为一门低级语言，对应于计算机或者其他可编程的硬件。<br>它和计算机的体系结构以及机器指令是强关联的。<br>换句话说，就是不同的汇编语言代码对应特定的硬件，所以不用谈可移植性了。<br>相对于需要编译和解释的高级语言代码来说，汇编代码只需要翻译成机器码就可以执行了。<br>所以汇编语言也往往被称作象征性机器码(symbolic machine code)</p>\n<h2 id=\"字节码-Byte-Code\"><a href=\"#字节码-Byte-Code\" class=\"headerlink\" title=\"字节码 Byte Code\"></a>字节码 Byte Code</h2><p>字节码严格来说不算是编程语言，而是高级编程语言为了种种需求（可移植性、可传输性、预编译等）而产生的中间码（Intermediate Code）。<br>它是由一堆指令集组成的代码，例如在<code>javac</code>编译过后的java源码产生的就是字节码。<br>源码在编译的过程中，是需要进行「词法分析 → 语法分析 → 生成目标代码」等过程的，在预编译的过程中，就完成这部分工作，生成字节码。<br>然后在后面交由解释器（这里通常指编程语言的虚拟机）解释执行，省去前面预编译的开销。</p>\n<h2 id=\"机器码-Machine-Code\"><a href=\"#机器码-Machine-Code\" class=\"headerlink\" title=\"机器码 Machine Code\"></a>机器码 Machine Code</h2><p>机器码是一组可以直接被CPU执行的指令集，<br>每一条指令都代表一个特定的任务，或者是加载，或者是跳转，亦或是计算操作等等。<br>所有可以直接被CPU执行的程序，都是由这么一系列的指令组成的。<br>机器码可是看作是编译过程中，最低级的代码，因外再往下就是交由硬件来执行了。<br>当然机器码也是可以被编辑的，但是以人类难以看懂的姿势存在，可读性非常差。</p>\n<h1 id=\"从熟悉的编程语言的角度来看看\"><a href=\"#从熟悉的编程语言的角度来看看\" class=\"headerlink\" title=\"从熟悉的编程语言的角度来看看\"></a>从熟悉的编程语言的角度来看看</h1><p><img src=\"/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif\" alt=\"从熟悉的编程语言的角度来看\"></p>\n<p>从左往右看，</p>\n<ol>\n<li>以 Java 为例，我们在文本编译器写好了 Java 代码，交由「编译器」编译成 Java Bytecode。然后 Bytecode 交由 JVM 来执行，这时候 JVM 充当了「解释器」的角色，在解释 Bytecode 成 Machine Code 的同时执行它，返回结果。</li>\n<li>以 <a href=\"https://www.wikiwand.com/zh/BASIC\" target=\"_blank\" rel=\"external\">BASIC</a> 语言（早期的可以由计算机直译的语言） 为例，通过文本编译器编写好，不用经历「编译」的过程，就可以直接交由操作系统内部来进行「解释」然后执行。</li>\n<li>以 C 语言为例，我们在文本编译器编写好源代码，然后运行 <code>gcc hello.c</code> 编译出 <code>hello.out</code> 文件，该文件由一系列的机器指令组成的机器码，可以直接交由硬件来执行。</li>\n</ol>\n<h1 id=\"抽象看本质：人与计算机之间的鸿沟\"><a href=\"#抽象看本质：人与计算机之间的鸿沟\" class=\"headerlink\" title=\"抽象看本质：人与计算机之间的鸿沟\"></a>抽象看本质：人与计算机之间的鸿沟</h1><p>无论是最近在看《暗时间》的作者刘未鹏，还是前一段时间听《以产品思维写文章》讲座的阿禅，还是其他的很多聪明的人。<br>他们都强调「抽象看本质」的能力，能从事物本身抽象出共通属性，看待本质。<br>这也是很多人所说的「跳出这个框框再看」的思维方式。</p>\n<p>无论是「编译 Compile」还是「解释 Interpret」。<br>本质还是<strong>「人与计算机的交流形式」</strong>，人的语言最终转换成机器语言。<br>一句 「Hello World」，经过一些列的「编译」和「解释」，最终转换成一系列包含机器指令的那些0和1，机器傻傻执行完之后，告诉你结果。</p>\n<p>就这么一个过程，我们就需要很多的翻译官。<br>有些翻译官可以做到同声传译（解释），有些翻译官却只能把我们的意图记下来再全部翻译（编译）给计算机。<br>而往往一个翻译官能力有限，也只能把你的语言，翻译成另外一种低级点的语言，再由另外懂这个语言的翻译官来翻译更接近计算机能读得懂的语言。</p>\n<p><img src=\"/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B531CE953267440FAA32A1DA644BFD68.png\" alt=\"人类和计算机的鸿沟.png\"></p>\n<h1 id=\"一句话描述「编译」与「解释」？\"><a href=\"#一句话描述「编译」与「解释」？\" class=\"headerlink\" title=\"一句话描述「编译」与「解释」？\"></a>一句话描述「编译」与「解释」？</h1><p>不如这张图来得直接：</p>\n<p><img src=\"/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B415AA74BF5438CCEB2FEAEDD002B1BD.jpg\" alt=\"一句话描述编译与解释\"></p>\n<p><strong>编译 Compile</strong>：把整个程序源代码翻译成另外一种代码，然后等待被执行，发生在运行之前，产物是「另一份代码」。<br><strong>解释 Interpret</strong>：把程序源代码一行一行的读懂然后执行，发生在运行时，产物是「运行结果」。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://stackoverflow.com/questions/2377273/how-does-an-interpreter-compiler-work\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/2377273/how-does-an-interpreter-compiler-work</a><br><a href=\"https://www.wikiwand.com/en/Interpreter_(computing\" target=\"_blank\" rel=\"external\">https://www.wikiwand.com/en/Interpreter_(computing</a>)<br><a href=\"https://www.wikiwand.com/en/Compiler\" target=\"_blank\" rel=\"external\">https://www.wikiwand.com/en/Compiler</a><br><a href=\"https://www.wikiwand.com/en/Machine_code\" target=\"_blank\" rel=\"external\">https://www.wikiwand.com/en/Machine_code</a><br><a href=\"https://www.wikiwand.com/en/High-level_programming_language\" target=\"_blank\" rel=\"external\">https://www.wikiwand.com/en/High-level_programming_language</a><br><a href=\"https://www.wikiwand.com/en/Low-level_programming_language\" target=\"_blank\" rel=\"external\">https://www.wikiwand.com/en/Low-level_programming_language</a><br><a href=\"https://www.wikiwand.com/en/Bytecode\" target=\"_blank\" rel=\"external\">https://www.wikiwand.com/en/Bytecode</a></p>\n","excerpt":"","more":"<p>最近在看一些编译过程的知识点，看的比较多的是英文文献。<br>在这之间经常遇到的两个单词让我着实迷惑：Compiler, Interpreter<br>中文翻译分别是：编译器，解释器。</p>\n<p>如果有人问我们「你知道什么是编译器么？」，<br>我们很有可能首先蔑视一下这个人，然后说：「知道啊，不就编译编程语言的程序嘛！」<br>要是别人再追问一句「那你知道解释器么？」，<br>这时候很有可能也会说「知道啊。」，但是很难再带有蔑视的语气了。<br>要是再问一句「那么编译器和解释器的区别是什么啊？」，<br>「呃……」</p>\n<p>那么到底什么是「编译器」，什么是「解释器」？<br>虽然对于两个词，我们很「耳熟」，但是「能详」么？<br>似乎我们并没有认真对待这两个词汇。</p>\n<h1 id=\"什么是编译器\"><a href=\"#什么是编译器\" class=\"headerlink\" title=\"什么是编译器\"></a>什么是编译器</h1><p>摘自 <a href=\"https://www.wikiwand.com/en/Compiler\">Wiki Compiler</a> 一段</p>\n<blockquote>\n<p>A compiler is a computer program (or a set of programs) that transforms source code written in a programming language (the source language) into another computer language (the target language), with the latter often having a binary form known as object code. The most common reason for converting source code is to create an executable program.</p>\n</blockquote>\n<p>大概意思：</p>\n<blockquote>\n<p>编译器是一种计算机程序，负责把一种编程语言编写的源码转换成另外一种计算机代码，后者往往是以二进制的形式被称为目标代码(object code)。这个转换的过程通常的目的是生成可执行的程序。</p>\n</blockquote>\n<p>编译器的产出是「另外一种代码」，然后这些代码等着被别人拿来执行，如果还不能直接被执行，那么还需要再编译或解释一遍，再交由计算机硬件执行。<br>编译器，往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。</p>\n<h1 id=\"什么是解释器\"><a href=\"#什么是解释器\" class=\"headerlink\" title=\"什么是解释器\"></a>什么是解释器</h1><p>摘自 <a href=\"#\">Wiki Interpreter</a> 一段</p>\n<blockquote>\n<p>In computer science, an interpreter is a computer program that directly executes, i.e. performs, instructions written in a programming or scripting language, without previously compiling them into a machine language program. An interpreter generally uses one of the following strategies for program execution:</p>\n<ol>\n<li>parse the source code and perform its behavior directly.</li>\n<li>translate source code into some efficient intermediate representation and immediately execute this.</li>\n<li>explicitly execute stored precompiled code made by a compiler which is part of the interpreter system.</li>\n</ol>\n</blockquote>\n<p>大概意思：</p>\n<blockquote>\n<p>在计算机科学中，解释器是一种计算机程序，它直接执行由编程语言或脚本语言编写的代码，并不会把源代码<strong>预编译</strong>成机器码。一个解释器，通常会用以下的姿势来执行程序代码：</p>\n<ol>\n<li>分析源代码，并且直接执行。</li>\n<li>把源代码翻译成相对更加高效率的中间码，然后立即执行它。</li>\n<li>执行由解释器内部的编译器预编译后保存的代码</li>\n</ol>\n</blockquote>\n<p>可以把解释器看成一个黑盒子，我们输入源码，它就会实时返回结果。<br>不同类型的解释器，黑盒子里面的构造不一样，有些还会集成编译器，缓存编译结果，用来提高执行效率（例如 Chrome V8 也是这么做的）。<br>解释器通常是工作在「运行时」，并且对于我们输入的源码，是一行一行的解释然后执行，然后返回结果。</p>\n<h1 id=\"分两个维度比较一下\"><a href=\"#分两个维度比较一下\" class=\"headerlink\" title=\"分两个维度比较一下\"></a>分两个维度比较一下</h1><h2 id=\"表现-Behavior\"><a href=\"#表现-Behavior\" class=\"headerlink\" title=\"表现 Behavior\"></a>表现 Behavior</h2><ul>\n<li><strong>编译器</strong>把源代码转换成其他的更低级的代码(例如二进制码、机器码)，但是不会执行它。</li>\n<li><strong>解释器</strong>会读取源代码，并且直接生成指令让计算机硬件执行，不会输出另外一种代码。</li>\n</ul>\n<h2 id=\"性能-Performance\"><a href=\"#性能-Performance\" class=\"headerlink\" title=\"性能 Performance\"></a>性能 Performance</h2><ul>\n<li><strong>编译器</strong>会事先用比较多的时间把整个程序的源代码编译成另外一种代码，后者往往较前者更加接近机器码，所以执行的效率会更加高。时间是消耗在预编译的过程中。</li>\n<li><strong>解释器</strong>会一行一行的读取源代码，解释，然后立即执行。这中间往往使用相对简单的词法分析、语法分析，压缩解释的时间，最后生成机器码，交由硬件执行。解释器适合比较低级的语言。但是相对于预编译好的代码，效率往往会更低。如何减少解释的次数和复杂性，是提高解释器效率的难题。</li>\n</ul>\n<h1 id=\"关于代码，需要知道的几个概念\"><a href=\"#关于代码，需要知道的几个概念\" class=\"headerlink\" title=\"关于代码，需要知道的几个概念\"></a>关于代码，需要知道的几个概念</h1><p>在看了不少不多关于「编译和解释」的文章之后，我发现下面的词汇是大量出现的。<br>知道这些词汇代表的意思，以及对应的层次，能够更好地看懂别人所要表达的意思。</p>\n<h2 id=\"高级语言代码-High-Level-Code\"><a href=\"#高级语言代码-High-Level-Code\" class=\"headerlink\" title=\"高级语言代码 High-Level Code\"></a>高级语言代码 High-Level Code</h2><p>高级语言代码，自然是指由高级编程语言编写代码，对计算机的细节有更高层次的抽象。<br>相对于低级编程语言（low-level programming language）更接近自然语言（人类的语言）。<br>集成一系列的自动工具（垃圾回收，内存管理等），会让程序员延长寿命，更快乐的编写出更简洁，更易读的程序代码。</p>\n<h2 id=\"低级语言代码-Low-Level-Code\"><a href=\"#低级语言代码-Low-Level-Code\" class=\"headerlink\" title=\"低级语言代码 Low-Level Code\"></a>低级语言代码 Low-Level Code</h2><p>低级语言代码，指由低级编程语言编写的代码，相对高级语言，少了更多的抽象概念，更加接近于汇编或者机器指令。<br>但是这也意味着代码的可移植性很差。</p>\n<p>在我看来，高与低，只是一组相对词而已。<br>越高级的语言，性能、自由度越不及低级语言。<br>但是在抽象、可读可写性、可移植性越比低级语言优秀。<br>在以前的年代，C/C++语言相对汇编语言，机器指令来说，肯定是高级语言。<br>而到了今天，我们更多人对C语言偏向认知为「低级语言」。<br>或许未来世界的开发者，看我们现在所熟悉的Java、PHP、Python、ECMAScript等等，都是「low」到爆的语言。</p>\n<h2 id=\"汇编语言-Assembly-Language\"><a href=\"#汇编语言-Assembly-Language\" class=\"headerlink\" title=\"汇编语言 Assembly Language\"></a>汇编语言 Assembly Language</h2><p>汇编语言作为一门低级语言，对应于计算机或者其他可编程的硬件。<br>它和计算机的体系结构以及机器指令是强关联的。<br>换句话说，就是不同的汇编语言代码对应特定的硬件，所以不用谈可移植性了。<br>相对于需要编译和解释的高级语言代码来说，汇编代码只需要翻译成机器码就可以执行了。<br>所以汇编语言也往往被称作象征性机器码(symbolic machine code)</p>\n<h2 id=\"字节码-Byte-Code\"><a href=\"#字节码-Byte-Code\" class=\"headerlink\" title=\"字节码 Byte Code\"></a>字节码 Byte Code</h2><p>字节码严格来说不算是编程语言，而是高级编程语言为了种种需求（可移植性、可传输性、预编译等）而产生的中间码（Intermediate Code）。<br>它是由一堆指令集组成的代码，例如在<code>javac</code>编译过后的java源码产生的就是字节码。<br>源码在编译的过程中，是需要进行「词法分析 → 语法分析 → 生成目标代码」等过程的，在预编译的过程中，就完成这部分工作，生成字节码。<br>然后在后面交由解释器（这里通常指编程语言的虚拟机）解释执行，省去前面预编译的开销。</p>\n<h2 id=\"机器码-Machine-Code\"><a href=\"#机器码-Machine-Code\" class=\"headerlink\" title=\"机器码 Machine Code\"></a>机器码 Machine Code</h2><p>机器码是一组可以直接被CPU执行的指令集，<br>每一条指令都代表一个特定的任务，或者是加载，或者是跳转，亦或是计算操作等等。<br>所有可以直接被CPU执行的程序，都是由这么一系列的指令组成的。<br>机器码可是看作是编译过程中，最低级的代码，因外再往下就是交由硬件来执行了。<br>当然机器码也是可以被编辑的，但是以人类难以看懂的姿势存在，可读性非常差。</p>\n<h1 id=\"从熟悉的编程语言的角度来看看\"><a href=\"#从熟悉的编程语言的角度来看看\" class=\"headerlink\" title=\"从熟悉的编程语言的角度来看看\"></a>从熟悉的编程语言的角度来看看</h1><p><img src=\"/image/blog/do-you-konw-the-different-between-compiler-and-interpreter/5698B76C4AAAE21598E7AB1A381B4AF9.gif\" alt=\"从熟悉的编程语言的角度来看\"></p>\n<p>从左往右看，</p>\n<ol>\n<li>以 Java 为例，我们在文本编译器写好了 Java 代码，交由「编译器」编译成 Java Bytecode。然后 Bytecode 交由 JVM 来执行，这时候 JVM 充当了「解释器」的角色，在解释 Bytecode 成 Machine Code 的同时执行它，返回结果。</li>\n<li>以 <a href=\"https://www.wikiwand.com/zh/BASIC\">BASIC</a> 语言（早期的可以由计算机直译的语言） 为例，通过文本编译器编写好，不用经历「编译」的过程，就可以直接交由操作系统内部来进行「解释」然后执行。</li>\n<li>以 C 语言为例，我们在文本编译器编写好源代码，然后运行 <code>gcc hello.c</code> 编译出 <code>hello.out</code> 文件，该文件由一系列的机器指令组成的机器码，可以直接交由硬件来执行。</li>\n</ol>\n<h1 id=\"抽象看本质：人与计算机之间的鸿沟\"><a href=\"#抽象看本质：人与计算机之间的鸿沟\" class=\"headerlink\" title=\"抽象看本质：人与计算机之间的鸿沟\"></a>抽象看本质：人与计算机之间的鸿沟</h1><p>无论是最近在看《暗时间》的作者刘未鹏，还是前一段时间听《以产品思维写文章》讲座的阿禅，还是其他的很多聪明的人。<br>他们都强调「抽象看本质」的能力，能从事物本身抽象出共通属性，看待本质。<br>这也是很多人所说的「跳出这个框框再看」的思维方式。</p>\n<p>无论是「编译 Compile」还是「解释 Interpret」。<br>本质还是<strong>「人与计算机的交流形式」</strong>，人的语言最终转换成机器语言。<br>一句 「Hello World」，经过一些列的「编译」和「解释」，最终转换成一系列包含机器指令的那些0和1，机器傻傻执行完之后，告诉你结果。</p>\n<p>就这么一个过程，我们就需要很多的翻译官。<br>有些翻译官可以做到同声传译（解释），有些翻译官却只能把我们的意图记下来再全部翻译（编译）给计算机。<br>而往往一个翻译官能力有限，也只能把你的语言，翻译成另外一种低级点的语言，再由另外懂这个语言的翻译官来翻译更接近计算机能读得懂的语言。</p>\n<p><img src=\"/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B531CE953267440FAA32A1DA644BFD68.png\" alt=\"人类和计算机的鸿沟.png\"></p>\n<h1 id=\"一句话描述「编译」与「解释」？\"><a href=\"#一句话描述「编译」与「解释」？\" class=\"headerlink\" title=\"一句话描述「编译」与「解释」？\"></a>一句话描述「编译」与「解释」？</h1><p>不如这张图来得直接：</p>\n<p><img src=\"/image/blog/do-you-konw-the-different-between-compiler-and-interpreter//B415AA74BF5438CCEB2FEAEDD002B1BD.jpg\" alt=\"一句话描述编译与解释\"></p>\n<p><strong>编译 Compile</strong>：把整个程序源代码翻译成另外一种代码，然后等待被执行，发生在运行之前，产物是「另一份代码」。<br><strong>解释 Interpret</strong>：把程序源代码一行一行的读懂然后执行，发生在运行时，产物是「运行结果」。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://stackoverflow.com/questions/2377273/how-does-an-interpreter-compiler-work\">http://stackoverflow.com/questions/2377273/how-does-an-interpreter-compiler-work</a><br><a href=\"https://www.wikiwand.com/en/Interpreter_(computing\">https://www.wikiwand.com/en/Interpreter_(computing</a>)<br><a href=\"https://www.wikiwand.com/en/Compiler\">https://www.wikiwand.com/en/Compiler</a><br><a href=\"https://www.wikiwand.com/en/Machine_code\">https://www.wikiwand.com/en/Machine_code</a><br><a href=\"https://www.wikiwand.com/en/High-level_programming_language\">https://www.wikiwand.com/en/High-level_programming_language</a><br><a href=\"https://www.wikiwand.com/en/Low-level_programming_language\">https://www.wikiwand.com/en/Low-level_programming_language</a><br><a href=\"https://www.wikiwand.com/en/Bytecode\">https://www.wikiwand.com/en/Bytecode</a></p>\n"},{"title":"jQuery动画反方向延伸","date":"2013-07-21T15:07:04.000Z","_content":"\nJquery的动画效果都是从左到右，从上到下延伸的。如果要实现反方向延伸呢？\n以下代码实现动画从右到左延伸，读者可以举一反三实现从下往上延伸的动画。\n\n**CSS**：\n```\n#bar {\n    margin-left: 100px;\n    height: 10px;\n    width: 0;\n    background: red;\n}\n```\n\n**jQuery**\n```\n$('#bar').animate({\n    marginLeft: 0,\n    width: 100\n});\n```","source":"_posts/jQuery动画反方向延伸.md","raw":"---\ntitle: jQuery动画反方向延伸\ncategory: 搬砖码农\ndate: 2013-07-21 23:07:04\ntags:\n- 前端\n---\n\nJquery的动画效果都是从左到右，从上到下延伸的。如果要实现反方向延伸呢？\n以下代码实现动画从右到左延伸，读者可以举一反三实现从下往上延伸的动画。\n\n**CSS**：\n```\n#bar {\n    margin-left: 100px;\n    height: 10px;\n    width: 0;\n    background: red;\n}\n```\n\n**jQuery**\n```\n$('#bar').animate({\n    marginLeft: 0,\n    width: 100\n});\n```","slug":"jQuery动画反方向延伸","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwpp000u15hl2ehnuttw","content":"<p>Jquery的动画效果都是从左到右，从上到下延伸的。如果要实现反方向延伸呢？<br>以下代码实现动画从右到左延伸，读者可以举一反三实现从下往上延伸的动画。</p>\n<p><strong>CSS</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#bar &#123;</div><div class=\"line\">    margin-left: 100px;</div><div class=\"line\">    height: 10px;</div><div class=\"line\">    width: 0;</div><div class=\"line\">    background: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>jQuery</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;#bar&apos;).animate(&#123;</div><div class=\"line\">    marginLeft: 0,</div><div class=\"line\">    width: 100</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>Jquery的动画效果都是从左到右，从上到下延伸的。如果要实现反方向延伸呢？<br>以下代码实现动画从右到左延伸，读者可以举一反三实现从下往上延伸的动画。</p>\n<p><strong>CSS</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#bar &#123;</div><div class=\"line\">    margin-left: 100px;</div><div class=\"line\">    height: 10px;</div><div class=\"line\">    width: 0;</div><div class=\"line\">    background: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>jQuery</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&apos;#bar&apos;).animate(&#123;</div><div class=\"line\">    marginLeft: 0,</div><div class=\"line\">    width: 100</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n"},{"title":"NodeJS中被忽略的内存","date":"2017-05-03T16:33:02.000Z","_content":"\n# The Past\n1.  [Memeye](https://github.com/JerryC8080/Memeye) 终于开源了，到目前为止已经有 153 个 star 了，但是后续没有再维护了，打算等我学完 Vue 以及对前端更加熟练之后，对前端部分进行重构，使得界面更加流畅。\n2. 输出文章九篇，其中八篇技术文。\n3. 输出了一本小书：「[理解 TCP 和 UDP](https://github.com/JerryC8080/understand-tcp-udp)」，这是我在复习计算机网络的产物，有幸能拿到 123 star （数字很特别）。\n4. 从魅族离职，入职有赞，换了个 Title，从「NodeJS 工程师」到「前端工程师」，这是很符合我个人的发展计划的，以 JS 栈为主的全栈道路。当然，前提需要是一个优秀的软件工程师。\n\n可惜的是，2017年的开头没有好好整理今年的目标。\n记得有句话很深刻：「人生中最适合的时机有两个，一个是十年前，一个是现在」\n虽然过了三分之一了，但现在计划，还来得及。\n\n# The Next\n希望到了 2018 年的自己：\n1. **Target**: 能解决大部分前端业务上的开发\n\t1. 深入前端，补足前端基础，包括 CSS、HTML5、ReactJS、Vue2，移动端开发\n\t2. 学习设计理论、色彩理论、看更多的优秀设计。\n\t3. 寻找设计领域比较好的读物，给读完。\n2. **Target**: 在社区有更加多的影响力\n\t1. 全年至少产出文章 12 - 20 篇\n\t2. 拥有一个 300 star 的开源项目\n\t3. 影响所在团队，逐渐营造技术氛围\n3. **Target**: 持续扎实基础实力\n\t1. 《鸟哥的Linux私房菜》\n\t2. 《设计模式》\n\t3. 《深入理解计算机操作系统》\n\t4. 《深入浅出 NodeJS》、《NodeJS 硬实战》、《Security Your NodeJS Application》\n\t5. 《高性能MySQL》\n\t6. 《CSS 权威指南》、《CSS 揭秘》\n\t7. 《Redis 设计与实现》、《Redis 实战》\n\t9. 《你不知道的 JavaScript》\n4. **Target**: 具有敏捷开发的实践经验\n\t1. 团队沟通\n\t2. 文档沉淀\n\t3. 影响力输出\n\t4. 代码质量\n\t5. 稳定交付\n\t6. 快速迭代流程\n5. **Target**: 拓展自身的技术视野\n\t1. 学习 Python，感受社区\n\t2. 学习 Go，感受社区\n6. **Target**: 技术之外\n\t1. 《软技能》\n\t2. 《浪潮之巅》一二册\n\t3. 《暗时间》第二次阅读\n\t4. 《如何阅读一本书》\n\n共勉。","source":"_posts/reconsidering-for-2017-Q1.md","raw":"---\ntitle: NodeJS中被忽略的内存\ncategory: 三省吾身\ndate: 2017-05-04 00:33:02\n---\n\n# The Past\n1.  [Memeye](https://github.com/JerryC8080/Memeye) 终于开源了，到目前为止已经有 153 个 star 了，但是后续没有再维护了，打算等我学完 Vue 以及对前端更加熟练之后，对前端部分进行重构，使得界面更加流畅。\n2. 输出文章九篇，其中八篇技术文。\n3. 输出了一本小书：「[理解 TCP 和 UDP](https://github.com/JerryC8080/understand-tcp-udp)」，这是我在复习计算机网络的产物，有幸能拿到 123 star （数字很特别）。\n4. 从魅族离职，入职有赞，换了个 Title，从「NodeJS 工程师」到「前端工程师」，这是很符合我个人的发展计划的，以 JS 栈为主的全栈道路。当然，前提需要是一个优秀的软件工程师。\n\n可惜的是，2017年的开头没有好好整理今年的目标。\n记得有句话很深刻：「人生中最适合的时机有两个，一个是十年前，一个是现在」\n虽然过了三分之一了，但现在计划，还来得及。\n\n# The Next\n希望到了 2018 年的自己：\n1. **Target**: 能解决大部分前端业务上的开发\n\t1. 深入前端，补足前端基础，包括 CSS、HTML5、ReactJS、Vue2，移动端开发\n\t2. 学习设计理论、色彩理论、看更多的优秀设计。\n\t3. 寻找设计领域比较好的读物，给读完。\n2. **Target**: 在社区有更加多的影响力\n\t1. 全年至少产出文章 12 - 20 篇\n\t2. 拥有一个 300 star 的开源项目\n\t3. 影响所在团队，逐渐营造技术氛围\n3. **Target**: 持续扎实基础实力\n\t1. 《鸟哥的Linux私房菜》\n\t2. 《设计模式》\n\t3. 《深入理解计算机操作系统》\n\t4. 《深入浅出 NodeJS》、《NodeJS 硬实战》、《Security Your NodeJS Application》\n\t5. 《高性能MySQL》\n\t6. 《CSS 权威指南》、《CSS 揭秘》\n\t7. 《Redis 设计与实现》、《Redis 实战》\n\t9. 《你不知道的 JavaScript》\n4. **Target**: 具有敏捷开发的实践经验\n\t1. 团队沟通\n\t2. 文档沉淀\n\t3. 影响力输出\n\t4. 代码质量\n\t5. 稳定交付\n\t6. 快速迭代流程\n5. **Target**: 拓展自身的技术视野\n\t1. 学习 Python，感受社区\n\t2. 学习 Go，感受社区\n6. **Target**: 技术之外\n\t1. 《软技能》\n\t2. 《浪潮之巅》一二册\n\t3. 《暗时间》第二次阅读\n\t4. 《如何阅读一本书》\n\n共勉。","slug":"reconsidering-for-2017-Q1","published":1,"updated":"2017-05-14T09:57:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwpr000x15hlxm4syngb","content":"<h1 id=\"The-Past\"><a href=\"#The-Past\" class=\"headerlink\" title=\"The Past\"></a>The Past</h1><ol>\n<li><a href=\"https://github.com/JerryC8080/Memeye\" target=\"_blank\" rel=\"external\">Memeye</a> 终于开源了，到目前为止已经有 153 个 star 了，但是后续没有再维护了，打算等我学完 Vue 以及对前端更加熟练之后，对前端部分进行重构，使得界面更加流畅。</li>\n<li>输出文章九篇，其中八篇技术文。</li>\n<li>输出了一本小书：「<a href=\"https://github.com/JerryC8080/understand-tcp-udp\" target=\"_blank\" rel=\"external\">理解 TCP 和 UDP</a>」，这是我在复习计算机网络的产物，有幸能拿到 123 star （数字很特别）。</li>\n<li>从魅族离职，入职有赞，换了个 Title，从「NodeJS 工程师」到「前端工程师」，这是很符合我个人的发展计划的，以 JS 栈为主的全栈道路。当然，前提需要是一个优秀的软件工程师。</li>\n</ol>\n<p>可惜的是，2017年的开头没有好好整理今年的目标。<br>记得有句话很深刻：「人生中最适合的时机有两个，一个是十年前，一个是现在」<br>虽然过了三分之一了，但现在计划，还来得及。</p>\n<h1 id=\"The-Next\"><a href=\"#The-Next\" class=\"headerlink\" title=\"The Next\"></a>The Next</h1><p>希望到了 2018 年的自己：</p>\n<ol>\n<li><strong>Target</strong>: 能解决大部分前端业务上的开发<ol>\n<li>深入前端，补足前端基础，包括 CSS、HTML5、ReactJS、Vue2，移动端开发</li>\n<li>学习设计理论、色彩理论、看更多的优秀设计。</li>\n<li>寻找设计领域比较好的读物，给读完。</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 在社区有更加多的影响力<ol>\n<li>全年至少产出文章 12 - 20 篇</li>\n<li>拥有一个 300 star 的开源项目</li>\n<li>影响所在团队，逐渐营造技术氛围</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 持续扎实基础实力<ol>\n<li>《鸟哥的Linux私房菜》</li>\n<li>《设计模式》</li>\n<li>《深入理解计算机操作系统》</li>\n<li>《深入浅出 NodeJS》、《NodeJS 硬实战》、《Security Your NodeJS Application》</li>\n<li>《高性能MySQL》</li>\n<li>《CSS 权威指南》、《CSS 揭秘》</li>\n<li>《Redis 设计与实现》、《Redis 实战》</li>\n<li>《你不知道的 JavaScript》</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 具有敏捷开发的实践经验<ol>\n<li>团队沟通</li>\n<li>文档沉淀</li>\n<li>影响力输出</li>\n<li>代码质量</li>\n<li>稳定交付</li>\n<li>快速迭代流程</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 拓展自身的技术视野<ol>\n<li>学习 Python，感受社区</li>\n<li>学习 Go，感受社区</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 技术之外<ol>\n<li>《软技能》</li>\n<li>《浪潮之巅》一二册</li>\n<li>《暗时间》第二次阅读</li>\n<li>《如何阅读一本书》</li>\n</ol>\n</li>\n</ol>\n<p>共勉。</p>\n","excerpt":"","more":"<h1 id=\"The-Past\"><a href=\"#The-Past\" class=\"headerlink\" title=\"The Past\"></a>The Past</h1><ol>\n<li><a href=\"https://github.com/JerryC8080/Memeye\">Memeye</a> 终于开源了，到目前为止已经有 153 个 star 了，但是后续没有再维护了，打算等我学完 Vue 以及对前端更加熟练之后，对前端部分进行重构，使得界面更加流畅。</li>\n<li>输出文章九篇，其中八篇技术文。</li>\n<li>输出了一本小书：「<a href=\"https://github.com/JerryC8080/understand-tcp-udp\">理解 TCP 和 UDP</a>」，这是我在复习计算机网络的产物，有幸能拿到 123 star （数字很特别）。</li>\n<li>从魅族离职，入职有赞，换了个 Title，从「NodeJS 工程师」到「前端工程师」，这是很符合我个人的发展计划的，以 JS 栈为主的全栈道路。当然，前提需要是一个优秀的软件工程师。</li>\n</ol>\n<p>可惜的是，2017年的开头没有好好整理今年的目标。<br>记得有句话很深刻：「人生中最适合的时机有两个，一个是十年前，一个是现在」<br>虽然过了三分之一了，但现在计划，还来得及。</p>\n<h1 id=\"The-Next\"><a href=\"#The-Next\" class=\"headerlink\" title=\"The Next\"></a>The Next</h1><p>希望到了 2018 年的自己：</p>\n<ol>\n<li><strong>Target</strong>: 能解决大部分前端业务上的开发<ol>\n<li>深入前端，补足前端基础，包括 CSS、HTML5、ReactJS、Vue2，移动端开发</li>\n<li>学习设计理论、色彩理论、看更多的优秀设计。</li>\n<li>寻找设计领域比较好的读物，给读完。</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 在社区有更加多的影响力<ol>\n<li>全年至少产出文章 12 - 20 篇</li>\n<li>拥有一个 300 star 的开源项目</li>\n<li>影响所在团队，逐渐营造技术氛围</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 持续扎实基础实力<ol>\n<li>《鸟哥的Linux私房菜》</li>\n<li>《设计模式》</li>\n<li>《深入理解计算机操作系统》</li>\n<li>《深入浅出 NodeJS》、《NodeJS 硬实战》、《Security Your NodeJS Application》</li>\n<li>《高性能MySQL》</li>\n<li>《CSS 权威指南》、《CSS 揭秘》</li>\n<li>《Redis 设计与实现》、《Redis 实战》</li>\n<li>《你不知道的 JavaScript》</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 具有敏捷开发的实践经验<ol>\n<li>团队沟通</li>\n<li>文档沉淀</li>\n<li>影响力输出</li>\n<li>代码质量</li>\n<li>稳定交付</li>\n<li>快速迭代流程</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 拓展自身的技术视野<ol>\n<li>学习 Python，感受社区</li>\n<li>学习 Go，感受社区</li>\n</ol>\n</li>\n<li><strong>Target</strong>: 技术之外<ol>\n<li>《软技能》</li>\n<li>《浪潮之巅》一二册</li>\n<li>《暗时间》第二次阅读</li>\n<li>《如何阅读一本书》</li>\n</ol>\n</li>\n</ol>\n<p>共勉。</p>\n"},{"title":"一款 NodeJS 轻量级内存监控工具","date":"2017-03-17T07:17:38.000Z","_content":"\n# [Memeye](https://github.com/JerryC8080/Memeye)\nGithub 链接：https://github.com/JerryC8080/Memeye\n\nMemeye 是一个轻量级的 NodeJS 进程监控工具，它提供 进程内存、V8 堆空间内存、操作系统内存 三大维度的数据可视化展示。\n前端部分，借助 [Vue2](https://github.com/vuejs/vue) 和 [ChartJS](https://github.com/chartjs/Chart.js) 提供了一个不错的动态展示面板。    \nMemeye 在宿主进程中，只植入了一个简单的数据收集器，其他工作则启动一个子进程，交由子进程来进行。    \n这样做能把 Memeye 的代码对宿主进程的影响降到最低，以确保数据的真实性。    \n\n### 特点\n- 轻量级\n- 简单\n- 面向开发环境\n- 可视化\n\n*Note: Memeye 暂时只支持单进程，NodeJS 分布式进程还不适用，所以不建议在产品环境使用。*\n\n# 动机\n总所周知，NodeJS 对内存是很敏感的。在去年 4 月我用 NodeJS 做的一个营销性的项目，在上线当天 PV 突破了 100W。        \n其中内存就呈现出持续上涨趋势，在排查问题的过程中，想寻找一个轻量级的，只要可视化的呈现内存使用情况的工具，无果。        \n然后就有了这个项目的想法，但当时由于繁忙只做出了一个 Demo 级别的，简单能用就发布了。    \n最近有时间，再次翻出来，重构改版，增加更多维度的数据展示。    \n\n# Demo\n[See preview demo](http://jerryc8080.github.io/Memeye/) (也许需要翻墙)\n\n# 兼容性\n- Node v7.x\n- Node v6.x\n\n# 安装 & 使用\n\n运行下面命令安装 : \n\n```\nnpm install memeye --save-dev\n```\n\n\n然后在你的代码中引入\n\n```\nconst memeye = require('memeye');\nmemeye();\n```\n\n最后打开你的浏览器，输入下面地址：\n\n```\nhttp://localhost:23333  //23333 port by defaul.\n```\n\n就这么简单！\n\n# Memeye 是如何工作的\n\nMemeye 有三个核心概念：Collector, Indicators, Dashboard。    \nCollector 运行在宿主进程中（你的NodeJS进程），Indicator 和 Dashboard 运行在子进程中，这样可以尽量减少 Memeye 代码对你的宿主进程的影响。    \n\n## Collector\nCollector 会监听宿主进程，并且收集数据，然后通过 IPC 通信管道发送数据给子进程，交由子进程处理。    \n\n## Indicator\nIndicator 像一个状态机。当它的属性变化的时候，会触发相应事件。所以我们可以用它来处理收集回来的数据。    \n\n## Dashboard\nDashboard 会以子进程的形式唤起。他会创建一个 Indicator 实例，以及启动一个集成 socket.io 的 Http 服务器。    \n然后绑定 Indicator 和进程通信管道，以接收父进程发过来的数据。    \n最后再绑定 Indicator 和 socket.io，这样可以在 Indicator 属性变化的时候发送数据给前端。    \n\n##Collector, Indicator, Dashboard 之间的通信\n\n![commication.jpeg](http://upload-images.jianshu.io/upload_images/79702-097ba6a11cc5b0ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 预览\n![预览](http://upload-images.jianshu.io/upload_images/79702-362b432432f6be64.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","source":"_posts/the-memeye.md","raw":"---\ntitle: 一款 NodeJS 轻量级内存监控工具\ndate: 2017-03-17 15:17:38\ntags:\n- Nodejs\n- Javascript\n- SOAP\ncategory: 搬砖码农\n---\n\n# [Memeye](https://github.com/JerryC8080/Memeye)\nGithub 链接：https://github.com/JerryC8080/Memeye\n\nMemeye 是一个轻量级的 NodeJS 进程监控工具，它提供 进程内存、V8 堆空间内存、操作系统内存 三大维度的数据可视化展示。\n前端部分，借助 [Vue2](https://github.com/vuejs/vue) 和 [ChartJS](https://github.com/chartjs/Chart.js) 提供了一个不错的动态展示面板。    \nMemeye 在宿主进程中，只植入了一个简单的数据收集器，其他工作则启动一个子进程，交由子进程来进行。    \n这样做能把 Memeye 的代码对宿主进程的影响降到最低，以确保数据的真实性。    \n\n### 特点\n- 轻量级\n- 简单\n- 面向开发环境\n- 可视化\n\n*Note: Memeye 暂时只支持单进程，NodeJS 分布式进程还不适用，所以不建议在产品环境使用。*\n\n# 动机\n总所周知，NodeJS 对内存是很敏感的。在去年 4 月我用 NodeJS 做的一个营销性的项目，在上线当天 PV 突破了 100W。        \n其中内存就呈现出持续上涨趋势，在排查问题的过程中，想寻找一个轻量级的，只要可视化的呈现内存使用情况的工具，无果。        \n然后就有了这个项目的想法，但当时由于繁忙只做出了一个 Demo 级别的，简单能用就发布了。    \n最近有时间，再次翻出来，重构改版，增加更多维度的数据展示。    \n\n# Demo\n[See preview demo](http://jerryc8080.github.io/Memeye/) (也许需要翻墙)\n\n# 兼容性\n- Node v7.x\n- Node v6.x\n\n# 安装 & 使用\n\n运行下面命令安装 : \n\n```\nnpm install memeye --save-dev\n```\n\n\n然后在你的代码中引入\n\n```\nconst memeye = require('memeye');\nmemeye();\n```\n\n最后打开你的浏览器，输入下面地址：\n\n```\nhttp://localhost:23333  //23333 port by defaul.\n```\n\n就这么简单！\n\n# Memeye 是如何工作的\n\nMemeye 有三个核心概念：Collector, Indicators, Dashboard。    \nCollector 运行在宿主进程中（你的NodeJS进程），Indicator 和 Dashboard 运行在子进程中，这样可以尽量减少 Memeye 代码对你的宿主进程的影响。    \n\n## Collector\nCollector 会监听宿主进程，并且收集数据，然后通过 IPC 通信管道发送数据给子进程，交由子进程处理。    \n\n## Indicator\nIndicator 像一个状态机。当它的属性变化的时候，会触发相应事件。所以我们可以用它来处理收集回来的数据。    \n\n## Dashboard\nDashboard 会以子进程的形式唤起。他会创建一个 Indicator 实例，以及启动一个集成 socket.io 的 Http 服务器。    \n然后绑定 Indicator 和进程通信管道，以接收父进程发过来的数据。    \n最后再绑定 Indicator 和 socket.io，这样可以在 Indicator 属性变化的时候发送数据给前端。    \n\n##Collector, Indicator, Dashboard 之间的通信\n\n![commication.jpeg](http://upload-images.jianshu.io/upload_images/79702-097ba6a11cc5b0ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 预览\n![预览](http://upload-images.jianshu.io/upload_images/79702-362b432432f6be64.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","slug":"the-memeye","published":1,"updated":"2017-05-14T09:58:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwpt001115hlov73itr4","content":"<h1 id=\"Memeye\"><a href=\"#Memeye\" class=\"headerlink\" title=\"Memeye\"></a><a href=\"https://github.com/JerryC8080/Memeye\" target=\"_blank\" rel=\"external\">Memeye</a></h1><p>Github 链接：<a href=\"https://github.com/JerryC8080/Memeye\" target=\"_blank\" rel=\"external\">https://github.com/JerryC8080/Memeye</a></p>\n<p>Memeye 是一个轻量级的 NodeJS 进程监控工具，它提供 进程内存、V8 堆空间内存、操作系统内存 三大维度的数据可视化展示。<br>前端部分，借助 <a href=\"https://github.com/vuejs/vue\" target=\"_blank\" rel=\"external\">Vue2</a> 和 <a href=\"https://github.com/chartjs/Chart.js\" target=\"_blank\" rel=\"external\">ChartJS</a> 提供了一个不错的动态展示面板。<br>Memeye 在宿主进程中，只植入了一个简单的数据收集器，其他工作则启动一个子进程，交由子进程来进行。<br>这样做能把 Memeye 的代码对宿主进程的影响降到最低，以确保数据的真实性。    </p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>轻量级</li>\n<li>简单</li>\n<li>面向开发环境</li>\n<li>可视化</li>\n</ul>\n<p><em>Note: Memeye 暂时只支持单进程，NodeJS 分布式进程还不适用，所以不建议在产品环境使用。</em></p>\n<h1 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h1><p>总所周知，NodeJS 对内存是很敏感的。在去年 4 月我用 NodeJS 做的一个营销性的项目，在上线当天 PV 突破了 100W。<br>其中内存就呈现出持续上涨趋势，在排查问题的过程中，想寻找一个轻量级的，只要可视化的呈现内存使用情况的工具，无果。<br>然后就有了这个项目的想法，但当时由于繁忙只做出了一个 Demo 级别的，简单能用就发布了。<br>最近有时间，再次翻出来，重构改版，增加更多维度的数据展示。    </p>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1><p><a href=\"http://jerryc8080.github.io/Memeye/\" target=\"_blank\" rel=\"external\">See preview demo</a> (也许需要翻墙)</p>\n<h1 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h1><ul>\n<li>Node v7.x</li>\n<li>Node v6.x</li>\n</ul>\n<h1 id=\"安装-amp-使用\"><a href=\"#安装-amp-使用\" class=\"headerlink\" title=\"安装 &amp; 使用\"></a>安装 &amp; 使用</h1><p>运行下面命令安装 : </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install memeye --save-dev</div></pre></td></tr></table></figure>\n<p>然后在你的代码中引入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">const memeye = require(&apos;memeye&apos;);</div><div class=\"line\">memeye();</div></pre></td></tr></table></figure>\n<p>最后打开你的浏览器，输入下面地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:23333  //23333 port by defaul.</div></pre></td></tr></table></figure>\n<p>就这么简单！</p>\n<h1 id=\"Memeye-是如何工作的\"><a href=\"#Memeye-是如何工作的\" class=\"headerlink\" title=\"Memeye 是如何工作的\"></a>Memeye 是如何工作的</h1><p>Memeye 有三个核心概念：Collector, Indicators, Dashboard。<br>Collector 运行在宿主进程中（你的NodeJS进程），Indicator 和 Dashboard 运行在子进程中，这样可以尽量减少 Memeye 代码对你的宿主进程的影响。    </p>\n<h2 id=\"Collector\"><a href=\"#Collector\" class=\"headerlink\" title=\"Collector\"></a>Collector</h2><p>Collector 会监听宿主进程，并且收集数据，然后通过 IPC 通信管道发送数据给子进程，交由子进程处理。    </p>\n<h2 id=\"Indicator\"><a href=\"#Indicator\" class=\"headerlink\" title=\"Indicator\"></a>Indicator</h2><p>Indicator 像一个状态机。当它的属性变化的时候，会触发相应事件。所以我们可以用它来处理收集回来的数据。    </p>\n<h2 id=\"Dashboard\"><a href=\"#Dashboard\" class=\"headerlink\" title=\"Dashboard\"></a>Dashboard</h2><p>Dashboard 会以子进程的形式唤起。他会创建一个 Indicator 实例，以及启动一个集成 socket.io 的 Http 服务器。<br>然后绑定 Indicator 和进程通信管道，以接收父进程发过来的数据。<br>最后再绑定 Indicator 和 socket.io，这样可以在 Indicator 属性变化的时候发送数据给前端。    </p>\n<p>##Collector, Indicator, Dashboard 之间的通信</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/79702-097ba6a11cc5b0ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"commication.jpeg\"></p>\n<h1 id=\"预览\"><a href=\"#预览\" class=\"headerlink\" title=\"预览\"></a>预览</h1><p><img src=\"http://upload-images.jianshu.io/upload_images/79702-362b432432f6be64.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"预览\"></p>\n","excerpt":"","more":"<h1 id=\"Memeye\"><a href=\"#Memeye\" class=\"headerlink\" title=\"Memeye\"></a><a href=\"https://github.com/JerryC8080/Memeye\">Memeye</a></h1><p>Github 链接：<a href=\"https://github.com/JerryC8080/Memeye\">https://github.com/JerryC8080/Memeye</a></p>\n<p>Memeye 是一个轻量级的 NodeJS 进程监控工具，它提供 进程内存、V8 堆空间内存、操作系统内存 三大维度的数据可视化展示。<br>前端部分，借助 <a href=\"https://github.com/vuejs/vue\">Vue2</a> 和 <a href=\"https://github.com/chartjs/Chart.js\">ChartJS</a> 提供了一个不错的动态展示面板。<br>Memeye 在宿主进程中，只植入了一个简单的数据收集器，其他工作则启动一个子进程，交由子进程来进行。<br>这样做能把 Memeye 的代码对宿主进程的影响降到最低，以确保数据的真实性。    </p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>轻量级</li>\n<li>简单</li>\n<li>面向开发环境</li>\n<li>可视化</li>\n</ul>\n<p><em>Note: Memeye 暂时只支持单进程，NodeJS 分布式进程还不适用，所以不建议在产品环境使用。</em></p>\n<h1 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h1><p>总所周知，NodeJS 对内存是很敏感的。在去年 4 月我用 NodeJS 做的一个营销性的项目，在上线当天 PV 突破了 100W。<br>其中内存就呈现出持续上涨趋势，在排查问题的过程中，想寻找一个轻量级的，只要可视化的呈现内存使用情况的工具，无果。<br>然后就有了这个项目的想法，但当时由于繁忙只做出了一个 Demo 级别的，简单能用就发布了。<br>最近有时间，再次翻出来，重构改版，增加更多维度的数据展示。    </p>\n<h1 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h1><p><a href=\"http://jerryc8080.github.io/Memeye/\">See preview demo</a> (也许需要翻墙)</p>\n<h1 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h1><ul>\n<li>Node v7.x</li>\n<li>Node v6.x</li>\n</ul>\n<h1 id=\"安装-amp-使用\"><a href=\"#安装-amp-使用\" class=\"headerlink\" title=\"安装 &amp; 使用\"></a>安装 &amp; 使用</h1><p>运行下面命令安装 : </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install memeye --save-dev</div></pre></td></tr></table></figure>\n<p>然后在你的代码中引入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">const memeye = require(&apos;memeye&apos;);</div><div class=\"line\">memeye();</div></pre></td></tr></table></figure>\n<p>最后打开你的浏览器，输入下面地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:23333  //23333 port by defaul.</div></pre></td></tr></table></figure>\n<p>就这么简单！</p>\n<h1 id=\"Memeye-是如何工作的\"><a href=\"#Memeye-是如何工作的\" class=\"headerlink\" title=\"Memeye 是如何工作的\"></a>Memeye 是如何工作的</h1><p>Memeye 有三个核心概念：Collector, Indicators, Dashboard。<br>Collector 运行在宿主进程中（你的NodeJS进程），Indicator 和 Dashboard 运行在子进程中，这样可以尽量减少 Memeye 代码对你的宿主进程的影响。    </p>\n<h2 id=\"Collector\"><a href=\"#Collector\" class=\"headerlink\" title=\"Collector\"></a>Collector</h2><p>Collector 会监听宿主进程，并且收集数据，然后通过 IPC 通信管道发送数据给子进程，交由子进程处理。    </p>\n<h2 id=\"Indicator\"><a href=\"#Indicator\" class=\"headerlink\" title=\"Indicator\"></a>Indicator</h2><p>Indicator 像一个状态机。当它的属性变化的时候，会触发相应事件。所以我们可以用它来处理收集回来的数据。    </p>\n<h2 id=\"Dashboard\"><a href=\"#Dashboard\" class=\"headerlink\" title=\"Dashboard\"></a>Dashboard</h2><p>Dashboard 会以子进程的形式唤起。他会创建一个 Indicator 实例，以及启动一个集成 socket.io 的 Http 服务器。<br>然后绑定 Indicator 和进程通信管道，以接收父进程发过来的数据。<br>最后再绑定 Indicator 和 socket.io，这样可以在 Indicator 属性变化的时候发送数据给前端。    </p>\n<p>##Collector, Indicator, Dashboard 之间的通信</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/79702-097ba6a11cc5b0ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"commication.jpeg\"></p>\n<h1 id=\"预览\"><a href=\"#预览\" class=\"headerlink\" title=\"预览\"></a>预览</h1><p><img src=\"http://upload-images.jianshu.io/upload_images/79702-362b432432f6be64.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"预览\"></p>\n"},{"title":"Gulp 基础与原理","date":"2017-02-28T05:49:00.000Z","_content":"\n\n# Gulp 概述\nGulp 是基于 NodeJS 的项目，一个用作自动化构建的工具，业界一般用来建造前端的工作流。\n\n它的核心原理其实很简单，最主要是通过各种 Transform Stream 来实现文件的处理，然后再进行输出。Transform Streams 是 NodeJS Stream 的一种，是可读又可写的，它会对传给它的对象做一些转换的操作。\n\n> 文件输入 →  Gulp 插件处理 → 文件输出\n\n原则上，gulp 可以针对文件做任何有趣、有创造力事情。\n而自动化构建，只是大家主要比较喜欢使用的方向。\n\nGulp 的特点：\n\n- **自动化** - Gulp 为你的工作流而服务，自动运行那些费事费力任务。\n- **平台透明** - Gulp 被集成到各种 IDE 中，并且除了 NodeJS 之外，其他如 PHP、.NET、Java 平台都可以使用 Gulp。\n- **强大生态系统** - 你可以使用 npm 上 2000+ 的插件来构造你的工作流。\n- **简单** - Gulp 只提供几个 API，这可以很快地学习和上手。\n\n# 使用 Gulp\n## 安装\n\n```\n$ npm install gulp-cli -g // 全局安装 Gulp 命令行工具\n$ npm install gulp -D // 在项目中，作为 devDependencies 依赖安装 gulp\n```\n\n## Gulpfile.js\n在使用 CLI 工具的时候，会执行该文件，它是一个可执行的 NodeJS 文件。原理上，你可以在里面运行任何 NodeJS 代码，然后通过调用 gulp 提供的 API，来执行 gulp 任务。\n`gulpfile.js`  文件一般都会放在项目的根目录中。\n\n一个使用 **[gulp-babel](https://www.npmjs.com/package/gulp-babel2/)** 插件来支持 es2015 语法的案例：\n```\nconst gulp = require('gulp');\nconst babel = require('gulp-babel');\n\ngulp.task('default', () => {\n    gulp.src('src/app.js')\n        .pipe(babel({\n            presets: ['es2015']\n        }))\n        .pipe(gulp.dest('dist'));\n});\n```\n\n# 基本概念与原理\n了解这些概念，对于了解 Gulp 的工作原理，和 API 的使用是很有帮助的。\n\n## 认识 Glob\n\nGlob 是一种用来匹配路径与文件的模式。有点类似于正则表达式，但是语法又有点差异。\n这种模式，被广泛用于命令行、Shell 等场景，大家熟悉的 `.gitignore` 文件也是使用这种模式。\n\n各大语言都有对于 Glob 的实现，例如 Go 和 PHP 的 `Glob` 函数，Python 中的 `glob` 模块。\n而 NodeJS 的实现是 **[minimatch](https://github.com/isaacs/minimatch)**, 而在 Gulp 源码中，就用了对 minimatch 进行封装的 **[node-glob](https://github.com/isaacs/node-glob)** 模块。\nGulp 的 API `gulp.watch` 和 `gulp.src` 都有用到 Glob 来匹配对应的路径和文件。\n下面是部分语法：\n* `*` \n匹配该路径段中 0 个或多个任意字符，\n  如：`js/*.js`， 匹配 js 目录下的所有 js 文件\n* `?` \n  匹配该路径段中 1 个任意字符，\n  如：`js/?.js`，匹配 js 目录下所有名字只有 1 个字的 js\n* `[...]` \n  匹配该路径段中在指定范围内字符，\n  如：`js/a[0-3].js`，匹配 js 目录下 a 开头,第二个字符为 0-3 之间（ 包括0和3 ）的 js（ a03.js不能被匹配到 ）\n\n* `!(pattern|pattern|pattern)` \n  匹配除所给出的模型以外的情况，\n  如：`js/!(a|b).js`，匹配 js 目录下名字中不包含 a ,也不包含 b 的所有文件.\n* `?(pattern|pattern|pattern)` \n  匹配所给出的模型中的 0 个或任意 1 个，\n  如：`js/?(a|a2|b).js`, 匹配 js 目录下 a.js , a2.js , b.js\n\n* `+(pattern|pattern|pattern)` \n  匹配所给出的模型中的 1 个或者多个，\n  如：`js/+(a|a1|b).js`, 匹配 js 目录下 a.js , a1.js , b.js , 或者 a, a1, b 这几个字符的组合的 js , 比如 ab.js\n* `*(pattern|pattern|pattern)`\n  匹配所给出的模型中的 0 个或多个或任意个的组合.\n  如：`js/*(a|a1|b).js`，匹配 js 目录下 a.js, a1.js, b.js 或者 a, a1, b这几个字符的组合的 js , 比如 ab.js\n\n* `@(pattern|pat*|pat?erN)`\n  匹配所给出的模型中的任意 1 个，\n  如：`js/@(a|a1|b)`, 匹配 js 目录下的 a.js, a1.js, b.js\n\n* `**`\n  与 `*` 一样可以匹配任何内容，但 `**`不仅匹配路径中的某一段,而且可以匹配 `a/b/c` 这样带有 `/` 的内容，所以，它还可以匹配子文件夹下的文件. \n  如：`js/**/*.js`，匹配 js 目录下及子文件夹中所有的 js 文件。\n\n更多 Glob 的知识和语法，可以参考：\n[Glob - Wiki](https://www.wikiwand.com/en/Glob_(programming)\n[Glob Primer](https://github.com/isaacs/node-glob#glob-primer)\n\n## 认识 Vinyl\n\n[Vinyl](https://github.com/gulpjs/vinyl) 是 Gulp 自创的一种用来描述一个虚拟文件的类，其中主要包括文件的内容和文件的路径两大信息。vinyl 模块，只是提供了一个类，而实现却交由 `vinyl-fs`\n\n[Vinyl-fs](https://github.com/gulpjs/vinyl-fs)，它主要的工作是接受 glob 模式的参数，然后读取匹配的文件。然后利用 Vinyl 制作一个 Transform Stream，称为 Vinyl Stream 对象，并返回。\n\n在 Gulp 中的 API `gulp.src`、`gulp.watch`、`gulp.dest` 都返回一个 Vinyl Stream 实例对象。Vinyl Stream 实例之间可以通过管道（ `vinyl1.pipe(vinyl2)` ）的形式来互相传输数据。 \n\n从 Gulp 的 [源码](https://github.com/gulpjs/gulp/blob/master/index.js#L25-L41) 中也能看出，这三个 API 都是由 vinyl-fs 提供全部的实现。\n\n再一点是，从这两个模块的实现来看，Gulp 是把文件内容以 Buffer 的形式读到内存中，然后再进行处理的。\n\n## 认识 Orchestrator\n[Orchestartor](https://github.com/robrich/orchestrator)，为 `gulp.task` 提供了全部实现，这可以从 [源码](https://github.com/gulpjs/gulp/blob/master/index.js#L14) 中看出。\n它为 Gulp 提供了任务相关的功能，包括任务注册、任务执行以及相对应的任务进度、错误监控等功能。\n\nOrchestartor 模块，只提供了一个 Orchestartor 类，该类的实例维护着一个 tasks 数组，该数组的内容就是一个我们使用 `gulp.task` 时注册的函数列表，以及函数的依赖和名字。\n通过 [源码](https://github.com/robrich/orchestrator/blob/master/index.js#L54-L57) 中，可以看到 tasks 的数据结构：\n```javascript\n...\nthis.tasks[name] = {\n  fn: fn,   // 任务的函数体\n  dep: dep,   // 任务所依赖的其他任务名称\n  name: name  // 该任务的名称\n};\n...\n```\n\n# Gulp 核心 API\n- gulp.src：获取文件\n- gulp.dest：写入文件\n- gulp.tasks：注册任务\n- gulp.watch：监控文件的改动\n\n## gulp.src\n`gulp.src( globs [, options] )`\n\n接收一个 globs 模式的对象，可以是 Array 或者 String，返回一个 Vinyl Stream 实例。\n而 options 有下面的值：\n  * buffer - Boolean, 控制 `file.contents` 是返回 buffer 还是 stream。\n  * read - Boolean，控制是否读取文件，如果 false，则 `file.contents` 为 `null`\n  * base - String，控制 glob 的 base，默认值是 glob 所有表达式的前置，例如 `client/js/**/*.js`, base 值就为 `client/js/`。而 glob 在保存输出路径的时候，取的是 base 之后的路径。所以可以通过该值，来进行输出路径的改写。\n\n## gulp.dest\n`gulp.dest( path [, options] )`\n\n接收输出路径，返回一个 Vinyl Stream 实例。\n而 options 有以下的值：\n * cwd - String， 默认值 `process.pwd()`，输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。\n * mode -  String，八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。\n\n## gulp.task\n`gulp.task( name [, deps ], fn )`\n\n定义一个使用 Orchestrator 实现的任务（task）。\n参数的描述如下：\n* name - 任务名称\n* deps - 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数\n* fn - 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。\n\n## gulp.watch\n`gulp.watch( glob [, opts ], tasks )`\nor\n`gulp.watch( glob [, opts, cb ] )`\n\n用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。\n各参数的描述如下：\n* glob - 为要监视的文件 Glob 匹配模式。\n* opts - 为一个可选的配置对象。\n* tasks - 为文件变化后要执行的任务，为一个数组\n\n# 常用插件\n\n- [gulp-load-plugins](https://www.npmjs.com/package/gulp-load-plugins)：自动加载 `package.json` 中的 gulp 插件\n- [gulp-rename](https://www.npmjs.com/package/gulp-rename)： 重命名\n- [gulp-uglify](https://www.npmjs.com/package/gulp-uglify)：文件压缩\n- [gulp-concat](https://www.npmjs.com/package/gulp-concat)：文件合并\n- [gulp-less](https://www.npmjs.com/package/gulp-less)：编译 less\n- [gulp-sass](https://www.npmjs.com/package/gulp-sass)：编译 sass\n- [gulp-clean-css](https://github.com/scniro/gulp-clean-css)：压缩 CSS 文件\n- [gulp-htmlmin](https://github.com/jonschlinkert/gulp-htmlmin)：压缩 HTML 文件\n- [gulp-babel](https://github.com/babel/gulp-babel): 使用 babel 编译 JS 文件\n- [gulp-jshint](https://www.npmjs.com/package/gulp-jshint)：jshint 检查\n- [gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin)：压缩jpg、png、gif等图片\n- [gulp-livereload](https://github.com/vohof/gulp-livereload)：当代码变化时，它可以帮我们自动刷新页面\n\n更多插件，可以搜索[官方插件库](http://gulpjs.com/plugins/)。","source":"_posts/gulp-base.md","raw":"---\ntitle: Gulp 基础与原理\ncategory: 搬砖码农\ndate: 2017-02-28 13:49:00\ntags:\n- 前端构建\n---\n\n\n# Gulp 概述\nGulp 是基于 NodeJS 的项目，一个用作自动化构建的工具，业界一般用来建造前端的工作流。\n\n它的核心原理其实很简单，最主要是通过各种 Transform Stream 来实现文件的处理，然后再进行输出。Transform Streams 是 NodeJS Stream 的一种，是可读又可写的，它会对传给它的对象做一些转换的操作。\n\n> 文件输入 →  Gulp 插件处理 → 文件输出\n\n原则上，gulp 可以针对文件做任何有趣、有创造力事情。\n而自动化构建，只是大家主要比较喜欢使用的方向。\n\nGulp 的特点：\n\n- **自动化** - Gulp 为你的工作流而服务，自动运行那些费事费力任务。\n- **平台透明** - Gulp 被集成到各种 IDE 中，并且除了 NodeJS 之外，其他如 PHP、.NET、Java 平台都可以使用 Gulp。\n- **强大生态系统** - 你可以使用 npm 上 2000+ 的插件来构造你的工作流。\n- **简单** - Gulp 只提供几个 API，这可以很快地学习和上手。\n\n# 使用 Gulp\n## 安装\n\n```\n$ npm install gulp-cli -g // 全局安装 Gulp 命令行工具\n$ npm install gulp -D // 在项目中，作为 devDependencies 依赖安装 gulp\n```\n\n## Gulpfile.js\n在使用 CLI 工具的时候，会执行该文件，它是一个可执行的 NodeJS 文件。原理上，你可以在里面运行任何 NodeJS 代码，然后通过调用 gulp 提供的 API，来执行 gulp 任务。\n`gulpfile.js`  文件一般都会放在项目的根目录中。\n\n一个使用 **[gulp-babel](https://www.npmjs.com/package/gulp-babel2/)** 插件来支持 es2015 语法的案例：\n```\nconst gulp = require('gulp');\nconst babel = require('gulp-babel');\n\ngulp.task('default', () => {\n    gulp.src('src/app.js')\n        .pipe(babel({\n            presets: ['es2015']\n        }))\n        .pipe(gulp.dest('dist'));\n});\n```\n\n# 基本概念与原理\n了解这些概念，对于了解 Gulp 的工作原理，和 API 的使用是很有帮助的。\n\n## 认识 Glob\n\nGlob 是一种用来匹配路径与文件的模式。有点类似于正则表达式，但是语法又有点差异。\n这种模式，被广泛用于命令行、Shell 等场景，大家熟悉的 `.gitignore` 文件也是使用这种模式。\n\n各大语言都有对于 Glob 的实现，例如 Go 和 PHP 的 `Glob` 函数，Python 中的 `glob` 模块。\n而 NodeJS 的实现是 **[minimatch](https://github.com/isaacs/minimatch)**, 而在 Gulp 源码中，就用了对 minimatch 进行封装的 **[node-glob](https://github.com/isaacs/node-glob)** 模块。\nGulp 的 API `gulp.watch` 和 `gulp.src` 都有用到 Glob 来匹配对应的路径和文件。\n下面是部分语法：\n* `*` \n匹配该路径段中 0 个或多个任意字符，\n  如：`js/*.js`， 匹配 js 目录下的所有 js 文件\n* `?` \n  匹配该路径段中 1 个任意字符，\n  如：`js/?.js`，匹配 js 目录下所有名字只有 1 个字的 js\n* `[...]` \n  匹配该路径段中在指定范围内字符，\n  如：`js/a[0-3].js`，匹配 js 目录下 a 开头,第二个字符为 0-3 之间（ 包括0和3 ）的 js（ a03.js不能被匹配到 ）\n\n* `!(pattern|pattern|pattern)` \n  匹配除所给出的模型以外的情况，\n  如：`js/!(a|b).js`，匹配 js 目录下名字中不包含 a ,也不包含 b 的所有文件.\n* `?(pattern|pattern|pattern)` \n  匹配所给出的模型中的 0 个或任意 1 个，\n  如：`js/?(a|a2|b).js`, 匹配 js 目录下 a.js , a2.js , b.js\n\n* `+(pattern|pattern|pattern)` \n  匹配所给出的模型中的 1 个或者多个，\n  如：`js/+(a|a1|b).js`, 匹配 js 目录下 a.js , a1.js , b.js , 或者 a, a1, b 这几个字符的组合的 js , 比如 ab.js\n* `*(pattern|pattern|pattern)`\n  匹配所给出的模型中的 0 个或多个或任意个的组合.\n  如：`js/*(a|a1|b).js`，匹配 js 目录下 a.js, a1.js, b.js 或者 a, a1, b这几个字符的组合的 js , 比如 ab.js\n\n* `@(pattern|pat*|pat?erN)`\n  匹配所给出的模型中的任意 1 个，\n  如：`js/@(a|a1|b)`, 匹配 js 目录下的 a.js, a1.js, b.js\n\n* `**`\n  与 `*` 一样可以匹配任何内容，但 `**`不仅匹配路径中的某一段,而且可以匹配 `a/b/c` 这样带有 `/` 的内容，所以，它还可以匹配子文件夹下的文件. \n  如：`js/**/*.js`，匹配 js 目录下及子文件夹中所有的 js 文件。\n\n更多 Glob 的知识和语法，可以参考：\n[Glob - Wiki](https://www.wikiwand.com/en/Glob_(programming)\n[Glob Primer](https://github.com/isaacs/node-glob#glob-primer)\n\n## 认识 Vinyl\n\n[Vinyl](https://github.com/gulpjs/vinyl) 是 Gulp 自创的一种用来描述一个虚拟文件的类，其中主要包括文件的内容和文件的路径两大信息。vinyl 模块，只是提供了一个类，而实现却交由 `vinyl-fs`\n\n[Vinyl-fs](https://github.com/gulpjs/vinyl-fs)，它主要的工作是接受 glob 模式的参数，然后读取匹配的文件。然后利用 Vinyl 制作一个 Transform Stream，称为 Vinyl Stream 对象，并返回。\n\n在 Gulp 中的 API `gulp.src`、`gulp.watch`、`gulp.dest` 都返回一个 Vinyl Stream 实例对象。Vinyl Stream 实例之间可以通过管道（ `vinyl1.pipe(vinyl2)` ）的形式来互相传输数据。 \n\n从 Gulp 的 [源码](https://github.com/gulpjs/gulp/blob/master/index.js#L25-L41) 中也能看出，这三个 API 都是由 vinyl-fs 提供全部的实现。\n\n再一点是，从这两个模块的实现来看，Gulp 是把文件内容以 Buffer 的形式读到内存中，然后再进行处理的。\n\n## 认识 Orchestrator\n[Orchestartor](https://github.com/robrich/orchestrator)，为 `gulp.task` 提供了全部实现，这可以从 [源码](https://github.com/gulpjs/gulp/blob/master/index.js#L14) 中看出。\n它为 Gulp 提供了任务相关的功能，包括任务注册、任务执行以及相对应的任务进度、错误监控等功能。\n\nOrchestartor 模块，只提供了一个 Orchestartor 类，该类的实例维护着一个 tasks 数组，该数组的内容就是一个我们使用 `gulp.task` 时注册的函数列表，以及函数的依赖和名字。\n通过 [源码](https://github.com/robrich/orchestrator/blob/master/index.js#L54-L57) 中，可以看到 tasks 的数据结构：\n```javascript\n...\nthis.tasks[name] = {\n  fn: fn,   // 任务的函数体\n  dep: dep,   // 任务所依赖的其他任务名称\n  name: name  // 该任务的名称\n};\n...\n```\n\n# Gulp 核心 API\n- gulp.src：获取文件\n- gulp.dest：写入文件\n- gulp.tasks：注册任务\n- gulp.watch：监控文件的改动\n\n## gulp.src\n`gulp.src( globs [, options] )`\n\n接收一个 globs 模式的对象，可以是 Array 或者 String，返回一个 Vinyl Stream 实例。\n而 options 有下面的值：\n  * buffer - Boolean, 控制 `file.contents` 是返回 buffer 还是 stream。\n  * read - Boolean，控制是否读取文件，如果 false，则 `file.contents` 为 `null`\n  * base - String，控制 glob 的 base，默认值是 glob 所有表达式的前置，例如 `client/js/**/*.js`, base 值就为 `client/js/`。而 glob 在保存输出路径的时候，取的是 base 之后的路径。所以可以通过该值，来进行输出路径的改写。\n\n## gulp.dest\n`gulp.dest( path [, options] )`\n\n接收输出路径，返回一个 Vinyl Stream 实例。\n而 options 有以下的值：\n * cwd - String， 默认值 `process.pwd()`，输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。\n * mode -  String，八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。\n\n## gulp.task\n`gulp.task( name [, deps ], fn )`\n\n定义一个使用 Orchestrator 实现的任务（task）。\n参数的描述如下：\n* name - 任务名称\n* deps - 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数\n* fn - 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。\n\n## gulp.watch\n`gulp.watch( glob [, opts ], tasks )`\nor\n`gulp.watch( glob [, opts, cb ] )`\n\n用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。\n各参数的描述如下：\n* glob - 为要监视的文件 Glob 匹配模式。\n* opts - 为一个可选的配置对象。\n* tasks - 为文件变化后要执行的任务，为一个数组\n\n# 常用插件\n\n- [gulp-load-plugins](https://www.npmjs.com/package/gulp-load-plugins)：自动加载 `package.json` 中的 gulp 插件\n- [gulp-rename](https://www.npmjs.com/package/gulp-rename)： 重命名\n- [gulp-uglify](https://www.npmjs.com/package/gulp-uglify)：文件压缩\n- [gulp-concat](https://www.npmjs.com/package/gulp-concat)：文件合并\n- [gulp-less](https://www.npmjs.com/package/gulp-less)：编译 less\n- [gulp-sass](https://www.npmjs.com/package/gulp-sass)：编译 sass\n- [gulp-clean-css](https://github.com/scniro/gulp-clean-css)：压缩 CSS 文件\n- [gulp-htmlmin](https://github.com/jonschlinkert/gulp-htmlmin)：压缩 HTML 文件\n- [gulp-babel](https://github.com/babel/gulp-babel): 使用 babel 编译 JS 文件\n- [gulp-jshint](https://www.npmjs.com/package/gulp-jshint)：jshint 检查\n- [gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin)：压缩jpg、png、gif等图片\n- [gulp-livereload](https://github.com/vohof/gulp-livereload)：当代码变化时，它可以帮我们自动刷新页面\n\n更多插件，可以搜索[官方插件库](http://gulpjs.com/plugins/)。","slug":"gulp-base","published":1,"updated":"2017-02-28T05:49:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwpv001515hloeygbxoh","content":"<h1 id=\"Gulp-概述\"><a href=\"#Gulp-概述\" class=\"headerlink\" title=\"Gulp 概述\"></a>Gulp 概述</h1><p>Gulp 是基于 NodeJS 的项目，一个用作自动化构建的工具，业界一般用来建造前端的工作流。</p>\n<p>它的核心原理其实很简单，最主要是通过各种 Transform Stream 来实现文件的处理，然后再进行输出。Transform Streams 是 NodeJS Stream 的一种，是可读又可写的，它会对传给它的对象做一些转换的操作。</p>\n<blockquote>\n<p>文件输入 →  Gulp 插件处理 → 文件输出</p>\n</blockquote>\n<p>原则上，gulp 可以针对文件做任何有趣、有创造力事情。<br>而自动化构建，只是大家主要比较喜欢使用的方向。</p>\n<p>Gulp 的特点：</p>\n<ul>\n<li><strong>自动化</strong> - Gulp 为你的工作流而服务，自动运行那些费事费力任务。</li>\n<li><strong>平台透明</strong> - Gulp 被集成到各种 IDE 中，并且除了 NodeJS 之外，其他如 PHP、.NET、Java 平台都可以使用 Gulp。</li>\n<li><strong>强大生态系统</strong> - 你可以使用 npm 上 2000+ 的插件来构造你的工作流。</li>\n<li><strong>简单</strong> - Gulp 只提供几个 API，这可以很快地学习和上手。</li>\n</ul>\n<h1 id=\"使用-Gulp\"><a href=\"#使用-Gulp\" class=\"headerlink\" title=\"使用 Gulp\"></a>使用 Gulp</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install gulp-cli -g // 全局安装 Gulp 命令行工具</div><div class=\"line\">$ npm install gulp -D // 在项目中，作为 devDependencies 依赖安装 gulp</div></pre></td></tr></table></figure>\n<h2 id=\"Gulpfile-js\"><a href=\"#Gulpfile-js\" class=\"headerlink\" title=\"Gulpfile.js\"></a>Gulpfile.js</h2><p>在使用 CLI 工具的时候，会执行该文件，它是一个可执行的 NodeJS 文件。原理上，你可以在里面运行任何 NodeJS 代码，然后通过调用 gulp 提供的 API，来执行 gulp 任务。<br><code>gulpfile.js</code>  文件一般都会放在项目的根目录中。</p>\n<p>一个使用 <strong><a href=\"https://www.npmjs.com/package/gulp-babel2/\" target=\"_blank\" rel=\"external\">gulp-babel</a></strong> 插件来支持 es2015 语法的案例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">const gulp = require(&apos;gulp&apos;);</div><div class=\"line\">const babel = require(&apos;gulp-babel&apos;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;default&apos;, () =&gt; &#123;</div><div class=\"line\">    gulp.src(&apos;src/app.js&apos;)</div><div class=\"line\">        .pipe(babel(&#123;</div><div class=\"line\">            presets: [&apos;es2015&apos;]</div><div class=\"line\">        &#125;))</div><div class=\"line\">        .pipe(gulp.dest(&apos;dist&apos;));</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h1 id=\"基本概念与原理\"><a href=\"#基本概念与原理\" class=\"headerlink\" title=\"基本概念与原理\"></a>基本概念与原理</h1><p>了解这些概念，对于了解 Gulp 的工作原理，和 API 的使用是很有帮助的。</p>\n<h2 id=\"认识-Glob\"><a href=\"#认识-Glob\" class=\"headerlink\" title=\"认识 Glob\"></a>认识 Glob</h2><p>Glob 是一种用来匹配路径与文件的模式。有点类似于正则表达式，但是语法又有点差异。<br>这种模式，被广泛用于命令行、Shell 等场景，大家熟悉的 <code>.gitignore</code> 文件也是使用这种模式。</p>\n<p>各大语言都有对于 Glob 的实现，例如 Go 和 PHP 的 <code>Glob</code> 函数，Python 中的 <code>glob</code> 模块。<br>而 NodeJS 的实现是 <strong><a href=\"https://github.com/isaacs/minimatch\" target=\"_blank\" rel=\"external\">minimatch</a></strong>, 而在 Gulp 源码中，就用了对 minimatch 进行封装的 <strong><a href=\"https://github.com/isaacs/node-glob\" target=\"_blank\" rel=\"external\">node-glob</a></strong> 模块。<br>Gulp 的 API <code>gulp.watch</code> 和 <code>gulp.src</code> 都有用到 Glob 来匹配对应的路径和文件。<br>下面是部分语法：</p>\n<ul>\n<li><code>*</code><br>匹配该路径段中 0 个或多个任意字符，<br>如：<code>js/*.js</code>， 匹配 js 目录下的所有 js 文件</li>\n<li><code>?</code><br>匹配该路径段中 1 个任意字符，<br>如：<code>js/?.js</code>，匹配 js 目录下所有名字只有 1 个字的 js</li>\n<li><p><code>[...]</code><br>匹配该路径段中在指定范围内字符，<br>如：<code>js/a[0-3].js</code>，匹配 js 目录下 a 开头,第二个字符为 0-3 之间（ 包括0和3 ）的 js（ a03.js不能被匹配到 ）</p>\n</li>\n<li><p><code>!(pattern|pattern|pattern)</code><br>匹配除所给出的模型以外的情况，<br>如：<code>js/!(a|b).js</code>，匹配 js 目录下名字中不包含 a ,也不包含 b 的所有文件.</p>\n</li>\n<li><p><code>?(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 0 个或任意 1 个，<br>如：<code>js/?(a|a2|b).js</code>, 匹配 js 目录下 a.js , a2.js , b.js</p>\n</li>\n<li><p><code>+(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 1 个或者多个，<br>如：<code>js/+(a|a1|b).js</code>, 匹配 js 目录下 a.js , a1.js , b.js , 或者 a, a1, b 这几个字符的组合的 js , 比如 ab.js</p>\n</li>\n<li><p><code>*(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 0 个或多个或任意个的组合.<br>如：<code>js/*(a|a1|b).js</code>，匹配 js 目录下 a.js, a1.js, b.js 或者 a, a1, b这几个字符的组合的 js , 比如 ab.js</p>\n</li>\n<li><p><code>@(pattern|pat*|pat?erN)</code><br>匹配所给出的模型中的任意 1 个，<br>如：<code>js/@(a|a1|b)</code>, 匹配 js 目录下的 a.js, a1.js, b.js</p>\n</li>\n<li><p><code>**</code><br>与 <code>*</code> 一样可以匹配任何内容，但 <code>**</code>不仅匹配路径中的某一段,而且可以匹配 <code>a/b/c</code> 这样带有 <code>/</code> 的内容，所以，它还可以匹配子文件夹下的文件.<br>如：<code>js/**/*.js</code>，匹配 js 目录下及子文件夹中所有的 js 文件。</p>\n</li>\n</ul>\n<p>更多 Glob 的知识和语法，可以参考：<br><a href=\"https://www.wikiwand.com/en/Glob_(programming\" target=\"_blank\" rel=\"external\">Glob - Wiki</a><br><a href=\"https://github.com/isaacs/node-glob#glob-primer\" target=\"_blank\" rel=\"external\">Glob Primer</a></p>\n<h2 id=\"认识-Vinyl\"><a href=\"#认识-Vinyl\" class=\"headerlink\" title=\"认识 Vinyl\"></a>认识 Vinyl</h2><p><a href=\"https://github.com/gulpjs/vinyl\" target=\"_blank\" rel=\"external\">Vinyl</a> 是 Gulp 自创的一种用来描述一个虚拟文件的类，其中主要包括文件的内容和文件的路径两大信息。vinyl 模块，只是提供了一个类，而实现却交由 <code>vinyl-fs</code></p>\n<p><a href=\"https://github.com/gulpjs/vinyl-fs\" target=\"_blank\" rel=\"external\">Vinyl-fs</a>，它主要的工作是接受 glob 模式的参数，然后读取匹配的文件。然后利用 Vinyl 制作一个 Transform Stream，称为 Vinyl Stream 对象，并返回。</p>\n<p>在 Gulp 中的 API <code>gulp.src</code>、<code>gulp.watch</code>、<code>gulp.dest</code> 都返回一个 Vinyl Stream 实例对象。Vinyl Stream 实例之间可以通过管道（ <code>vinyl1.pipe(vinyl2)</code> ）的形式来互相传输数据。 </p>\n<p>从 Gulp 的 <a href=\"https://github.com/gulpjs/gulp/blob/master/index.js#L25-L41\" target=\"_blank\" rel=\"external\">源码</a> 中也能看出，这三个 API 都是由 vinyl-fs 提供全部的实现。</p>\n<p>再一点是，从这两个模块的实现来看，Gulp 是把文件内容以 Buffer 的形式读到内存中，然后再进行处理的。</p>\n<h2 id=\"认识-Orchestrator\"><a href=\"#认识-Orchestrator\" class=\"headerlink\" title=\"认识 Orchestrator\"></a>认识 Orchestrator</h2><p><a href=\"https://github.com/robrich/orchestrator\" target=\"_blank\" rel=\"external\">Orchestartor</a>，为 <code>gulp.task</code> 提供了全部实现，这可以从 <a href=\"https://github.com/gulpjs/gulp/blob/master/index.js#L14\" target=\"_blank\" rel=\"external\">源码</a> 中看出。<br>它为 Gulp 提供了任务相关的功能，包括任务注册、任务执行以及相对应的任务进度、错误监控等功能。</p>\n<p>Orchestartor 模块，只提供了一个 Orchestartor 类，该类的实例维护着一个 tasks 数组，该数组的内容就是一个我们使用 <code>gulp.task</code> 时注册的函数列表，以及函数的依赖和名字。<br>通过 <a href=\"https://github.com/robrich/orchestrator/blob/master/index.js#L54-L57\" target=\"_blank\" rel=\"external\">源码</a> 中，可以看到 tasks 的数据结构：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">this.tasks[name] = &#123;</div><div class=\"line\">  <span class=\"attr\">fn</span>: fn,   <span class=\"comment\">// 任务的函数体</span></div><div class=\"line\">  dep: dep,   <span class=\"comment\">// 任务所依赖的其他任务名称</span></div><div class=\"line\">  name: name  <span class=\"comment\">// 该任务的名称</span></div><div class=\"line\">&#125;;</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h1 id=\"Gulp-核心-API\"><a href=\"#Gulp-核心-API\" class=\"headerlink\" title=\"Gulp 核心 API\"></a>Gulp 核心 API</h1><ul>\n<li>gulp.src：获取文件</li>\n<li>gulp.dest：写入文件</li>\n<li>gulp.tasks：注册任务</li>\n<li>gulp.watch：监控文件的改动</li>\n</ul>\n<h2 id=\"gulp-src\"><a href=\"#gulp-src\" class=\"headerlink\" title=\"gulp.src\"></a>gulp.src</h2><p><code>gulp.src( globs [, options] )</code></p>\n<p>接收一个 globs 模式的对象，可以是 Array 或者 String，返回一个 Vinyl Stream 实例。<br>而 options 有下面的值：</p>\n<ul>\n<li>buffer - Boolean, 控制 <code>file.contents</code> 是返回 buffer 还是 stream。</li>\n<li>read - Boolean，控制是否读取文件，如果 false，则 <code>file.contents</code> 为 <code>null</code></li>\n<li>base - String，控制 glob 的 base，默认值是 glob 所有表达式的前置，例如 <code>client/js/**/*.js</code>, base 值就为 <code>client/js/</code>。而 glob 在保存输出路径的时候，取的是 base 之后的路径。所以可以通过该值，来进行输出路径的改写。</li>\n</ul>\n<h2 id=\"gulp-dest\"><a href=\"#gulp-dest\" class=\"headerlink\" title=\"gulp.dest\"></a>gulp.dest</h2><p><code>gulp.dest( path [, options] )</code></p>\n<p>接收输出路径，返回一个 Vinyl Stream 实例。<br>而 options 有以下的值：</p>\n<ul>\n<li>cwd - String， 默认值 <code>process.pwd()</code>，输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。</li>\n<li>mode -  String，八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。</li>\n</ul>\n<h2 id=\"gulp-task\"><a href=\"#gulp-task\" class=\"headerlink\" title=\"gulp.task\"></a>gulp.task</h2><p><code>gulp.task( name [, deps ], fn )</code></p>\n<p>定义一个使用 Orchestrator 实现的任务（task）。<br>参数的描述如下：</p>\n<ul>\n<li>name - 任务名称</li>\n<li>deps - 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数</li>\n<li>fn - 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。</li>\n</ul>\n<h2 id=\"gulp-watch\"><a href=\"#gulp-watch\" class=\"headerlink\" title=\"gulp.watch\"></a>gulp.watch</h2><p><code>gulp.watch( glob [, opts ], tasks )</code><br>or<br><code>gulp.watch( glob [, opts, cb ] )</code></p>\n<p>用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。<br>各参数的描述如下：</p>\n<ul>\n<li>glob - 为要监视的文件 Glob 匹配模式。</li>\n<li>opts - 为一个可选的配置对象。</li>\n<li>tasks - 为文件变化后要执行的任务，为一个数组</li>\n</ul>\n<h1 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件\"></a>常用插件</h1><ul>\n<li><a href=\"https://www.npmjs.com/package/gulp-load-plugins\" target=\"_blank\" rel=\"external\">gulp-load-plugins</a>：自动加载 <code>package.json</code> 中的 gulp 插件</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-rename\" target=\"_blank\" rel=\"external\">gulp-rename</a>： 重命名</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-uglify\" target=\"_blank\" rel=\"external\">gulp-uglify</a>：文件压缩</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-concat\" target=\"_blank\" rel=\"external\">gulp-concat</a>：文件合并</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-less\" target=\"_blank\" rel=\"external\">gulp-less</a>：编译 less</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-sass\" target=\"_blank\" rel=\"external\">gulp-sass</a>：编译 sass</li>\n<li><a href=\"https://github.com/scniro/gulp-clean-css\" target=\"_blank\" rel=\"external\">gulp-clean-css</a>：压缩 CSS 文件</li>\n<li><a href=\"https://github.com/jonschlinkert/gulp-htmlmin\" target=\"_blank\" rel=\"external\">gulp-htmlmin</a>：压缩 HTML 文件</li>\n<li><a href=\"https://github.com/babel/gulp-babel\" target=\"_blank\" rel=\"external\">gulp-babel</a>: 使用 babel 编译 JS 文件</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-jshint\" target=\"_blank\" rel=\"external\">gulp-jshint</a>：jshint 检查</li>\n<li><a href=\"https://github.com/sindresorhus/gulp-imagemin\" target=\"_blank\" rel=\"external\">gulp-imagemin</a>：压缩jpg、png、gif等图片</li>\n<li><a href=\"https://github.com/vohof/gulp-livereload\" target=\"_blank\" rel=\"external\">gulp-livereload</a>：当代码变化时，它可以帮我们自动刷新页面</li>\n</ul>\n<p>更多插件，可以搜索<a href=\"http://gulpjs.com/plugins/\" target=\"_blank\" rel=\"external\">官方插件库</a>。</p>\n","excerpt":"","more":"<h1 id=\"Gulp-概述\"><a href=\"#Gulp-概述\" class=\"headerlink\" title=\"Gulp 概述\"></a>Gulp 概述</h1><p>Gulp 是基于 NodeJS 的项目，一个用作自动化构建的工具，业界一般用来建造前端的工作流。</p>\n<p>它的核心原理其实很简单，最主要是通过各种 Transform Stream 来实现文件的处理，然后再进行输出。Transform Streams 是 NodeJS Stream 的一种，是可读又可写的，它会对传给它的对象做一些转换的操作。</p>\n<blockquote>\n<p>文件输入 →  Gulp 插件处理 → 文件输出</p>\n</blockquote>\n<p>原则上，gulp 可以针对文件做任何有趣、有创造力事情。<br>而自动化构建，只是大家主要比较喜欢使用的方向。</p>\n<p>Gulp 的特点：</p>\n<ul>\n<li><strong>自动化</strong> - Gulp 为你的工作流而服务，自动运行那些费事费力任务。</li>\n<li><strong>平台透明</strong> - Gulp 被集成到各种 IDE 中，并且除了 NodeJS 之外，其他如 PHP、.NET、Java 平台都可以使用 Gulp。</li>\n<li><strong>强大生态系统</strong> - 你可以使用 npm 上 2000+ 的插件来构造你的工作流。</li>\n<li><strong>简单</strong> - Gulp 只提供几个 API，这可以很快地学习和上手。</li>\n</ul>\n<h1 id=\"使用-Gulp\"><a href=\"#使用-Gulp\" class=\"headerlink\" title=\"使用 Gulp\"></a>使用 Gulp</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install gulp-cli -g // 全局安装 Gulp 命令行工具</div><div class=\"line\">$ npm install gulp -D // 在项目中，作为 devDependencies 依赖安装 gulp</div></pre></td></tr></table></figure>\n<h2 id=\"Gulpfile-js\"><a href=\"#Gulpfile-js\" class=\"headerlink\" title=\"Gulpfile.js\"></a>Gulpfile.js</h2><p>在使用 CLI 工具的时候，会执行该文件，它是一个可执行的 NodeJS 文件。原理上，你可以在里面运行任何 NodeJS 代码，然后通过调用 gulp 提供的 API，来执行 gulp 任务。<br><code>gulpfile.js</code>  文件一般都会放在项目的根目录中。</p>\n<p>一个使用 <strong><a href=\"https://www.npmjs.com/package/gulp-babel2/\">gulp-babel</a></strong> 插件来支持 es2015 语法的案例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">const gulp = require(&apos;gulp&apos;);</div><div class=\"line\">const babel = require(&apos;gulp-babel&apos;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;default&apos;, () =&gt; &#123;</div><div class=\"line\">    gulp.src(&apos;src/app.js&apos;)</div><div class=\"line\">        .pipe(babel(&#123;</div><div class=\"line\">            presets: [&apos;es2015&apos;]</div><div class=\"line\">        &#125;))</div><div class=\"line\">        .pipe(gulp.dest(&apos;dist&apos;));</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h1 id=\"基本概念与原理\"><a href=\"#基本概念与原理\" class=\"headerlink\" title=\"基本概念与原理\"></a>基本概念与原理</h1><p>了解这些概念，对于了解 Gulp 的工作原理，和 API 的使用是很有帮助的。</p>\n<h2 id=\"认识-Glob\"><a href=\"#认识-Glob\" class=\"headerlink\" title=\"认识 Glob\"></a>认识 Glob</h2><p>Glob 是一种用来匹配路径与文件的模式。有点类似于正则表达式，但是语法又有点差异。<br>这种模式，被广泛用于命令行、Shell 等场景，大家熟悉的 <code>.gitignore</code> 文件也是使用这种模式。</p>\n<p>各大语言都有对于 Glob 的实现，例如 Go 和 PHP 的 <code>Glob</code> 函数，Python 中的 <code>glob</code> 模块。<br>而 NodeJS 的实现是 <strong><a href=\"https://github.com/isaacs/minimatch\">minimatch</a></strong>, 而在 Gulp 源码中，就用了对 minimatch 进行封装的 <strong><a href=\"https://github.com/isaacs/node-glob\">node-glob</a></strong> 模块。<br>Gulp 的 API <code>gulp.watch</code> 和 <code>gulp.src</code> 都有用到 Glob 来匹配对应的路径和文件。<br>下面是部分语法：</p>\n<ul>\n<li><code>*</code><br>匹配该路径段中 0 个或多个任意字符，<br>如：<code>js/*.js</code>， 匹配 js 目录下的所有 js 文件</li>\n<li><code>?</code><br>匹配该路径段中 1 个任意字符，<br>如：<code>js/?.js</code>，匹配 js 目录下所有名字只有 1 个字的 js</li>\n<li><p><code>[...]</code><br>匹配该路径段中在指定范围内字符，<br>如：<code>js/a[0-3].js</code>，匹配 js 目录下 a 开头,第二个字符为 0-3 之间（ 包括0和3 ）的 js（ a03.js不能被匹配到 ）</p>\n</li>\n<li><p><code>!(pattern|pattern|pattern)</code><br>匹配除所给出的模型以外的情况，<br>如：<code>js/!(a|b).js</code>，匹配 js 目录下名字中不包含 a ,也不包含 b 的所有文件.</p>\n</li>\n<li><p><code>?(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 0 个或任意 1 个，<br>如：<code>js/?(a|a2|b).js</code>, 匹配 js 目录下 a.js , a2.js , b.js</p>\n</li>\n<li><p><code>+(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 1 个或者多个，<br>如：<code>js/+(a|a1|b).js</code>, 匹配 js 目录下 a.js , a1.js , b.js , 或者 a, a1, b 这几个字符的组合的 js , 比如 ab.js</p>\n</li>\n<li><p><code>*(pattern|pattern|pattern)</code><br>匹配所给出的模型中的 0 个或多个或任意个的组合.<br>如：<code>js/*(a|a1|b).js</code>，匹配 js 目录下 a.js, a1.js, b.js 或者 a, a1, b这几个字符的组合的 js , 比如 ab.js</p>\n</li>\n<li><p><code>@(pattern|pat*|pat?erN)</code><br>匹配所给出的模型中的任意 1 个，<br>如：<code>js/@(a|a1|b)</code>, 匹配 js 目录下的 a.js, a1.js, b.js</p>\n</li>\n<li><p><code>**</code><br>与 <code>*</code> 一样可以匹配任何内容，但 <code>**</code>不仅匹配路径中的某一段,而且可以匹配 <code>a/b/c</code> 这样带有 <code>/</code> 的内容，所以，它还可以匹配子文件夹下的文件.<br>如：<code>js/**/*.js</code>，匹配 js 目录下及子文件夹中所有的 js 文件。</p>\n</li>\n</ul>\n<p>更多 Glob 的知识和语法，可以参考：<br><a href=\"https://www.wikiwand.com/en/Glob_(programming\">Glob - Wiki</a><br><a href=\"https://github.com/isaacs/node-glob#glob-primer\">Glob Primer</a></p>\n<h2 id=\"认识-Vinyl\"><a href=\"#认识-Vinyl\" class=\"headerlink\" title=\"认识 Vinyl\"></a>认识 Vinyl</h2><p><a href=\"https://github.com/gulpjs/vinyl\">Vinyl</a> 是 Gulp 自创的一种用来描述一个虚拟文件的类，其中主要包括文件的内容和文件的路径两大信息。vinyl 模块，只是提供了一个类，而实现却交由 <code>vinyl-fs</code></p>\n<p><a href=\"https://github.com/gulpjs/vinyl-fs\">Vinyl-fs</a>，它主要的工作是接受 glob 模式的参数，然后读取匹配的文件。然后利用 Vinyl 制作一个 Transform Stream，称为 Vinyl Stream 对象，并返回。</p>\n<p>在 Gulp 中的 API <code>gulp.src</code>、<code>gulp.watch</code>、<code>gulp.dest</code> 都返回一个 Vinyl Stream 实例对象。Vinyl Stream 实例之间可以通过管道（ <code>vinyl1.pipe(vinyl2)</code> ）的形式来互相传输数据。 </p>\n<p>从 Gulp 的 <a href=\"https://github.com/gulpjs/gulp/blob/master/index.js#L25-L41\">源码</a> 中也能看出，这三个 API 都是由 vinyl-fs 提供全部的实现。</p>\n<p>再一点是，从这两个模块的实现来看，Gulp 是把文件内容以 Buffer 的形式读到内存中，然后再进行处理的。</p>\n<h2 id=\"认识-Orchestrator\"><a href=\"#认识-Orchestrator\" class=\"headerlink\" title=\"认识 Orchestrator\"></a>认识 Orchestrator</h2><p><a href=\"https://github.com/robrich/orchestrator\">Orchestartor</a>，为 <code>gulp.task</code> 提供了全部实现，这可以从 <a href=\"https://github.com/gulpjs/gulp/blob/master/index.js#L14\">源码</a> 中看出。<br>它为 Gulp 提供了任务相关的功能，包括任务注册、任务执行以及相对应的任务进度、错误监控等功能。</p>\n<p>Orchestartor 模块，只提供了一个 Orchestartor 类，该类的实例维护着一个 tasks 数组，该数组的内容就是一个我们使用 <code>gulp.task</code> 时注册的函数列表，以及函数的依赖和名字。<br>通过 <a href=\"https://github.com/robrich/orchestrator/blob/master/index.js#L54-L57\">源码</a> 中，可以看到 tasks 的数据结构：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">this.tasks[name] = &#123;</div><div class=\"line\">  <span class=\"attr\">fn</span>: fn,   <span class=\"comment\">// 任务的函数体</span></div><div class=\"line\">  dep: dep,   <span class=\"comment\">// 任务所依赖的其他任务名称</span></div><div class=\"line\">  name: name  <span class=\"comment\">// 该任务的名称</span></div><div class=\"line\">&#125;;</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h1 id=\"Gulp-核心-API\"><a href=\"#Gulp-核心-API\" class=\"headerlink\" title=\"Gulp 核心 API\"></a>Gulp 核心 API</h1><ul>\n<li>gulp.src：获取文件</li>\n<li>gulp.dest：写入文件</li>\n<li>gulp.tasks：注册任务</li>\n<li>gulp.watch：监控文件的改动</li>\n</ul>\n<h2 id=\"gulp-src\"><a href=\"#gulp-src\" class=\"headerlink\" title=\"gulp.src\"></a>gulp.src</h2><p><code>gulp.src( globs [, options] )</code></p>\n<p>接收一个 globs 模式的对象，可以是 Array 或者 String，返回一个 Vinyl Stream 实例。<br>而 options 有下面的值：</p>\n<ul>\n<li>buffer - Boolean, 控制 <code>file.contents</code> 是返回 buffer 还是 stream。</li>\n<li>read - Boolean，控制是否读取文件，如果 false，则 <code>file.contents</code> 为 <code>null</code></li>\n<li>base - String，控制 glob 的 base，默认值是 glob 所有表达式的前置，例如 <code>client/js/**/*.js</code>, base 值就为 <code>client/js/</code>。而 glob 在保存输出路径的时候，取的是 base 之后的路径。所以可以通过该值，来进行输出路径的改写。</li>\n</ul>\n<h2 id=\"gulp-dest\"><a href=\"#gulp-dest\" class=\"headerlink\" title=\"gulp.dest\"></a>gulp.dest</h2><p><code>gulp.dest( path [, options] )</code></p>\n<p>接收输出路径，返回一个 Vinyl Stream 实例。<br>而 options 有以下的值：</p>\n<ul>\n<li>cwd - String， 默认值 <code>process.pwd()</code>，输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。</li>\n<li>mode -  String，八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。</li>\n</ul>\n<h2 id=\"gulp-task\"><a href=\"#gulp-task\" class=\"headerlink\" title=\"gulp.task\"></a>gulp.task</h2><p><code>gulp.task( name [, deps ], fn )</code></p>\n<p>定义一个使用 Orchestrator 实现的任务（task）。<br>参数的描述如下：</p>\n<ul>\n<li>name - 任务名称</li>\n<li>deps - 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数</li>\n<li>fn - 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。</li>\n</ul>\n<h2 id=\"gulp-watch\"><a href=\"#gulp-watch\" class=\"headerlink\" title=\"gulp.watch\"></a>gulp.watch</h2><p><code>gulp.watch( glob [, opts ], tasks )</code><br>or<br><code>gulp.watch( glob [, opts, cb ] )</code></p>\n<p>用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务。<br>各参数的描述如下：</p>\n<ul>\n<li>glob - 为要监视的文件 Glob 匹配模式。</li>\n<li>opts - 为一个可选的配置对象。</li>\n<li>tasks - 为文件变化后要执行的任务，为一个数组</li>\n</ul>\n<h1 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件\"></a>常用插件</h1><ul>\n<li><a href=\"https://www.npmjs.com/package/gulp-load-plugins\">gulp-load-plugins</a>：自动加载 <code>package.json</code> 中的 gulp 插件</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-rename\">gulp-rename</a>： 重命名</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-uglify\">gulp-uglify</a>：文件压缩</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-concat\">gulp-concat</a>：文件合并</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-less\">gulp-less</a>：编译 less</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-sass\">gulp-sass</a>：编译 sass</li>\n<li><a href=\"https://github.com/scniro/gulp-clean-css\">gulp-clean-css</a>：压缩 CSS 文件</li>\n<li><a href=\"https://github.com/jonschlinkert/gulp-htmlmin\">gulp-htmlmin</a>：压缩 HTML 文件</li>\n<li><a href=\"https://github.com/babel/gulp-babel\">gulp-babel</a>: 使用 babel 编译 JS 文件</li>\n<li><a href=\"https://www.npmjs.com/package/gulp-jshint\">gulp-jshint</a>：jshint 检查</li>\n<li><a href=\"https://github.com/sindresorhus/gulp-imagemin\">gulp-imagemin</a>：压缩jpg、png、gif等图片</li>\n<li><a href=\"https://github.com/vohof/gulp-livereload\">gulp-livereload</a>：当代码变化时，它可以帮我们自动刷新页面</li>\n</ul>\n<p>更多插件，可以搜索<a href=\"http://gulpjs.com/plugins/\">官方插件库</a>。</p>\n"},{"title":"JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS","date":"2016-11-08T02:36:00.000Z","_content":"\n\n# Motivation\nJavaScript 是一款拥有「自动垃圾回收」功能的编程语言。\n市面上具有这样功能的语言，一般都是拥有相对应的虚拟机的，像 Java的JVM ，C#的CLR ，PHP的Zend。\n虚拟机一般实现了代码解析，内存的管理、布局、垃圾回收等功能。\n不像C/C++这种没有虚拟机的语言，它们需要手动管理内存。\nC/C++语言编译后的文件，是可以直接运行的。\n\n我认为学习一门开发语言，除了知道一些语法上的使用，各种API的调用以外。学习相应的虚拟机也是很有必要的。而 JavaScript 由于其特殊的历史原因，并不是只有 V8 一个引擎。但是目前 V8 它是业界最优秀的 JavaScript 引擎，也就成为了一个学习样本。\n\n如今的 JavaScript 不仅仅是用在浏览器端了，也因为 NodeJS 的关系得以在服务器端运行。和浏览器端不同的地方在于服务器端对资源的敏感性是很高的。当业务规模大了，并发量上来了，一些很细小的问题会放大。这时候一些小小的内存泄漏，都会酿造灾难。\n\n所以作为一个 JavaScript 开发者，搞清楚从敲入 `console.log('hello   world')`，直到后面交由CPU执行的中间过程是很重要的。\n这也对如何用 JavaScript 这门松散的语言编写出高质量的代码是具有指导作用的。\n\n想真正做到 JavaScript 全栈，路漫漫其修远兮。\n\n# V8 概述\nV8 作为一个 JavaScript 引擎，最初是服役于 Google Chrome 浏览器的。它随着 Chrome 的第一版发布而发布以及开源。现在它除了 Chrome 浏览器，已经有很多其他的使用者了。诸如 NodeJS、MongoDB、CouchDB 等。\n\nJavaScript 作为 Prototype-Based Language , 基于它使用 Prototype 继承的特征，V8 使用了直译的方式，即把 JavaScript 代码直接编译成机器码( Machine Code, 有些地方也叫 Native Code )，然后直接交由硬件执行。\n与传统的「编译-解析-执行」的流程不同，V8 处理 JavaScript，并没有二进制码或其他的中间码。\n\n** 简单来说，V8主要工作就是：「把 JavaScript 直译成机器码，然后运行」**\n但这中间，往往是一个复杂的过程，它需要处理很多的难题，诸如：\n1. 编译优化\n2. 内存管理\n3. 垃圾回收\n\n我写的这一系列文章，也是从这三个大点来出发，解读V8针对这些内容的处理。\n\n# V8 In NodeJS\n\n## NodeJS源码小览\n\nNodeJS，是怎么引入V8的？\n我们关注[Node的源码](https://github.com/nodejs/node)目录：\n\n```\n.\n├── ...\n├── deps\n│   ├── ...\n│   ├── v8\n│   ├── ...\n├── ...\n├── lib\n│   ├── ...\n│   ├── buffer.js\n│   ├── child_process.js\n│   ├── console.js\n│   ├── ...\n├── node -> out/Release/node\n├── ...\n├── out\n│   ├── ...\n│   ├── Release\n|         ├── node\n|         ├── node.d\n|         ├── obj\n|             └── gen\n|                 ├── ...\n|                 ├── node_natives.h\n|                 ├── ...\n│   ├── ...\n├── src\n│   ├── ...\n│   ├── debug-agent.cc\n│   ├── debug-agent.h\n│   ├── env-inl.h\n│   ├── env.cc\n│   ├── ...\n├── \n...\n```\n\n需要关注的几个目录和文件：\n\n**`/deps/v8`**：这里是V8源码所在文件夹，你会发现里面的目录结构跟[V8源码](https://github.com/v8/v8)十分相似。NodeJS除了移植V8源码，还在增添了一些内容。\n\n**`/src`**：由C/C++编写的核心模块所在文件夹，由C/C++编写的这部分模块被称为「Builtin Module」\n\n**`/lib`**：由JavaScript编写的核心模块所在文件夹，这部分被称为「Native Code」，在编译Node源码的时候，会采用V8附带的`js2c.py`工具，把所有内置的JavaScript代码转换成C++里面的数组，生成`out/Release/obj/gen/node_natives.h`文件。有些 Native Module 需要借助于 Builtin Module 实现背后的功能。\n\n**`/out`**：该目录是Node源码编译(命令行运行`make`)后生成的目录，里面包含了Node的可执行文件。当在命令行中键入`node xxx.js`，实际就是运行了`out/Release/node`文件。\n\n来张图说明一下V8在Node运行时的整体过程。\n\n![v8 in nodejs.png](/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png)\n\nNode在启动的时候，就已经把 Native Module，Builtin Module 加载到内存里面了。后来的 JavaScript 代码，就需要通过 V8 进行动态编译解析运行。\n\n## 查看V8版本号\n\nNodeJS的进步与V8息息相关，关注每个NodeJS版本所对应的V8版本，可以加强该版本新功能的理解和由来。\n\n在NodeJS中，通过`process.versions`可以查看NodeJS依赖模块的版本号，V8就包含其中。\n\n例如，我运行的 `v7.0.0`的NodeJS：\n```\n$ node\n> process.versions\n{ http_parser: '2.7.0',\n  node: '8.0.0-pre',\n  v8: '5.4.500.36',\n  uv: '1.10.0',\n  zlib: '1.2.8',\n  ares: '1.10.1-DEV',\n  modules: '51',\n  openssl: '1.0.2j',\n  icu: '58.1',\n  unicode: '9.0',\n  cldr: '30.0.2',\n  tz: '2016g' }\n```\n\n# NodeJS与V8的缠绵\n\n- 2008年9月，V8 的第一个版本随着 Chrome 的第一版本发布。\n- 2009年5月，NodeJS 的第一个版本由 Ryan Dahl 在 GitHub 上发布。\n- 2010年12月，[官方公布](https://blog.chromium.org/2010/12/new-crankshaft-for-v8.html) V8 的名为 Crankshaft 的优化编译器，与原来的 Full Compiler 一起工作，声称较2008年版本提高50%性能。\n- 2014年12月， io.js 从久久不更新的 NodeJS 分出来支，并且引入最新的 V8 ，这时候 NodeJS 处于`0.12.17`版本。\n- 2015年2月，NodeJS基金宣布NodeJS(`v0.12`)和io.js(`v3.3`)合并，合并版本在未来发布。\n- 2015年7月7日，[官方公布](https://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html)又一个新的名为TurBoFan的优化编译器，主要提供ES6的新语法，以及提高性能。并表明该编译器最终目标是全部替代Crankshaft编译器\n- 2015年7月17日，[官方发布](http://v8project.blogspot.com/2015/07/v8-45-release.html)集成TurboFan的V8版本(`v4.5`)\n- 2015年9月08日，NodeJS紧跟着[发布](https://nodejs.org/en/blog/release/v4.0.0/)了与io.js的合并版本(`V4.0`)，引入最新的V8，给开发者们带来了最新的ES6语法，以及性能上的提高。\n- 2015年8月28日，V8[发布](http://v8project.blogspot.com/2015/08/v8-release-46.html)`v4.6`版本\n- 2015年10月29日，NodeJS[发布](https://nodejs.org/en/blog/release/v5.0.0/)`V5.0.0`版本\n- 2016年3月15日，V8[发布](http://v8project.blogspot.com/2016/03/v8-release-50.html)`v5.0`版本\n- 2016年4月26日，NodeJS[发布](https://nodejs.org/en/blog/release/v6.0.0/)`V6.0.0`版本\n- 2016年7月18日，V8[发布](http://v8project.blogspot.com/2016/07/v8-release-53.html)`v5.3`版本，新增名为Ignition的解析器(Interpreter)，跟原有的优化编译器(Crankshaft and TurboFan)进行串联工作，提供了更加优化的内存使用方案，主要针对于低内存的Android设备，并称在未来会普及到全平台。\n- 2016年10月25日，NodeJS[发布](https://nodejs.org/en/blog/release/v7.0.0/)`v7.0.0`版本\n- 截止到今天(2016年11月)，NodeJS版本`v7.0.0`，搭配了`v5.4`的v8，而官方发布的最新v8版本是`v5.5`。\n\n回顾整个历程，由于NodeJS是搭建在V8之上的，所以NodeJS很多「新增语言特性」和「提高性能」等更新都需要依赖V8的发布日程。\n\n就像NodeJS和io.js宣布合并，和真正发布`V4.0`版本的中间，还隔了V8的生命历程一个重大的更新(发布 TurboFan 编译器，该编译器引入了大量的ES6语法支持。)。这个更新直接提供了相当一部分的ES6语法，以及性能上的提高。\n\n# 总结\n本篇主要描述了下面几点：\n1. 我的写作动机，理解NodeJS底层，给写出高质量JavaScript代码提供指导。\n2. 简单描述V8的角色，以及主要职责：编译优化、内存管理、垃圾回收。\n3. 通过NodeJS源码目录，以及NodeJS代码加载过程，来认识V8在这之中的位置。\n4. 罗列NodeJS与V8的历代迭代版本以及联系，强调V8在NodeJS中的地位。","source":"_posts/the-v8-what-javascripter-should-konw-of-v8-in-nodejs.md","raw":"---\ntitle: JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS\ndate: 2016-11-08 10:36:00\ntags:\n- Javascript\n- v8\n- NodeJS\ncategory: 搬砖码农\n---\n\n\n# Motivation\nJavaScript 是一款拥有「自动垃圾回收」功能的编程语言。\n市面上具有这样功能的语言，一般都是拥有相对应的虚拟机的，像 Java的JVM ，C#的CLR ，PHP的Zend。\n虚拟机一般实现了代码解析，内存的管理、布局、垃圾回收等功能。\n不像C/C++这种没有虚拟机的语言，它们需要手动管理内存。\nC/C++语言编译后的文件，是可以直接运行的。\n\n我认为学习一门开发语言，除了知道一些语法上的使用，各种API的调用以外。学习相应的虚拟机也是很有必要的。而 JavaScript 由于其特殊的历史原因，并不是只有 V8 一个引擎。但是目前 V8 它是业界最优秀的 JavaScript 引擎，也就成为了一个学习样本。\n\n如今的 JavaScript 不仅仅是用在浏览器端了，也因为 NodeJS 的关系得以在服务器端运行。和浏览器端不同的地方在于服务器端对资源的敏感性是很高的。当业务规模大了，并发量上来了，一些很细小的问题会放大。这时候一些小小的内存泄漏，都会酿造灾难。\n\n所以作为一个 JavaScript 开发者，搞清楚从敲入 `console.log('hello   world')`，直到后面交由CPU执行的中间过程是很重要的。\n这也对如何用 JavaScript 这门松散的语言编写出高质量的代码是具有指导作用的。\n\n想真正做到 JavaScript 全栈，路漫漫其修远兮。\n\n# V8 概述\nV8 作为一个 JavaScript 引擎，最初是服役于 Google Chrome 浏览器的。它随着 Chrome 的第一版发布而发布以及开源。现在它除了 Chrome 浏览器，已经有很多其他的使用者了。诸如 NodeJS、MongoDB、CouchDB 等。\n\nJavaScript 作为 Prototype-Based Language , 基于它使用 Prototype 继承的特征，V8 使用了直译的方式，即把 JavaScript 代码直接编译成机器码( Machine Code, 有些地方也叫 Native Code )，然后直接交由硬件执行。\n与传统的「编译-解析-执行」的流程不同，V8 处理 JavaScript，并没有二进制码或其他的中间码。\n\n** 简单来说，V8主要工作就是：「把 JavaScript 直译成机器码，然后运行」**\n但这中间，往往是一个复杂的过程，它需要处理很多的难题，诸如：\n1. 编译优化\n2. 内存管理\n3. 垃圾回收\n\n我写的这一系列文章，也是从这三个大点来出发，解读V8针对这些内容的处理。\n\n# V8 In NodeJS\n\n## NodeJS源码小览\n\nNodeJS，是怎么引入V8的？\n我们关注[Node的源码](https://github.com/nodejs/node)目录：\n\n```\n.\n├── ...\n├── deps\n│   ├── ...\n│   ├── v8\n│   ├── ...\n├── ...\n├── lib\n│   ├── ...\n│   ├── buffer.js\n│   ├── child_process.js\n│   ├── console.js\n│   ├── ...\n├── node -> out/Release/node\n├── ...\n├── out\n│   ├── ...\n│   ├── Release\n|         ├── node\n|         ├── node.d\n|         ├── obj\n|             └── gen\n|                 ├── ...\n|                 ├── node_natives.h\n|                 ├── ...\n│   ├── ...\n├── src\n│   ├── ...\n│   ├── debug-agent.cc\n│   ├── debug-agent.h\n│   ├── env-inl.h\n│   ├── env.cc\n│   ├── ...\n├── \n...\n```\n\n需要关注的几个目录和文件：\n\n**`/deps/v8`**：这里是V8源码所在文件夹，你会发现里面的目录结构跟[V8源码](https://github.com/v8/v8)十分相似。NodeJS除了移植V8源码，还在增添了一些内容。\n\n**`/src`**：由C/C++编写的核心模块所在文件夹，由C/C++编写的这部分模块被称为「Builtin Module」\n\n**`/lib`**：由JavaScript编写的核心模块所在文件夹，这部分被称为「Native Code」，在编译Node源码的时候，会采用V8附带的`js2c.py`工具，把所有内置的JavaScript代码转换成C++里面的数组，生成`out/Release/obj/gen/node_natives.h`文件。有些 Native Module 需要借助于 Builtin Module 实现背后的功能。\n\n**`/out`**：该目录是Node源码编译(命令行运行`make`)后生成的目录，里面包含了Node的可执行文件。当在命令行中键入`node xxx.js`，实际就是运行了`out/Release/node`文件。\n\n来张图说明一下V8在Node运行时的整体过程。\n\n![v8 in nodejs.png](/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png)\n\nNode在启动的时候，就已经把 Native Module，Builtin Module 加载到内存里面了。后来的 JavaScript 代码，就需要通过 V8 进行动态编译解析运行。\n\n## 查看V8版本号\n\nNodeJS的进步与V8息息相关，关注每个NodeJS版本所对应的V8版本，可以加强该版本新功能的理解和由来。\n\n在NodeJS中，通过`process.versions`可以查看NodeJS依赖模块的版本号，V8就包含其中。\n\n例如，我运行的 `v7.0.0`的NodeJS：\n```\n$ node\n> process.versions\n{ http_parser: '2.7.0',\n  node: '8.0.0-pre',\n  v8: '5.4.500.36',\n  uv: '1.10.0',\n  zlib: '1.2.8',\n  ares: '1.10.1-DEV',\n  modules: '51',\n  openssl: '1.0.2j',\n  icu: '58.1',\n  unicode: '9.0',\n  cldr: '30.0.2',\n  tz: '2016g' }\n```\n\n# NodeJS与V8的缠绵\n\n- 2008年9月，V8 的第一个版本随着 Chrome 的第一版本发布。\n- 2009年5月，NodeJS 的第一个版本由 Ryan Dahl 在 GitHub 上发布。\n- 2010年12月，[官方公布](https://blog.chromium.org/2010/12/new-crankshaft-for-v8.html) V8 的名为 Crankshaft 的优化编译器，与原来的 Full Compiler 一起工作，声称较2008年版本提高50%性能。\n- 2014年12月， io.js 从久久不更新的 NodeJS 分出来支，并且引入最新的 V8 ，这时候 NodeJS 处于`0.12.17`版本。\n- 2015年2月，NodeJS基金宣布NodeJS(`v0.12`)和io.js(`v3.3`)合并，合并版本在未来发布。\n- 2015年7月7日，[官方公布](https://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html)又一个新的名为TurBoFan的优化编译器，主要提供ES6的新语法，以及提高性能。并表明该编译器最终目标是全部替代Crankshaft编译器\n- 2015年7月17日，[官方发布](http://v8project.blogspot.com/2015/07/v8-45-release.html)集成TurboFan的V8版本(`v4.5`)\n- 2015年9月08日，NodeJS紧跟着[发布](https://nodejs.org/en/blog/release/v4.0.0/)了与io.js的合并版本(`V4.0`)，引入最新的V8，给开发者们带来了最新的ES6语法，以及性能上的提高。\n- 2015年8月28日，V8[发布](http://v8project.blogspot.com/2015/08/v8-release-46.html)`v4.6`版本\n- 2015年10月29日，NodeJS[发布](https://nodejs.org/en/blog/release/v5.0.0/)`V5.0.0`版本\n- 2016年3月15日，V8[发布](http://v8project.blogspot.com/2016/03/v8-release-50.html)`v5.0`版本\n- 2016年4月26日，NodeJS[发布](https://nodejs.org/en/blog/release/v6.0.0/)`V6.0.0`版本\n- 2016年7月18日，V8[发布](http://v8project.blogspot.com/2016/07/v8-release-53.html)`v5.3`版本，新增名为Ignition的解析器(Interpreter)，跟原有的优化编译器(Crankshaft and TurboFan)进行串联工作，提供了更加优化的内存使用方案，主要针对于低内存的Android设备，并称在未来会普及到全平台。\n- 2016年10月25日，NodeJS[发布](https://nodejs.org/en/blog/release/v7.0.0/)`v7.0.0`版本\n- 截止到今天(2016年11月)，NodeJS版本`v7.0.0`，搭配了`v5.4`的v8，而官方发布的最新v8版本是`v5.5`。\n\n回顾整个历程，由于NodeJS是搭建在V8之上的，所以NodeJS很多「新增语言特性」和「提高性能」等更新都需要依赖V8的发布日程。\n\n就像NodeJS和io.js宣布合并，和真正发布`V4.0`版本的中间，还隔了V8的生命历程一个重大的更新(发布 TurboFan 编译器，该编译器引入了大量的ES6语法支持。)。这个更新直接提供了相当一部分的ES6语法，以及性能上的提高。\n\n# 总结\n本篇主要描述了下面几点：\n1. 我的写作动机，理解NodeJS底层，给写出高质量JavaScript代码提供指导。\n2. 简单描述V8的角色，以及主要职责：编译优化、内存管理、垃圾回收。\n3. 通过NodeJS源码目录，以及NodeJS代码加载过程，来认识V8在这之中的位置。\n4. 罗列NodeJS与V8的历代迭代版本以及联系，强调V8在NodeJS中的地位。","slug":"the-v8-what-javascripter-should-konw-of-v8-in-nodejs","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwpy001815hlhpy5upw0","content":"<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h1><p>JavaScript 是一款拥有「自动垃圾回收」功能的编程语言。<br>市面上具有这样功能的语言，一般都是拥有相对应的虚拟机的，像 Java的JVM ，C#的CLR ，PHP的Zend。<br>虚拟机一般实现了代码解析，内存的管理、布局、垃圾回收等功能。<br>不像C/C++这种没有虚拟机的语言，它们需要手动管理内存。<br>C/C++语言编译后的文件，是可以直接运行的。</p>\n<p>我认为学习一门开发语言，除了知道一些语法上的使用，各种API的调用以外。学习相应的虚拟机也是很有必要的。而 JavaScript 由于其特殊的历史原因，并不是只有 V8 一个引擎。但是目前 V8 它是业界最优秀的 JavaScript 引擎，也就成为了一个学习样本。</p>\n<p>如今的 JavaScript 不仅仅是用在浏览器端了，也因为 NodeJS 的关系得以在服务器端运行。和浏览器端不同的地方在于服务器端对资源的敏感性是很高的。当业务规模大了，并发量上来了，一些很细小的问题会放大。这时候一些小小的内存泄漏，都会酿造灾难。</p>\n<p>所以作为一个 JavaScript 开发者，搞清楚从敲入 <code>console.log(&#39;hello   world&#39;)</code>，直到后面交由CPU执行的中间过程是很重要的。<br>这也对如何用 JavaScript 这门松散的语言编写出高质量的代码是具有指导作用的。</p>\n<p>想真正做到 JavaScript 全栈，路漫漫其修远兮。</p>\n<h1 id=\"V8-概述\"><a href=\"#V8-概述\" class=\"headerlink\" title=\"V8 概述\"></a>V8 概述</h1><p>V8 作为一个 JavaScript 引擎，最初是服役于 Google Chrome 浏览器的。它随着 Chrome 的第一版发布而发布以及开源。现在它除了 Chrome 浏览器，已经有很多其他的使用者了。诸如 NodeJS、MongoDB、CouchDB 等。</p>\n<p>JavaScript 作为 Prototype-Based Language , 基于它使用 Prototype 继承的特征，V8 使用了直译的方式，即把 JavaScript 代码直接编译成机器码( Machine Code, 有些地方也叫 Native Code )，然后直接交由硬件执行。<br>与传统的「编译-解析-执行」的流程不同，V8 处理 JavaScript，并没有二进制码或其他的中间码。</p>\n<p><strong> 简单来说，V8主要工作就是：「把 JavaScript 直译成机器码，然后运行」</strong><br>但这中间，往往是一个复杂的过程，它需要处理很多的难题，诸如：</p>\n<ol>\n<li>编译优化</li>\n<li>内存管理</li>\n<li>垃圾回收</li>\n</ol>\n<p>我写的这一系列文章，也是从这三个大点来出发，解读V8针对这些内容的处理。</p>\n<h1 id=\"V8-In-NodeJS\"><a href=\"#V8-In-NodeJS\" class=\"headerlink\" title=\"V8 In NodeJS\"></a>V8 In NodeJS</h1><h2 id=\"NodeJS源码小览\"><a href=\"#NodeJS源码小览\" class=\"headerlink\" title=\"NodeJS源码小览\"></a>NodeJS源码小览</h2><p>NodeJS，是怎么引入V8的？<br>我们关注<a href=\"https://github.com/nodejs/node\" target=\"_blank\" rel=\"external\">Node的源码</a>目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── ...</div><div class=\"line\">├── deps</div><div class=\"line\">│   ├── ...</div><div class=\"line\">│   ├── v8</div><div class=\"line\">│   ├── ...</div><div class=\"line\">├── ...</div><div class=\"line\">├── lib</div><div class=\"line\">│   ├── ...</div><div class=\"line\">│   ├── buffer.js</div><div class=\"line\">│   ├── child_process.js</div><div class=\"line\">│   ├── console.js</div><div class=\"line\">│   ├── ...</div><div class=\"line\">├── node -&gt; out/Release/node</div><div class=\"line\">├── ...</div><div class=\"line\">├── out</div><div class=\"line\">│   ├── ...</div><div class=\"line\">│   ├── Release</div><div class=\"line\">|         ├── node</div><div class=\"line\">|         ├── node.d</div><div class=\"line\">|         ├── obj</div><div class=\"line\">|             └── gen</div><div class=\"line\">|                 ├── ...</div><div class=\"line\">|                 ├── node_natives.h</div><div class=\"line\">|                 ├── ...</div><div class=\"line\">│   ├── ...</div><div class=\"line\">├── src</div><div class=\"line\">│   ├── ...</div><div class=\"line\">│   ├── debug-agent.cc</div><div class=\"line\">│   ├── debug-agent.h</div><div class=\"line\">│   ├── env-inl.h</div><div class=\"line\">│   ├── env.cc</div><div class=\"line\">│   ├── ...</div><div class=\"line\">├── </div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>需要关注的几个目录和文件：</p>\n<p><strong><code>/deps/v8</code></strong>：这里是V8源码所在文件夹，你会发现里面的目录结构跟<a href=\"https://github.com/v8/v8\" target=\"_blank\" rel=\"external\">V8源码</a>十分相似。NodeJS除了移植V8源码，还在增添了一些内容。</p>\n<p><strong><code>/src</code></strong>：由C/C++编写的核心模块所在文件夹，由C/C++编写的这部分模块被称为「Builtin Module」</p>\n<p><strong><code>/lib</code></strong>：由JavaScript编写的核心模块所在文件夹，这部分被称为「Native Code」，在编译Node源码的时候，会采用V8附带的<code>js2c.py</code>工具，把所有内置的JavaScript代码转换成C++里面的数组，生成<code>out/Release/obj/gen/node_natives.h</code>文件。有些 Native Module 需要借助于 Builtin Module 实现背后的功能。</p>\n<p><strong><code>/out</code></strong>：该目录是Node源码编译(命令行运行<code>make</code>)后生成的目录，里面包含了Node的可执行文件。当在命令行中键入<code>node xxx.js</code>，实际就是运行了<code>out/Release/node</code>文件。</p>\n<p>来张图说明一下V8在Node运行时的整体过程。</p>\n<p><img src=\"/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png\" alt=\"v8 in nodejs.png\"></p>\n<p>Node在启动的时候，就已经把 Native Module，Builtin Module 加载到内存里面了。后来的 JavaScript 代码，就需要通过 V8 进行动态编译解析运行。</p>\n<h2 id=\"查看V8版本号\"><a href=\"#查看V8版本号\" class=\"headerlink\" title=\"查看V8版本号\"></a>查看V8版本号</h2><p>NodeJS的进步与V8息息相关，关注每个NodeJS版本所对应的V8版本，可以加强该版本新功能的理解和由来。</p>\n<p>在NodeJS中，通过<code>process.versions</code>可以查看NodeJS依赖模块的版本号，V8就包含其中。</p>\n<p>例如，我运行的 <code>v7.0.0</code>的NodeJS：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node</div><div class=\"line\">&gt; process.versions</div><div class=\"line\">&#123; http_parser: &apos;2.7.0&apos;,</div><div class=\"line\">  node: &apos;8.0.0-pre&apos;,</div><div class=\"line\">  v8: &apos;5.4.500.36&apos;,</div><div class=\"line\">  uv: &apos;1.10.0&apos;,</div><div class=\"line\">  zlib: &apos;1.2.8&apos;,</div><div class=\"line\">  ares: &apos;1.10.1-DEV&apos;,</div><div class=\"line\">  modules: &apos;51&apos;,</div><div class=\"line\">  openssl: &apos;1.0.2j&apos;,</div><div class=\"line\">  icu: &apos;58.1&apos;,</div><div class=\"line\">  unicode: &apos;9.0&apos;,</div><div class=\"line\">  cldr: &apos;30.0.2&apos;,</div><div class=\"line\">  tz: &apos;2016g&apos; &#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"NodeJS与V8的缠绵\"><a href=\"#NodeJS与V8的缠绵\" class=\"headerlink\" title=\"NodeJS与V8的缠绵\"></a>NodeJS与V8的缠绵</h1><ul>\n<li>2008年9月，V8 的第一个版本随着 Chrome 的第一版本发布。</li>\n<li>2009年5月，NodeJS 的第一个版本由 Ryan Dahl 在 GitHub 上发布。</li>\n<li>2010年12月，<a href=\"https://blog.chromium.org/2010/12/new-crankshaft-for-v8.html\" target=\"_blank\" rel=\"external\">官方公布</a> V8 的名为 Crankshaft 的优化编译器，与原来的 Full Compiler 一起工作，声称较2008年版本提高50%性能。</li>\n<li>2014年12月， io.js 从久久不更新的 NodeJS 分出来支，并且引入最新的 V8 ，这时候 NodeJS 处于<code>0.12.17</code>版本。</li>\n<li>2015年2月，NodeJS基金宣布NodeJS(<code>v0.12</code>)和io.js(<code>v3.3</code>)合并，合并版本在未来发布。</li>\n<li>2015年7月7日，<a href=\"https://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html\" target=\"_blank\" rel=\"external\">官方公布</a>又一个新的名为TurBoFan的优化编译器，主要提供ES6的新语法，以及提高性能。并表明该编译器最终目标是全部替代Crankshaft编译器</li>\n<li>2015年7月17日，<a href=\"http://v8project.blogspot.com/2015/07/v8-45-release.html\" target=\"_blank\" rel=\"external\">官方发布</a>集成TurboFan的V8版本(<code>v4.5</code>)</li>\n<li>2015年9月08日，NodeJS紧跟着<a href=\"https://nodejs.org/en/blog/release/v4.0.0/\" target=\"_blank\" rel=\"external\">发布</a>了与io.js的合并版本(<code>V4.0</code>)，引入最新的V8，给开发者们带来了最新的ES6语法，以及性能上的提高。</li>\n<li>2015年8月28日，V8<a href=\"http://v8project.blogspot.com/2015/08/v8-release-46.html\" target=\"_blank\" rel=\"external\">发布</a><code>v4.6</code>版本</li>\n<li>2015年10月29日，NodeJS<a href=\"https://nodejs.org/en/blog/release/v5.0.0/\" target=\"_blank\" rel=\"external\">发布</a><code>V5.0.0</code>版本</li>\n<li>2016年3月15日，V8<a href=\"http://v8project.blogspot.com/2016/03/v8-release-50.html\" target=\"_blank\" rel=\"external\">发布</a><code>v5.0</code>版本</li>\n<li>2016年4月26日，NodeJS<a href=\"https://nodejs.org/en/blog/release/v6.0.0/\" target=\"_blank\" rel=\"external\">发布</a><code>V6.0.0</code>版本</li>\n<li>2016年7月18日，V8<a href=\"http://v8project.blogspot.com/2016/07/v8-release-53.html\" target=\"_blank\" rel=\"external\">发布</a><code>v5.3</code>版本，新增名为Ignition的解析器(Interpreter)，跟原有的优化编译器(Crankshaft and TurboFan)进行串联工作，提供了更加优化的内存使用方案，主要针对于低内存的Android设备，并称在未来会普及到全平台。</li>\n<li>2016年10月25日，NodeJS<a href=\"https://nodejs.org/en/blog/release/v7.0.0/\" target=\"_blank\" rel=\"external\">发布</a><code>v7.0.0</code>版本</li>\n<li>截止到今天(2016年11月)，NodeJS版本<code>v7.0.0</code>，搭配了<code>v5.4</code>的v8，而官方发布的最新v8版本是<code>v5.5</code>。</li>\n</ul>\n<p>回顾整个历程，由于NodeJS是搭建在V8之上的，所以NodeJS很多「新增语言特性」和「提高性能」等更新都需要依赖V8的发布日程。</p>\n<p>就像NodeJS和io.js宣布合并，和真正发布<code>V4.0</code>版本的中间，还隔了V8的生命历程一个重大的更新(发布 TurboFan 编译器，该编译器引入了大量的ES6语法支持。)。这个更新直接提供了相当一部分的ES6语法，以及性能上的提高。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本篇主要描述了下面几点：</p>\n<ol>\n<li>我的写作动机，理解NodeJS底层，给写出高质量JavaScript代码提供指导。</li>\n<li>简单描述V8的角色，以及主要职责：编译优化、内存管理、垃圾回收。</li>\n<li>通过NodeJS源码目录，以及NodeJS代码加载过程，来认识V8在这之中的位置。</li>\n<li>罗列NodeJS与V8的历代迭代版本以及联系，强调V8在NodeJS中的地位。</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h1><p>JavaScript 是一款拥有「自动垃圾回收」功能的编程语言。<br>市面上具有这样功能的语言，一般都是拥有相对应的虚拟机的，像 Java的JVM ，C#的CLR ，PHP的Zend。<br>虚拟机一般实现了代码解析，内存的管理、布局、垃圾回收等功能。<br>不像C/C++这种没有虚拟机的语言，它们需要手动管理内存。<br>C/C++语言编译后的文件，是可以直接运行的。</p>\n<p>我认为学习一门开发语言，除了知道一些语法上的使用，各种API的调用以外。学习相应的虚拟机也是很有必要的。而 JavaScript 由于其特殊的历史原因，并不是只有 V8 一个引擎。但是目前 V8 它是业界最优秀的 JavaScript 引擎，也就成为了一个学习样本。</p>\n<p>如今的 JavaScript 不仅仅是用在浏览器端了，也因为 NodeJS 的关系得以在服务器端运行。和浏览器端不同的地方在于服务器端对资源的敏感性是很高的。当业务规模大了，并发量上来了，一些很细小的问题会放大。这时候一些小小的内存泄漏，都会酿造灾难。</p>\n<p>所以作为一个 JavaScript 开发者，搞清楚从敲入 <code>console.log(&#39;hello   world&#39;)</code>，直到后面交由CPU执行的中间过程是很重要的。<br>这也对如何用 JavaScript 这门松散的语言编写出高质量的代码是具有指导作用的。</p>\n<p>想真正做到 JavaScript 全栈，路漫漫其修远兮。</p>\n<h1 id=\"V8-概述\"><a href=\"#V8-概述\" class=\"headerlink\" title=\"V8 概述\"></a>V8 概述</h1><p>V8 作为一个 JavaScript 引擎，最初是服役于 Google Chrome 浏览器的。它随着 Chrome 的第一版发布而发布以及开源。现在它除了 Chrome 浏览器，已经有很多其他的使用者了。诸如 NodeJS、MongoDB、CouchDB 等。</p>\n<p>JavaScript 作为 Prototype-Based Language , 基于它使用 Prototype 继承的特征，V8 使用了直译的方式，即把 JavaScript 代码直接编译成机器码( Machine Code, 有些地方也叫 Native Code )，然后直接交由硬件执行。<br>与传统的「编译-解析-执行」的流程不同，V8 处理 JavaScript，并没有二进制码或其他的中间码。</p>\n<p><strong> 简单来说，V8主要工作就是：「把 JavaScript 直译成机器码，然后运行」</strong><br>但这中间，往往是一个复杂的过程，它需要处理很多的难题，诸如：</p>\n<ol>\n<li>编译优化</li>\n<li>内存管理</li>\n<li>垃圾回收</li>\n</ol>\n<p>我写的这一系列文章，也是从这三个大点来出发，解读V8针对这些内容的处理。</p>\n<h1 id=\"V8-In-NodeJS\"><a href=\"#V8-In-NodeJS\" class=\"headerlink\" title=\"V8 In NodeJS\"></a>V8 In NodeJS</h1><h2 id=\"NodeJS源码小览\"><a href=\"#NodeJS源码小览\" class=\"headerlink\" title=\"NodeJS源码小览\"></a>NodeJS源码小览</h2><p>NodeJS，是怎么引入V8的？<br>我们关注<a href=\"https://github.com/nodejs/node\">Node的源码</a>目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── ...</div><div class=\"line\">├── deps</div><div class=\"line\">│   ├── ...</div><div class=\"line\">│   ├── v8</div><div class=\"line\">│   ├── ...</div><div class=\"line\">├── ...</div><div class=\"line\">├── lib</div><div class=\"line\">│   ├── ...</div><div class=\"line\">│   ├── buffer.js</div><div class=\"line\">│   ├── child_process.js</div><div class=\"line\">│   ├── console.js</div><div class=\"line\">│   ├── ...</div><div class=\"line\">├── node -&gt; out/Release/node</div><div class=\"line\">├── ...</div><div class=\"line\">├── out</div><div class=\"line\">│   ├── ...</div><div class=\"line\">│   ├── Release</div><div class=\"line\">|         ├── node</div><div class=\"line\">|         ├── node.d</div><div class=\"line\">|         ├── obj</div><div class=\"line\">|             └── gen</div><div class=\"line\">|                 ├── ...</div><div class=\"line\">|                 ├── node_natives.h</div><div class=\"line\">|                 ├── ...</div><div class=\"line\">│   ├── ...</div><div class=\"line\">├── src</div><div class=\"line\">│   ├── ...</div><div class=\"line\">│   ├── debug-agent.cc</div><div class=\"line\">│   ├── debug-agent.h</div><div class=\"line\">│   ├── env-inl.h</div><div class=\"line\">│   ├── env.cc</div><div class=\"line\">│   ├── ...</div><div class=\"line\">├── </div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>需要关注的几个目录和文件：</p>\n<p><strong><code>/deps/v8</code></strong>：这里是V8源码所在文件夹，你会发现里面的目录结构跟<a href=\"https://github.com/v8/v8\">V8源码</a>十分相似。NodeJS除了移植V8源码，还在增添了一些内容。</p>\n<p><strong><code>/src</code></strong>：由C/C++编写的核心模块所在文件夹，由C/C++编写的这部分模块被称为「Builtin Module」</p>\n<p><strong><code>/lib</code></strong>：由JavaScript编写的核心模块所在文件夹，这部分被称为「Native Code」，在编译Node源码的时候，会采用V8附带的<code>js2c.py</code>工具，把所有内置的JavaScript代码转换成C++里面的数组，生成<code>out/Release/obj/gen/node_natives.h</code>文件。有些 Native Module 需要借助于 Builtin Module 实现背后的功能。</p>\n<p><strong><code>/out</code></strong>：该目录是Node源码编译(命令行运行<code>make</code>)后生成的目录，里面包含了Node的可执行文件。当在命令行中键入<code>node xxx.js</code>，实际就是运行了<code>out/Release/node</code>文件。</p>\n<p>来张图说明一下V8在Node运行时的整体过程。</p>\n<p><img src=\"/image/blog/the-v8-what-javascripter-should-konw/85B39636DBC008CDB299B1BB6E45883B.png\" alt=\"v8 in nodejs.png\"></p>\n<p>Node在启动的时候，就已经把 Native Module，Builtin Module 加载到内存里面了。后来的 JavaScript 代码，就需要通过 V8 进行动态编译解析运行。</p>\n<h2 id=\"查看V8版本号\"><a href=\"#查看V8版本号\" class=\"headerlink\" title=\"查看V8版本号\"></a>查看V8版本号</h2><p>NodeJS的进步与V8息息相关，关注每个NodeJS版本所对应的V8版本，可以加强该版本新功能的理解和由来。</p>\n<p>在NodeJS中，通过<code>process.versions</code>可以查看NodeJS依赖模块的版本号，V8就包含其中。</p>\n<p>例如，我运行的 <code>v7.0.0</code>的NodeJS：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node</div><div class=\"line\">&gt; process.versions</div><div class=\"line\">&#123; http_parser: &apos;2.7.0&apos;,</div><div class=\"line\">  node: &apos;8.0.0-pre&apos;,</div><div class=\"line\">  v8: &apos;5.4.500.36&apos;,</div><div class=\"line\">  uv: &apos;1.10.0&apos;,</div><div class=\"line\">  zlib: &apos;1.2.8&apos;,</div><div class=\"line\">  ares: &apos;1.10.1-DEV&apos;,</div><div class=\"line\">  modules: &apos;51&apos;,</div><div class=\"line\">  openssl: &apos;1.0.2j&apos;,</div><div class=\"line\">  icu: &apos;58.1&apos;,</div><div class=\"line\">  unicode: &apos;9.0&apos;,</div><div class=\"line\">  cldr: &apos;30.0.2&apos;,</div><div class=\"line\">  tz: &apos;2016g&apos; &#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"NodeJS与V8的缠绵\"><a href=\"#NodeJS与V8的缠绵\" class=\"headerlink\" title=\"NodeJS与V8的缠绵\"></a>NodeJS与V8的缠绵</h1><ul>\n<li>2008年9月，V8 的第一个版本随着 Chrome 的第一版本发布。</li>\n<li>2009年5月，NodeJS 的第一个版本由 Ryan Dahl 在 GitHub 上发布。</li>\n<li>2010年12月，<a href=\"https://blog.chromium.org/2010/12/new-crankshaft-for-v8.html\">官方公布</a> V8 的名为 Crankshaft 的优化编译器，与原来的 Full Compiler 一起工作，声称较2008年版本提高50%性能。</li>\n<li>2014年12月， io.js 从久久不更新的 NodeJS 分出来支，并且引入最新的 V8 ，这时候 NodeJS 处于<code>0.12.17</code>版本。</li>\n<li>2015年2月，NodeJS基金宣布NodeJS(<code>v0.12</code>)和io.js(<code>v3.3</code>)合并，合并版本在未来发布。</li>\n<li>2015年7月7日，<a href=\"https://blog.chromium.org/2015/07/revving-up-javascript-performance-with.html\">官方公布</a>又一个新的名为TurBoFan的优化编译器，主要提供ES6的新语法，以及提高性能。并表明该编译器最终目标是全部替代Crankshaft编译器</li>\n<li>2015年7月17日，<a href=\"http://v8project.blogspot.com/2015/07/v8-45-release.html\">官方发布</a>集成TurboFan的V8版本(<code>v4.5</code>)</li>\n<li>2015年9月08日，NodeJS紧跟着<a href=\"https://nodejs.org/en/blog/release/v4.0.0/\">发布</a>了与io.js的合并版本(<code>V4.0</code>)，引入最新的V8，给开发者们带来了最新的ES6语法，以及性能上的提高。</li>\n<li>2015年8月28日，V8<a href=\"http://v8project.blogspot.com/2015/08/v8-release-46.html\">发布</a><code>v4.6</code>版本</li>\n<li>2015年10月29日，NodeJS<a href=\"https://nodejs.org/en/blog/release/v5.0.0/\">发布</a><code>V5.0.0</code>版本</li>\n<li>2016年3月15日，V8<a href=\"http://v8project.blogspot.com/2016/03/v8-release-50.html\">发布</a><code>v5.0</code>版本</li>\n<li>2016年4月26日，NodeJS<a href=\"https://nodejs.org/en/blog/release/v6.0.0/\">发布</a><code>V6.0.0</code>版本</li>\n<li>2016年7月18日，V8<a href=\"http://v8project.blogspot.com/2016/07/v8-release-53.html\">发布</a><code>v5.3</code>版本，新增名为Ignition的解析器(Interpreter)，跟原有的优化编译器(Crankshaft and TurboFan)进行串联工作，提供了更加优化的内存使用方案，主要针对于低内存的Android设备，并称在未来会普及到全平台。</li>\n<li>2016年10月25日，NodeJS<a href=\"https://nodejs.org/en/blog/release/v7.0.0/\">发布</a><code>v7.0.0</code>版本</li>\n<li>截止到今天(2016年11月)，NodeJS版本<code>v7.0.0</code>，搭配了<code>v5.4</code>的v8，而官方发布的最新v8版本是<code>v5.5</code>。</li>\n</ul>\n<p>回顾整个历程，由于NodeJS是搭建在V8之上的，所以NodeJS很多「新增语言特性」和「提高性能」等更新都需要依赖V8的发布日程。</p>\n<p>就像NodeJS和io.js宣布合并，和真正发布<code>V4.0</code>版本的中间，还隔了V8的生命历程一个重大的更新(发布 TurboFan 编译器，该编译器引入了大量的ES6语法支持。)。这个更新直接提供了相当一部分的ES6语法，以及性能上的提高。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本篇主要描述了下面几点：</p>\n<ol>\n<li>我的写作动机，理解NodeJS底层，给写出高质量JavaScript代码提供指导。</li>\n<li>简单描述V8的角色，以及主要职责：编译优化、内存管理、垃圾回收。</li>\n<li>通过NodeJS源码目录，以及NodeJS代码加载过程，来认识V8在这之中的位置。</li>\n<li>罗列NodeJS与V8的历代迭代版本以及联系，强调V8在NodeJS中的地位。</li>\n</ol>\n"},{"title":"「ES6笔记」Babel","date":"2016-06-19T15:09:40.000Z","_content":"\n# .babelrc\nBabel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。\n规则如下：\n```\n{\n  \"presets\": [],\n  \"plugins\": []\n}\n```\n\n`presets`字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。\n```\n# ES2015转码规则\n$ npm install --save-dev babel-preset-es2015\n\n# react转码规则\n$ npm install --save-dev babel-preset-react\n\n# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个\n$ npm install --save-dev babel-preset-stage-0\n$ npm install --save-dev babel-preset-stage-1\n$ npm install --save-dev babel-preset-stage-2\n$ npm install --save-dev babel-preset-stage-3\n```\n然后讲这些规则加入`.babelrc`\n```\n  {\n    \"presets\": [\n      \"es2015\",\n      \"react\",\n      \"stage-2\"\n    ],\n    \"plugins\": []\n  }\n```\n\n# babel-cli\n`npm install babel-cli --save-dev`\n该工具用于命令行转码\n基本用法：\n```\n# 转码结果输出到标准输出\n$ babel example.js\n\n# 转码结果写入一个文件\n# --out-file 或 -o 参数指定输出文件\n$ babel example.js --out-file compiled.js\n# 或者\n$ babel example.js -o compiled.js\n\n# 整个目录转码\n# --out-dir 或 -d 参数指定输出目录\n$ babel src --out-dir lib\n# 或者\n$ babel src -d lib\n\n# -s 参数生成source map文件\n$ babel src -d lib -s\n```\n\n## 使用npm script 构建\n把`node-cli`安装在项目中，然后改写`package.json`\n```\n{\n  // ...\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.0.0\"\n  },\n  \"scripts\": {\n    \"build\": \"babel src -d lib\"\n  },\n}\n```\n\n# babel-node\n`babel-node`给`node`包上一层外衣，使得可以像使用`node`那样执行js文件，这个过程是运行时编译。\n```\nbabel-node index.js\n```\n`babel-node`随着`babel-cli`安装。\n\n# babel-register\n```\nnpm install babel-register --save-dev\n```\n`babel-register`模块改写`require`命令，为它加上一个钩子。此后，每当使用`require`加载`.js、.jsx、.es、.es6`后缀名的文件，就会先用Babel进行转码。\n然后，在`require`之前，引入`babel-register`\n```\nrequire(\"babel-register\");\nrequire(\"./index.js\");\n```\n这个过程是运行时编译，只适用于开发环境中\n\n# babel-core\n`npm install --save-dev babel-core`\n`babel-core`可以使在代码中使用`babel`的API\n```\nvar babel = require('babel-core');\n\n// 字符串转码\nbabel.transform('code();', options);\n// => { code, map, ast }\n\n// 文件转码（异步）\nbabel.transformFile('filename.js', options, function(err, result) {\n  result; // => { code, map, ast }\n});\n\n// 文件转码（同步）\nbabel.transformFileSync('filename.js', options);\n// => { code, map, ast }\n\n// Babel AST转码\nbabel.transformFromAst(ast, code, options);\n// => { code, map, ast }\n```\n\n# babel-polyfill\n由于`babel`默认转换的是语法，而一些ES6环境扩展的API，却没有转换。像`Array.from`、`String.padStart`并不会转换，如果要使用到这部分API，那就需要在文件中引入`babel-polyfill`\n```\n// script.js\nrequire(\"babel-polyfill\");\nconst name = 'jc';\nconsole.log(name.padStart(10));\n```\n以上脚本会被转换成\n```\n// complied.js\n\"use strict\";\nrequire(\"babel-polyfill\");\nvar name = 'jc';\nconsole.log(name.padStart(10));\n```\n直接在低版本Node环境中执行转换后的脚本，会正常运行。\n注意的是，`babel-node script.js`会报`only one instance of babel-polyfill is allowed`错误\n\n# babel-browser\n在浏览器中运行时编译，可以引入`babel-core@5` 文件中的 `browser.min.js`文件\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js\"></script>\n```\n注意的是，在Babel6.0之后中，babel-core不会再提供`browser.min.js`\n\n# babel-standalone\n`babel-standalone`是给那些非Node.js环境中使用最新的JavaScript而服务的。\n这部分描述见于[babel-standalone](https://github.com/Daniel15/babel-standalone);\n\n使用`babel-standalone`可以取代`babel-browser`的方案，在脚本中引入\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js\"></script>\n<script type=\"text/babel\">\n// Your ES6 code\n</script>\n```\n\n# babel in mocha\n在使用mocha的时候，除了可以使用`babel-register`，也可以使用以下方式\n在`package.json`中添加：\n```\n\"scripts\": {\n  \"test\": \"mocha --ui qunit --compilers js:babel-core/register\"\n}\n```\n上面命令中，`--compilers`参数指定脚本的转码器，规定后缀名为js的文件，都需要使用`babel-core/register`先转码。\n\n# babel with webpack\n使用`babel-loader`可以在webpack打包过程中编译ES2015的代码。\n安装以下依赖\n```\nnpm install babel-core babel-loader babel-preset-2015 webpack --save-dev\n```\n然后在项目中新建`webpack.config.js`\n```\nmodule.exports = {\n  entry: \"./src/app.js\",\n  output: {\n    path: './bin',\n    filename: 'app.bunble.js'\n  },\n  module: {\n    loaders: [{\n      loader: 'babel-loader',\n      test: /.js$/,\n      exclude: /node_modules/\n    }]\n  }\n}\n```\n通过配置`loaders`，把所用`.js`后缀的文件通过babel编译。\n在这里为了避免编译依赖模块的代码，剔除`node_modules`文件夹。","source":"_posts/「ES6笔记」 Babel.md","raw":"---\ntitle: 「ES6笔记」Babel\ncategory: 搬砖码农\ndate: 2016-6-19 23:09:40\ntags:\n- babel\n- ES6\n---\n\n# .babelrc\nBabel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。\n规则如下：\n```\n{\n  \"presets\": [],\n  \"plugins\": []\n}\n```\n\n`presets`字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。\n```\n# ES2015转码规则\n$ npm install --save-dev babel-preset-es2015\n\n# react转码规则\n$ npm install --save-dev babel-preset-react\n\n# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个\n$ npm install --save-dev babel-preset-stage-0\n$ npm install --save-dev babel-preset-stage-1\n$ npm install --save-dev babel-preset-stage-2\n$ npm install --save-dev babel-preset-stage-3\n```\n然后讲这些规则加入`.babelrc`\n```\n  {\n    \"presets\": [\n      \"es2015\",\n      \"react\",\n      \"stage-2\"\n    ],\n    \"plugins\": []\n  }\n```\n\n# babel-cli\n`npm install babel-cli --save-dev`\n该工具用于命令行转码\n基本用法：\n```\n# 转码结果输出到标准输出\n$ babel example.js\n\n# 转码结果写入一个文件\n# --out-file 或 -o 参数指定输出文件\n$ babel example.js --out-file compiled.js\n# 或者\n$ babel example.js -o compiled.js\n\n# 整个目录转码\n# --out-dir 或 -d 参数指定输出目录\n$ babel src --out-dir lib\n# 或者\n$ babel src -d lib\n\n# -s 参数生成source map文件\n$ babel src -d lib -s\n```\n\n## 使用npm script 构建\n把`node-cli`安装在项目中，然后改写`package.json`\n```\n{\n  // ...\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.0.0\"\n  },\n  \"scripts\": {\n    \"build\": \"babel src -d lib\"\n  },\n}\n```\n\n# babel-node\n`babel-node`给`node`包上一层外衣，使得可以像使用`node`那样执行js文件，这个过程是运行时编译。\n```\nbabel-node index.js\n```\n`babel-node`随着`babel-cli`安装。\n\n# babel-register\n```\nnpm install babel-register --save-dev\n```\n`babel-register`模块改写`require`命令，为它加上一个钩子。此后，每当使用`require`加载`.js、.jsx、.es、.es6`后缀名的文件，就会先用Babel进行转码。\n然后，在`require`之前，引入`babel-register`\n```\nrequire(\"babel-register\");\nrequire(\"./index.js\");\n```\n这个过程是运行时编译，只适用于开发环境中\n\n# babel-core\n`npm install --save-dev babel-core`\n`babel-core`可以使在代码中使用`babel`的API\n```\nvar babel = require('babel-core');\n\n// 字符串转码\nbabel.transform('code();', options);\n// => { code, map, ast }\n\n// 文件转码（异步）\nbabel.transformFile('filename.js', options, function(err, result) {\n  result; // => { code, map, ast }\n});\n\n// 文件转码（同步）\nbabel.transformFileSync('filename.js', options);\n// => { code, map, ast }\n\n// Babel AST转码\nbabel.transformFromAst(ast, code, options);\n// => { code, map, ast }\n```\n\n# babel-polyfill\n由于`babel`默认转换的是语法，而一些ES6环境扩展的API，却没有转换。像`Array.from`、`String.padStart`并不会转换，如果要使用到这部分API，那就需要在文件中引入`babel-polyfill`\n```\n// script.js\nrequire(\"babel-polyfill\");\nconst name = 'jc';\nconsole.log(name.padStart(10));\n```\n以上脚本会被转换成\n```\n// complied.js\n\"use strict\";\nrequire(\"babel-polyfill\");\nvar name = 'jc';\nconsole.log(name.padStart(10));\n```\n直接在低版本Node环境中执行转换后的脚本，会正常运行。\n注意的是，`babel-node script.js`会报`only one instance of babel-polyfill is allowed`错误\n\n# babel-browser\n在浏览器中运行时编译，可以引入`babel-core@5` 文件中的 `browser.min.js`文件\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js\"></script>\n```\n注意的是，在Babel6.0之后中，babel-core不会再提供`browser.min.js`\n\n# babel-standalone\n`babel-standalone`是给那些非Node.js环境中使用最新的JavaScript而服务的。\n这部分描述见于[babel-standalone](https://github.com/Daniel15/babel-standalone);\n\n使用`babel-standalone`可以取代`babel-browser`的方案，在脚本中引入\n```\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js\"></script>\n<script type=\"text/babel\">\n// Your ES6 code\n</script>\n```\n\n# babel in mocha\n在使用mocha的时候，除了可以使用`babel-register`，也可以使用以下方式\n在`package.json`中添加：\n```\n\"scripts\": {\n  \"test\": \"mocha --ui qunit --compilers js:babel-core/register\"\n}\n```\n上面命令中，`--compilers`参数指定脚本的转码器，规定后缀名为js的文件，都需要使用`babel-core/register`先转码。\n\n# babel with webpack\n使用`babel-loader`可以在webpack打包过程中编译ES2015的代码。\n安装以下依赖\n```\nnpm install babel-core babel-loader babel-preset-2015 webpack --save-dev\n```\n然后在项目中新建`webpack.config.js`\n```\nmodule.exports = {\n  entry: \"./src/app.js\",\n  output: {\n    path: './bin',\n    filename: 'app.bunble.js'\n  },\n  module: {\n    loaders: [{\n      loader: 'babel-loader',\n      test: /.js$/,\n      exclude: /node_modules/\n    }]\n  }\n}\n```\n通过配置`loaders`，把所用`.js`后缀的文件通过babel编译。\n在这里为了避免编译依赖模块的代码，剔除`node_modules`文件夹。","slug":"「ES6笔记」 Babel","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwq1001c15hlj5yc928u","content":"<h1 id=\"babelrc\"><a href=\"#babelrc\" class=\"headerlink\" title=\".babelrc\"></a>.babelrc</h1><p>Babel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。<br>规则如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;presets&quot;: [],</div><div class=\"line\">  &quot;plugins&quot;: []</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>presets</code>字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"># ES2015转码规则</div><div class=\"line\">$ npm install --save-dev babel-preset-es2015</div><div class=\"line\"></div><div class=\"line\"># react转码规则</div><div class=\"line\">$ npm install --save-dev babel-preset-react</div><div class=\"line\"></div><div class=\"line\"># ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个</div><div class=\"line\">$ npm install --save-dev babel-preset-stage-0</div><div class=\"line\">$ npm install --save-dev babel-preset-stage-1</div><div class=\"line\">$ npm install --save-dev babel-preset-stage-2</div><div class=\"line\">$ npm install --save-dev babel-preset-stage-3</div></pre></td></tr></table></figure></p>\n<p>然后讲这些规则加入<code>.babelrc</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;presets&quot;: [</div><div class=\"line\">    &quot;es2015&quot;,</div><div class=\"line\">    &quot;react&quot;,</div><div class=\"line\">    &quot;stage-2&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;plugins&quot;: []</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"babel-cli\"><a href=\"#babel-cli\" class=\"headerlink\" title=\"babel-cli\"></a>babel-cli</h1><p><code>npm install babel-cli --save-dev</code><br>该工具用于命令行转码<br>基本用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 转码结果输出到标准输出</div><div class=\"line\">$ babel example.js</div><div class=\"line\"></div><div class=\"line\"># 转码结果写入一个文件</div><div class=\"line\"># --out-file 或 -o 参数指定输出文件</div><div class=\"line\">$ babel example.js --out-file compiled.js</div><div class=\"line\"># 或者</div><div class=\"line\">$ babel example.js -o compiled.js</div><div class=\"line\"></div><div class=\"line\"># 整个目录转码</div><div class=\"line\"># --out-dir 或 -d 参数指定输出目录</div><div class=\"line\">$ babel src --out-dir lib</div><div class=\"line\"># 或者</div><div class=\"line\">$ babel src -d lib</div><div class=\"line\"></div><div class=\"line\"># -s 参数生成source map文件</div><div class=\"line\">$ babel src -d lib -s</div></pre></td></tr></table></figure></p>\n<h2 id=\"使用npm-script-构建\"><a href=\"#使用npm-script-构建\" class=\"headerlink\" title=\"使用npm script 构建\"></a>使用npm script 构建</h2><p>把<code>node-cli</code>安装在项目中，然后改写<code>package.json</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  // ...</div><div class=\"line\">  &quot;devDependencies&quot;: &#123;</div><div class=\"line\">    &quot;babel-cli&quot;: &quot;^6.0.0&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;scripts&quot;: &#123;</div><div class=\"line\">    &quot;build&quot;: &quot;babel src -d lib&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"babel-node\"><a href=\"#babel-node\" class=\"headerlink\" title=\"babel-node\"></a>babel-node</h1><p><code>babel-node</code>给<code>node</code>包上一层外衣，使得可以像使用<code>node</code>那样执行js文件，这个过程是运行时编译。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">babel-node index.js</div></pre></td></tr></table></figure></p>\n<p><code>babel-node</code>随着<code>babel-cli</code>安装。</p>\n<h1 id=\"babel-register\"><a href=\"#babel-register\" class=\"headerlink\" title=\"babel-register\"></a>babel-register</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install babel-register --save-dev</div></pre></td></tr></table></figure>\n<p><code>babel-register</code>模块改写<code>require</code>命令，为它加上一个钩子。此后，每当使用<code>require</code>加载<code>.js、.jsx、.es、.es6</code>后缀名的文件，就会先用Babel进行转码。<br>然后，在<code>require</code>之前，引入<code>babel-register</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">require(&quot;babel-register&quot;);</div><div class=\"line\">require(&quot;./index.js&quot;);</div></pre></td></tr></table></figure></p>\n<p>这个过程是运行时编译，只适用于开发环境中</p>\n<h1 id=\"babel-core\"><a href=\"#babel-core\" class=\"headerlink\" title=\"babel-core\"></a>babel-core</h1><p><code>npm install --save-dev babel-core</code><br><code>babel-core</code>可以使在代码中使用<code>babel</code>的API<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var babel = require(&apos;babel-core&apos;);</div><div class=\"line\"></div><div class=\"line\">// 字符串转码</div><div class=\"line\">babel.transform(&apos;code();&apos;, options);</div><div class=\"line\">// =&gt; &#123; code, map, ast &#125;</div><div class=\"line\"></div><div class=\"line\">// 文件转码（异步）</div><div class=\"line\">babel.transformFile(&apos;filename.js&apos;, options, function(err, result) &#123;</div><div class=\"line\">  result; // =&gt; &#123; code, map, ast &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// 文件转码（同步）</div><div class=\"line\">babel.transformFileSync(&apos;filename.js&apos;, options);</div><div class=\"line\">// =&gt; &#123; code, map, ast &#125;</div><div class=\"line\"></div><div class=\"line\">// Babel AST转码</div><div class=\"line\">babel.transformFromAst(ast, code, options);</div><div class=\"line\">// =&gt; &#123; code, map, ast &#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"babel-polyfill\"><a href=\"#babel-polyfill\" class=\"headerlink\" title=\"babel-polyfill\"></a>babel-polyfill</h1><p>由于<code>babel</code>默认转换的是语法，而一些ES6环境扩展的API，却没有转换。像<code>Array.from</code>、<code>String.padStart</code>并不会转换，如果要使用到这部分API，那就需要在文件中引入<code>babel-polyfill</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// script.js</div><div class=\"line\">require(&quot;babel-polyfill&quot;);</div><div class=\"line\">const name = &apos;jc&apos;;</div><div class=\"line\">console.log(name.padStart(10));</div></pre></td></tr></table></figure></p>\n<p>以上脚本会被转换成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// complied.js</div><div class=\"line\">&quot;use strict&quot;;</div><div class=\"line\">require(&quot;babel-polyfill&quot;);</div><div class=\"line\">var name = &apos;jc&apos;;</div><div class=\"line\">console.log(name.padStart(10));</div></pre></td></tr></table></figure></p>\n<p>直接在低版本Node环境中执行转换后的脚本，会正常运行。<br>注意的是，<code>babel-node script.js</code>会报<code>only one instance of babel-polyfill is allowed</code>错误</p>\n<h1 id=\"babel-browser\"><a href=\"#babel-browser\" class=\"headerlink\" title=\"babel-browser\"></a>babel-browser</h1><p>在浏览器中运行时编译，可以引入<code>babel-core@5</code> 文件中的 <code>browser.min.js</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>注意的是，在Babel6.0之后中，babel-core不会再提供<code>browser.min.js</code></p>\n<h1 id=\"babel-standalone\"><a href=\"#babel-standalone\" class=\"headerlink\" title=\"babel-standalone\"></a>babel-standalone</h1><p><code>babel-standalone</code>是给那些非Node.js环境中使用最新的JavaScript而服务的。<br>这部分描述见于<a href=\"https://github.com/Daniel15/babel-standalone\" target=\"_blank\" rel=\"external\">babel-standalone</a>;</p>\n<p>使用<code>babel-standalone</code>可以取代<code>babel-browser</code>的方案，在脚本中引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script type=&quot;text/babel&quot;&gt;</div><div class=\"line\">// Your ES6 code</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<h1 id=\"babel-in-mocha\"><a href=\"#babel-in-mocha\" class=\"headerlink\" title=\"babel in mocha\"></a>babel in mocha</h1><p>在使用mocha的时候，除了可以使用<code>babel-register</code>，也可以使用以下方式<br>在<code>package.json</code>中添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;scripts&quot;: &#123;</div><div class=\"line\">  &quot;test&quot;: &quot;mocha --ui qunit --compilers js:babel-core/register&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面命令中，<code>--compilers</code>参数指定脚本的转码器，规定后缀名为js的文件，都需要使用<code>babel-core/register</code>先转码。</p>\n<h1 id=\"babel-with-webpack\"><a href=\"#babel-with-webpack\" class=\"headerlink\" title=\"babel with webpack\"></a>babel with webpack</h1><p>使用<code>babel-loader</code>可以在webpack打包过程中编译ES2015的代码。<br>安装以下依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install babel-core babel-loader babel-preset-2015 webpack --save-dev</div></pre></td></tr></table></figure></p>\n<p>然后在项目中新建<code>webpack.config.js</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  entry: &quot;./src/app.js&quot;,</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    path: &apos;./bin&apos;,</div><div class=\"line\">    filename: &apos;app.bunble.js&apos;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  module: &#123;</div><div class=\"line\">    loaders: [&#123;</div><div class=\"line\">      loader: &apos;babel-loader&apos;,</div><div class=\"line\">      test: /.js$/,</div><div class=\"line\">      exclude: /node_modules/</div><div class=\"line\">    &#125;]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过配置<code>loaders</code>，把所用<code>.js</code>后缀的文件通过babel编译。<br>在这里为了避免编译依赖模块的代码，剔除<code>node_modules</code>文件夹。</p>\n","excerpt":"","more":"<h1 id=\"babelrc\"><a href=\"#babelrc\" class=\"headerlink\" title=\".babelrc\"></a>.babelrc</h1><p>Babel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。<br>规则如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;presets&quot;: [],</div><div class=\"line\">  &quot;plugins&quot;: []</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>presets</code>字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"># ES2015转码规则</div><div class=\"line\">$ npm install --save-dev babel-preset-es2015</div><div class=\"line\"></div><div class=\"line\"># react转码规则</div><div class=\"line\">$ npm install --save-dev babel-preset-react</div><div class=\"line\"></div><div class=\"line\"># ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个</div><div class=\"line\">$ npm install --save-dev babel-preset-stage-0</div><div class=\"line\">$ npm install --save-dev babel-preset-stage-1</div><div class=\"line\">$ npm install --save-dev babel-preset-stage-2</div><div class=\"line\">$ npm install --save-dev babel-preset-stage-3</div></pre></td></tr></table></figure></p>\n<p>然后讲这些规则加入<code>.babelrc</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;presets&quot;: [</div><div class=\"line\">    &quot;es2015&quot;,</div><div class=\"line\">    &quot;react&quot;,</div><div class=\"line\">    &quot;stage-2&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;plugins&quot;: []</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"babel-cli\"><a href=\"#babel-cli\" class=\"headerlink\" title=\"babel-cli\"></a>babel-cli</h1><p><code>npm install babel-cli --save-dev</code><br>该工具用于命令行转码<br>基本用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 转码结果输出到标准输出</div><div class=\"line\">$ babel example.js</div><div class=\"line\"></div><div class=\"line\"># 转码结果写入一个文件</div><div class=\"line\"># --out-file 或 -o 参数指定输出文件</div><div class=\"line\">$ babel example.js --out-file compiled.js</div><div class=\"line\"># 或者</div><div class=\"line\">$ babel example.js -o compiled.js</div><div class=\"line\"></div><div class=\"line\"># 整个目录转码</div><div class=\"line\"># --out-dir 或 -d 参数指定输出目录</div><div class=\"line\">$ babel src --out-dir lib</div><div class=\"line\"># 或者</div><div class=\"line\">$ babel src -d lib</div><div class=\"line\"></div><div class=\"line\"># -s 参数生成source map文件</div><div class=\"line\">$ babel src -d lib -s</div></pre></td></tr></table></figure></p>\n<h2 id=\"使用npm-script-构建\"><a href=\"#使用npm-script-构建\" class=\"headerlink\" title=\"使用npm script 构建\"></a>使用npm script 构建</h2><p>把<code>node-cli</code>安装在项目中，然后改写<code>package.json</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  // ...</div><div class=\"line\">  &quot;devDependencies&quot;: &#123;</div><div class=\"line\">    &quot;babel-cli&quot;: &quot;^6.0.0&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;scripts&quot;: &#123;</div><div class=\"line\">    &quot;build&quot;: &quot;babel src -d lib&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"babel-node\"><a href=\"#babel-node\" class=\"headerlink\" title=\"babel-node\"></a>babel-node</h1><p><code>babel-node</code>给<code>node</code>包上一层外衣，使得可以像使用<code>node</code>那样执行js文件，这个过程是运行时编译。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">babel-node index.js</div></pre></td></tr></table></figure></p>\n<p><code>babel-node</code>随着<code>babel-cli</code>安装。</p>\n<h1 id=\"babel-register\"><a href=\"#babel-register\" class=\"headerlink\" title=\"babel-register\"></a>babel-register</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install babel-register --save-dev</div></pre></td></tr></table></figure>\n<p><code>babel-register</code>模块改写<code>require</code>命令，为它加上一个钩子。此后，每当使用<code>require</code>加载<code>.js、.jsx、.es、.es6</code>后缀名的文件，就会先用Babel进行转码。<br>然后，在<code>require</code>之前，引入<code>babel-register</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">require(&quot;babel-register&quot;);</div><div class=\"line\">require(&quot;./index.js&quot;);</div></pre></td></tr></table></figure></p>\n<p>这个过程是运行时编译，只适用于开发环境中</p>\n<h1 id=\"babel-core\"><a href=\"#babel-core\" class=\"headerlink\" title=\"babel-core\"></a>babel-core</h1><p><code>npm install --save-dev babel-core</code><br><code>babel-core</code>可以使在代码中使用<code>babel</code>的API<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var babel = require(&apos;babel-core&apos;);</div><div class=\"line\"></div><div class=\"line\">// 字符串转码</div><div class=\"line\">babel.transform(&apos;code();&apos;, options);</div><div class=\"line\">// =&gt; &#123; code, map, ast &#125;</div><div class=\"line\"></div><div class=\"line\">// 文件转码（异步）</div><div class=\"line\">babel.transformFile(&apos;filename.js&apos;, options, function(err, result) &#123;</div><div class=\"line\">  result; // =&gt; &#123; code, map, ast &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// 文件转码（同步）</div><div class=\"line\">babel.transformFileSync(&apos;filename.js&apos;, options);</div><div class=\"line\">// =&gt; &#123; code, map, ast &#125;</div><div class=\"line\"></div><div class=\"line\">// Babel AST转码</div><div class=\"line\">babel.transformFromAst(ast, code, options);</div><div class=\"line\">// =&gt; &#123; code, map, ast &#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"babel-polyfill\"><a href=\"#babel-polyfill\" class=\"headerlink\" title=\"babel-polyfill\"></a>babel-polyfill</h1><p>由于<code>babel</code>默认转换的是语法，而一些ES6环境扩展的API，却没有转换。像<code>Array.from</code>、<code>String.padStart</code>并不会转换，如果要使用到这部分API，那就需要在文件中引入<code>babel-polyfill</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// script.js</div><div class=\"line\">require(&quot;babel-polyfill&quot;);</div><div class=\"line\">const name = &apos;jc&apos;;</div><div class=\"line\">console.log(name.padStart(10));</div></pre></td></tr></table></figure></p>\n<p>以上脚本会被转换成<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// complied.js</div><div class=\"line\">&quot;use strict&quot;;</div><div class=\"line\">require(&quot;babel-polyfill&quot;);</div><div class=\"line\">var name = &apos;jc&apos;;</div><div class=\"line\">console.log(name.padStart(10));</div></pre></td></tr></table></figure></p>\n<p>直接在低版本Node环境中执行转换后的脚本，会正常运行。<br>注意的是，<code>babel-node script.js</code>会报<code>only one instance of babel-polyfill is allowed</code>错误</p>\n<h1 id=\"babel-browser\"><a href=\"#babel-browser\" class=\"headerlink\" title=\"babel-browser\"></a>babel-browser</h1><p>在浏览器中运行时编译，可以引入<code>babel-core@5</code> 文件中的 <code>browser.min.js</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p>注意的是，在Babel6.0之后中，babel-core不会再提供<code>browser.min.js</code></p>\n<h1 id=\"babel-standalone\"><a href=\"#babel-standalone\" class=\"headerlink\" title=\"babel-standalone\"></a>babel-standalone</h1><p><code>babel-standalone</code>是给那些非Node.js环境中使用最新的JavaScript而服务的。<br>这部分描述见于<a href=\"https://github.com/Daniel15/babel-standalone\">babel-standalone</a>;</p>\n<p>使用<code>babel-standalone</code>可以取代<code>babel-browser</code>的方案，在脚本中引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script type=&quot;text/babel&quot;&gt;</div><div class=\"line\">// Your ES6 code</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<h1 id=\"babel-in-mocha\"><a href=\"#babel-in-mocha\" class=\"headerlink\" title=\"babel in mocha\"></a>babel in mocha</h1><p>在使用mocha的时候，除了可以使用<code>babel-register</code>，也可以使用以下方式<br>在<code>package.json</code>中添加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;scripts&quot;: &#123;</div><div class=\"line\">  &quot;test&quot;: &quot;mocha --ui qunit --compilers js:babel-core/register&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面命令中，<code>--compilers</code>参数指定脚本的转码器，规定后缀名为js的文件，都需要使用<code>babel-core/register</code>先转码。</p>\n<h1 id=\"babel-with-webpack\"><a href=\"#babel-with-webpack\" class=\"headerlink\" title=\"babel with webpack\"></a>babel with webpack</h1><p>使用<code>babel-loader</code>可以在webpack打包过程中编译ES2015的代码。<br>安装以下依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install babel-core babel-loader babel-preset-2015 webpack --save-dev</div></pre></td></tr></table></figure></p>\n<p>然后在项目中新建<code>webpack.config.js</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  entry: &quot;./src/app.js&quot;,</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    path: &apos;./bin&apos;,</div><div class=\"line\">    filename: &apos;app.bunble.js&apos;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  module: &#123;</div><div class=\"line\">    loaders: [&#123;</div><div class=\"line\">      loader: &apos;babel-loader&apos;,</div><div class=\"line\">      test: /.js$/,</div><div class=\"line\">      exclude: /node_modules/</div><div class=\"line\">    &#125;]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>通过配置<code>loaders</code>，把所用<code>.js</code>后缀的文件通过babel编译。<br>在这里为了避免编译依赖模块的代码，剔除<code>node_modules</code>文件夹。</p>\n"},{"title":"程序员如何保证「专注」与「效率」","date":"2016-11-27T05:08:00.000Z","_content":"\n多年前，家母常骂我容易沉迷，沉迷游戏，沉迷小说，沉迷电视剧，沉迷XXX。\n意思就是说，例如当我在玩游戏的时候，很难打断我，完全沉入进去了，叫吃饭都听不见。\n在我看来，「沉迷」与「专注」实质描述同一样事物的两个相反词义的词汇。\n用在主观认为正确的事情上，叫「专注」，专注读书，专注学习，专注搬砖写代码。\n用在主观认为不正确的事情上，叫「沉迷」，沉迷游戏，沉迷小说，沉迷肥皂电视剧。\n所以，小孩子千万别「沉迷」，像「沉迷网游」会被爱子心切的家长送去给杨教授进行电击治疗的哦。\n我们还是来谈谈可以提高生产率的「专注」。\n\n# 什么是专注\n简而言之，专注就是注意力分散的对立面。\n记得大学时候教我英语的老教授说过的一句，\n「知道为什么你们一直都学不好英语么，你们这一代人生活在一个太多诱惑的世界。」\n\n每一天，我们坐下来打开电脑，想做点什么正经事情的时候。\n却又无意中打开微博看看热搜榜，看看林丹出轨，宋冬野吸毒入狱，papi酱和逻辑思维闹分手。\n又会拿起手机刷刷朋友圈，看看小伙伴自拍照，旅游照，三姑六婆姨妈姑丈的心灵鸡汤。\n还会打开知乎，看看各种「如何评价XXX」，「XXX是什么样的体验」。\n\n就像吴晓波每周都会说的「世界如此喧嚣」。\n现代人生活在一个充满了干扰的世界，社交、邮件、电话、短信、走神、打断，纷至沓来。\n\n不知道你还记得最近一次解决真正的难题是什么时候吗？\n你可能是在试图修复一些BUG，或者要弄清楚为什么代码跑不动。\n时间飞逝，你忘了吃饭、喝水乃至睡觉，一门心思扑在你的任务上。\n你全身心的投入到单个项目上，如果任何人胆敢打扰你，你就会暴跳如雷。\n这就是「专注」。\n就像生活中许多事情一样，专注就像一个「冲量」的游戏，想要达到专注工作的状态很难，但是一旦进入专注状态，就能轻松的保持下去。\n\n## 冲量\n「冲量」是一个物理词汇\n> 冲量是作用在物体上的力在时间上的累积，一个随时间改变的力对一个物体的冲量指这个力的作用对时间的积累效果。\n\n我觉得用来形容人类思维从一个「注意力分散」的状态进入到「专注」状态的过程是再好不过的概念了。\n\n就像我们开车在高速公路上行驶时的提速过程，车在进入高速行驶之前需要更换几个档位，让车提到五档，需要点时间和油耗。一旦开到五档，那就能轻松巡航了。\n倘若你开在每隔一百米一个红绿灯的道路上，总是不断的起步停车，那么整体的速度会很慢，且油耗高，顺带还给「雾霾」增添多一分贡献。\n\n又像我们启动电脑程序，第一次打开程序往往需要较长的时间。因为计算机要花一些时间把程序代码写入到内存，之后，你使用软件就更加顺畅了。\n就像以前写Java的程序员，上班第一件事打开MyEclipse，然后直到下班才关闭。\n也像你忽悠产品经理，打开网站第一次会慢点，第二次就会飞快了。\n\n所以，当我们需要对一件事情「专注」的时候，我们需要花一些时间把所有的事务在脑子里过一遍，然后才能达到思维高峰以完成任务。\n\n如果不幸，你专注期间，产经忽如其来讨论需求，测试忽如其来报BUG，之后你还需要重新回想刚才做到哪里，重新花一些时间来形成「冲量」。就像计算机线程间来回切换所需要花费的成本。\n被打断的间隔越长，需要继续之前的任务所需要的成本也就越高。\n忽然想起个段子：「你跟产经讨论了一天，他的需求有了，你的代码呢？」\n\n## 思维体力\n我觉得进入专注所需要的「冲量」是可以通过锻炼来缩短的。\n也就是说每个人进入「专注」状态所需要的时间是不一样的，并且我们可以通过特定技巧和方法来锻炼，进而缩短进入「专注」所需要的成本。\n\n如果把这个过程比喻为「思维预热」，那么「思维体力」可以用来指的长期保持专注状态的能力。\n这个能力，因人而异，也因事而异。\n\n有些人能一下子专注几个小时，例如爱音乐的吉他手可以抱着吉他玩一下午直到腰酸背痛。\n有些人却只能一下子专注半小时，例如开个会议，直到听到老领导说「我再讲最后几句」。\n还有些人只能专注前面的十分钟，例如大部分学生，听老教授讲枯燥无味的课。(不排除趣味相投的学生听的津津有味)\n\n长时间的「专注」，容易让人思维疲劳。\n不同人对于不同的事情保持「专注」的时间也不一样。\n明白这样的道理，我们可以通过一些规则或者灵活的方法来让我们的思维可以在「休息」和「运行」的状态有序的切换。\n\n比如「番茄工作法」。\n番茄工作法的核心概念也很简单，可以总结成：\n> 一个标准番茄时间是25分钟(工作)，前后两个番茄时间的标准间隔时间是5分钟(休息)。\n把一个任务所需要完成的时间，细分到以番茄时间来做单位。\n番茄时间内强迫自己专注到当前任务中，休息时间可以用来处理需要处理的其他事务（回邮件，回短信等等）。\n以这种「工作」，「休息」的状态来回切换，达到高效率完成工作任务。\n\n## 单线程\n人的思维，就像一台「单核计算机」，同一个时间，你只能处理一个任务。\n我们所承担的多个任务都要「环境切换」的成本。\n当我们从一个任务切换到另外一个任务的时候，我们必须要唤醒某些记忆才可以重新开始工作。\n\n想必你也试过，一下子想完成多个事情，犹豫再三，决定从某一个任务开始着手，结果在执行这个任务的过程中，心理还想着其他的任务，以至于没有完全投入当前任务，大大降低效率。\n\n如果把「人脑」比作「CPU」，那么我们需要一些方法来进行「资源调度」，以及「任务管理」。\n让我们的大脑「明确目标」，专心处理当前任务，而不用去考虑其他没有完成的任务。\n\n# 如何保持专注\n\n明白了什么是「专注」，以及专注的克星「打断」。\n我们可以总结保持专注所需要解决的几个主要问题：\n1. 锻炼专注，缩短冲量的成本\n2. 减少干扰源，避免打断\n3. 注意休息，注意思维体力\n4. 学会管理任务，明确目标\n\n下面是，一些建议与安利。\n\n## 「番茄闹钟」类工具\n**[番茄土豆](https://pomotodo.com/)**\n我用了最久的一款集成了 GTD 应用，它集成了「番茄闹钟」和「任务管理」的功能。\n以下是这款产品做的很不错的几点：\n1. 支持多个客户端，囊括了iOS、Android、Mac、Windows以及网页端。\n2. 还支持「时间记录」的功能，一周下来，你可以看看时间都花在哪里了，效率如何。\n3. 支持任务打标签\n\n**此刻**\n一款iOS平台的单纯的「番茄闹钟」，别有任务管理，没有白噪音。只有单纯的「25分钟-5分钟」的循环。\n当我极简风的情绪来了，就会用这个APP。\n\n## 「白噪音」类应用\n**[潮汐](https://itunes.apple.com/cn/app/chao-xi-bao-chi-zhuan-zhu/id1077776989?mt=8)**\niOS平台独占，融合了「冥想」「白噪音」「番茄闹钟」的应用。\n也用过一段时间，是一款难得的优秀作品，只有五种白噪音，清新的界面，很适合调整心情，来装一会逼。\n\n![潮汐](/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg)\n(注：界面太美，忍不住贴个图了)\n\n## 「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」\n当我打开IDE或者文本编译器，准备专注的写几段代码的时候。\n发现戴上耳机，播放着一张「后摇」歌单，特别能让我专注的思考如何实现功能，编码的效率也提升不少。\n\n**一副耳机**\n这里我不需要讨论耳机的选购，每个人的爱好需求都不一样。选择你自己喜欢的就好。\n\n**一份后摇歌单**\n有些人把后摇看作摇滚乐的一种，虽在音乐界这个叫法有些争议，但我们不需要去管。\n后摇的一个特点是，所用乐器一般与摇滚乐相同，但节奏、和声、旋律、音色及和弦进行，都有别于传统摇滚。\n没有歌词，没有人声，打破传统歌曲长度，有些甚至长达二三十分钟。\n后摇给我的感觉，不像传统类似「班得瑞」那种「轻音乐」，它多了一丝激情，多了一份节奏感，更适合写代码。\n\n如果你不嫌弃的话，这里有一份不错的网易云音乐的歌单：[多巴胺作菜，后摇作酒](http://music.163.com/#/share/1337344/122993280)\n\n** 再额外推荐点，班得瑞十三张专辑 **\n如果你不喜欢「后摇」，想找一份不错的「轻音乐」歌单，可以试试[「班得瑞」](http://music.163.com/#/artist/album?id=88149)十三张专辑。\n班得瑞（Bandari）是瑞士音乐公司AG旗下的一个新纪元音乐项目。\n其作品以环境音乐、冥想音乐为主，主要以睡眠、减压为主要音乐功能。\n风格方面，班得瑞的音乐有许多改编自日本和欧美的新世纪音乐、凯尔特音乐、乡村音乐或老式情歌的乐曲。\n\n\n**一双普通的海绵耳塞**\n耳机戴多了，戴久了，是会严重影响听力的，并且是不可恢复的损伤。\n「白噪音」的方法并不能滥用，所以你的抗噪音能力较弱的话，可以去淘宝十几块钱买一副普通的海绵耳塞，戴上也可以隔离世界。但就是有点撑耳朵，一开始会不习惯。\n\n## 「GTD (Go To Do)」类工具\n\n**[Wunderlist](https://www.wunderlist.com)**\n中文叫「奇妙清单」，一款我从大学就用到现在的GTD应用，对比 Trello，Teambition，这款更适于个人使用。\n单纯的记录想做的事情，做完了就打钩，打钩的那一声清脆的「叮」还是百听不厌。\n一个账号通用Android、iOS、Mac、Windows、网页平台。\n\n**[Trello](https://trello.com/)**\n更适合团队协作的，「面板式」的任务管理工具。\n能把任务分为不同的状态，分配给不同的人，定义好时间。\n项目进度，个人进度一目了然。\n支持Web、iOS、Android三个平台\n\n**[Teambition](https://www.teambition.com/)**\n这也是一款在我大学和小伙伴做项目的就开始用的团队任务协作工具，是国内一家位于上海的优秀团队的产品。\n同样支持Web、iOS、Android三个平台。\n有企业版和免费两个版本，如果低于10个人合作的话，Teambition是一个不错的选择。\n\n## 「记录日志」类工具\n\n回顾和总结是一个好习惯。\n一天一小结，一周一大结，还有季度总结，年度总结。\n并不是写给谁看，而是写给自己看，记录自己的时间，知道时间花费去哪里了，有哪些产出，有哪些长进。\n无论你选择怎么样的生活方式，也不应该让不断流逝的时间走得不明不白，不清不楚。\n\n对我个人来说，记笔记最重要的是两点：\n1. 支持云同步\n2. 支持Markdown\n\n** [印象笔记](https://www.yinxiang.com/?from=evernote) 结合 [马克飞象](https://maxiang.io/) **\n很久以前我用「有道云笔记」，后来因为找不到支持 Markdown 的支持加上网易邮箱暴库的原因。就转到了「印象笔记」，然后结合着第三方开发者开发的「马克飞象」，来用 Markdown 语法写了一段时间的日志。\n总的体验还不错，但是这种方式还是显得有些笨拙，而且不支持其他客户端的编辑。\n直到遇到了「Day One」的限免。\n\n** [Day One](http://dayoneapp.com/) **\n又是一款iOS平台独占的优秀应用，对于苹果党来说绝对是强悍的日记应用。只要你手头上有ipad，或者iphone，或者macbook，随时拿起来写点什么。\n就是因为这种方便性，我在day ones写了有很多突发奇想的idea或者感悟或者感想，以及一些可以用来写作的主题。\n\n## 「思维导图」类工具\n\n1970年，英国的托尼·布詹提出了一种辅助思考的工具——思维导图。\n它是通过平面上一个主题发散出来相关联对象所形成的中心网状结构的图。\n由于这种表现方式比单纯的文本更加接近人类思考时的空间想象，越来越多人用于创造性思维过程中。\n而我用思维脑图来做的比较多的是：\n1. 项目设计、架构设计。\n2. 个人任务整理。\n3. 思考的时候用来记录思维过程。\n4. 做会议笔记、读书笔记。\n\n**[百度脑图](http://naotu.baidu.com/)**\n尽管最近的百度口碑都不好，但是无可厚非的是，百度下面的确有些产品是做的不错的，也不能一言蔽之。\n百度脑图算是一个，比较纯粹的操作方式，加上一个云同步的功能，已经足够大部分需求了。\n但是唯一让我还不满足的是，没有移动端的支持。\n又是直到 「MindNode」限免为止.....\n\n**[Mindnode](http://mindnode.com/)**\n如 DayOne ，Mindnode 是iOS独占的一款优秀应用，最重要可以三个客户端同步使用。\n嗯，如果你是个苹果党，也正好不差钱，Mindnode我认为是最好的解决方案。\n\n## 最后的一个建议，关注健康\n身体乃革命本钱，人类有区别与其他动物，就是能有反思自己思维的能力。\n我们以血肉之躯来到世上，在诸如科幻片中可以实现「思想数字化」之前，我们的思想和思维的运作，都要依赖于我们现在的身体。\n保养好我们的身体，可以让我们更好的完成更多的事情。\n所以，我们开始站立办公了，解决方案就是：[「39块的宜家拉克边桌」](http://www.ikea.com/cn/zh/catalog/products/00193664/)\n\n![站立办公](/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg)\n\n\n# 最后再啰嗦一下，关于团队效率\n以上，都是讲述了如何提高个人的工作效率。\n但是，现实的人类生产工作，都是团队性的，我们寻求在能保证个人效率之外，还需最大兼容到团队的效率。\n\n这里有一篇文章很好地讲述了一些「团队效率」的观点，也基本符合我现在所在团队的价值观。\n[腾讯：管理研发大团队就像10人小分队](http://m.jiemian.com/article/800398.html)\n\n我的总结如下：\n1. 角色分明，各司其职\n2. 迭代流程，形成循环\n3. 需求透明，进度透明\n4. 线上数据，随手可得\n5. 沟通沉淀，形成归档\n\n然后我们也一直在思考如何提高团队的效率，也有辅助一些工具，由于边幅问题。\n改天另立文章，来安利一些不错的工具。\n\n# 总结\n本篇讲述了以下内容：\n1. 关于什么是专注，如何理解专注，以及如何达到专注。\n2. 要做到专注，需要解决的问题。\n3. 借助工具来解决这些问题，安利了一波。\n4. 简单提及了一下团队效率\n\n# 关于转载\n本文默认允许转载，但：\n1. 请务必注明出处：[BlueSun | 《程序员如何保证「专注」与「效率」》](http://huang-jerryc.com/2016/11/27/keep-focus-and-efficiency/)\n2. 如果你不介意，我希望转载的同时，可以得到一声告知。(Email：huangjerryc@gmail.com)\n\n感谢！","source":"_posts/keep-focus-and-efficiency.md","raw":"---\ntitle: 程序员如何保证「专注」与「效率」\ndate: 2016-11-27 13:08:00\ntags:\n- 效率\n- 专注\ncategory: 搬砖码农\n---\n\n多年前，家母常骂我容易沉迷，沉迷游戏，沉迷小说，沉迷电视剧，沉迷XXX。\n意思就是说，例如当我在玩游戏的时候，很难打断我，完全沉入进去了，叫吃饭都听不见。\n在我看来，「沉迷」与「专注」实质描述同一样事物的两个相反词义的词汇。\n用在主观认为正确的事情上，叫「专注」，专注读书，专注学习，专注搬砖写代码。\n用在主观认为不正确的事情上，叫「沉迷」，沉迷游戏，沉迷小说，沉迷肥皂电视剧。\n所以，小孩子千万别「沉迷」，像「沉迷网游」会被爱子心切的家长送去给杨教授进行电击治疗的哦。\n我们还是来谈谈可以提高生产率的「专注」。\n\n# 什么是专注\n简而言之，专注就是注意力分散的对立面。\n记得大学时候教我英语的老教授说过的一句，\n「知道为什么你们一直都学不好英语么，你们这一代人生活在一个太多诱惑的世界。」\n\n每一天，我们坐下来打开电脑，想做点什么正经事情的时候。\n却又无意中打开微博看看热搜榜，看看林丹出轨，宋冬野吸毒入狱，papi酱和逻辑思维闹分手。\n又会拿起手机刷刷朋友圈，看看小伙伴自拍照，旅游照，三姑六婆姨妈姑丈的心灵鸡汤。\n还会打开知乎，看看各种「如何评价XXX」，「XXX是什么样的体验」。\n\n就像吴晓波每周都会说的「世界如此喧嚣」。\n现代人生活在一个充满了干扰的世界，社交、邮件、电话、短信、走神、打断，纷至沓来。\n\n不知道你还记得最近一次解决真正的难题是什么时候吗？\n你可能是在试图修复一些BUG，或者要弄清楚为什么代码跑不动。\n时间飞逝，你忘了吃饭、喝水乃至睡觉，一门心思扑在你的任务上。\n你全身心的投入到单个项目上，如果任何人胆敢打扰你，你就会暴跳如雷。\n这就是「专注」。\n就像生活中许多事情一样，专注就像一个「冲量」的游戏，想要达到专注工作的状态很难，但是一旦进入专注状态，就能轻松的保持下去。\n\n## 冲量\n「冲量」是一个物理词汇\n> 冲量是作用在物体上的力在时间上的累积，一个随时间改变的力对一个物体的冲量指这个力的作用对时间的积累效果。\n\n我觉得用来形容人类思维从一个「注意力分散」的状态进入到「专注」状态的过程是再好不过的概念了。\n\n就像我们开车在高速公路上行驶时的提速过程，车在进入高速行驶之前需要更换几个档位，让车提到五档，需要点时间和油耗。一旦开到五档，那就能轻松巡航了。\n倘若你开在每隔一百米一个红绿灯的道路上，总是不断的起步停车，那么整体的速度会很慢，且油耗高，顺带还给「雾霾」增添多一分贡献。\n\n又像我们启动电脑程序，第一次打开程序往往需要较长的时间。因为计算机要花一些时间把程序代码写入到内存，之后，你使用软件就更加顺畅了。\n就像以前写Java的程序员，上班第一件事打开MyEclipse，然后直到下班才关闭。\n也像你忽悠产品经理，打开网站第一次会慢点，第二次就会飞快了。\n\n所以，当我们需要对一件事情「专注」的时候，我们需要花一些时间把所有的事务在脑子里过一遍，然后才能达到思维高峰以完成任务。\n\n如果不幸，你专注期间，产经忽如其来讨论需求，测试忽如其来报BUG，之后你还需要重新回想刚才做到哪里，重新花一些时间来形成「冲量」。就像计算机线程间来回切换所需要花费的成本。\n被打断的间隔越长，需要继续之前的任务所需要的成本也就越高。\n忽然想起个段子：「你跟产经讨论了一天，他的需求有了，你的代码呢？」\n\n## 思维体力\n我觉得进入专注所需要的「冲量」是可以通过锻炼来缩短的。\n也就是说每个人进入「专注」状态所需要的时间是不一样的，并且我们可以通过特定技巧和方法来锻炼，进而缩短进入「专注」所需要的成本。\n\n如果把这个过程比喻为「思维预热」，那么「思维体力」可以用来指的长期保持专注状态的能力。\n这个能力，因人而异，也因事而异。\n\n有些人能一下子专注几个小时，例如爱音乐的吉他手可以抱着吉他玩一下午直到腰酸背痛。\n有些人却只能一下子专注半小时，例如开个会议，直到听到老领导说「我再讲最后几句」。\n还有些人只能专注前面的十分钟，例如大部分学生，听老教授讲枯燥无味的课。(不排除趣味相投的学生听的津津有味)\n\n长时间的「专注」，容易让人思维疲劳。\n不同人对于不同的事情保持「专注」的时间也不一样。\n明白这样的道理，我们可以通过一些规则或者灵活的方法来让我们的思维可以在「休息」和「运行」的状态有序的切换。\n\n比如「番茄工作法」。\n番茄工作法的核心概念也很简单，可以总结成：\n> 一个标准番茄时间是25分钟(工作)，前后两个番茄时间的标准间隔时间是5分钟(休息)。\n把一个任务所需要完成的时间，细分到以番茄时间来做单位。\n番茄时间内强迫自己专注到当前任务中，休息时间可以用来处理需要处理的其他事务（回邮件，回短信等等）。\n以这种「工作」，「休息」的状态来回切换，达到高效率完成工作任务。\n\n## 单线程\n人的思维，就像一台「单核计算机」，同一个时间，你只能处理一个任务。\n我们所承担的多个任务都要「环境切换」的成本。\n当我们从一个任务切换到另外一个任务的时候，我们必须要唤醒某些记忆才可以重新开始工作。\n\n想必你也试过，一下子想完成多个事情，犹豫再三，决定从某一个任务开始着手，结果在执行这个任务的过程中，心理还想着其他的任务，以至于没有完全投入当前任务，大大降低效率。\n\n如果把「人脑」比作「CPU」，那么我们需要一些方法来进行「资源调度」，以及「任务管理」。\n让我们的大脑「明确目标」，专心处理当前任务，而不用去考虑其他没有完成的任务。\n\n# 如何保持专注\n\n明白了什么是「专注」，以及专注的克星「打断」。\n我们可以总结保持专注所需要解决的几个主要问题：\n1. 锻炼专注，缩短冲量的成本\n2. 减少干扰源，避免打断\n3. 注意休息，注意思维体力\n4. 学会管理任务，明确目标\n\n下面是，一些建议与安利。\n\n## 「番茄闹钟」类工具\n**[番茄土豆](https://pomotodo.com/)**\n我用了最久的一款集成了 GTD 应用，它集成了「番茄闹钟」和「任务管理」的功能。\n以下是这款产品做的很不错的几点：\n1. 支持多个客户端，囊括了iOS、Android、Mac、Windows以及网页端。\n2. 还支持「时间记录」的功能，一周下来，你可以看看时间都花在哪里了，效率如何。\n3. 支持任务打标签\n\n**此刻**\n一款iOS平台的单纯的「番茄闹钟」，别有任务管理，没有白噪音。只有单纯的「25分钟-5分钟」的循环。\n当我极简风的情绪来了，就会用这个APP。\n\n## 「白噪音」类应用\n**[潮汐](https://itunes.apple.com/cn/app/chao-xi-bao-chi-zhuan-zhu/id1077776989?mt=8)**\niOS平台独占，融合了「冥想」「白噪音」「番茄闹钟」的应用。\n也用过一段时间，是一款难得的优秀作品，只有五种白噪音，清新的界面，很适合调整心情，来装一会逼。\n\n![潮汐](/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg)\n(注：界面太美，忍不住贴个图了)\n\n## 「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」\n当我打开IDE或者文本编译器，准备专注的写几段代码的时候。\n发现戴上耳机，播放着一张「后摇」歌单，特别能让我专注的思考如何实现功能，编码的效率也提升不少。\n\n**一副耳机**\n这里我不需要讨论耳机的选购，每个人的爱好需求都不一样。选择你自己喜欢的就好。\n\n**一份后摇歌单**\n有些人把后摇看作摇滚乐的一种，虽在音乐界这个叫法有些争议，但我们不需要去管。\n后摇的一个特点是，所用乐器一般与摇滚乐相同，但节奏、和声、旋律、音色及和弦进行，都有别于传统摇滚。\n没有歌词，没有人声，打破传统歌曲长度，有些甚至长达二三十分钟。\n后摇给我的感觉，不像传统类似「班得瑞」那种「轻音乐」，它多了一丝激情，多了一份节奏感，更适合写代码。\n\n如果你不嫌弃的话，这里有一份不错的网易云音乐的歌单：[多巴胺作菜，后摇作酒](http://music.163.com/#/share/1337344/122993280)\n\n** 再额外推荐点，班得瑞十三张专辑 **\n如果你不喜欢「后摇」，想找一份不错的「轻音乐」歌单，可以试试[「班得瑞」](http://music.163.com/#/artist/album?id=88149)十三张专辑。\n班得瑞（Bandari）是瑞士音乐公司AG旗下的一个新纪元音乐项目。\n其作品以环境音乐、冥想音乐为主，主要以睡眠、减压为主要音乐功能。\n风格方面，班得瑞的音乐有许多改编自日本和欧美的新世纪音乐、凯尔特音乐、乡村音乐或老式情歌的乐曲。\n\n\n**一双普通的海绵耳塞**\n耳机戴多了，戴久了，是会严重影响听力的，并且是不可恢复的损伤。\n「白噪音」的方法并不能滥用，所以你的抗噪音能力较弱的话，可以去淘宝十几块钱买一副普通的海绵耳塞，戴上也可以隔离世界。但就是有点撑耳朵，一开始会不习惯。\n\n## 「GTD (Go To Do)」类工具\n\n**[Wunderlist](https://www.wunderlist.com)**\n中文叫「奇妙清单」，一款我从大学就用到现在的GTD应用，对比 Trello，Teambition，这款更适于个人使用。\n单纯的记录想做的事情，做完了就打钩，打钩的那一声清脆的「叮」还是百听不厌。\n一个账号通用Android、iOS、Mac、Windows、网页平台。\n\n**[Trello](https://trello.com/)**\n更适合团队协作的，「面板式」的任务管理工具。\n能把任务分为不同的状态，分配给不同的人，定义好时间。\n项目进度，个人进度一目了然。\n支持Web、iOS、Android三个平台\n\n**[Teambition](https://www.teambition.com/)**\n这也是一款在我大学和小伙伴做项目的就开始用的团队任务协作工具，是国内一家位于上海的优秀团队的产品。\n同样支持Web、iOS、Android三个平台。\n有企业版和免费两个版本，如果低于10个人合作的话，Teambition是一个不错的选择。\n\n## 「记录日志」类工具\n\n回顾和总结是一个好习惯。\n一天一小结，一周一大结，还有季度总结，年度总结。\n并不是写给谁看，而是写给自己看，记录自己的时间，知道时间花费去哪里了，有哪些产出，有哪些长进。\n无论你选择怎么样的生活方式，也不应该让不断流逝的时间走得不明不白，不清不楚。\n\n对我个人来说，记笔记最重要的是两点：\n1. 支持云同步\n2. 支持Markdown\n\n** [印象笔记](https://www.yinxiang.com/?from=evernote) 结合 [马克飞象](https://maxiang.io/) **\n很久以前我用「有道云笔记」，后来因为找不到支持 Markdown 的支持加上网易邮箱暴库的原因。就转到了「印象笔记」，然后结合着第三方开发者开发的「马克飞象」，来用 Markdown 语法写了一段时间的日志。\n总的体验还不错，但是这种方式还是显得有些笨拙，而且不支持其他客户端的编辑。\n直到遇到了「Day One」的限免。\n\n** [Day One](http://dayoneapp.com/) **\n又是一款iOS平台独占的优秀应用，对于苹果党来说绝对是强悍的日记应用。只要你手头上有ipad，或者iphone，或者macbook，随时拿起来写点什么。\n就是因为这种方便性，我在day ones写了有很多突发奇想的idea或者感悟或者感想，以及一些可以用来写作的主题。\n\n## 「思维导图」类工具\n\n1970年，英国的托尼·布詹提出了一种辅助思考的工具——思维导图。\n它是通过平面上一个主题发散出来相关联对象所形成的中心网状结构的图。\n由于这种表现方式比单纯的文本更加接近人类思考时的空间想象，越来越多人用于创造性思维过程中。\n而我用思维脑图来做的比较多的是：\n1. 项目设计、架构设计。\n2. 个人任务整理。\n3. 思考的时候用来记录思维过程。\n4. 做会议笔记、读书笔记。\n\n**[百度脑图](http://naotu.baidu.com/)**\n尽管最近的百度口碑都不好，但是无可厚非的是，百度下面的确有些产品是做的不错的，也不能一言蔽之。\n百度脑图算是一个，比较纯粹的操作方式，加上一个云同步的功能，已经足够大部分需求了。\n但是唯一让我还不满足的是，没有移动端的支持。\n又是直到 「MindNode」限免为止.....\n\n**[Mindnode](http://mindnode.com/)**\n如 DayOne ，Mindnode 是iOS独占的一款优秀应用，最重要可以三个客户端同步使用。\n嗯，如果你是个苹果党，也正好不差钱，Mindnode我认为是最好的解决方案。\n\n## 最后的一个建议，关注健康\n身体乃革命本钱，人类有区别与其他动物，就是能有反思自己思维的能力。\n我们以血肉之躯来到世上，在诸如科幻片中可以实现「思想数字化」之前，我们的思想和思维的运作，都要依赖于我们现在的身体。\n保养好我们的身体，可以让我们更好的完成更多的事情。\n所以，我们开始站立办公了，解决方案就是：[「39块的宜家拉克边桌」](http://www.ikea.com/cn/zh/catalog/products/00193664/)\n\n![站立办公](/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg)\n\n\n# 最后再啰嗦一下，关于团队效率\n以上，都是讲述了如何提高个人的工作效率。\n但是，现实的人类生产工作，都是团队性的，我们寻求在能保证个人效率之外，还需最大兼容到团队的效率。\n\n这里有一篇文章很好地讲述了一些「团队效率」的观点，也基本符合我现在所在团队的价值观。\n[腾讯：管理研发大团队就像10人小分队](http://m.jiemian.com/article/800398.html)\n\n我的总结如下：\n1. 角色分明，各司其职\n2. 迭代流程，形成循环\n3. 需求透明，进度透明\n4. 线上数据，随手可得\n5. 沟通沉淀，形成归档\n\n然后我们也一直在思考如何提高团队的效率，也有辅助一些工具，由于边幅问题。\n改天另立文章，来安利一些不错的工具。\n\n# 总结\n本篇讲述了以下内容：\n1. 关于什么是专注，如何理解专注，以及如何达到专注。\n2. 要做到专注，需要解决的问题。\n3. 借助工具来解决这些问题，安利了一波。\n4. 简单提及了一下团队效率\n\n# 关于转载\n本文默认允许转载，但：\n1. 请务必注明出处：[BlueSun | 《程序员如何保证「专注」与「效率」》](http://huang-jerryc.com/2016/11/27/keep-focus-and-efficiency/)\n2. 如果你不介意，我希望转载的同时，可以得到一声告知。(Email：huangjerryc@gmail.com)\n\n感谢！","slug":"keep-focus-and-efficiency","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwq2001e15hlua7dg015","content":"<p>多年前，家母常骂我容易沉迷，沉迷游戏，沉迷小说，沉迷电视剧，沉迷XXX。<br>意思就是说，例如当我在玩游戏的时候，很难打断我，完全沉入进去了，叫吃饭都听不见。<br>在我看来，「沉迷」与「专注」实质描述同一样事物的两个相反词义的词汇。<br>用在主观认为正确的事情上，叫「专注」，专注读书，专注学习，专注搬砖写代码。<br>用在主观认为不正确的事情上，叫「沉迷」，沉迷游戏，沉迷小说，沉迷肥皂电视剧。<br>所以，小孩子千万别「沉迷」，像「沉迷网游」会被爱子心切的家长送去给杨教授进行电击治疗的哦。<br>我们还是来谈谈可以提高生产率的「专注」。</p>\n<h1 id=\"什么是专注\"><a href=\"#什么是专注\" class=\"headerlink\" title=\"什么是专注\"></a>什么是专注</h1><p>简而言之，专注就是注意力分散的对立面。<br>记得大学时候教我英语的老教授说过的一句，<br>「知道为什么你们一直都学不好英语么，你们这一代人生活在一个太多诱惑的世界。」</p>\n<p>每一天，我们坐下来打开电脑，想做点什么正经事情的时候。<br>却又无意中打开微博看看热搜榜，看看林丹出轨，宋冬野吸毒入狱，papi酱和逻辑思维闹分手。<br>又会拿起手机刷刷朋友圈，看看小伙伴自拍照，旅游照，三姑六婆姨妈姑丈的心灵鸡汤。<br>还会打开知乎，看看各种「如何评价XXX」，「XXX是什么样的体验」。</p>\n<p>就像吴晓波每周都会说的「世界如此喧嚣」。<br>现代人生活在一个充满了干扰的世界，社交、邮件、电话、短信、走神、打断，纷至沓来。</p>\n<p>不知道你还记得最近一次解决真正的难题是什么时候吗？<br>你可能是在试图修复一些BUG，或者要弄清楚为什么代码跑不动。<br>时间飞逝，你忘了吃饭、喝水乃至睡觉，一门心思扑在你的任务上。<br>你全身心的投入到单个项目上，如果任何人胆敢打扰你，你就会暴跳如雷。<br>这就是「专注」。<br>就像生活中许多事情一样，专注就像一个「冲量」的游戏，想要达到专注工作的状态很难，但是一旦进入专注状态，就能轻松的保持下去。</p>\n<h2 id=\"冲量\"><a href=\"#冲量\" class=\"headerlink\" title=\"冲量\"></a>冲量</h2><p>「冲量」是一个物理词汇</p>\n<blockquote>\n<p>冲量是作用在物体上的力在时间上的累积，一个随时间改变的力对一个物体的冲量指这个力的作用对时间的积累效果。</p>\n</blockquote>\n<p>我觉得用来形容人类思维从一个「注意力分散」的状态进入到「专注」状态的过程是再好不过的概念了。</p>\n<p>就像我们开车在高速公路上行驶时的提速过程，车在进入高速行驶之前需要更换几个档位，让车提到五档，需要点时间和油耗。一旦开到五档，那就能轻松巡航了。<br>倘若你开在每隔一百米一个红绿灯的道路上，总是不断的起步停车，那么整体的速度会很慢，且油耗高，顺带还给「雾霾」增添多一分贡献。</p>\n<p>又像我们启动电脑程序，第一次打开程序往往需要较长的时间。因为计算机要花一些时间把程序代码写入到内存，之后，你使用软件就更加顺畅了。<br>就像以前写Java的程序员，上班第一件事打开MyEclipse，然后直到下班才关闭。<br>也像你忽悠产品经理，打开网站第一次会慢点，第二次就会飞快了。</p>\n<p>所以，当我们需要对一件事情「专注」的时候，我们需要花一些时间把所有的事务在脑子里过一遍，然后才能达到思维高峰以完成任务。</p>\n<p>如果不幸，你专注期间，产经忽如其来讨论需求，测试忽如其来报BUG，之后你还需要重新回想刚才做到哪里，重新花一些时间来形成「冲量」。就像计算机线程间来回切换所需要花费的成本。<br>被打断的间隔越长，需要继续之前的任务所需要的成本也就越高。<br>忽然想起个段子：「你跟产经讨论了一天，他的需求有了，你的代码呢？」</p>\n<h2 id=\"思维体力\"><a href=\"#思维体力\" class=\"headerlink\" title=\"思维体力\"></a>思维体力</h2><p>我觉得进入专注所需要的「冲量」是可以通过锻炼来缩短的。<br>也就是说每个人进入「专注」状态所需要的时间是不一样的，并且我们可以通过特定技巧和方法来锻炼，进而缩短进入「专注」所需要的成本。</p>\n<p>如果把这个过程比喻为「思维预热」，那么「思维体力」可以用来指的长期保持专注状态的能力。<br>这个能力，因人而异，也因事而异。</p>\n<p>有些人能一下子专注几个小时，例如爱音乐的吉他手可以抱着吉他玩一下午直到腰酸背痛。<br>有些人却只能一下子专注半小时，例如开个会议，直到听到老领导说「我再讲最后几句」。<br>还有些人只能专注前面的十分钟，例如大部分学生，听老教授讲枯燥无味的课。(不排除趣味相投的学生听的津津有味)</p>\n<p>长时间的「专注」，容易让人思维疲劳。<br>不同人对于不同的事情保持「专注」的时间也不一样。<br>明白这样的道理，我们可以通过一些规则或者灵活的方法来让我们的思维可以在「休息」和「运行」的状态有序的切换。</p>\n<p>比如「番茄工作法」。<br>番茄工作法的核心概念也很简单，可以总结成：</p>\n<blockquote>\n<p>一个标准番茄时间是25分钟(工作)，前后两个番茄时间的标准间隔时间是5分钟(休息)。<br>把一个任务所需要完成的时间，细分到以番茄时间来做单位。<br>番茄时间内强迫自己专注到当前任务中，休息时间可以用来处理需要处理的其他事务（回邮件，回短信等等）。<br>以这种「工作」，「休息」的状态来回切换，达到高效率完成工作任务。</p>\n</blockquote>\n<h2 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h2><p>人的思维，就像一台「单核计算机」，同一个时间，你只能处理一个任务。<br>我们所承担的多个任务都要「环境切换」的成本。<br>当我们从一个任务切换到另外一个任务的时候，我们必须要唤醒某些记忆才可以重新开始工作。</p>\n<p>想必你也试过，一下子想完成多个事情，犹豫再三，决定从某一个任务开始着手，结果在执行这个任务的过程中，心理还想着其他的任务，以至于没有完全投入当前任务，大大降低效率。</p>\n<p>如果把「人脑」比作「CPU」，那么我们需要一些方法来进行「资源调度」，以及「任务管理」。<br>让我们的大脑「明确目标」，专心处理当前任务，而不用去考虑其他没有完成的任务。</p>\n<h1 id=\"如何保持专注\"><a href=\"#如何保持专注\" class=\"headerlink\" title=\"如何保持专注\"></a>如何保持专注</h1><p>明白了什么是「专注」，以及专注的克星「打断」。<br>我们可以总结保持专注所需要解决的几个主要问题：</p>\n<ol>\n<li>锻炼专注，缩短冲量的成本</li>\n<li>减少干扰源，避免打断</li>\n<li>注意休息，注意思维体力</li>\n<li>学会管理任务，明确目标</li>\n</ol>\n<p>下面是，一些建议与安利。</p>\n<h2 id=\"「番茄闹钟」类工具\"><a href=\"#「番茄闹钟」类工具\" class=\"headerlink\" title=\"「番茄闹钟」类工具\"></a>「番茄闹钟」类工具</h2><p><strong><a href=\"https://pomotodo.com/\" target=\"_blank\" rel=\"external\">番茄土豆</a></strong><br>我用了最久的一款集成了 GTD 应用，它集成了「番茄闹钟」和「任务管理」的功能。<br>以下是这款产品做的很不错的几点：</p>\n<ol>\n<li>支持多个客户端，囊括了iOS、Android、Mac、Windows以及网页端。</li>\n<li>还支持「时间记录」的功能，一周下来，你可以看看时间都花在哪里了，效率如何。</li>\n<li>支持任务打标签</li>\n</ol>\n<p><strong>此刻</strong><br>一款iOS平台的单纯的「番茄闹钟」，别有任务管理，没有白噪音。只有单纯的「25分钟-5分钟」的循环。<br>当我极简风的情绪来了，就会用这个APP。</p>\n<h2 id=\"「白噪音」类应用\"><a href=\"#「白噪音」类应用\" class=\"headerlink\" title=\"「白噪音」类应用\"></a>「白噪音」类应用</h2><p><strong><a href=\"https://itunes.apple.com/cn/app/chao-xi-bao-chi-zhuan-zhu/id1077776989?mt=8\" target=\"_blank\" rel=\"external\">潮汐</a></strong><br>iOS平台独占，融合了「冥想」「白噪音」「番茄闹钟」的应用。<br>也用过一段时间，是一款难得的优秀作品，只有五种白噪音，清新的界面，很适合调整心情，来装一会逼。</p>\n<p><img src=\"/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg\" alt=\"潮汐\"><br>(注：界面太美，忍不住贴个图了)</p>\n<h2 id=\"「一副耳机」-加-「一份后摇歌单」-再加-「一双普通的海绵耳塞」\"><a href=\"#「一副耳机」-加-「一份后摇歌单」-再加-「一双普通的海绵耳塞」\" class=\"headerlink\" title=\"「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」\"></a>「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」</h2><p>当我打开IDE或者文本编译器，准备专注的写几段代码的时候。<br>发现戴上耳机，播放着一张「后摇」歌单，特别能让我专注的思考如何实现功能，编码的效率也提升不少。</p>\n<p><strong>一副耳机</strong><br>这里我不需要讨论耳机的选购，每个人的爱好需求都不一样。选择你自己喜欢的就好。</p>\n<p><strong>一份后摇歌单</strong><br>有些人把后摇看作摇滚乐的一种，虽在音乐界这个叫法有些争议，但我们不需要去管。<br>后摇的一个特点是，所用乐器一般与摇滚乐相同，但节奏、和声、旋律、音色及和弦进行，都有别于传统摇滚。<br>没有歌词，没有人声，打破传统歌曲长度，有些甚至长达二三十分钟。<br>后摇给我的感觉，不像传统类似「班得瑞」那种「轻音乐」，它多了一丝激情，多了一份节奏感，更适合写代码。</p>\n<p>如果你不嫌弃的话，这里有一份不错的网易云音乐的歌单：<a href=\"http://music.163.com/#/share/1337344/122993280\" target=\"_blank\" rel=\"external\">多巴胺作菜，后摇作酒</a></p>\n<p><strong> 再额外推荐点，班得瑞十三张专辑 </strong><br>如果你不喜欢「后摇」，想找一份不错的「轻音乐」歌单，可以试试<a href=\"http://music.163.com/#/artist/album?id=88149\" target=\"_blank\" rel=\"external\">「班得瑞」</a>十三张专辑。<br>班得瑞（Bandari）是瑞士音乐公司AG旗下的一个新纪元音乐项目。<br>其作品以环境音乐、冥想音乐为主，主要以睡眠、减压为主要音乐功能。<br>风格方面，班得瑞的音乐有许多改编自日本和欧美的新世纪音乐、凯尔特音乐、乡村音乐或老式情歌的乐曲。</p>\n<p><strong>一双普通的海绵耳塞</strong><br>耳机戴多了，戴久了，是会严重影响听力的，并且是不可恢复的损伤。<br>「白噪音」的方法并不能滥用，所以你的抗噪音能力较弱的话，可以去淘宝十几块钱买一副普通的海绵耳塞，戴上也可以隔离世界。但就是有点撑耳朵，一开始会不习惯。</p>\n<h2 id=\"「GTD-Go-To-Do-」类工具\"><a href=\"#「GTD-Go-To-Do-」类工具\" class=\"headerlink\" title=\"「GTD (Go To Do)」类工具\"></a>「GTD (Go To Do)」类工具</h2><p><strong><a href=\"https://www.wunderlist.com\" target=\"_blank\" rel=\"external\">Wunderlist</a></strong><br>中文叫「奇妙清单」，一款我从大学就用到现在的GTD应用，对比 Trello，Teambition，这款更适于个人使用。<br>单纯的记录想做的事情，做完了就打钩，打钩的那一声清脆的「叮」还是百听不厌。<br>一个账号通用Android、iOS、Mac、Windows、网页平台。</p>\n<p><strong><a href=\"https://trello.com/\" target=\"_blank\" rel=\"external\">Trello</a></strong><br>更适合团队协作的，「面板式」的任务管理工具。<br>能把任务分为不同的状态，分配给不同的人，定义好时间。<br>项目进度，个人进度一目了然。<br>支持Web、iOS、Android三个平台</p>\n<p><strong><a href=\"https://www.teambition.com/\" target=\"_blank\" rel=\"external\">Teambition</a></strong><br>这也是一款在我大学和小伙伴做项目的就开始用的团队任务协作工具，是国内一家位于上海的优秀团队的产品。<br>同样支持Web、iOS、Android三个平台。<br>有企业版和免费两个版本，如果低于10个人合作的话，Teambition是一个不错的选择。</p>\n<h2 id=\"「记录日志」类工具\"><a href=\"#「记录日志」类工具\" class=\"headerlink\" title=\"「记录日志」类工具\"></a>「记录日志」类工具</h2><p>回顾和总结是一个好习惯。<br>一天一小结，一周一大结，还有季度总结，年度总结。<br>并不是写给谁看，而是写给自己看，记录自己的时间，知道时间花费去哪里了，有哪些产出，有哪些长进。<br>无论你选择怎么样的生活方式，也不应该让不断流逝的时间走得不明不白，不清不楚。</p>\n<p>对我个人来说，记笔记最重要的是两点：</p>\n<ol>\n<li>支持云同步</li>\n<li>支持Markdown</li>\n</ol>\n<p><strong> <a href=\"https://www.yinxiang.com/?from=evernote\" target=\"_blank\" rel=\"external\">印象笔记</a> 结合 <a href=\"https://maxiang.io/\" target=\"_blank\" rel=\"external\">马克飞象</a> </strong><br>很久以前我用「有道云笔记」，后来因为找不到支持 Markdown 的支持加上网易邮箱暴库的原因。就转到了「印象笔记」，然后结合着第三方开发者开发的「马克飞象」，来用 Markdown 语法写了一段时间的日志。<br>总的体验还不错，但是这种方式还是显得有些笨拙，而且不支持其他客户端的编辑。<br>直到遇到了「Day One」的限免。</p>\n<p><strong> <a href=\"http://dayoneapp.com/\" target=\"_blank\" rel=\"external\">Day One</a> </strong><br>又是一款iOS平台独占的优秀应用，对于苹果党来说绝对是强悍的日记应用。只要你手头上有ipad，或者iphone，或者macbook，随时拿起来写点什么。<br>就是因为这种方便性，我在day ones写了有很多突发奇想的idea或者感悟或者感想，以及一些可以用来写作的主题。</p>\n<h2 id=\"「思维导图」类工具\"><a href=\"#「思维导图」类工具\" class=\"headerlink\" title=\"「思维导图」类工具\"></a>「思维导图」类工具</h2><p>1970年，英国的托尼·布詹提出了一种辅助思考的工具——思维导图。<br>它是通过平面上一个主题发散出来相关联对象所形成的中心网状结构的图。<br>由于这种表现方式比单纯的文本更加接近人类思考时的空间想象，越来越多人用于创造性思维过程中。<br>而我用思维脑图来做的比较多的是：</p>\n<ol>\n<li>项目设计、架构设计。</li>\n<li>个人任务整理。</li>\n<li>思考的时候用来记录思维过程。</li>\n<li>做会议笔记、读书笔记。</li>\n</ol>\n<p><strong><a href=\"http://naotu.baidu.com/\" target=\"_blank\" rel=\"external\">百度脑图</a></strong><br>尽管最近的百度口碑都不好，但是无可厚非的是，百度下面的确有些产品是做的不错的，也不能一言蔽之。<br>百度脑图算是一个，比较纯粹的操作方式，加上一个云同步的功能，已经足够大部分需求了。<br>但是唯一让我还不满足的是，没有移动端的支持。<br>又是直到 「MindNode」限免为止…..</p>\n<p><strong><a href=\"http://mindnode.com/\" target=\"_blank\" rel=\"external\">Mindnode</a></strong><br>如 DayOne ，Mindnode 是iOS独占的一款优秀应用，最重要可以三个客户端同步使用。<br>嗯，如果你是个苹果党，也正好不差钱，Mindnode我认为是最好的解决方案。</p>\n<h2 id=\"最后的一个建议，关注健康\"><a href=\"#最后的一个建议，关注健康\" class=\"headerlink\" title=\"最后的一个建议，关注健康\"></a>最后的一个建议，关注健康</h2><p>身体乃革命本钱，人类有区别与其他动物，就是能有反思自己思维的能力。<br>我们以血肉之躯来到世上，在诸如科幻片中可以实现「思想数字化」之前，我们的思想和思维的运作，都要依赖于我们现在的身体。<br>保养好我们的身体，可以让我们更好的完成更多的事情。<br>所以，我们开始站立办公了，解决方案就是：<a href=\"http://www.ikea.com/cn/zh/catalog/products/00193664/\" target=\"_blank\" rel=\"external\">「39块的宜家拉克边桌」</a></p>\n<p><img src=\"/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg\" alt=\"站立办公\"></p>\n<h1 id=\"最后再啰嗦一下，关于团队效率\"><a href=\"#最后再啰嗦一下，关于团队效率\" class=\"headerlink\" title=\"最后再啰嗦一下，关于团队效率\"></a>最后再啰嗦一下，关于团队效率</h1><p>以上，都是讲述了如何提高个人的工作效率。<br>但是，现实的人类生产工作，都是团队性的，我们寻求在能保证个人效率之外，还需最大兼容到团队的效率。</p>\n<p>这里有一篇文章很好地讲述了一些「团队效率」的观点，也基本符合我现在所在团队的价值观。<br><a href=\"http://m.jiemian.com/article/800398.html\" target=\"_blank\" rel=\"external\">腾讯：管理研发大团队就像10人小分队</a></p>\n<p>我的总结如下：</p>\n<ol>\n<li>角色分明，各司其职</li>\n<li>迭代流程，形成循环</li>\n<li>需求透明，进度透明</li>\n<li>线上数据，随手可得</li>\n<li>沟通沉淀，形成归档</li>\n</ol>\n<p>然后我们也一直在思考如何提高团队的效率，也有辅助一些工具，由于边幅问题。<br>改天另立文章，来安利一些不错的工具。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本篇讲述了以下内容：</p>\n<ol>\n<li>关于什么是专注，如何理解专注，以及如何达到专注。</li>\n<li>要做到专注，需要解决的问题。</li>\n<li>借助工具来解决这些问题，安利了一波。</li>\n<li>简单提及了一下团队效率</li>\n</ol>\n<h1 id=\"关于转载\"><a href=\"#关于转载\" class=\"headerlink\" title=\"关于转载\"></a>关于转载</h1><p>本文默认允许转载，但：</p>\n<ol>\n<li>请务必注明出处：<a href=\"http://huang-jerryc.com/2016/11/27/keep-focus-and-efficiency/\">BlueSun | 《程序员如何保证「专注」与「效率」》</a></li>\n<li>如果你不介意，我希望转载的同时，可以得到一声告知。(Email：huangjerryc@gmail.com)</li>\n</ol>\n<p>感谢！</p>\n","excerpt":"","more":"<p>多年前，家母常骂我容易沉迷，沉迷游戏，沉迷小说，沉迷电视剧，沉迷XXX。<br>意思就是说，例如当我在玩游戏的时候，很难打断我，完全沉入进去了，叫吃饭都听不见。<br>在我看来，「沉迷」与「专注」实质描述同一样事物的两个相反词义的词汇。<br>用在主观认为正确的事情上，叫「专注」，专注读书，专注学习，专注搬砖写代码。<br>用在主观认为不正确的事情上，叫「沉迷」，沉迷游戏，沉迷小说，沉迷肥皂电视剧。<br>所以，小孩子千万别「沉迷」，像「沉迷网游」会被爱子心切的家长送去给杨教授进行电击治疗的哦。<br>我们还是来谈谈可以提高生产率的「专注」。</p>\n<h1 id=\"什么是专注\"><a href=\"#什么是专注\" class=\"headerlink\" title=\"什么是专注\"></a>什么是专注</h1><p>简而言之，专注就是注意力分散的对立面。<br>记得大学时候教我英语的老教授说过的一句，<br>「知道为什么你们一直都学不好英语么，你们这一代人生活在一个太多诱惑的世界。」</p>\n<p>每一天，我们坐下来打开电脑，想做点什么正经事情的时候。<br>却又无意中打开微博看看热搜榜，看看林丹出轨，宋冬野吸毒入狱，papi酱和逻辑思维闹分手。<br>又会拿起手机刷刷朋友圈，看看小伙伴自拍照，旅游照，三姑六婆姨妈姑丈的心灵鸡汤。<br>还会打开知乎，看看各种「如何评价XXX」，「XXX是什么样的体验」。</p>\n<p>就像吴晓波每周都会说的「世界如此喧嚣」。<br>现代人生活在一个充满了干扰的世界，社交、邮件、电话、短信、走神、打断，纷至沓来。</p>\n<p>不知道你还记得最近一次解决真正的难题是什么时候吗？<br>你可能是在试图修复一些BUG，或者要弄清楚为什么代码跑不动。<br>时间飞逝，你忘了吃饭、喝水乃至睡觉，一门心思扑在你的任务上。<br>你全身心的投入到单个项目上，如果任何人胆敢打扰你，你就会暴跳如雷。<br>这就是「专注」。<br>就像生活中许多事情一样，专注就像一个「冲量」的游戏，想要达到专注工作的状态很难，但是一旦进入专注状态，就能轻松的保持下去。</p>\n<h2 id=\"冲量\"><a href=\"#冲量\" class=\"headerlink\" title=\"冲量\"></a>冲量</h2><p>「冲量」是一个物理词汇</p>\n<blockquote>\n<p>冲量是作用在物体上的力在时间上的累积，一个随时间改变的力对一个物体的冲量指这个力的作用对时间的积累效果。</p>\n</blockquote>\n<p>我觉得用来形容人类思维从一个「注意力分散」的状态进入到「专注」状态的过程是再好不过的概念了。</p>\n<p>就像我们开车在高速公路上行驶时的提速过程，车在进入高速行驶之前需要更换几个档位，让车提到五档，需要点时间和油耗。一旦开到五档，那就能轻松巡航了。<br>倘若你开在每隔一百米一个红绿灯的道路上，总是不断的起步停车，那么整体的速度会很慢，且油耗高，顺带还给「雾霾」增添多一分贡献。</p>\n<p>又像我们启动电脑程序，第一次打开程序往往需要较长的时间。因为计算机要花一些时间把程序代码写入到内存，之后，你使用软件就更加顺畅了。<br>就像以前写Java的程序员，上班第一件事打开MyEclipse，然后直到下班才关闭。<br>也像你忽悠产品经理，打开网站第一次会慢点，第二次就会飞快了。</p>\n<p>所以，当我们需要对一件事情「专注」的时候，我们需要花一些时间把所有的事务在脑子里过一遍，然后才能达到思维高峰以完成任务。</p>\n<p>如果不幸，你专注期间，产经忽如其来讨论需求，测试忽如其来报BUG，之后你还需要重新回想刚才做到哪里，重新花一些时间来形成「冲量」。就像计算机线程间来回切换所需要花费的成本。<br>被打断的间隔越长，需要继续之前的任务所需要的成本也就越高。<br>忽然想起个段子：「你跟产经讨论了一天，他的需求有了，你的代码呢？」</p>\n<h2 id=\"思维体力\"><a href=\"#思维体力\" class=\"headerlink\" title=\"思维体力\"></a>思维体力</h2><p>我觉得进入专注所需要的「冲量」是可以通过锻炼来缩短的。<br>也就是说每个人进入「专注」状态所需要的时间是不一样的，并且我们可以通过特定技巧和方法来锻炼，进而缩短进入「专注」所需要的成本。</p>\n<p>如果把这个过程比喻为「思维预热」，那么「思维体力」可以用来指的长期保持专注状态的能力。<br>这个能力，因人而异，也因事而异。</p>\n<p>有些人能一下子专注几个小时，例如爱音乐的吉他手可以抱着吉他玩一下午直到腰酸背痛。<br>有些人却只能一下子专注半小时，例如开个会议，直到听到老领导说「我再讲最后几句」。<br>还有些人只能专注前面的十分钟，例如大部分学生，听老教授讲枯燥无味的课。(不排除趣味相投的学生听的津津有味)</p>\n<p>长时间的「专注」，容易让人思维疲劳。<br>不同人对于不同的事情保持「专注」的时间也不一样。<br>明白这样的道理，我们可以通过一些规则或者灵活的方法来让我们的思维可以在「休息」和「运行」的状态有序的切换。</p>\n<p>比如「番茄工作法」。<br>番茄工作法的核心概念也很简单，可以总结成：</p>\n<blockquote>\n<p>一个标准番茄时间是25分钟(工作)，前后两个番茄时间的标准间隔时间是5分钟(休息)。<br>把一个任务所需要完成的时间，细分到以番茄时间来做单位。<br>番茄时间内强迫自己专注到当前任务中，休息时间可以用来处理需要处理的其他事务（回邮件，回短信等等）。<br>以这种「工作」，「休息」的状态来回切换，达到高效率完成工作任务。</p>\n</blockquote>\n<h2 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h2><p>人的思维，就像一台「单核计算机」，同一个时间，你只能处理一个任务。<br>我们所承担的多个任务都要「环境切换」的成本。<br>当我们从一个任务切换到另外一个任务的时候，我们必须要唤醒某些记忆才可以重新开始工作。</p>\n<p>想必你也试过，一下子想完成多个事情，犹豫再三，决定从某一个任务开始着手，结果在执行这个任务的过程中，心理还想着其他的任务，以至于没有完全投入当前任务，大大降低效率。</p>\n<p>如果把「人脑」比作「CPU」，那么我们需要一些方法来进行「资源调度」，以及「任务管理」。<br>让我们的大脑「明确目标」，专心处理当前任务，而不用去考虑其他没有完成的任务。</p>\n<h1 id=\"如何保持专注\"><a href=\"#如何保持专注\" class=\"headerlink\" title=\"如何保持专注\"></a>如何保持专注</h1><p>明白了什么是「专注」，以及专注的克星「打断」。<br>我们可以总结保持专注所需要解决的几个主要问题：</p>\n<ol>\n<li>锻炼专注，缩短冲量的成本</li>\n<li>减少干扰源，避免打断</li>\n<li>注意休息，注意思维体力</li>\n<li>学会管理任务，明确目标</li>\n</ol>\n<p>下面是，一些建议与安利。</p>\n<h2 id=\"「番茄闹钟」类工具\"><a href=\"#「番茄闹钟」类工具\" class=\"headerlink\" title=\"「番茄闹钟」类工具\"></a>「番茄闹钟」类工具</h2><p><strong><a href=\"https://pomotodo.com/\">番茄土豆</a></strong><br>我用了最久的一款集成了 GTD 应用，它集成了「番茄闹钟」和「任务管理」的功能。<br>以下是这款产品做的很不错的几点：</p>\n<ol>\n<li>支持多个客户端，囊括了iOS、Android、Mac、Windows以及网页端。</li>\n<li>还支持「时间记录」的功能，一周下来，你可以看看时间都花在哪里了，效率如何。</li>\n<li>支持任务打标签</li>\n</ol>\n<p><strong>此刻</strong><br>一款iOS平台的单纯的「番茄闹钟」，别有任务管理，没有白噪音。只有单纯的「25分钟-5分钟」的循环。<br>当我极简风的情绪来了，就会用这个APP。</p>\n<h2 id=\"「白噪音」类应用\"><a href=\"#「白噪音」类应用\" class=\"headerlink\" title=\"「白噪音」类应用\"></a>「白噪音」类应用</h2><p><strong><a href=\"https://itunes.apple.com/cn/app/chao-xi-bao-chi-zhuan-zhu/id1077776989?mt=8\">潮汐</a></strong><br>iOS平台独占，融合了「冥想」「白噪音」「番茄闹钟」的应用。<br>也用过一段时间，是一款难得的优秀作品，只有五种白噪音，清新的界面，很适合调整心情，来装一会逼。</p>\n<p><img src=\"/image/blog/keep-focus-and-efficiency/C23BFA5E15958ACFD18469835B9D3DFC.jpg\" alt=\"潮汐\"><br>(注：界面太美，忍不住贴个图了)</p>\n<h2 id=\"「一副耳机」-加-「一份后摇歌单」-再加-「一双普通的海绵耳塞」\"><a href=\"#「一副耳机」-加-「一份后摇歌单」-再加-「一双普通的海绵耳塞」\" class=\"headerlink\" title=\"「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」\"></a>「一副耳机」 加 「一份后摇歌单」 再加 「一双普通的海绵耳塞」</h2><p>当我打开IDE或者文本编译器，准备专注的写几段代码的时候。<br>发现戴上耳机，播放着一张「后摇」歌单，特别能让我专注的思考如何实现功能，编码的效率也提升不少。</p>\n<p><strong>一副耳机</strong><br>这里我不需要讨论耳机的选购，每个人的爱好需求都不一样。选择你自己喜欢的就好。</p>\n<p><strong>一份后摇歌单</strong><br>有些人把后摇看作摇滚乐的一种，虽在音乐界这个叫法有些争议，但我们不需要去管。<br>后摇的一个特点是，所用乐器一般与摇滚乐相同，但节奏、和声、旋律、音色及和弦进行，都有别于传统摇滚。<br>没有歌词，没有人声，打破传统歌曲长度，有些甚至长达二三十分钟。<br>后摇给我的感觉，不像传统类似「班得瑞」那种「轻音乐」，它多了一丝激情，多了一份节奏感，更适合写代码。</p>\n<p>如果你不嫌弃的话，这里有一份不错的网易云音乐的歌单：<a href=\"http://music.163.com/#/share/1337344/122993280\">多巴胺作菜，后摇作酒</a></p>\n<p><strong> 再额外推荐点，班得瑞十三张专辑 </strong><br>如果你不喜欢「后摇」，想找一份不错的「轻音乐」歌单，可以试试<a href=\"http://music.163.com/#/artist/album?id=88149\">「班得瑞」</a>十三张专辑。<br>班得瑞（Bandari）是瑞士音乐公司AG旗下的一个新纪元音乐项目。<br>其作品以环境音乐、冥想音乐为主，主要以睡眠、减压为主要音乐功能。<br>风格方面，班得瑞的音乐有许多改编自日本和欧美的新世纪音乐、凯尔特音乐、乡村音乐或老式情歌的乐曲。</p>\n<p><strong>一双普通的海绵耳塞</strong><br>耳机戴多了，戴久了，是会严重影响听力的，并且是不可恢复的损伤。<br>「白噪音」的方法并不能滥用，所以你的抗噪音能力较弱的话，可以去淘宝十几块钱买一副普通的海绵耳塞，戴上也可以隔离世界。但就是有点撑耳朵，一开始会不习惯。</p>\n<h2 id=\"「GTD-Go-To-Do-」类工具\"><a href=\"#「GTD-Go-To-Do-」类工具\" class=\"headerlink\" title=\"「GTD (Go To Do)」类工具\"></a>「GTD (Go To Do)」类工具</h2><p><strong><a href=\"https://www.wunderlist.com\">Wunderlist</a></strong><br>中文叫「奇妙清单」，一款我从大学就用到现在的GTD应用，对比 Trello，Teambition，这款更适于个人使用。<br>单纯的记录想做的事情，做完了就打钩，打钩的那一声清脆的「叮」还是百听不厌。<br>一个账号通用Android、iOS、Mac、Windows、网页平台。</p>\n<p><strong><a href=\"https://trello.com/\">Trello</a></strong><br>更适合团队协作的，「面板式」的任务管理工具。<br>能把任务分为不同的状态，分配给不同的人，定义好时间。<br>项目进度，个人进度一目了然。<br>支持Web、iOS、Android三个平台</p>\n<p><strong><a href=\"https://www.teambition.com/\">Teambition</a></strong><br>这也是一款在我大学和小伙伴做项目的就开始用的团队任务协作工具，是国内一家位于上海的优秀团队的产品。<br>同样支持Web、iOS、Android三个平台。<br>有企业版和免费两个版本，如果低于10个人合作的话，Teambition是一个不错的选择。</p>\n<h2 id=\"「记录日志」类工具\"><a href=\"#「记录日志」类工具\" class=\"headerlink\" title=\"「记录日志」类工具\"></a>「记录日志」类工具</h2><p>回顾和总结是一个好习惯。<br>一天一小结，一周一大结，还有季度总结，年度总结。<br>并不是写给谁看，而是写给自己看，记录自己的时间，知道时间花费去哪里了，有哪些产出，有哪些长进。<br>无论你选择怎么样的生活方式，也不应该让不断流逝的时间走得不明不白，不清不楚。</p>\n<p>对我个人来说，记笔记最重要的是两点：</p>\n<ol>\n<li>支持云同步</li>\n<li>支持Markdown</li>\n</ol>\n<p><strong> <a href=\"https://www.yinxiang.com/?from=evernote\">印象笔记</a> 结合 <a href=\"https://maxiang.io/\">马克飞象</a> </strong><br>很久以前我用「有道云笔记」，后来因为找不到支持 Markdown 的支持加上网易邮箱暴库的原因。就转到了「印象笔记」，然后结合着第三方开发者开发的「马克飞象」，来用 Markdown 语法写了一段时间的日志。<br>总的体验还不错，但是这种方式还是显得有些笨拙，而且不支持其他客户端的编辑。<br>直到遇到了「Day One」的限免。</p>\n<p><strong> <a href=\"http://dayoneapp.com/\">Day One</a> </strong><br>又是一款iOS平台独占的优秀应用，对于苹果党来说绝对是强悍的日记应用。只要你手头上有ipad，或者iphone，或者macbook，随时拿起来写点什么。<br>就是因为这种方便性，我在day ones写了有很多突发奇想的idea或者感悟或者感想，以及一些可以用来写作的主题。</p>\n<h2 id=\"「思维导图」类工具\"><a href=\"#「思维导图」类工具\" class=\"headerlink\" title=\"「思维导图」类工具\"></a>「思维导图」类工具</h2><p>1970年，英国的托尼·布詹提出了一种辅助思考的工具——思维导图。<br>它是通过平面上一个主题发散出来相关联对象所形成的中心网状结构的图。<br>由于这种表现方式比单纯的文本更加接近人类思考时的空间想象，越来越多人用于创造性思维过程中。<br>而我用思维脑图来做的比较多的是：</p>\n<ol>\n<li>项目设计、架构设计。</li>\n<li>个人任务整理。</li>\n<li>思考的时候用来记录思维过程。</li>\n<li>做会议笔记、读书笔记。</li>\n</ol>\n<p><strong><a href=\"http://naotu.baidu.com/\">百度脑图</a></strong><br>尽管最近的百度口碑都不好，但是无可厚非的是，百度下面的确有些产品是做的不错的，也不能一言蔽之。<br>百度脑图算是一个，比较纯粹的操作方式，加上一个云同步的功能，已经足够大部分需求了。<br>但是唯一让我还不满足的是，没有移动端的支持。<br>又是直到 「MindNode」限免为止…..</p>\n<p><strong><a href=\"http://mindnode.com/\">Mindnode</a></strong><br>如 DayOne ，Mindnode 是iOS独占的一款优秀应用，最重要可以三个客户端同步使用。<br>嗯，如果你是个苹果党，也正好不差钱，Mindnode我认为是最好的解决方案。</p>\n<h2 id=\"最后的一个建议，关注健康\"><a href=\"#最后的一个建议，关注健康\" class=\"headerlink\" title=\"最后的一个建议，关注健康\"></a>最后的一个建议，关注健康</h2><p>身体乃革命本钱，人类有区别与其他动物，就是能有反思自己思维的能力。<br>我们以血肉之躯来到世上，在诸如科幻片中可以实现「思想数字化」之前，我们的思想和思维的运作，都要依赖于我们现在的身体。<br>保养好我们的身体，可以让我们更好的完成更多的事情。<br>所以，我们开始站立办公了，解决方案就是：<a href=\"http://www.ikea.com/cn/zh/catalog/products/00193664/\">「39块的宜家拉克边桌」</a></p>\n<p><img src=\"/image/blog/keep-focus-and-efficiency/27126781261050CE71F6C864731FB459.jpg\" alt=\"站立办公\"></p>\n<h1 id=\"最后再啰嗦一下，关于团队效率\"><a href=\"#最后再啰嗦一下，关于团队效率\" class=\"headerlink\" title=\"最后再啰嗦一下，关于团队效率\"></a>最后再啰嗦一下，关于团队效率</h1><p>以上，都是讲述了如何提高个人的工作效率。<br>但是，现实的人类生产工作，都是团队性的，我们寻求在能保证个人效率之外，还需最大兼容到团队的效率。</p>\n<p>这里有一篇文章很好地讲述了一些「团队效率」的观点，也基本符合我现在所在团队的价值观。<br><a href=\"http://m.jiemian.com/article/800398.html\">腾讯：管理研发大团队就像10人小分队</a></p>\n<p>我的总结如下：</p>\n<ol>\n<li>角色分明，各司其职</li>\n<li>迭代流程，形成循环</li>\n<li>需求透明，进度透明</li>\n<li>线上数据，随手可得</li>\n<li>沟通沉淀，形成归档</li>\n</ol>\n<p>然后我们也一直在思考如何提高团队的效率，也有辅助一些工具，由于边幅问题。<br>改天另立文章，来安利一些不错的工具。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本篇讲述了以下内容：</p>\n<ol>\n<li>关于什么是专注，如何理解专注，以及如何达到专注。</li>\n<li>要做到专注，需要解决的问题。</li>\n<li>借助工具来解决这些问题，安利了一波。</li>\n<li>简单提及了一下团队效率</li>\n</ol>\n<h1 id=\"关于转载\"><a href=\"#关于转载\" class=\"headerlink\" title=\"关于转载\"></a>关于转载</h1><p>本文默认允许转载，但：</p>\n<ol>\n<li>请务必注明出处：<a href=\"http://huang-jerryc.com/2016/11/27/keep-focus-and-efficiency/\">BlueSun | 《程序员如何保证「专注」与「效率」》</a></li>\n<li>如果你不介意，我希望转载的同时，可以得到一声告知。(Email：huangjerryc@gmail.com)</li>\n</ol>\n<p>感谢！</p>\n"},{"title":"「理解HTTP」之常见的状态码","date":"2016-05-22T14:22:25.000Z","_content":"\n状态码的职责是当客户端向服务器端发送请求时，描述返回请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了什么错误。\n\n[RFC2616](http://pretty-rfc.herokuapp.com/RFC2616)定义的状态码，由3位数字和原因短信组成。\n数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种：\n\n| Type | Reason-phrase | Note |\n| ---  | -----| ------------- |\n| 1XX  | Informational | 信息性状态码，表示接受的请求正在处理 |\n| 2XX  | Success | 成功状态码，表示请求正常处理完毕 |\n| 3XX  | Redirection | 重定向状态码，表示需要客户端需要进行附加操作 |\n| 4XX  | Client Error | 客户端错误状态码，表示服务器无法处理请求 |\n| 5XX  | Server Error | 服务器错误状态码，表示服务器处理请求出错 |\n\nRFC2616记录的HTTP状态码有37种，再加上「WebDAV」([RFC4918](https://datatracker.ietf.org/doc/rfc4918/)、[5842](https://datatracker.ietf.org/doc/rfc5842/))和「Additional HTTP Status Codes」([RFC6585](https://datatracker.ietf.org/doc/rfc6585/))，数量就达到60多种。\n然并卵，这么多种HTTP状态码，其实常用的大概只有14种，本文就讲讲这14种状态码。\n\n## 2XX Success\n> This class of status code indicates that the client's request was successfully received, understood, and accepted.\n\n2xx 响应结果表示从客户端发来的请求在服务器端被正常处理了。\n\n### 200 OK\n请求被成功处理，服务器会根据不同的请求方法返回结果：\n**GET**：请求的对应资源会作为响应返回。\n**HEAD**：请求的对应资源的响应头(entity-header)会作为响应返回,不包括响应体(message-body)。\n**POST**：返回处理对应请求的结果。\n\n### 204 No Content\n该状态码表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.\n比如，客户端是浏览器的话，发出的请求返回204响应，那么浏览器显示的页面不会发生更新。\n\n### 206 Partial Content\n该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。\n客户端发起的请求，必须在请求头中包含[`Range`](http://pretty-rfc.herokuapp.com/RFC2616#header.range)字段。服务端响应报文中，必须包含由`Content-Range`指定范围的实体内容(entity-bodies )\n\n## 3XX Redirection\n> This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.\n\n3XX 响应结果表明浏览器需要执行某些特殊的处理以完成请求。\n\n### 301 Moved Permanently\n永久性重定向。该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI。并且根据请求的方法有不同的处理方式：\n**HEAD**：必须在响应头部`Location`字段中指明新的永久性的URI。\n**GET**：除了有`Location`字段以外，还需要在响应体中附上永久性URI的超链接文本。\n**POST**：客户端在发送POST请求，受到301响应之后，不应该自动跳转URI，应当让用户确认跳转。\n\n比如，如果一个URI已经在浏览器中被收藏为书签，这时应该按照`Location`首部字段提示的URI重新保存。\n例如建立一个收藏的书签：\n```\nhttp://wan.bigertech.com\n```\n当访问这个书签的时候，请求会被重定向到\n```\nhttp://wan.meizu.com\n```\n并且对应的书签会被改变，指向`http://wan.meizu.com`\n不信？Try yourself.\n\n### 302 Found\n临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。\n和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。\n如果，用户把一个URI收藏为书签，302响应是不会像301那样去更新书签。\n\n### 303 See Other\n该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。\n但是有一点是需要注意的，许多HTTP/1.1版以前的浏览器不能正确理解303状态码，很多现存的浏览器讲302响应视为303响应，并且使用GET方式访问`Location`中规定的的URI，而无视原先请求的方法。\n在RFC2616中有相关的这样一段原文：\n> Note: Many pre-HTTP/1.1 user agents do not understand the 303 status. When interoperability with such clients is a concern, the 302 status code may be used instead, since most user agents react to a 302 response as described here for 303.\n\n### 304 Not Modified\n该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主题部分。附带条件的请求指的是采用GET方法的请求头中包含：[`If-Match`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-match)、[`If-Modified-Since`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-modified-since)、[`If-None-Match`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-none-match)、[`If-Range`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-range)、[`If-Unmodified-Since`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-unmodified-since)中任一首部。\n\n### 307 Temporary Redirect\n临时重定向。该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。(302指定使用原有请求方法，303指定使用GET方法)\n\n## 4XX Client Error\n> The 4xx class of status code is intended for cases in which the client seems to have erred.\n\n4XX 的响应结果表明客户端是发生错误的原因所在\n\n### 400 Bad Request\n表示该请求报文中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。\n\n### 401 Unauthorized\n该状态码表示发送的请求需要有通过HTTP认证(Basic认证，Digest认证)的认证信息。返回含有401的响应，必须在头部包含[`WWW-Authenticate`](http://pretty-rfc.herokuapp.com/RFC2616#header.www-authenticate)以指明服务器需要哪种方式的认证。\n当客户端再次请求该资源的时候，需要在请求头中的[`Authorization`](http://pretty-rfc.herokuapp.com/RFC2616#header.authorization)包含认证信息。\n更多关于认证授权的信息关注[RFC2617](http://pretty-rfc.herokuapp.com/RFC2617)\n\n### 403 Forbidden\n该状态码表明对请求资源的访问被服务器拒绝了。服务器没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分原因进行描述，这样就能让用户看到了。\n未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应。\n\n### 404 Not Found\n该状态码表明服务器上无法找到指定的资源。通常被用于服务器不想透露拒绝请求的原因，或者没有其他的响应可提供。\n\n## 5XX Server Error\n> Response status codes beginning with the digit \"5\" indicate cases in which the server is aware that it has erred or is incapable of performing the request. \n\n5XX 的响应结果表明服务器本身发生错误，或者没有足够的能力来处理请求。\n\n### 500 Internal Server Error\n该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的BUG或某些临时的故障。\n\n### 503 Service Unavailable\n该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上需要的时间，最好写入`Retry-After`首部字段再返回给客户端。\n\n","source":"_posts/「理解HTTP」之常见的状态码.md","raw":"---\ntitle: 「理解HTTP」之常见的状态码\ncategory: 搬砖码农\ndate: 2016-05-22 22:22:25\ntags: \n- http\n---\n\n状态码的职责是当客户端向服务器端发送请求时，描述返回请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了什么错误。\n\n[RFC2616](http://pretty-rfc.herokuapp.com/RFC2616)定义的状态码，由3位数字和原因短信组成。\n数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种：\n\n| Type | Reason-phrase | Note |\n| ---  | -----| ------------- |\n| 1XX  | Informational | 信息性状态码，表示接受的请求正在处理 |\n| 2XX  | Success | 成功状态码，表示请求正常处理完毕 |\n| 3XX  | Redirection | 重定向状态码，表示需要客户端需要进行附加操作 |\n| 4XX  | Client Error | 客户端错误状态码，表示服务器无法处理请求 |\n| 5XX  | Server Error | 服务器错误状态码，表示服务器处理请求出错 |\n\nRFC2616记录的HTTP状态码有37种，再加上「WebDAV」([RFC4918](https://datatracker.ietf.org/doc/rfc4918/)、[5842](https://datatracker.ietf.org/doc/rfc5842/))和「Additional HTTP Status Codes」([RFC6585](https://datatracker.ietf.org/doc/rfc6585/))，数量就达到60多种。\n然并卵，这么多种HTTP状态码，其实常用的大概只有14种，本文就讲讲这14种状态码。\n\n## 2XX Success\n> This class of status code indicates that the client's request was successfully received, understood, and accepted.\n\n2xx 响应结果表示从客户端发来的请求在服务器端被正常处理了。\n\n### 200 OK\n请求被成功处理，服务器会根据不同的请求方法返回结果：\n**GET**：请求的对应资源会作为响应返回。\n**HEAD**：请求的对应资源的响应头(entity-header)会作为响应返回,不包括响应体(message-body)。\n**POST**：返回处理对应请求的结果。\n\n### 204 No Content\n该状态码表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.\n比如，客户端是浏览器的话，发出的请求返回204响应，那么浏览器显示的页面不会发生更新。\n\n### 206 Partial Content\n该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。\n客户端发起的请求，必须在请求头中包含[`Range`](http://pretty-rfc.herokuapp.com/RFC2616#header.range)字段。服务端响应报文中，必须包含由`Content-Range`指定范围的实体内容(entity-bodies )\n\n## 3XX Redirection\n> This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.\n\n3XX 响应结果表明浏览器需要执行某些特殊的处理以完成请求。\n\n### 301 Moved Permanently\n永久性重定向。该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI。并且根据请求的方法有不同的处理方式：\n**HEAD**：必须在响应头部`Location`字段中指明新的永久性的URI。\n**GET**：除了有`Location`字段以外，还需要在响应体中附上永久性URI的超链接文本。\n**POST**：客户端在发送POST请求，受到301响应之后，不应该自动跳转URI，应当让用户确认跳转。\n\n比如，如果一个URI已经在浏览器中被收藏为书签，这时应该按照`Location`首部字段提示的URI重新保存。\n例如建立一个收藏的书签：\n```\nhttp://wan.bigertech.com\n```\n当访问这个书签的时候，请求会被重定向到\n```\nhttp://wan.meizu.com\n```\n并且对应的书签会被改变，指向`http://wan.meizu.com`\n不信？Try yourself.\n\n### 302 Found\n临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。\n和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。\n如果，用户把一个URI收藏为书签，302响应是不会像301那样去更新书签。\n\n### 303 See Other\n该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。\n但是有一点是需要注意的，许多HTTP/1.1版以前的浏览器不能正确理解303状态码，很多现存的浏览器讲302响应视为303响应，并且使用GET方式访问`Location`中规定的的URI，而无视原先请求的方法。\n在RFC2616中有相关的这样一段原文：\n> Note: Many pre-HTTP/1.1 user agents do not understand the 303 status. When interoperability with such clients is a concern, the 302 status code may be used instead, since most user agents react to a 302 response as described here for 303.\n\n### 304 Not Modified\n该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主题部分。附带条件的请求指的是采用GET方法的请求头中包含：[`If-Match`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-match)、[`If-Modified-Since`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-modified-since)、[`If-None-Match`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-none-match)、[`If-Range`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-range)、[`If-Unmodified-Since`](http://pretty-rfc.herokuapp.com/RFC2616#header.if-unmodified-since)中任一首部。\n\n### 307 Temporary Redirect\n临时重定向。该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。(302指定使用原有请求方法，303指定使用GET方法)\n\n## 4XX Client Error\n> The 4xx class of status code is intended for cases in which the client seems to have erred.\n\n4XX 的响应结果表明客户端是发生错误的原因所在\n\n### 400 Bad Request\n表示该请求报文中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。\n\n### 401 Unauthorized\n该状态码表示发送的请求需要有通过HTTP认证(Basic认证，Digest认证)的认证信息。返回含有401的响应，必须在头部包含[`WWW-Authenticate`](http://pretty-rfc.herokuapp.com/RFC2616#header.www-authenticate)以指明服务器需要哪种方式的认证。\n当客户端再次请求该资源的时候，需要在请求头中的[`Authorization`](http://pretty-rfc.herokuapp.com/RFC2616#header.authorization)包含认证信息。\n更多关于认证授权的信息关注[RFC2617](http://pretty-rfc.herokuapp.com/RFC2617)\n\n### 403 Forbidden\n该状态码表明对请求资源的访问被服务器拒绝了。服务器没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分原因进行描述，这样就能让用户看到了。\n未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应。\n\n### 404 Not Found\n该状态码表明服务器上无法找到指定的资源。通常被用于服务器不想透露拒绝请求的原因，或者没有其他的响应可提供。\n\n## 5XX Server Error\n> Response status codes beginning with the digit \"5\" indicate cases in which the server is aware that it has erred or is incapable of performing the request. \n\n5XX 的响应结果表明服务器本身发生错误，或者没有足够的能力来处理请求。\n\n### 500 Internal Server Error\n该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的BUG或某些临时的故障。\n\n### 503 Service Unavailable\n该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上需要的时间，最好写入`Retry-After`首部字段再返回给客户端。\n\n","slug":"「理解HTTP」之常见的状态码","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwq4001h15hlpkg6brw0","content":"<p>状态码的职责是当客户端向服务器端发送请求时，描述返回请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了什么错误。</p>\n<p><a href=\"http://pretty-rfc.herokuapp.com/RFC2616\" target=\"_blank\" rel=\"external\">RFC2616</a>定义的状态码，由3位数字和原因短信组成。<br>数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种：</p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Reason-phrase</th>\n<th>Note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td>Informational</td>\n<td>信息性状态码，表示接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success</td>\n<td>成功状态码，表示请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection</td>\n<td>重定向状态码，表示需要客户端需要进行附加操作</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error</td>\n<td>客户端错误状态码，表示服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error</td>\n<td>服务器错误状态码，表示服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<p>RFC2616记录的HTTP状态码有37种，再加上「WebDAV」(<a href=\"https://datatracker.ietf.org/doc/rfc4918/\" target=\"_blank\" rel=\"external\">RFC4918</a>、<a href=\"https://datatracker.ietf.org/doc/rfc5842/\" target=\"_blank\" rel=\"external\">5842</a>)和「Additional HTTP Status Codes」(<a href=\"https://datatracker.ietf.org/doc/rfc6585/\" target=\"_blank\" rel=\"external\">RFC6585</a>)，数量就达到60多种。<br>然并卵，这么多种HTTP状态码，其实常用的大概只有14种，本文就讲讲这14种状态码。</p>\n<h2 id=\"2XX-Success\"><a href=\"#2XX-Success\" class=\"headerlink\" title=\"2XX Success\"></a>2XX Success</h2><blockquote>\n<p>This class of status code indicates that the client’s request was successfully received, understood, and accepted.</p>\n</blockquote>\n<p>2xx 响应结果表示从客户端发来的请求在服务器端被正常处理了。</p>\n<h3 id=\"200-OK\"><a href=\"#200-OK\" class=\"headerlink\" title=\"200 OK\"></a>200 OK</h3><p>请求被成功处理，服务器会根据不同的请求方法返回结果：<br><strong>GET</strong>：请求的对应资源会作为响应返回。<br><strong>HEAD</strong>：请求的对应资源的响应头(entity-header)会作为响应返回,不包括响应体(message-body)。<br><strong>POST</strong>：返回处理对应请求的结果。</p>\n<h3 id=\"204-No-Content\"><a href=\"#204-No-Content\" class=\"headerlink\" title=\"204 No Content\"></a>204 No Content</h3><p>该状态码表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.<br>比如，客户端是浏览器的话，发出的请求返回204响应，那么浏览器显示的页面不会发生更新。</p>\n<h3 id=\"206-Partial-Content\"><a href=\"#206-Partial-Content\" class=\"headerlink\" title=\"206 Partial Content\"></a>206 Partial Content</h3><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。<br>客户端发起的请求，必须在请求头中包含<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.range\" target=\"_blank\" rel=\"external\"><code>Range</code></a>字段。服务端响应报文中，必须包含由<code>Content-Range</code>指定范围的实体内容(entity-bodies )</p>\n<h2 id=\"3XX-Redirection\"><a href=\"#3XX-Redirection\" class=\"headerlink\" title=\"3XX Redirection\"></a>3XX Redirection</h2><blockquote>\n<p>This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.</p>\n</blockquote>\n<p>3XX 响应结果表明浏览器需要执行某些特殊的处理以完成请求。</p>\n<h3 id=\"301-Moved-Permanently\"><a href=\"#301-Moved-Permanently\" class=\"headerlink\" title=\"301 Moved Permanently\"></a>301 Moved Permanently</h3><p>永久性重定向。该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI。并且根据请求的方法有不同的处理方式：<br><strong>HEAD</strong>：必须在响应头部<code>Location</code>字段中指明新的永久性的URI。<br><strong>GET</strong>：除了有<code>Location</code>字段以外，还需要在响应体中附上永久性URI的超链接文本。<br><strong>POST</strong>：客户端在发送POST请求，受到301响应之后，不应该自动跳转URI，应当让用户确认跳转。</p>\n<p>比如，如果一个URI已经在浏览器中被收藏为书签，这时应该按照<code>Location</code>首部字段提示的URI重新保存。<br>例如建立一个收藏的书签：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://wan.bigertech.com</div></pre></td></tr></table></figure></p>\n<p>当访问这个书签的时候，请求会被重定向到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://wan.meizu.com</div></pre></td></tr></table></figure></p>\n<p>并且对应的书签会被改变，指向<code>http://wan.meizu.com</code><br>不信？Try yourself.</p>\n<h3 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a>302 Found</h3><p>临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。<br>和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。<br>如果，用户把一个URI收藏为书签，302响应是不会像301那样去更新书签。</p>\n<h3 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h3><p>该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。<br>但是有一点是需要注意的，许多HTTP/1.1版以前的浏览器不能正确理解303状态码，很多现存的浏览器讲302响应视为303响应，并且使用GET方式访问<code>Location</code>中规定的的URI，而无视原先请求的方法。<br>在RFC2616中有相关的这样一段原文：</p>\n<blockquote>\n<p>Note: Many pre-HTTP/1.1 user agents do not understand the 303 status. When interoperability with such clients is a concern, the 302 status code may be used instead, since most user agents react to a 302 response as described here for 303.</p>\n</blockquote>\n<h3 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a>304 Not Modified</h3><p>该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主题部分。附带条件的请求指的是采用GET方法的请求头中包含：<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-match\" target=\"_blank\" rel=\"external\"><code>If-Match</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-modified-since\" target=\"_blank\" rel=\"external\"><code>If-Modified-Since</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-none-match\" target=\"_blank\" rel=\"external\"><code>If-None-Match</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-range\" target=\"_blank\" rel=\"external\"><code>If-Range</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-unmodified-since\" target=\"_blank\" rel=\"external\"><code>If-Unmodified-Since</code></a>中任一首部。</p>\n<h3 id=\"307-Temporary-Redirect\"><a href=\"#307-Temporary-Redirect\" class=\"headerlink\" title=\"307 Temporary Redirect\"></a>307 Temporary Redirect</h3><p>临时重定向。该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。(302指定使用原有请求方法，303指定使用GET方法)</p>\n<h2 id=\"4XX-Client-Error\"><a href=\"#4XX-Client-Error\" class=\"headerlink\" title=\"4XX Client Error\"></a>4XX Client Error</h2><blockquote>\n<p>The 4xx class of status code is intended for cases in which the client seems to have erred.</p>\n</blockquote>\n<p>4XX 的响应结果表明客户端是发生错误的原因所在</p>\n<h3 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h3><p>表示该请求报文中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。</p>\n<h3 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h3><p>该状态码表示发送的请求需要有通过HTTP认证(Basic认证，Digest认证)的认证信息。返回含有401的响应，必须在头部包含<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.www-authenticate\" target=\"_blank\" rel=\"external\"><code>WWW-Authenticate</code></a>以指明服务器需要哪种方式的认证。<br>当客户端再次请求该资源的时候，需要在请求头中的<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.authorization\" target=\"_blank\" rel=\"external\"><code>Authorization</code></a>包含认证信息。<br>更多关于认证授权的信息关注<a href=\"http://pretty-rfc.herokuapp.com/RFC2617\" target=\"_blank\" rel=\"external\">RFC2617</a></p>\n<h3 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a>403 Forbidden</h3><p>该状态码表明对请求资源的访问被服务器拒绝了。服务器没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分原因进行描述，这样就能让用户看到了。<br>未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应。</p>\n<h3 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h3><p>该状态码表明服务器上无法找到指定的资源。通常被用于服务器不想透露拒绝请求的原因，或者没有其他的响应可提供。</p>\n<h2 id=\"5XX-Server-Error\"><a href=\"#5XX-Server-Error\" class=\"headerlink\" title=\"5XX Server Error\"></a>5XX Server Error</h2><blockquote>\n<p>Response status codes beginning with the digit “5” indicate cases in which the server is aware that it has erred or is incapable of performing the request. </p>\n</blockquote>\n<p>5XX 的响应结果表明服务器本身发生错误，或者没有足够的能力来处理请求。</p>\n<h3 id=\"500-Internal-Server-Error\"><a href=\"#500-Internal-Server-Error\" class=\"headerlink\" title=\"500 Internal Server Error\"></a>500 Internal Server Error</h3><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的BUG或某些临时的故障。</p>\n<h3 id=\"503-Service-Unavailable\"><a href=\"#503-Service-Unavailable\" class=\"headerlink\" title=\"503 Service Unavailable\"></a>503 Service Unavailable</h3><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上需要的时间，最好写入<code>Retry-After</code>首部字段再返回给客户端。</p>\n","excerpt":"","more":"<p>状态码的职责是当客户端向服务器端发送请求时，描述返回请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了什么错误。</p>\n<p><a href=\"http://pretty-rfc.herokuapp.com/RFC2616\">RFC2616</a>定义的状态码，由3位数字和原因短信组成。<br>数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种：</p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Reason-phrase</th>\n<th>Note</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td>Informational</td>\n<td>信息性状态码，表示接受的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success</td>\n<td>成功状态码，表示请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection</td>\n<td>重定向状态码，表示需要客户端需要进行附加操作</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error</td>\n<td>客户端错误状态码，表示服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error</td>\n<td>服务器错误状态码，表示服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<p>RFC2616记录的HTTP状态码有37种，再加上「WebDAV」(<a href=\"https://datatracker.ietf.org/doc/rfc4918/\">RFC4918</a>、<a href=\"https://datatracker.ietf.org/doc/rfc5842/\">5842</a>)和「Additional HTTP Status Codes」(<a href=\"https://datatracker.ietf.org/doc/rfc6585/\">RFC6585</a>)，数量就达到60多种。<br>然并卵，这么多种HTTP状态码，其实常用的大概只有14种，本文就讲讲这14种状态码。</p>\n<h2 id=\"2XX-Success\"><a href=\"#2XX-Success\" class=\"headerlink\" title=\"2XX Success\"></a>2XX Success</h2><blockquote>\n<p>This class of status code indicates that the client’s request was successfully received, understood, and accepted.</p>\n</blockquote>\n<p>2xx 响应结果表示从客户端发来的请求在服务器端被正常处理了。</p>\n<h3 id=\"200-OK\"><a href=\"#200-OK\" class=\"headerlink\" title=\"200 OK\"></a>200 OK</h3><p>请求被成功处理，服务器会根据不同的请求方法返回结果：<br><strong>GET</strong>：请求的对应资源会作为响应返回。<br><strong>HEAD</strong>：请求的对应资源的响应头(entity-header)会作为响应返回,不包括响应体(message-body)。<br><strong>POST</strong>：返回处理对应请求的结果。</p>\n<h3 id=\"204-No-Content\"><a href=\"#204-No-Content\" class=\"headerlink\" title=\"204 No Content\"></a>204 No Content</h3><p>该状态码表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.<br>比如，客户端是浏览器的话，发出的请求返回204响应，那么浏览器显示的页面不会发生更新。</p>\n<h3 id=\"206-Partial-Content\"><a href=\"#206-Partial-Content\" class=\"headerlink\" title=\"206 Partial Content\"></a>206 Partial Content</h3><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。<br>客户端发起的请求，必须在请求头中包含<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.range\"><code>Range</code></a>字段。服务端响应报文中，必须包含由<code>Content-Range</code>指定范围的实体内容(entity-bodies )</p>\n<h2 id=\"3XX-Redirection\"><a href=\"#3XX-Redirection\" class=\"headerlink\" title=\"3XX Redirection\"></a>3XX Redirection</h2><blockquote>\n<p>This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.</p>\n</blockquote>\n<p>3XX 响应结果表明浏览器需要执行某些特殊的处理以完成请求。</p>\n<h3 id=\"301-Moved-Permanently\"><a href=\"#301-Moved-Permanently\" class=\"headerlink\" title=\"301 Moved Permanently\"></a>301 Moved Permanently</h3><p>永久性重定向。该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI。并且根据请求的方法有不同的处理方式：<br><strong>HEAD</strong>：必须在响应头部<code>Location</code>字段中指明新的永久性的URI。<br><strong>GET</strong>：除了有<code>Location</code>字段以外，还需要在响应体中附上永久性URI的超链接文本。<br><strong>POST</strong>：客户端在发送POST请求，受到301响应之后，不应该自动跳转URI，应当让用户确认跳转。</p>\n<p>比如，如果一个URI已经在浏览器中被收藏为书签，这时应该按照<code>Location</code>首部字段提示的URI重新保存。<br>例如建立一个收藏的书签：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://wan.bigertech.com</div></pre></td></tr></table></figure></p>\n<p>当访问这个书签的时候，请求会被重定向到<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://wan.meizu.com</div></pre></td></tr></table></figure></p>\n<p>并且对应的书签会被改变，指向<code>http://wan.meizu.com</code><br>不信？Try yourself.</p>\n<h3 id=\"302-Found\"><a href=\"#302-Found\" class=\"headerlink\" title=\"302 Found\"></a>302 Found</h3><p>临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。<br>和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。<br>如果，用户把一个URI收藏为书签，302响应是不会像301那样去更新书签。</p>\n<h3 id=\"303-See-Other\"><a href=\"#303-See-Other\" class=\"headerlink\" title=\"303 See Other\"></a>303 See Other</h3><p>该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。<br>但是有一点是需要注意的，许多HTTP/1.1版以前的浏览器不能正确理解303状态码，很多现存的浏览器讲302响应视为303响应，并且使用GET方式访问<code>Location</code>中规定的的URI，而无视原先请求的方法。<br>在RFC2616中有相关的这样一段原文：</p>\n<blockquote>\n<p>Note: Many pre-HTTP/1.1 user agents do not understand the 303 status. When interoperability with such clients is a concern, the 302 status code may be used instead, since most user agents react to a 302 response as described here for 303.</p>\n</blockquote>\n<h3 id=\"304-Not-Modified\"><a href=\"#304-Not-Modified\" class=\"headerlink\" title=\"304 Not Modified\"></a>304 Not Modified</h3><p>该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主题部分。附带条件的请求指的是采用GET方法的请求头中包含：<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-match\"><code>If-Match</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-modified-since\"><code>If-Modified-Since</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-none-match\"><code>If-None-Match</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-range\"><code>If-Range</code></a>、<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.if-unmodified-since\"><code>If-Unmodified-Since</code></a>中任一首部。</p>\n<h3 id=\"307-Temporary-Redirect\"><a href=\"#307-Temporary-Redirect\" class=\"headerlink\" title=\"307 Temporary Redirect\"></a>307 Temporary Redirect</h3><p>临时重定向。该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。(302指定使用原有请求方法，303指定使用GET方法)</p>\n<h2 id=\"4XX-Client-Error\"><a href=\"#4XX-Client-Error\" class=\"headerlink\" title=\"4XX Client Error\"></a>4XX Client Error</h2><blockquote>\n<p>The 4xx class of status code is intended for cases in which the client seems to have erred.</p>\n</blockquote>\n<p>4XX 的响应结果表明客户端是发生错误的原因所在</p>\n<h3 id=\"400-Bad-Request\"><a href=\"#400-Bad-Request\" class=\"headerlink\" title=\"400 Bad Request\"></a>400 Bad Request</h3><p>表示该请求报文中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。</p>\n<h3 id=\"401-Unauthorized\"><a href=\"#401-Unauthorized\" class=\"headerlink\" title=\"401 Unauthorized\"></a>401 Unauthorized</h3><p>该状态码表示发送的请求需要有通过HTTP认证(Basic认证，Digest认证)的认证信息。返回含有401的响应，必须在头部包含<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.www-authenticate\"><code>WWW-Authenticate</code></a>以指明服务器需要哪种方式的认证。<br>当客户端再次请求该资源的时候，需要在请求头中的<a href=\"http://pretty-rfc.herokuapp.com/RFC2616#header.authorization\"><code>Authorization</code></a>包含认证信息。<br>更多关于认证授权的信息关注<a href=\"http://pretty-rfc.herokuapp.com/RFC2617\">RFC2617</a></p>\n<h3 id=\"403-Forbidden\"><a href=\"#403-Forbidden\" class=\"headerlink\" title=\"403 Forbidden\"></a>403 Forbidden</h3><p>该状态码表明对请求资源的访问被服务器拒绝了。服务器没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分原因进行描述，这样就能让用户看到了。<br>未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应。</p>\n<h3 id=\"404-Not-Found\"><a href=\"#404-Not-Found\" class=\"headerlink\" title=\"404 Not Found\"></a>404 Not Found</h3><p>该状态码表明服务器上无法找到指定的资源。通常被用于服务器不想透露拒绝请求的原因，或者没有其他的响应可提供。</p>\n<h2 id=\"5XX-Server-Error\"><a href=\"#5XX-Server-Error\" class=\"headerlink\" title=\"5XX Server Error\"></a>5XX Server Error</h2><blockquote>\n<p>Response status codes beginning with the digit “5” indicate cases in which the server is aware that it has erred or is incapable of performing the request. </p>\n</blockquote>\n<p>5XX 的响应结果表明服务器本身发生错误，或者没有足够的能力来处理请求。</p>\n<h3 id=\"500-Internal-Server-Error\"><a href=\"#500-Internal-Server-Error\" class=\"headerlink\" title=\"500 Internal Server Error\"></a>500 Internal Server Error</h3><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的BUG或某些临时的故障。</p>\n<h3 id=\"503-Service-Unavailable\"><a href=\"#503-Service-Unavailable\" class=\"headerlink\" title=\"503 Service Unavailable\"></a>503 Service Unavailable</h3><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上需要的时间，最好写入<code>Retry-After</code>首部字段再返回给客户端。</p>\n"},{"title":"了解 Nginx 的基本概念","date":"2016-10-14T09:39:00.000Z","_content":"\n# 前言\n本篇是我学习Nginx的一些笔记，主要内容讲述了一些了解Nginx需要的基本概念。\n然后探讨一下Nginx的模块化的组织架构，以及各个模块的分类、工作方式、职责和提供的相关指令。\n主要达到以下目的：\n1. 了解Nginx的大概运行原理\n2. 了解Nginx的基本概念\n3. 知道怎么看官方文档。\n\n# 关于Nginx\nNginx是一款面向性能设计的HTTP服务器，能反向代理HTTP，HTTPS和邮件相关(SMTP，POP3，IMAP)的协议链接。并且提供了负载均衡以及HTTP缓存。\n它的设计充分使用异步事件模型，削减上下文调度的开销，提高服务器并发能力。\n采用了模块化设计，提供了丰富模块的第三方模块。\n所以关于Nginx，有这些标签：「异步」「事件」「模块化」「高性能」「高并发」「反向代理」「负载均衡」\n \n# 基本概念\n\n## 进程模型\nNginx的进程是使用经典的「Master-Worker」模型。\nNginx在启动后，会有一个master进程和多个worker进程。\nmaster进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。\nworker进程主要处理基本的网络事件，多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。需要注意的是，每个Worker只有主线程，即所谓的「单线程」。\n一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。\nworker进程的个数是可以设置的，一般会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。更多的worker数，只会导致进程来竞争cpu资源。\n\n![Nginx 进程模型.png](/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png)\n\n## 事件模型\nNginx对于事件，以「异步非阻塞」方式来实现。\n异步和非异步，阻塞和非阻塞是两组不同的概念，前者更多对于应用程序而言，而后者更多对于CPU来说：\n1. 异步：执行一个动作之后，可以去操作别的操作，然后等待通知再回来执行刚才没执行完的操作。\n2. 非异步(同步)：执行一个操作之后，等待结果，然后才继续执行下面的操作。\n3. 阻塞：给CPU传达任务之后，一直等待CPU处理完毕(即使会产生I/O)，然后才执行下面操作。\n4. 非阻塞：给CPU传达任务之后，继续处理后面的操作，隔段时间再来询问之前的操作是否完成。这样的及过程也叫「轮询」\n\nNginx的「异步非阻塞」方式，具体到系统调用的话，就是像select/poll/epoll/kqueue这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。\n\nepoll是在Linux上关于事件的实现，而kqueue是OpenBSD或FreeBSD操作系统上采用类似epoll的事件模型。\n所以重点讲解一下epoll的模型：\n\n![epoll事件模型.png](/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png)\n\n\n该方案给是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进入休眠，直到事件将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。\n\n## 反向代理\n要了解「反向代理」，首先需要知道什么是「代理服务器」和「正向代理」\n\n### 代理服务器\n在网络中，客户端发起一个请求，获取服务器端的资源。它们之间并不是建立一条直接的通道，而是被代理服务器所转发。\n代理服务器作为网络中的媒介将互联网上获取的资源返回给相关的客户端。\n我们通常所说的代理，一般都指的是「正向代理」，是相对于客户端来说的。\n比方说我链接了一个VPN，我访问Google的时候，客户端发起的请求到了VPN，VPN帮忙转发请求Google的服务器，然后把Google响应返回给客户端。这个过程，VPN就充当了「正向代理服务器」的角色。\n\n![代理服务器.png](/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png)\n\n### 反向代理\n和「正向代理」不同，「反向代理」的说法面向于服务器端。一个客户端请求来到代理服务器，代理服务器根据客户端的请求的不同而把请求转发到不同的服务器，这个过程在「负载均衡」中，也会发生两个一样的请求，会转发到完全不一样的服务器中的情况。\n「反向代理」是「负载均衡」实现的前提，正因为代理服务器有了解析请求，分发请求的能力，才能实现负载均衡，降低每一台服务器的负荷。\n利用「反向代理」，除了实现负载均衡，还可以实现诸如：SSL加密，静态内容缓存，gzip压缩，减速上传，安全等功能\n\n![反向代理.png](/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png)\n\n## 负载均衡\n负载均衡（Load balancing）是一种计算机网络技术，用来在多个服务器中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。\n使用带有负载均衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务的实现可以通过软件和硬件来实现。\n负载均衡的分发，一般都会有多套算法来处理分发问题。\n\n## 连接 Connection  \n在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。利用nginx封装的connection，我们可以很方便的使用nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。\n而nginx中的http请求的处理就是建立在connection之上的，所以nginx不仅可以作为一个web服务器，也可以作为邮件服务器。\n当然，利用nginx提供的connection，我们可以与任何后端服务打交道。\n\n### 最大连接数\n在nginx中，每个进程会有一个连接数的最大上限，这个上限与系统对fd的限制不一样。\n在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。\nnginx通过设置`worker_connectons`来设置每个进程支持的最大连接数。如果该值大于nofile，那么实际的最大连接数是nofile，nginx会有警告。\nnginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是`worker_connections`。这里的连接池里面保存的其实不是真实的连接，它只是一个`worker_connections`大小的一个`ngx_connection_t`结构的数组。并且，nginx会通过一个链表`free_connections`来保存所有的空闲`ngx_connection_t`，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。\n\n所以，一个nginx能建立的最大连接数：`worker_connections * worker_processes`，\n如果当nginx作为反向代理的话，因为一个请求nginx要建立客户端和服务器的请求，所以最大连接数是：`worker_connections * worker_processes / 2`\n\n## 请求 Request\n在nginx中我们指http请求，具体到nginx中的数据结构是`ngx_http_request_t`。\n它是对一个http请求的封装，nginx通过`ngx_http_request_t`来保存解析请求与输出响应相关的数据。\n一个http请求，包含请求行、请求头、请求体、响应行、响应头、响应体。\n\n一般性的网络请求处理过程是：\n1. 客户端会发送请求过来。\n2. 然后我们读取一行数据，分析出请求行中包含的method、uri、http_version信息。\n3. 然后再一行一行处理请求头，并根据请求method与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。\n4. 得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。\n5. 在将响应发送给客户端之后，一个完整的请求就处理完了。\n\n而nginx处理请求的时候会有一些小小的区别，比如，当请求头读取完成后，就开始进行请求的处理了。\n\n### Nginx处理请求过程\n\nnginx处理一个请求的抽象概念过程：\n1. request 请求进来\n2. 初始化HTTP Request， 生成 HTTP Request对象\n3. 处理请求头\n4. 处理请求体\n5. 调用与此请求关联的handler（根据你URL或者Location配置）\n6. 依次调用各phase handler进行处理\n\t1. 获取location配置\n\t2. 产生适当的响应\n\t3. 发送response header\n\t4. 发送response body\n\t\n\n# 基本数据结构\nnginx的作者为追求极致的高效，自己实现了很多颇具特色的nginx风格的数据结构以及公共函数。比如，nginx提供了带长度的字符串，根据编译器选项优化过的字符串拷贝函数ngx_copy等。\n*ps: 下横线分割是C语言的变量名风格*\n\n| Data Structure | Description |\n| -------------  | ----------- |\n| ngx_str_t | 字符串封装 |\n| ngx_pool_t | 提供一种机制，帮助管理一系列的资源（内存，文件）|\n| ngx_array_t | 数组结构 |\n| ngx_chain_t | 主要用于模块之间数据传递的链表实现 |\n| ngx_buf_t | 就是ngx_chain_t链表的每个节点的实际实现，代表某种具体的数据。|\n| ngx_list_t | list数据结构的实现，以及增强 |\n| ngx_queue_t | 实现的双向链表 |\n| ngx_hash_t | hash表的实现 |\n| ngx_hash_wildcard_t | 为处理带有通配符域名的匹配问题实现的hash表结构 |\n| ngx_combinded_t | 在于提供一个方便的容器包含三个类型的hash表 |\n| ngx_hash_keys_arrays_t | 用于构建其他类型的hash的辅助类 |\n\n# 配置\nnginx的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于nginx安装目录下的conf目录下。\n指令由nginx的各个模块提供，不同的模块会提供不同的指令来实现配置。\n指令除了Key-Value的形式，还有作用域指令。\nnginx.conf中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。\n\n下面的这些上下文指令是用的比较多：\n\n| Directive | Description | Contains Directive |\n| --------  | ----------- | ------------------ |\n| main | nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。| user, worker_processes, error_log, events, http, mail |\n| http | 与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。| server |\n| server | http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。 | listen, server_name, access_log, location, protocol, proxy, smtp_auth, xclient |\n| location | http服务中，某些特定的URL对应的一系列配置项。| index, root |\n| mail | 实现email相关的SMTP/IMAP/POP3代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。| server, http, imap_capabilities |\n\n# 模块\nnginx将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现SSI的模块，实现与上游服务器进行通讯的模块，实现与FastCGI服务进行通讯的模块。\n模块分三类：\n1. 核心模块\n2. 辅助模块\n3. 第三方模块\n\n根据官方文档排版，辅助模块还分了以下几类：\n1. http\n2. mail\n3. stream\n\n而根据其功能可以分成这几大类：\n1. **handler模块**\n  此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。\n2. **filter模块**\n  过滤响应头和内容的模块，可以对回复的头和内容进行处理。它的处理时间在获取回复内容之后，向用户发送响应之前。\n3. **upstream模块**\n  upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream模块是一种特殊的handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。\n4. **load balance模块**\n  负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器\n\n\n\n# 结尾\n\n本文讲述了Nginx的一些基本概念。\nNginx是线程模型是Master-Worker模式的，每个worker是单线程的，也就是处理请求是单线程处理的。而单线程并发的事件模型是「异步非阻塞I/O」模型。\n并且讲述了「反向代理」「负载均衡」的概念，这是nginx能高性能处理高并发的原因之一。\nNginx对于网络请求是有Connection和Request的概念和封装的。\nNginx的源码组织架构是模块化的，不同的模块实现不一样的职责，然后它们被连接起来一起干一件大事，知道模块有哪些分类，可以让我们知道怎么查找官方文档。\n在没有看过有哪些指令，哪些指令有什么功能之前，是不能完全知道nginx提供什么样的功能的，那就抱着，那就抱着「能想到的别人都想到并实现了」的想法来使用nginx吧。Nginx作为一个代理服务，在中间想做什么都可以啦。\n\n# 参考\n[Nginx开发从入门到精通](http://tengine.taobao.org/book/chapter_04.html#id2)\n[Nginx官方网站](http://nginx.org/)\n[《计算机操作系统》]()\n[《深入浅出Node.js》]()","source":"_posts/了解 Nginx 的基本概念.md","raw":"---\ntitle: 了解 Nginx 的基本概念\ncategory: 搬砖码农\ndate: 2016-10-14 17:39:00\ntags:\n- Nginx\n---\n\n# 前言\n本篇是我学习Nginx的一些笔记，主要内容讲述了一些了解Nginx需要的基本概念。\n然后探讨一下Nginx的模块化的组织架构，以及各个模块的分类、工作方式、职责和提供的相关指令。\n主要达到以下目的：\n1. 了解Nginx的大概运行原理\n2. 了解Nginx的基本概念\n3. 知道怎么看官方文档。\n\n# 关于Nginx\nNginx是一款面向性能设计的HTTP服务器，能反向代理HTTP，HTTPS和邮件相关(SMTP，POP3，IMAP)的协议链接。并且提供了负载均衡以及HTTP缓存。\n它的设计充分使用异步事件模型，削减上下文调度的开销，提高服务器并发能力。\n采用了模块化设计，提供了丰富模块的第三方模块。\n所以关于Nginx，有这些标签：「异步」「事件」「模块化」「高性能」「高并发」「反向代理」「负载均衡」\n \n# 基本概念\n\n## 进程模型\nNginx的进程是使用经典的「Master-Worker」模型。\nNginx在启动后，会有一个master进程和多个worker进程。\nmaster进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。\nworker进程主要处理基本的网络事件，多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。需要注意的是，每个Worker只有主线程，即所谓的「单线程」。\n一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。\nworker进程的个数是可以设置的，一般会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。更多的worker数，只会导致进程来竞争cpu资源。\n\n![Nginx 进程模型.png](/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png)\n\n## 事件模型\nNginx对于事件，以「异步非阻塞」方式来实现。\n异步和非异步，阻塞和非阻塞是两组不同的概念，前者更多对于应用程序而言，而后者更多对于CPU来说：\n1. 异步：执行一个动作之后，可以去操作别的操作，然后等待通知再回来执行刚才没执行完的操作。\n2. 非异步(同步)：执行一个操作之后，等待结果，然后才继续执行下面的操作。\n3. 阻塞：给CPU传达任务之后，一直等待CPU处理完毕(即使会产生I/O)，然后才执行下面操作。\n4. 非阻塞：给CPU传达任务之后，继续处理后面的操作，隔段时间再来询问之前的操作是否完成。这样的及过程也叫「轮询」\n\nNginx的「异步非阻塞」方式，具体到系统调用的话，就是像select/poll/epoll/kqueue这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。\n\nepoll是在Linux上关于事件的实现，而kqueue是OpenBSD或FreeBSD操作系统上采用类似epoll的事件模型。\n所以重点讲解一下epoll的模型：\n\n![epoll事件模型.png](/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png)\n\n\n该方案给是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进入休眠，直到事件将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。\n\n## 反向代理\n要了解「反向代理」，首先需要知道什么是「代理服务器」和「正向代理」\n\n### 代理服务器\n在网络中，客户端发起一个请求，获取服务器端的资源。它们之间并不是建立一条直接的通道，而是被代理服务器所转发。\n代理服务器作为网络中的媒介将互联网上获取的资源返回给相关的客户端。\n我们通常所说的代理，一般都指的是「正向代理」，是相对于客户端来说的。\n比方说我链接了一个VPN，我访问Google的时候，客户端发起的请求到了VPN，VPN帮忙转发请求Google的服务器，然后把Google响应返回给客户端。这个过程，VPN就充当了「正向代理服务器」的角色。\n\n![代理服务器.png](/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png)\n\n### 反向代理\n和「正向代理」不同，「反向代理」的说法面向于服务器端。一个客户端请求来到代理服务器，代理服务器根据客户端的请求的不同而把请求转发到不同的服务器，这个过程在「负载均衡」中，也会发生两个一样的请求，会转发到完全不一样的服务器中的情况。\n「反向代理」是「负载均衡」实现的前提，正因为代理服务器有了解析请求，分发请求的能力，才能实现负载均衡，降低每一台服务器的负荷。\n利用「反向代理」，除了实现负载均衡，还可以实现诸如：SSL加密，静态内容缓存，gzip压缩，减速上传，安全等功能\n\n![反向代理.png](/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png)\n\n## 负载均衡\n负载均衡（Load balancing）是一种计算机网络技术，用来在多个服务器中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。\n使用带有负载均衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务的实现可以通过软件和硬件来实现。\n负载均衡的分发，一般都会有多套算法来处理分发问题。\n\n## 连接 Connection  \n在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。利用nginx封装的connection，我们可以很方便的使用nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。\n而nginx中的http请求的处理就是建立在connection之上的，所以nginx不仅可以作为一个web服务器，也可以作为邮件服务器。\n当然，利用nginx提供的connection，我们可以与任何后端服务打交道。\n\n### 最大连接数\n在nginx中，每个进程会有一个连接数的最大上限，这个上限与系统对fd的限制不一样。\n在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。\nnginx通过设置`worker_connectons`来设置每个进程支持的最大连接数。如果该值大于nofile，那么实际的最大连接数是nofile，nginx会有警告。\nnginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是`worker_connections`。这里的连接池里面保存的其实不是真实的连接，它只是一个`worker_connections`大小的一个`ngx_connection_t`结构的数组。并且，nginx会通过一个链表`free_connections`来保存所有的空闲`ngx_connection_t`，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。\n\n所以，一个nginx能建立的最大连接数：`worker_connections * worker_processes`，\n如果当nginx作为反向代理的话，因为一个请求nginx要建立客户端和服务器的请求，所以最大连接数是：`worker_connections * worker_processes / 2`\n\n## 请求 Request\n在nginx中我们指http请求，具体到nginx中的数据结构是`ngx_http_request_t`。\n它是对一个http请求的封装，nginx通过`ngx_http_request_t`来保存解析请求与输出响应相关的数据。\n一个http请求，包含请求行、请求头、请求体、响应行、响应头、响应体。\n\n一般性的网络请求处理过程是：\n1. 客户端会发送请求过来。\n2. 然后我们读取一行数据，分析出请求行中包含的method、uri、http_version信息。\n3. 然后再一行一行处理请求头，并根据请求method与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。\n4. 得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。\n5. 在将响应发送给客户端之后，一个完整的请求就处理完了。\n\n而nginx处理请求的时候会有一些小小的区别，比如，当请求头读取完成后，就开始进行请求的处理了。\n\n### Nginx处理请求过程\n\nnginx处理一个请求的抽象概念过程：\n1. request 请求进来\n2. 初始化HTTP Request， 生成 HTTP Request对象\n3. 处理请求头\n4. 处理请求体\n5. 调用与此请求关联的handler（根据你URL或者Location配置）\n6. 依次调用各phase handler进行处理\n\t1. 获取location配置\n\t2. 产生适当的响应\n\t3. 发送response header\n\t4. 发送response body\n\t\n\n# 基本数据结构\nnginx的作者为追求极致的高效，自己实现了很多颇具特色的nginx风格的数据结构以及公共函数。比如，nginx提供了带长度的字符串，根据编译器选项优化过的字符串拷贝函数ngx_copy等。\n*ps: 下横线分割是C语言的变量名风格*\n\n| Data Structure | Description |\n| -------------  | ----------- |\n| ngx_str_t | 字符串封装 |\n| ngx_pool_t | 提供一种机制，帮助管理一系列的资源（内存，文件）|\n| ngx_array_t | 数组结构 |\n| ngx_chain_t | 主要用于模块之间数据传递的链表实现 |\n| ngx_buf_t | 就是ngx_chain_t链表的每个节点的实际实现，代表某种具体的数据。|\n| ngx_list_t | list数据结构的实现，以及增强 |\n| ngx_queue_t | 实现的双向链表 |\n| ngx_hash_t | hash表的实现 |\n| ngx_hash_wildcard_t | 为处理带有通配符域名的匹配问题实现的hash表结构 |\n| ngx_combinded_t | 在于提供一个方便的容器包含三个类型的hash表 |\n| ngx_hash_keys_arrays_t | 用于构建其他类型的hash的辅助类 |\n\n# 配置\nnginx的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于nginx安装目录下的conf目录下。\n指令由nginx的各个模块提供，不同的模块会提供不同的指令来实现配置。\n指令除了Key-Value的形式，还有作用域指令。\nnginx.conf中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。\n\n下面的这些上下文指令是用的比较多：\n\n| Directive | Description | Contains Directive |\n| --------  | ----------- | ------------------ |\n| main | nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。| user, worker_processes, error_log, events, http, mail |\n| http | 与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。| server |\n| server | http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。 | listen, server_name, access_log, location, protocol, proxy, smtp_auth, xclient |\n| location | http服务中，某些特定的URL对应的一系列配置项。| index, root |\n| mail | 实现email相关的SMTP/IMAP/POP3代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。| server, http, imap_capabilities |\n\n# 模块\nnginx将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现SSI的模块，实现与上游服务器进行通讯的模块，实现与FastCGI服务进行通讯的模块。\n模块分三类：\n1. 核心模块\n2. 辅助模块\n3. 第三方模块\n\n根据官方文档排版，辅助模块还分了以下几类：\n1. http\n2. mail\n3. stream\n\n而根据其功能可以分成这几大类：\n1. **handler模块**\n  此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。\n2. **filter模块**\n  过滤响应头和内容的模块，可以对回复的头和内容进行处理。它的处理时间在获取回复内容之后，向用户发送响应之前。\n3. **upstream模块**\n  upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream模块是一种特殊的handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。\n4. **load balance模块**\n  负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器\n\n\n\n# 结尾\n\n本文讲述了Nginx的一些基本概念。\nNginx是线程模型是Master-Worker模式的，每个worker是单线程的，也就是处理请求是单线程处理的。而单线程并发的事件模型是「异步非阻塞I/O」模型。\n并且讲述了「反向代理」「负载均衡」的概念，这是nginx能高性能处理高并发的原因之一。\nNginx对于网络请求是有Connection和Request的概念和封装的。\nNginx的源码组织架构是模块化的，不同的模块实现不一样的职责，然后它们被连接起来一起干一件大事，知道模块有哪些分类，可以让我们知道怎么查找官方文档。\n在没有看过有哪些指令，哪些指令有什么功能之前，是不能完全知道nginx提供什么样的功能的，那就抱着，那就抱着「能想到的别人都想到并实现了」的想法来使用nginx吧。Nginx作为一个代理服务，在中间想做什么都可以啦。\n\n# 参考\n[Nginx开发从入门到精通](http://tengine.taobao.org/book/chapter_04.html#id2)\n[Nginx官方网站](http://nginx.org/)\n[《计算机操作系统》]()\n[《深入浅出Node.js》]()","slug":"了解 Nginx 的基本概念","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwq5001j15hlni12pfx0","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本篇是我学习Nginx的一些笔记，主要内容讲述了一些了解Nginx需要的基本概念。<br>然后探讨一下Nginx的模块化的组织架构，以及各个模块的分类、工作方式、职责和提供的相关指令。<br>主要达到以下目的：</p>\n<ol>\n<li>了解Nginx的大概运行原理</li>\n<li>了解Nginx的基本概念</li>\n<li>知道怎么看官方文档。</li>\n</ol>\n<h1 id=\"关于Nginx\"><a href=\"#关于Nginx\" class=\"headerlink\" title=\"关于Nginx\"></a>关于Nginx</h1><p>Nginx是一款面向性能设计的HTTP服务器，能反向代理HTTP，HTTPS和邮件相关(SMTP，POP3，IMAP)的协议链接。并且提供了负载均衡以及HTTP缓存。<br>它的设计充分使用异步事件模型，削减上下文调度的开销，提高服务器并发能力。<br>采用了模块化设计，提供了丰富模块的第三方模块。<br>所以关于Nginx，有这些标签：「异步」「事件」「模块化」「高性能」「高并发」「反向代理」「负载均衡」</p>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><h2 id=\"进程模型\"><a href=\"#进程模型\" class=\"headerlink\" title=\"进程模型\"></a>进程模型</h2><p>Nginx的进程是使用经典的「Master-Worker」模型。<br>Nginx在启动后，会有一个master进程和多个worker进程。<br>master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。<br>worker进程主要处理基本的网络事件，多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。需要注意的是，每个Worker只有主线程，即所谓的「单线程」。<br>一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。<br>worker进程的个数是可以设置的，一般会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。更多的worker数，只会导致进程来竞争cpu资源。</p>\n<p><img src=\"/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png\" alt=\"Nginx 进程模型.png\"></p>\n<h2 id=\"事件模型\"><a href=\"#事件模型\" class=\"headerlink\" title=\"事件模型\"></a>事件模型</h2><p>Nginx对于事件，以「异步非阻塞」方式来实现。<br>异步和非异步，阻塞和非阻塞是两组不同的概念，前者更多对于应用程序而言，而后者更多对于CPU来说：</p>\n<ol>\n<li>异步：执行一个动作之后，可以去操作别的操作，然后等待通知再回来执行刚才没执行完的操作。</li>\n<li>非异步(同步)：执行一个操作之后，等待结果，然后才继续执行下面的操作。</li>\n<li>阻塞：给CPU传达任务之后，一直等待CPU处理完毕(即使会产生I/O)，然后才执行下面操作。</li>\n<li>非阻塞：给CPU传达任务之后，继续处理后面的操作，隔段时间再来询问之前的操作是否完成。这样的及过程也叫「轮询」</li>\n</ol>\n<p>Nginx的「异步非阻塞」方式，具体到系统调用的话，就是像select/poll/epoll/kqueue这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。</p>\n<p>epoll是在Linux上关于事件的实现，而kqueue是OpenBSD或FreeBSD操作系统上采用类似epoll的事件模型。<br>所以重点讲解一下epoll的模型：</p>\n<p><img src=\"/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png\" alt=\"epoll事件模型.png\"></p>\n<p>该方案给是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进入休眠，直到事件将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。</p>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>要了解「反向代理」，首先需要知道什么是「代理服务器」和「正向代理」</p>\n<h3 id=\"代理服务器\"><a href=\"#代理服务器\" class=\"headerlink\" title=\"代理服务器\"></a>代理服务器</h3><p>在网络中，客户端发起一个请求，获取服务器端的资源。它们之间并不是建立一条直接的通道，而是被代理服务器所转发。<br>代理服务器作为网络中的媒介将互联网上获取的资源返回给相关的客户端。<br>我们通常所说的代理，一般都指的是「正向代理」，是相对于客户端来说的。<br>比方说我链接了一个VPN，我访问Google的时候，客户端发起的请求到了VPN，VPN帮忙转发请求Google的服务器，然后把Google响应返回给客户端。这个过程，VPN就充当了「正向代理服务器」的角色。</p>\n<p><img src=\"/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png\" alt=\"代理服务器.png\"></p>\n<h3 id=\"反向代理-1\"><a href=\"#反向代理-1\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><p>和「正向代理」不同，「反向代理」的说法面向于服务器端。一个客户端请求来到代理服务器，代理服务器根据客户端的请求的不同而把请求转发到不同的服务器，这个过程在「负载均衡」中，也会发生两个一样的请求，会转发到完全不一样的服务器中的情况。<br>「反向代理」是「负载均衡」实现的前提，正因为代理服务器有了解析请求，分发请求的能力，才能实现负载均衡，降低每一台服务器的负荷。<br>利用「反向代理」，除了实现负载均衡，还可以实现诸如：SSL加密，静态内容缓存，gzip压缩，减速上传，安全等功能</p>\n<p><img src=\"/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png\" alt=\"反向代理.png\"></p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>负载均衡（Load balancing）是一种计算机网络技术，用来在多个服务器中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。<br>使用带有负载均衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务的实现可以通过软件和硬件来实现。<br>负载均衡的分发，一般都会有多套算法来处理分发问题。</p>\n<h2 id=\"连接-Connection\"><a href=\"#连接-Connection\" class=\"headerlink\" title=\"连接 Connection\"></a>连接 Connection</h2><p>在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。利用nginx封装的connection，我们可以很方便的使用nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。<br>而nginx中的http请求的处理就是建立在connection之上的，所以nginx不仅可以作为一个web服务器，也可以作为邮件服务器。<br>当然，利用nginx提供的connection，我们可以与任何后端服务打交道。</p>\n<h3 id=\"最大连接数\"><a href=\"#最大连接数\" class=\"headerlink\" title=\"最大连接数\"></a>最大连接数</h3><p>在nginx中，每个进程会有一个连接数的最大上限，这个上限与系统对fd的限制不一样。<br>在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。<br>nginx通过设置<code>worker_connectons</code>来设置每个进程支持的最大连接数。如果该值大于nofile，那么实际的最大连接数是nofile，nginx会有警告。<br>nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是<code>worker_connections</code>。这里的连接池里面保存的其实不是真实的连接，它只是一个<code>worker_connections</code>大小的一个<code>ngx_connection_t</code>结构的数组。并且，nginx会通过一个链表<code>free_connections</code>来保存所有的空闲<code>ngx_connection_t</code>，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。</p>\n<p>所以，一个nginx能建立的最大连接数：<code>worker_connections * worker_processes</code>，<br>如果当nginx作为反向代理的话，因为一个请求nginx要建立客户端和服务器的请求，所以最大连接数是：<code>worker_connections * worker_processes / 2</code></p>\n<h2 id=\"请求-Request\"><a href=\"#请求-Request\" class=\"headerlink\" title=\"请求 Request\"></a>请求 Request</h2><p>在nginx中我们指http请求，具体到nginx中的数据结构是<code>ngx_http_request_t</code>。<br>它是对一个http请求的封装，nginx通过<code>ngx_http_request_t</code>来保存解析请求与输出响应相关的数据。<br>一个http请求，包含请求行、请求头、请求体、响应行、响应头、响应体。</p>\n<p>一般性的网络请求处理过程是：</p>\n<ol>\n<li>客户端会发送请求过来。</li>\n<li>然后我们读取一行数据，分析出请求行中包含的method、uri、http_version信息。</li>\n<li>然后再一行一行处理请求头，并根据请求method与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。</li>\n<li>得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。</li>\n<li>在将响应发送给客户端之后，一个完整的请求就处理完了。</li>\n</ol>\n<p>而nginx处理请求的时候会有一些小小的区别，比如，当请求头读取完成后，就开始进行请求的处理了。</p>\n<h3 id=\"Nginx处理请求过程\"><a href=\"#Nginx处理请求过程\" class=\"headerlink\" title=\"Nginx处理请求过程\"></a>Nginx处理请求过程</h3><p>nginx处理一个请求的抽象概念过程：</p>\n<ol>\n<li>request 请求进来</li>\n<li>初始化HTTP Request， 生成 HTTP Request对象</li>\n<li>处理请求头</li>\n<li>处理请求体</li>\n<li>调用与此请求关联的handler（根据你URL或者Location配置）</li>\n<li>依次调用各phase handler进行处理<ol>\n<li>获取location配置</li>\n<li>产生适当的响应</li>\n<li>发送response header</li>\n<li>发送response body</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"基本数据结构\"><a href=\"#基本数据结构\" class=\"headerlink\" title=\"基本数据结构\"></a>基本数据结构</h1><p>nginx的作者为追求极致的高效，自己实现了很多颇具特色的nginx风格的数据结构以及公共函数。比如，nginx提供了带长度的字符串，根据编译器选项优化过的字符串拷贝函数ngx_copy等。<br><em>ps: 下横线分割是C语言的变量名风格</em></p>\n<table>\n<thead>\n<tr>\n<th>Data Structure</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ngx_str_t</td>\n<td>字符串封装</td>\n</tr>\n<tr>\n<td>ngx_pool_t</td>\n<td>提供一种机制，帮助管理一系列的资源（内存，文件）</td>\n</tr>\n<tr>\n<td>ngx_array_t</td>\n<td>数组结构</td>\n</tr>\n<tr>\n<td>ngx_chain_t</td>\n<td>主要用于模块之间数据传递的链表实现</td>\n</tr>\n<tr>\n<td>ngx_buf_t</td>\n<td>就是ngx_chain_t链表的每个节点的实际实现，代表某种具体的数据。</td>\n</tr>\n<tr>\n<td>ngx_list_t</td>\n<td>list数据结构的实现，以及增强</td>\n</tr>\n<tr>\n<td>ngx_queue_t</td>\n<td>实现的双向链表</td>\n</tr>\n<tr>\n<td>ngx_hash_t</td>\n<td>hash表的实现</td>\n</tr>\n<tr>\n<td>ngx_hash_wildcard_t</td>\n<td>为处理带有通配符域名的匹配问题实现的hash表结构</td>\n</tr>\n<tr>\n<td>ngx_combinded_t</td>\n<td>在于提供一个方便的容器包含三个类型的hash表</td>\n</tr>\n<tr>\n<td>ngx_hash_keys_arrays_t</td>\n<td>用于构建其他类型的hash的辅助类</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>nginx的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于nginx安装目录下的conf目录下。<br>指令由nginx的各个模块提供，不同的模块会提供不同的指令来实现配置。<br>指令除了Key-Value的形式，还有作用域指令。<br>nginx.conf中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。</p>\n<p>下面的这些上下文指令是用的比较多：</p>\n<table>\n<thead>\n<tr>\n<th>Directive</th>\n<th>Description</th>\n<th>Contains Directive</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>main</td>\n<td>nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。</td>\n<td>user, worker_processes, error_log, events, http, mail</td>\n</tr>\n<tr>\n<td>http</td>\n<td>与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。</td>\n<td>server</td>\n</tr>\n<tr>\n<td>server</td>\n<td>http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。</td>\n<td>listen, server_name, access_log, location, protocol, proxy, smtp_auth, xclient</td>\n</tr>\n<tr>\n<td>location</td>\n<td>http服务中，某些特定的URL对应的一系列配置项。</td>\n<td>index, root</td>\n</tr>\n<tr>\n<td>mail</td>\n<td>实现email相关的SMTP/IMAP/POP3代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。</td>\n<td>server, http, imap_capabilities</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1><p>nginx将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现SSI的模块，实现与上游服务器进行通讯的模块，实现与FastCGI服务进行通讯的模块。<br>模块分三类：</p>\n<ol>\n<li>核心模块</li>\n<li>辅助模块</li>\n<li>第三方模块</li>\n</ol>\n<p>根据官方文档排版，辅助模块还分了以下几类：</p>\n<ol>\n<li>http</li>\n<li>mail</li>\n<li>stream</li>\n</ol>\n<p>而根据其功能可以分成这几大类：</p>\n<ol>\n<li><strong>handler模块</strong><br>此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。</li>\n<li><strong>filter模块</strong><br>过滤响应头和内容的模块，可以对回复的头和内容进行处理。它的处理时间在获取回复内容之后，向用户发送响应之前。</li>\n<li><strong>upstream模块</strong><br>upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream模块是一种特殊的handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。</li>\n<li><strong>load balance模块</strong><br>负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器</li>\n</ol>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>本文讲述了Nginx的一些基本概念。<br>Nginx是线程模型是Master-Worker模式的，每个worker是单线程的，也就是处理请求是单线程处理的。而单线程并发的事件模型是「异步非阻塞I/O」模型。<br>并且讲述了「反向代理」「负载均衡」的概念，这是nginx能高性能处理高并发的原因之一。<br>Nginx对于网络请求是有Connection和Request的概念和封装的。<br>Nginx的源码组织架构是模块化的，不同的模块实现不一样的职责，然后它们被连接起来一起干一件大事，知道模块有哪些分类，可以让我们知道怎么查找官方文档。<br>在没有看过有哪些指令，哪些指令有什么功能之前，是不能完全知道nginx提供什么样的功能的，那就抱着，那就抱着「能想到的别人都想到并实现了」的想法来使用nginx吧。Nginx作为一个代理服务，在中间想做什么都可以啦。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://tengine.taobao.org/book/chapter_04.html#id2\" target=\"_blank\" rel=\"external\">Nginx开发从入门到精通</a><br><a href=\"http://nginx.org/\" target=\"_blank\" rel=\"external\">Nginx官方网站</a><br><a href=\"\">《计算机操作系统》</a><br><a href=\"\">《深入浅出Node.js》</a></p>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>本篇是我学习Nginx的一些笔记，主要内容讲述了一些了解Nginx需要的基本概念。<br>然后探讨一下Nginx的模块化的组织架构，以及各个模块的分类、工作方式、职责和提供的相关指令。<br>主要达到以下目的：</p>\n<ol>\n<li>了解Nginx的大概运行原理</li>\n<li>了解Nginx的基本概念</li>\n<li>知道怎么看官方文档。</li>\n</ol>\n<h1 id=\"关于Nginx\"><a href=\"#关于Nginx\" class=\"headerlink\" title=\"关于Nginx\"></a>关于Nginx</h1><p>Nginx是一款面向性能设计的HTTP服务器，能反向代理HTTP，HTTPS和邮件相关(SMTP，POP3，IMAP)的协议链接。并且提供了负载均衡以及HTTP缓存。<br>它的设计充分使用异步事件模型，削减上下文调度的开销，提高服务器并发能力。<br>采用了模块化设计，提供了丰富模块的第三方模块。<br>所以关于Nginx，有这些标签：「异步」「事件」「模块化」「高性能」「高并发」「反向代理」「负载均衡」</p>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><h2 id=\"进程模型\"><a href=\"#进程模型\" class=\"headerlink\" title=\"进程模型\"></a>进程模型</h2><p>Nginx的进程是使用经典的「Master-Worker」模型。<br>Nginx在启动后，会有一个master进程和多个worker进程。<br>master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。<br>worker进程主要处理基本的网络事件，多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。需要注意的是，每个Worker只有主线程，即所谓的「单线程」。<br>一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。<br>worker进程的个数是可以设置的，一般会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。更多的worker数，只会导致进程来竞争cpu资源。</p>\n<p><img src=\"/image/blog/understand-nginx-concept/D412AB7534AE2EB44540446CC5573534.png\" alt=\"Nginx 进程模型.png\"></p>\n<h2 id=\"事件模型\"><a href=\"#事件模型\" class=\"headerlink\" title=\"事件模型\"></a>事件模型</h2><p>Nginx对于事件，以「异步非阻塞」方式来实现。<br>异步和非异步，阻塞和非阻塞是两组不同的概念，前者更多对于应用程序而言，而后者更多对于CPU来说：</p>\n<ol>\n<li>异步：执行一个动作之后，可以去操作别的操作，然后等待通知再回来执行刚才没执行完的操作。</li>\n<li>非异步(同步)：执行一个操作之后，等待结果，然后才继续执行下面的操作。</li>\n<li>阻塞：给CPU传达任务之后，一直等待CPU处理完毕(即使会产生I/O)，然后才执行下面操作。</li>\n<li>非阻塞：给CPU传达任务之后，继续处理后面的操作，隔段时间再来询问之前的操作是否完成。这样的及过程也叫「轮询」</li>\n</ol>\n<p>Nginx的「异步非阻塞」方式，具体到系统调用的话，就是像select/poll/epoll/kqueue这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。</p>\n<p>epoll是在Linux上关于事件的实现，而kqueue是OpenBSD或FreeBSD操作系统上采用类似epoll的事件模型。<br>所以重点讲解一下epoll的模型：</p>\n<p><img src=\"/image/blog/understand-nginx-concept/57A6A903E3C2E44B13B33BB2E25BDAD0.png\" alt=\"epoll事件模型.png\"></p>\n<p>该方案给是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进入休眠，直到事件将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。</p>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>要了解「反向代理」，首先需要知道什么是「代理服务器」和「正向代理」</p>\n<h3 id=\"代理服务器\"><a href=\"#代理服务器\" class=\"headerlink\" title=\"代理服务器\"></a>代理服务器</h3><p>在网络中，客户端发起一个请求，获取服务器端的资源。它们之间并不是建立一条直接的通道，而是被代理服务器所转发。<br>代理服务器作为网络中的媒介将互联网上获取的资源返回给相关的客户端。<br>我们通常所说的代理，一般都指的是「正向代理」，是相对于客户端来说的。<br>比方说我链接了一个VPN，我访问Google的时候，客户端发起的请求到了VPN，VPN帮忙转发请求Google的服务器，然后把Google响应返回给客户端。这个过程，VPN就充当了「正向代理服务器」的角色。</p>\n<p><img src=\"/image/blog/understand-nginx-concept/67B3801CA06A50CFAEC12E154D86E17C.png\" alt=\"代理服务器.png\"></p>\n<h3 id=\"反向代理-1\"><a href=\"#反向代理-1\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><p>和「正向代理」不同，「反向代理」的说法面向于服务器端。一个客户端请求来到代理服务器，代理服务器根据客户端的请求的不同而把请求转发到不同的服务器，这个过程在「负载均衡」中，也会发生两个一样的请求，会转发到完全不一样的服务器中的情况。<br>「反向代理」是「负载均衡」实现的前提，正因为代理服务器有了解析请求，分发请求的能力，才能实现负载均衡，降低每一台服务器的负荷。<br>利用「反向代理」，除了实现负载均衡，还可以实现诸如：SSL加密，静态内容缓存，gzip压缩，减速上传，安全等功能</p>\n<p><img src=\"/image/blog/understand-nginx-concept/AF9F8A26CD1A65010090A0FE5DA8B42B.png\" alt=\"反向代理.png\"></p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>负载均衡（Load balancing）是一种计算机网络技术，用来在多个服务器中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。<br>使用带有负载均衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务的实现可以通过软件和硬件来实现。<br>负载均衡的分发，一般都会有多套算法来处理分发问题。</p>\n<h2 id=\"连接-Connection\"><a href=\"#连接-Connection\" class=\"headerlink\" title=\"连接 Connection\"></a>连接 Connection</h2><p>在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。利用nginx封装的connection，我们可以很方便的使用nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。<br>而nginx中的http请求的处理就是建立在connection之上的，所以nginx不仅可以作为一个web服务器，也可以作为邮件服务器。<br>当然，利用nginx提供的connection，我们可以与任何后端服务打交道。</p>\n<h3 id=\"最大连接数\"><a href=\"#最大连接数\" class=\"headerlink\" title=\"最大连接数\"></a>最大连接数</h3><p>在nginx中，每个进程会有一个连接数的最大上限，这个上限与系统对fd的限制不一样。<br>在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。<br>nginx通过设置<code>worker_connectons</code>来设置每个进程支持的最大连接数。如果该值大于nofile，那么实际的最大连接数是nofile，nginx会有警告。<br>nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是<code>worker_connections</code>。这里的连接池里面保存的其实不是真实的连接，它只是一个<code>worker_connections</code>大小的一个<code>ngx_connection_t</code>结构的数组。并且，nginx会通过一个链表<code>free_connections</code>来保存所有的空闲<code>ngx_connection_t</code>，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。</p>\n<p>所以，一个nginx能建立的最大连接数：<code>worker_connections * worker_processes</code>，<br>如果当nginx作为反向代理的话，因为一个请求nginx要建立客户端和服务器的请求，所以最大连接数是：<code>worker_connections * worker_processes / 2</code></p>\n<h2 id=\"请求-Request\"><a href=\"#请求-Request\" class=\"headerlink\" title=\"请求 Request\"></a>请求 Request</h2><p>在nginx中我们指http请求，具体到nginx中的数据结构是<code>ngx_http_request_t</code>。<br>它是对一个http请求的封装，nginx通过<code>ngx_http_request_t</code>来保存解析请求与输出响应相关的数据。<br>一个http请求，包含请求行、请求头、请求体、响应行、响应头、响应体。</p>\n<p>一般性的网络请求处理过程是：</p>\n<ol>\n<li>客户端会发送请求过来。</li>\n<li>然后我们读取一行数据，分析出请求行中包含的method、uri、http_version信息。</li>\n<li>然后再一行一行处理请求头，并根据请求method与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。</li>\n<li>得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。</li>\n<li>在将响应发送给客户端之后，一个完整的请求就处理完了。</li>\n</ol>\n<p>而nginx处理请求的时候会有一些小小的区别，比如，当请求头读取完成后，就开始进行请求的处理了。</p>\n<h3 id=\"Nginx处理请求过程\"><a href=\"#Nginx处理请求过程\" class=\"headerlink\" title=\"Nginx处理请求过程\"></a>Nginx处理请求过程</h3><p>nginx处理一个请求的抽象概念过程：</p>\n<ol>\n<li>request 请求进来</li>\n<li>初始化HTTP Request， 生成 HTTP Request对象</li>\n<li>处理请求头</li>\n<li>处理请求体</li>\n<li>调用与此请求关联的handler（根据你URL或者Location配置）</li>\n<li>依次调用各phase handler进行处理<ol>\n<li>获取location配置</li>\n<li>产生适当的响应</li>\n<li>发送response header</li>\n<li>发送response body</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"基本数据结构\"><a href=\"#基本数据结构\" class=\"headerlink\" title=\"基本数据结构\"></a>基本数据结构</h1><p>nginx的作者为追求极致的高效，自己实现了很多颇具特色的nginx风格的数据结构以及公共函数。比如，nginx提供了带长度的字符串，根据编译器选项优化过的字符串拷贝函数ngx_copy等。<br><em>ps: 下横线分割是C语言的变量名风格</em></p>\n<table>\n<thead>\n<tr>\n<th>Data Structure</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ngx_str_t</td>\n<td>字符串封装</td>\n</tr>\n<tr>\n<td>ngx_pool_t</td>\n<td>提供一种机制，帮助管理一系列的资源（内存，文件）</td>\n</tr>\n<tr>\n<td>ngx_array_t</td>\n<td>数组结构</td>\n</tr>\n<tr>\n<td>ngx_chain_t</td>\n<td>主要用于模块之间数据传递的链表实现</td>\n</tr>\n<tr>\n<td>ngx_buf_t</td>\n<td>就是ngx_chain_t链表的每个节点的实际实现，代表某种具体的数据。</td>\n</tr>\n<tr>\n<td>ngx_list_t</td>\n<td>list数据结构的实现，以及增强</td>\n</tr>\n<tr>\n<td>ngx_queue_t</td>\n<td>实现的双向链表</td>\n</tr>\n<tr>\n<td>ngx_hash_t</td>\n<td>hash表的实现</td>\n</tr>\n<tr>\n<td>ngx_hash_wildcard_t</td>\n<td>为处理带有通配符域名的匹配问题实现的hash表结构</td>\n</tr>\n<tr>\n<td>ngx_combinded_t</td>\n<td>在于提供一个方便的容器包含三个类型的hash表</td>\n</tr>\n<tr>\n<td>ngx_hash_keys_arrays_t</td>\n<td>用于构建其他类型的hash的辅助类</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>nginx的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于nginx安装目录下的conf目录下。<br>指令由nginx的各个模块提供，不同的模块会提供不同的指令来实现配置。<br>指令除了Key-Value的形式，还有作用域指令。<br>nginx.conf中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。</p>\n<p>下面的这些上下文指令是用的比较多：</p>\n<table>\n<thead>\n<tr>\n<th>Directive</th>\n<th>Description</th>\n<th>Contains Directive</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>main</td>\n<td>nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。</td>\n<td>user, worker_processes, error_log, events, http, mail</td>\n</tr>\n<tr>\n<td>http</td>\n<td>与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。</td>\n<td>server</td>\n</tr>\n<tr>\n<td>server</td>\n<td>http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server.每个server通过监听的地址来区分。</td>\n<td>listen, server_name, access_log, location, protocol, proxy, smtp_auth, xclient</td>\n</tr>\n<tr>\n<td>location</td>\n<td>http服务中，某些特定的URL对应的一系列配置项。</td>\n<td>index, root</td>\n</tr>\n<tr>\n<td>mail</td>\n<td>实现email相关的SMTP/IMAP/POP3代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。</td>\n<td>server, http, imap_capabilities</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1><p>nginx将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现SSI的模块，实现与上游服务器进行通讯的模块，实现与FastCGI服务进行通讯的模块。<br>模块分三类：</p>\n<ol>\n<li>核心模块</li>\n<li>辅助模块</li>\n<li>第三方模块</li>\n</ol>\n<p>根据官方文档排版，辅助模块还分了以下几类：</p>\n<ol>\n<li>http</li>\n<li>mail</li>\n<li>stream</li>\n</ol>\n<p>而根据其功能可以分成这几大类：</p>\n<ol>\n<li><strong>handler模块</strong><br>此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。</li>\n<li><strong>filter模块</strong><br>过滤响应头和内容的模块，可以对回复的头和内容进行处理。它的处理时间在获取回复内容之后，向用户发送响应之前。</li>\n<li><strong>upstream模块</strong><br>upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream模块是一种特殊的handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。</li>\n<li><strong>load balance模块</strong><br>负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器</li>\n</ol>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>本文讲述了Nginx的一些基本概念。<br>Nginx是线程模型是Master-Worker模式的，每个worker是单线程的，也就是处理请求是单线程处理的。而单线程并发的事件模型是「异步非阻塞I/O」模型。<br>并且讲述了「反向代理」「负载均衡」的概念，这是nginx能高性能处理高并发的原因之一。<br>Nginx对于网络请求是有Connection和Request的概念和封装的。<br>Nginx的源码组织架构是模块化的，不同的模块实现不一样的职责，然后它们被连接起来一起干一件大事，知道模块有哪些分类，可以让我们知道怎么查找官方文档。<br>在没有看过有哪些指令，哪些指令有什么功能之前，是不能完全知道nginx提供什么样的功能的，那就抱着，那就抱着「能想到的别人都想到并实现了」的想法来使用nginx吧。Nginx作为一个代理服务，在中间想做什么都可以啦。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://tengine.taobao.org/book/chapter_04.html#id2\">Nginx开发从入门到精通</a><br><a href=\"http://nginx.org/\">Nginx官方网站</a><br><a href=\"\">《计算机操作系统》</a><br><a href=\"\">《深入浅出Node.js》</a></p>\n"},{"title":"魅族的冬与夏","date":"2017-01-24T17:47:00.000Z","_content":"\n# 冬天\n我在离职协议书上面，签下了名字。\n犹如当年签订实习协议一样的字迹，不同的只是那份心情。\n\n我坐在魅族大楼前面围绕着一颗树而摆成的弧形长椅子，喝了口小卖部买来的咖啡。\n两年半之间，偶尔在午后偷得一丝慵懒，来到这里喝杯咖啡，感受着珠海的安静。\n\n抬头45度，当年满载绿叶的树，已经被寒风吹散，只剩下枝与干。\n我曾经幻想过很多次，会有一个两鬓斑白的老人坐在我身旁，告诉我这棵树的名字和故事。\n\n如此我的故事就会变得更具戏剧性，但现在我只能叫它「一棵树」。\n一棵树先生，花开花落，经历过多少个珠海的冬与夏。\n我两年半的魅族生涯，也被他看在眼里。\n\n![冬天](/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg)\n\n\n# 实习\n2014 年的暑假过后，跟我一起在大学做了不少项目的死党糖水哥找到了深圳的实习。\n他总是什么都比我快一步，也是从他话语中知道了珠海魅族下的笔戈科技在招「前端开发」。\n\n同时，带我入坑前端开发以及给予我第一个实战机会的师兄，邀请我到他的公司工作。\n在投简历的前两天，我去拜访以前实习的公司。因为那里是我成长过的地方，那时候公司不大，几个人，但是气氛很好。虽然短短的两个月，但是对这家公司的感情还是蛮深刻的。\n师兄知道我正在找实习，就邀请我来一起干，让我负责主要的 NodeJS 和前端开发。\n一时间，我下不了决定。一方面难以拒绝师兄的热情相邀，一方面又放不下自己准备良久的面试。我当时就实说了，正在准备面试一家公司，待我回去考虑过再给答复。\n回去后，我思考了一个晚上，也用笔和纸列举了去两家公司的利与弊。\n最终，我还是决定了先去魅族试一下。\n\n我很感激师兄的邀请和对我的欣赏，但是那时候的我就一心想见识更多的人与事。\n我记得跟他说了一句话：「我想试一下魅族」。\n是的，我只投了一封简历，只投给了魅族笔戈科技。\n\n很快就收到了面试官回复的邮件。大概内容就是很高兴收到简历，然后约定电话面试的时间。\n在经过一个多小时的电话面试，以及一个面对面面试。\n我终于收到了魅族的 Offer 邮件。\n\n同时，还收到了总监盖文张的额外邮件，邮件内容主要介绍了魅族科技、笔戈科技、还有简单的个人简介，还扔了一大堆文献资料要我去阅读。最后还不忘布置一个家庭作业：一份关于我自身的全面社交账号列表，以及详细的自我简介，以及我未来想要做的事情。\n\n从邮件的文字中，能深刻的感受盖文张对于每个成员负责的态度。\n那时候我很高兴，能和一位如此有亲和力和有想法的人工作，那是多么幸运的事情。\n\n所以，尽然我语文作文能力低弱，也是使劲的憋出了一篇2000字的感想。\n\n\n# 笔戈科技\n我记得第一次踏入魅族科技楼的一瞬间，看到一楼大厅的装横的那份感动。\n就像那时候魅族设计出来的手机一样，那么的简洁，那么的灵动。\n\n![魅族一楼大厅](/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg)\n\n我在笔戈科技，所属于 Web 开发组，组内只有老大一个 NodeJS 开发，再加上包括我在内的三个前端实习生。\n老大跟我说，你看这么多前端实习生，本来不打算再招前端实习生了，但是看到你以前做的项目蛮多的，就破例了。这句话，让我心里偷偷窃喜了好一段时间。\n\n当时我们组主要是负责笔戈博客项目，以及一些营销导向型的短期项目。\n笔戈博客是在 Ghost 的基础上构建的，修修补补源代码，加上了一些业务性的定制功能。\n我记得那时候看 Ghost 的源码，因为不懂 Promise ，看的非常吃力。\nGhost 的前端部分使用的是 EmberJS，在2014年前端的 MVC 框架比较流行的是 AngularJS、EmberJS、BackboneJS。\n构建项目的用的是 Grunt，CSS 部分的 sass、less 在当年也已经开始普及起来。\n对于我一个只懂 jQuery、BootStrap 、以及前端三项基本功的实习生，掌握前端工程化技术是一项让人充满新鲜感与兴奋的挑战。\n\n当时技术团队的人员配置很不平衡，一个后端对应三个前端，所以后端的工作强度很大，前端反而显得清闲。\n不出半个月，一个午饭时分，老大跟我说：「你不是会 NodeJS 吗，要不尝试转后端？」\n我思考了很久，大学立下的职业规划是成为一名出色的前端工程师。\n但是要做好前端，首先是成为一名合格的软件工程师。我觉得是一次机会，所以就答应了，后面的两年的时间，工作上就绝大部分从事着后端开发。\n随后我也感激我当时的选择，后端的工作能让我从不同的角度来了解软件开发。\n在我转型不久，很快又来了一位 NodeJS 实习生。从现在来看，他也是我们组最后的一位实习生。\n\n在笔戈科技，虽然有不同的职能组，但是那时候人还少，不同职能的大家都可以混在一起，而且管理上也十分的扁平化。我们使用很多优秀的工具来进行团队合作，例如 Teambition、Google Docs，还统一购买科学上网服务。\n\n就像我在入职前写给盖文张对于笔戈的看法所描述的，笔戈科技就像魅族的一个特种部队，效率和敏捷性都很高。\n\n# 笔戈玩\n在入职直到 2014 年末之前，我都一直做着一些琐碎的事情，笔戈博客的维护，以及一些营销导向性的短期项目，就像内部的一个外包技术团队。\n我想，如果那时候没有魅玩帮的立项，估计我半年之后就不会在魅族了。\n\n就趋近于年末的时候，盖文张召集我们技术组开会，谈论一个新项目的想法。\n要做一个魅族旗下推广型的平台，推广方向就是我们所从事的「智能硬件」方向。\n这时候，一个智能硬件试玩网站的雏形诞生了，叫「笔戈玩」。\n\n项目立项了，就要撸起袖子开始干了。\n团队的主要技术栈是 NodeJS，我们需要一个能快速搭建项目的 NodeJS 企业级开发框架。\n我们对比了 Meteor、Strongloop、SailsJS，最后被 SailsJS 清晰的 MVC 分层所吸引，选择了 SailsJS 框架来开发。当然，框架的功能性，扩展性，和社区活跃度都是需要被考虑的，记得当年我写了一篇 [《为什么使用 SailsJS》](http://huang-jerryc.com/2015/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Sails/)，现在看回去，有不少的东西可以补充。\n\n\n就这样，一个老大带着四个实习生，三个 NodeJS，两个前端，从项目分析、概要设计、详细设计、数据库设计、再到编码实现，在农历年之前完成了「笔戈玩」的第一版本。\n年后，由于之前对框架的不熟悉，导致产出的代码欠佳，然后重新推翻，再次重构。\n又一个月的时间，发布了第一个内部测试版本。\n经过一段时间的测试、修复、运营准备，终于在 2015 年 5 月 21 日，「笔戈玩」正式上线。\n\n# 简书 —— 笔戈 Web Team\n\n在「笔戈玩」第一版本上线之后，我也迎来了我的毕业。\n\n盖文张是很注重团队成员自身发展的，他也很鼓励我们多看书多涉猎，也建立了读书经费。\n在我们办公室的角落，就有一个小小的书柜，都放满了大家要求买的书。\n除了看书，多写作也是被鼓励的。\n笔戈博客是我们部门的业余产出，写作就像笔戈不成形的团队文化，当时就在全部门内推行了这样的制度：每人每月定额产出文章，产出不奖励，不产出要罚钱。\n产出的文章，经过筛选，会发表在笔戈博客。\n我们写代码的人要求低一点，一个月一篇，写不出要罚 100 块，罚的钱，用来补贴部门经费。\n我那时候的实习工资 2000 加上补贴，一个月不缺勤到手也就 2700。罚 100 块，是多么痛心的事情。\n所以我们憋也要憋出来几个字。\n\n如果我们写一些技术类的，倒是没那么痛苦。\n可偏偏那时候我们技术老大说，尽量不要写技术类的。理由是笔戈博客的读者并不是技术向的。\n其实对于我们这群纯理科生，是有点为难的。\n我在笔戈的第一篇文章，是使劲憋出来的：[《盘点国内的那些ROM》](http://huang-jerryc.com/2015/03/03/%E7%9B%98%E7%82%B9%E5%9B%BD%E5%86%85%E7%9A%84%E9%82%A3%E4%BA%9BROM/)\n\n之后我就在思考，有什么办法可以发挥我们的所长，并且符合这个制度。\n我的想法是，我们团队应该是作为一个技术团队的名义来抛头露面，我们的产出可以是纯技术导向，我们把内容聚合起来，作为一个专题，或一个频道，或者其他什么样的形式。\n\n正好笔戈当时也在简书上面发表文章，以增加曝光度。\n我就回学校毕业之前，给盖文张发了一封邮件，把我对团队文化建设的构思路描述了一遍。\n大概就是先从简书开始，建立一个「笔戈 Web Team」的专题，以笔戈的名义为依托，来给我们技术人提供练笔和展示的地方。\n因为简书并不是纯粹的技术社区，受众并不多，我们可以肆无忌惮的写一点东西，而不怕被人鄙视水平不够。\n待我们的水平和产出上来了，考虑转移更纯粹的技术社区，或者建立团队的技术博客。\n我举例了 AlloyTeam，Taobao FED 这些大厂出名的博客。\n同时还说明了这样做的好处，一是写作会逼迫我们思考和总结，对我们技术水平提升有明显的作用。二是可以打响名声，提高成员自豪感，提升凝聚力，同时也有助于招聘。\n\n盖文张很快回复了邮件，他赞同这样的做法，另外给了我笔戈科技在简书的账号密码，让我来创建这个专题。\n同时，我也把这个想法跟技术老大说。我们老大是很进步向的，也很赞成这样的做法。\n\n自此，我们开始以团队的名义进行技术文章的产出，一点一点的积累和提升。\n截止现在，尽管我们已经转移产出的场地，但是简书上面的 「[笔戈 Web Team](http://www.jianshu.com/c/2a4335808d4c)」，已经有103篇文章。\n\n# 第一次出省\n\n从大学毕业之后，我和魅族签订了我人生的第一份劳动合同。正式成为了魅族的员工，虽然之前实习的日子都是被当做正式员工来用。但是不同的是，我终于可以领着符合水平的薪水了。\n\n毕业回来正好碰上了 MX5 的发布会，公司需要征集员工志愿者，我就应征了。\n于是乎，人生第一次出差，也是这个稚嫩的广东人的第一次出省。\n\n我们订的是动卧票，晚上从广州出发， 第二天就能到北京。\n看着地图的定位慢慢的越过广东的边界，心头涌上莫名的一股激动。\n记得那天晚上，躺在摇晃的车厢中，闭上眼，脑海晃出了很多画面，一场星际旅行。\n\n然后，打开当时很流行的「足记」，写下了一些胡思乱想。\n现在看回去，自己还真像个小孩。\n\n![出省](/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg)\n\n同行的还有几个要好的同事，我们是提前一天到达的。\n在空闲的时间，我们相约去了北京的「798艺术区」。\n我想，每一个来到这里的年轻人，都会爱上这里弥漫着创意以及艺术气息的空气。\n\n![798艺术区](/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg)\n\n# 第一次出国\n\n在北京回来之后，正好碰上公司的年度旅游。\n听一些老员工说「今年开始才有旅游经费的，你碰到好时候了」，比较遗憾的是，那也是唯一一年有旅游经费的。\n公司的旅游经费只够短距离玩个三四天左右，以自行组织报销的形式，然后部门的一些土豪君给出一种方案，就是自己多掏腰包，然后一起去泰国玩一转。\n听到这方案，心里埋藏已久的射手座的心，再出跳出来作祟。\n花光了一年实习的积蓄，跟着土豪同事们去泰国了，那也是我第一次踏出中国的大陆。\n\n![泰旅](/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg)\n![泰旅](/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg)\n\n# 魅玩帮\n\n2015 年 9 月，「笔戈玩」更名「魅玩帮」，明确定位「魅族旗下新品分享平台」，由新的总监接手这个项目，帮团队理了至关重要的一件事：产品要和魅族价值挂钩。\n\nWeb 开发组，自然而然也就划分到新总监门下。\n这时候我们小组已经从当初的 5 人小团队，增加到 11 人了，\n继我们组最后一个实习生之后， 又来了一个测试妹子，后来转运维去了。 \n然后，又来了一个 NodeJS 的后端，除了帅人品还很好。\n然后，又来了一个测试妹子，爱吃爱玩，还会卖萌，我经常说：「你要是瘦了肯定是个美女」。\n同时间来的还有一个香港硕士生，做前端开发，人帅，逼格比我还高。\n再后来，又来了一个 JAVA 的后端，也是硕士毕业，基础很赞，人很接地气。\n最后，再来了一个项目经理。\n再加上原来项目整合分配到的一位御用设计师，和一位会卖萌的产品经理。\n于是乎，「魅玩帮」团队，从一个实习生团队，慢慢的增长到一个成型的小团队，配置到位。\n卖萌产经经常说，她遇到一群聪明的人。\n\n项目重定位之后的一系列工作就是接入魅族用户中心，魅族论坛，Flyme 论坛。\n这涉及到跨部门之间的合作，由于技术上是由我一直跟对方沟通的。\n后来，老大跟我说：「你参与的比较多，由你来主导这次开发吧」，喜出望外。\n随后被打了鸡血一样，事无巨细，从设计、文档、技术方案给理了清楚，再加上一群很棒的伙伴，功能很快就做完了。\n\n随着「魅玩帮」的用户量上升，产品想要一个「消息提醒」的功能。之前的工作给老大留下了不错的印象，这个任务就被分给我了。\n消息系统的开发，也是我觉得工作内做的比较有条理性的工作之一。\n经常性，产品想要一个东西，但是并不能完全的描述这个东西的细节，消息提醒也是一样。\n开发需要做的是，帮忙缕清整个东西的逻辑和业务，我首先是分析业内的一些成型的产品，例如知乎、简书的消息提醒功能。\n通过分析，抽象本质，整理业务功能，写出大概的功能设计，以及实现思路，然后再开会沟通。\n经过多次沟通和修改，然后编码实现。\n那时候明白了一个道理，一项功能或者一个项目，最费时间和精力的是在前期的沟通和设计上面，编码实现在一个熟练的开发者手上，反而是最简单的事情。\n最后内部整理文档，外部输出思路：[《消息系统设计与实现》](http://huang-jerryc.com/2015/10/14/%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8C%E4%B8%8A%E7%AF%87%E3%80%8D/)\n\n# 优秀员工\n\n很快，2015 年过去了。\n部门年会在一家酒店吃年夜饭，那是难忘的一天。\n那一天，收到了一个肯定，「优秀员工奖」。\n是我们技术老大帮忙提名的，记得他年末跟我谈话的时候说的一句：「你是进步最快的，比其他人更靠谱些」。\n\n![优秀员工奖](/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg)\n\n# Segmentfault —— 魅族科技开发团队\n\n年后，经过半年的时间，我们组对于技术的积累，以及文笔的熟练度，有了一定的提升。\n于是乎，我们开始考虑换一个输出文章的地方。\n当时我的想法是，建立一个我们独立的博客站点，但我的只能算作提议，最终还是技术 leader 以他认可的方式行动了：在 Segmentfault 以团队的名义来输出内容。\n于是，我们在 SF 建立了专题：「[魅族科技开发团队](https://segmentfault.com/blog/meizu)」。\n现在回想起来，这的确是一个明智之举，借助更垂直化的社区，可以给我们带来更多的关注量，和曝光度。当时魅族内部，还没有以团队名义来对外输出内容，我们做了，而且还做得不错。\n同时，以团队为的姿势，也得到了 SF 社区的欢迎。\n\n还记得，曾经连续两个季度入选 Top Writer 之后，均收到社区寄过来的小礼物和卡片，那份激动的心情。\n以前也混过想 CNodeJS，V2EX，CSDN 之类的技术社区，但是从来没有遇到一个这么认真的技术社区。能感觉得到 SF 社区的那颗真诚在做社区的心。\n\n我经常说，程序员就像中欧的骑士一样， Fight For Honor。\n如果 SF 捉到了这一点，就可以留住更多的优秀产出者，就会吸引更多学习者，然后再反过来哺乳社区，形成一个良性循环。\n\n![SF Top Writer](/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg)\n\n# 凌晨六点的东岸牌坊\n\n2016 年 3 月份，我接到了一个很酷的工作。\n公司预定在 4 月 6 日开一场魅蓝新品发布会，而在发布会之前的预热活动，想搞一个抽奖，送特斯拉。\n我们 Web 组提供技术支持，设计以及策划的工作由市场部的其他部门协作完成。\n整个项目工期很赶，我们基本实行了临时的 996，加班加点赶工期，那时候很充实。\n\n就在 3 月 23 日上午，我们上线了「406魅蓝发布会」的项目。\n上线的前一天晚上大家通宵战到天亮，我们下班打卡的时候，已经连续工作了 29 个小时。\n\n项目上线的前几个小时，太阳刚从东边升起，我们眼睁睁的看着漆黑的夜，渐渐地明亮起来。\n珠海的三四月正是潮湿天气，空气中充满了水分子，初升的阳光很弱，还没有足够的能量消散这一层薄雾。\n走到办公室的窗前，一副迷人朦胧的景色映入眼帘。\n这是，凌晨 6 点钟的东岸牌坊。\n\n![东岸牌坊](/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg)\n\n因为公司动用了大部分的传播渠道来推广这个网站，当天的日 PV 突破 100W，让我激动了很久。\n整个项目我负责的不单单只是后端功能的开发，还需要在整个项目上把握进度，那时候能感觉到老大有放权给我们的意思，虽然没有明说。\n这让我们在项目上，进度上，站在更加有责任感的位置思考问题。\n技术上比较简单，前端页面提供几个 HTML 页面，服务器使用了阿里云，以及阿里云提供的 MySQL 。\n在单元测试上我比较重视，覆盖率 100%。\n安全性方面，使用了极验的验证码，绝大程度上避免了恶意的刷码行为。\n这一次的项目，让我在做一个高并发、高性能、高稳定、响应速度高要求的项目有了更多的经验。\n\n# 危机感\n\n本来一切都是很顺利，团队氛围很好，也很有干劲。\n加上之前的顺风顺水，我曾以为我能在公司干出一番成绩和事业。\n然而开始有了一些不好的变化，4 月份公司发生了一些不开心的事，于是乎，奇怪的味道慢慢蔓延开来，从最初的难以察觉到后面越发刺鼻。\n4 月，也正值跳槽旺季，我收到了几个猎头和一些公司的邀请。\n由于一个意外，老大知道了，就在这个大家嗅觉都特别敏感的时期。\n然后被约去喝咖啡了，我也正好把我所思所虑表达清楚。\n我们老大是一个平易近人，也很能理解下属的 leader。\n我说，魅玩帮 2.0 在即，我还可以提供一些推动力，最起码 2016 年还会留着，干完该干的事情。\n我这样说是给老大承诺，也给自己定心，我知道坚持的美。\n其实那时候，尽然有对薪资的不满意，但是对团队的感情，以及产品的感情更胜于此。\n噢，不舍的还有珠海安逸的生活。\n没有人不在意钱，我也在意。\n而大多数人赚钱，也是为了让生活更美好。\n但是如果一旦你的生活跟一家公司强关联起来，就没法确保你安逸的生活哪一天不会被毁掉。\n同时，你的决定和行动也会受到更加多因素的影响和束缚。\n\n无论怎么样，终究，我的危机感变得比以往更加强烈。\n\n# 魅玩帮 2.0\n\n魅玩帮尝试了最后一个转型，从「试玩」为主转向「内容输出」为主。\n于是，魅玩帮走向了 2.0。\n2.0 的功能点很多，需求也很多。\n但是对于我来说，技术上早已经轻车熟路，所以问题不大。\n大多都是业务，逻辑，API。\n值得写的东西也不多。\n\n# 西山日薄的魅玩帮\n\n经过两年的时间，魅玩帮的模式也玩的差不多了，功能也越发趋于完善，产品也越来越成熟。\n但是，我也渐渐地明白，魅玩帮的模式，有一个致命的弱点，没有直接的盈利模式。\n它的影响力，是附属在魅族品牌下的，只能是营销上的一个辅助性工具，就算我们技术上把项目做得再精，再出色。\n没有发现盈利点，就没能够在内部提高我们的不可割舍性，最直接的影响也就是我们的待遇和福利。\n我们没有给公司创造收入，那么我们的工资就像是在烧钱。（实际上，我们内部接的营销项目，也是间接帮公司省掉外包的支出）\n在年末，上层决定要把「魅玩帮」并入到「魅族社区」，我渐渐的意识到我们做了两年多的产品已经西山日薄了。\n\n我也发现，这时候离开，是对团队的影响最小的时候。\n\n\n# 成长\n\n从大学实习开始，直到毕业之后的一年半，已经在魅族度过了两年零三个月。\n在这里经历过很多的第一次，也认识了很棒很聪明的朋友和同事，从他们身上看到，也学到了很多东西。\n在这里，我的生活和工作是融合在一起的，但却没有一丝的违和感，融合的那么自然，有机。\n团队的大家除了是同事，还是一群好朋友，好基友。\n而技术老大，两年了，也像师傅一样，从最初的手把手教，到后面的信任，放手。\n慢慢的，忽然意识到，是时候出师了。\n\n在这里锻炼的不单单只有技术，\n还有做人、做事的道理，\n还有职场上处事的道理，\n还有眼界和认识，\n还有思维方式，思考方法\n等等......\n\n是的，感谢魅族。\n今天，我毕业了，从魅族。\n\n\n# 夏天\n魅族，诞生在一个南方的海滨城市——珠海。\n这里一年中似乎只有夏天与冬天，秋天和春天短到以至于你感觉不到他们来过。\n魅族科技楼的前面，立着一颗树。\n我依然清晰的记得，那一年，我来的时候，它满载绿油油的叶子。\n在阳光下，温暖且湿润的风吹过，叶子唰唰的响，切出无数缕光束，打到我的脸上。\n\n![夏天](/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg)","source":"_posts/the-winter-and-summer-of-Meizu.md","raw":"---\ntitle: 魅族的冬与夏\ncategory: 三省吾身\ndate: 2017-01-25 01:47:00\n---\n\n# 冬天\n我在离职协议书上面，签下了名字。\n犹如当年签订实习协议一样的字迹，不同的只是那份心情。\n\n我坐在魅族大楼前面围绕着一颗树而摆成的弧形长椅子，喝了口小卖部买来的咖啡。\n两年半之间，偶尔在午后偷得一丝慵懒，来到这里喝杯咖啡，感受着珠海的安静。\n\n抬头45度，当年满载绿叶的树，已经被寒风吹散，只剩下枝与干。\n我曾经幻想过很多次，会有一个两鬓斑白的老人坐在我身旁，告诉我这棵树的名字和故事。\n\n如此我的故事就会变得更具戏剧性，但现在我只能叫它「一棵树」。\n一棵树先生，花开花落，经历过多少个珠海的冬与夏。\n我两年半的魅族生涯，也被他看在眼里。\n\n![冬天](/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg)\n\n\n# 实习\n2014 年的暑假过后，跟我一起在大学做了不少项目的死党糖水哥找到了深圳的实习。\n他总是什么都比我快一步，也是从他话语中知道了珠海魅族下的笔戈科技在招「前端开发」。\n\n同时，带我入坑前端开发以及给予我第一个实战机会的师兄，邀请我到他的公司工作。\n在投简历的前两天，我去拜访以前实习的公司。因为那里是我成长过的地方，那时候公司不大，几个人，但是气氛很好。虽然短短的两个月，但是对这家公司的感情还是蛮深刻的。\n师兄知道我正在找实习，就邀请我来一起干，让我负责主要的 NodeJS 和前端开发。\n一时间，我下不了决定。一方面难以拒绝师兄的热情相邀，一方面又放不下自己准备良久的面试。我当时就实说了，正在准备面试一家公司，待我回去考虑过再给答复。\n回去后，我思考了一个晚上，也用笔和纸列举了去两家公司的利与弊。\n最终，我还是决定了先去魅族试一下。\n\n我很感激师兄的邀请和对我的欣赏，但是那时候的我就一心想见识更多的人与事。\n我记得跟他说了一句话：「我想试一下魅族」。\n是的，我只投了一封简历，只投给了魅族笔戈科技。\n\n很快就收到了面试官回复的邮件。大概内容就是很高兴收到简历，然后约定电话面试的时间。\n在经过一个多小时的电话面试，以及一个面对面面试。\n我终于收到了魅族的 Offer 邮件。\n\n同时，还收到了总监盖文张的额外邮件，邮件内容主要介绍了魅族科技、笔戈科技、还有简单的个人简介，还扔了一大堆文献资料要我去阅读。最后还不忘布置一个家庭作业：一份关于我自身的全面社交账号列表，以及详细的自我简介，以及我未来想要做的事情。\n\n从邮件的文字中，能深刻的感受盖文张对于每个成员负责的态度。\n那时候我很高兴，能和一位如此有亲和力和有想法的人工作，那是多么幸运的事情。\n\n所以，尽然我语文作文能力低弱，也是使劲的憋出了一篇2000字的感想。\n\n\n# 笔戈科技\n我记得第一次踏入魅族科技楼的一瞬间，看到一楼大厅的装横的那份感动。\n就像那时候魅族设计出来的手机一样，那么的简洁，那么的灵动。\n\n![魅族一楼大厅](/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg)\n\n我在笔戈科技，所属于 Web 开发组，组内只有老大一个 NodeJS 开发，再加上包括我在内的三个前端实习生。\n老大跟我说，你看这么多前端实习生，本来不打算再招前端实习生了，但是看到你以前做的项目蛮多的，就破例了。这句话，让我心里偷偷窃喜了好一段时间。\n\n当时我们组主要是负责笔戈博客项目，以及一些营销导向型的短期项目。\n笔戈博客是在 Ghost 的基础上构建的，修修补补源代码，加上了一些业务性的定制功能。\n我记得那时候看 Ghost 的源码，因为不懂 Promise ，看的非常吃力。\nGhost 的前端部分使用的是 EmberJS，在2014年前端的 MVC 框架比较流行的是 AngularJS、EmberJS、BackboneJS。\n构建项目的用的是 Grunt，CSS 部分的 sass、less 在当年也已经开始普及起来。\n对于我一个只懂 jQuery、BootStrap 、以及前端三项基本功的实习生，掌握前端工程化技术是一项让人充满新鲜感与兴奋的挑战。\n\n当时技术团队的人员配置很不平衡，一个后端对应三个前端，所以后端的工作强度很大，前端反而显得清闲。\n不出半个月，一个午饭时分，老大跟我说：「你不是会 NodeJS 吗，要不尝试转后端？」\n我思考了很久，大学立下的职业规划是成为一名出色的前端工程师。\n但是要做好前端，首先是成为一名合格的软件工程师。我觉得是一次机会，所以就答应了，后面的两年的时间，工作上就绝大部分从事着后端开发。\n随后我也感激我当时的选择，后端的工作能让我从不同的角度来了解软件开发。\n在我转型不久，很快又来了一位 NodeJS 实习生。从现在来看，他也是我们组最后的一位实习生。\n\n在笔戈科技，虽然有不同的职能组，但是那时候人还少，不同职能的大家都可以混在一起，而且管理上也十分的扁平化。我们使用很多优秀的工具来进行团队合作，例如 Teambition、Google Docs，还统一购买科学上网服务。\n\n就像我在入职前写给盖文张对于笔戈的看法所描述的，笔戈科技就像魅族的一个特种部队，效率和敏捷性都很高。\n\n# 笔戈玩\n在入职直到 2014 年末之前，我都一直做着一些琐碎的事情，笔戈博客的维护，以及一些营销导向性的短期项目，就像内部的一个外包技术团队。\n我想，如果那时候没有魅玩帮的立项，估计我半年之后就不会在魅族了。\n\n就趋近于年末的时候，盖文张召集我们技术组开会，谈论一个新项目的想法。\n要做一个魅族旗下推广型的平台，推广方向就是我们所从事的「智能硬件」方向。\n这时候，一个智能硬件试玩网站的雏形诞生了，叫「笔戈玩」。\n\n项目立项了，就要撸起袖子开始干了。\n团队的主要技术栈是 NodeJS，我们需要一个能快速搭建项目的 NodeJS 企业级开发框架。\n我们对比了 Meteor、Strongloop、SailsJS，最后被 SailsJS 清晰的 MVC 分层所吸引，选择了 SailsJS 框架来开发。当然，框架的功能性，扩展性，和社区活跃度都是需要被考虑的，记得当年我写了一篇 [《为什么使用 SailsJS》](http://huang-jerryc.com/2015/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Sails/)，现在看回去，有不少的东西可以补充。\n\n\n就这样，一个老大带着四个实习生，三个 NodeJS，两个前端，从项目分析、概要设计、详细设计、数据库设计、再到编码实现，在农历年之前完成了「笔戈玩」的第一版本。\n年后，由于之前对框架的不熟悉，导致产出的代码欠佳，然后重新推翻，再次重构。\n又一个月的时间，发布了第一个内部测试版本。\n经过一段时间的测试、修复、运营准备，终于在 2015 年 5 月 21 日，「笔戈玩」正式上线。\n\n# 简书 —— 笔戈 Web Team\n\n在「笔戈玩」第一版本上线之后，我也迎来了我的毕业。\n\n盖文张是很注重团队成员自身发展的，他也很鼓励我们多看书多涉猎，也建立了读书经费。\n在我们办公室的角落，就有一个小小的书柜，都放满了大家要求买的书。\n除了看书，多写作也是被鼓励的。\n笔戈博客是我们部门的业余产出，写作就像笔戈不成形的团队文化，当时就在全部门内推行了这样的制度：每人每月定额产出文章，产出不奖励，不产出要罚钱。\n产出的文章，经过筛选，会发表在笔戈博客。\n我们写代码的人要求低一点，一个月一篇，写不出要罚 100 块，罚的钱，用来补贴部门经费。\n我那时候的实习工资 2000 加上补贴，一个月不缺勤到手也就 2700。罚 100 块，是多么痛心的事情。\n所以我们憋也要憋出来几个字。\n\n如果我们写一些技术类的，倒是没那么痛苦。\n可偏偏那时候我们技术老大说，尽量不要写技术类的。理由是笔戈博客的读者并不是技术向的。\n其实对于我们这群纯理科生，是有点为难的。\n我在笔戈的第一篇文章，是使劲憋出来的：[《盘点国内的那些ROM》](http://huang-jerryc.com/2015/03/03/%E7%9B%98%E7%82%B9%E5%9B%BD%E5%86%85%E7%9A%84%E9%82%A3%E4%BA%9BROM/)\n\n之后我就在思考，有什么办法可以发挥我们的所长，并且符合这个制度。\n我的想法是，我们团队应该是作为一个技术团队的名义来抛头露面，我们的产出可以是纯技术导向，我们把内容聚合起来，作为一个专题，或一个频道，或者其他什么样的形式。\n\n正好笔戈当时也在简书上面发表文章，以增加曝光度。\n我就回学校毕业之前，给盖文张发了一封邮件，把我对团队文化建设的构思路描述了一遍。\n大概就是先从简书开始，建立一个「笔戈 Web Team」的专题，以笔戈的名义为依托，来给我们技术人提供练笔和展示的地方。\n因为简书并不是纯粹的技术社区，受众并不多，我们可以肆无忌惮的写一点东西，而不怕被人鄙视水平不够。\n待我们的水平和产出上来了，考虑转移更纯粹的技术社区，或者建立团队的技术博客。\n我举例了 AlloyTeam，Taobao FED 这些大厂出名的博客。\n同时还说明了这样做的好处，一是写作会逼迫我们思考和总结，对我们技术水平提升有明显的作用。二是可以打响名声，提高成员自豪感，提升凝聚力，同时也有助于招聘。\n\n盖文张很快回复了邮件，他赞同这样的做法，另外给了我笔戈科技在简书的账号密码，让我来创建这个专题。\n同时，我也把这个想法跟技术老大说。我们老大是很进步向的，也很赞成这样的做法。\n\n自此，我们开始以团队的名义进行技术文章的产出，一点一点的积累和提升。\n截止现在，尽管我们已经转移产出的场地，但是简书上面的 「[笔戈 Web Team](http://www.jianshu.com/c/2a4335808d4c)」，已经有103篇文章。\n\n# 第一次出省\n\n从大学毕业之后，我和魅族签订了我人生的第一份劳动合同。正式成为了魅族的员工，虽然之前实习的日子都是被当做正式员工来用。但是不同的是，我终于可以领着符合水平的薪水了。\n\n毕业回来正好碰上了 MX5 的发布会，公司需要征集员工志愿者，我就应征了。\n于是乎，人生第一次出差，也是这个稚嫩的广东人的第一次出省。\n\n我们订的是动卧票，晚上从广州出发， 第二天就能到北京。\n看着地图的定位慢慢的越过广东的边界，心头涌上莫名的一股激动。\n记得那天晚上，躺在摇晃的车厢中，闭上眼，脑海晃出了很多画面，一场星际旅行。\n\n然后，打开当时很流行的「足记」，写下了一些胡思乱想。\n现在看回去，自己还真像个小孩。\n\n![出省](/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg)\n\n同行的还有几个要好的同事，我们是提前一天到达的。\n在空闲的时间，我们相约去了北京的「798艺术区」。\n我想，每一个来到这里的年轻人，都会爱上这里弥漫着创意以及艺术气息的空气。\n\n![798艺术区](/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg)\n\n# 第一次出国\n\n在北京回来之后，正好碰上公司的年度旅游。\n听一些老员工说「今年开始才有旅游经费的，你碰到好时候了」，比较遗憾的是，那也是唯一一年有旅游经费的。\n公司的旅游经费只够短距离玩个三四天左右，以自行组织报销的形式，然后部门的一些土豪君给出一种方案，就是自己多掏腰包，然后一起去泰国玩一转。\n听到这方案，心里埋藏已久的射手座的心，再出跳出来作祟。\n花光了一年实习的积蓄，跟着土豪同事们去泰国了，那也是我第一次踏出中国的大陆。\n\n![泰旅](/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg)\n![泰旅](/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg)\n\n# 魅玩帮\n\n2015 年 9 月，「笔戈玩」更名「魅玩帮」，明确定位「魅族旗下新品分享平台」，由新的总监接手这个项目，帮团队理了至关重要的一件事：产品要和魅族价值挂钩。\n\nWeb 开发组，自然而然也就划分到新总监门下。\n这时候我们小组已经从当初的 5 人小团队，增加到 11 人了，\n继我们组最后一个实习生之后， 又来了一个测试妹子，后来转运维去了。 \n然后，又来了一个 NodeJS 的后端，除了帅人品还很好。\n然后，又来了一个测试妹子，爱吃爱玩，还会卖萌，我经常说：「你要是瘦了肯定是个美女」。\n同时间来的还有一个香港硕士生，做前端开发，人帅，逼格比我还高。\n再后来，又来了一个 JAVA 的后端，也是硕士毕业，基础很赞，人很接地气。\n最后，再来了一个项目经理。\n再加上原来项目整合分配到的一位御用设计师，和一位会卖萌的产品经理。\n于是乎，「魅玩帮」团队，从一个实习生团队，慢慢的增长到一个成型的小团队，配置到位。\n卖萌产经经常说，她遇到一群聪明的人。\n\n项目重定位之后的一系列工作就是接入魅族用户中心，魅族论坛，Flyme 论坛。\n这涉及到跨部门之间的合作，由于技术上是由我一直跟对方沟通的。\n后来，老大跟我说：「你参与的比较多，由你来主导这次开发吧」，喜出望外。\n随后被打了鸡血一样，事无巨细，从设计、文档、技术方案给理了清楚，再加上一群很棒的伙伴，功能很快就做完了。\n\n随着「魅玩帮」的用户量上升，产品想要一个「消息提醒」的功能。之前的工作给老大留下了不错的印象，这个任务就被分给我了。\n消息系统的开发，也是我觉得工作内做的比较有条理性的工作之一。\n经常性，产品想要一个东西，但是并不能完全的描述这个东西的细节，消息提醒也是一样。\n开发需要做的是，帮忙缕清整个东西的逻辑和业务，我首先是分析业内的一些成型的产品，例如知乎、简书的消息提醒功能。\n通过分析，抽象本质，整理业务功能，写出大概的功能设计，以及实现思路，然后再开会沟通。\n经过多次沟通和修改，然后编码实现。\n那时候明白了一个道理，一项功能或者一个项目，最费时间和精力的是在前期的沟通和设计上面，编码实现在一个熟练的开发者手上，反而是最简单的事情。\n最后内部整理文档，外部输出思路：[《消息系统设计与实现》](http://huang-jerryc.com/2015/10/14/%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8C%E4%B8%8A%E7%AF%87%E3%80%8D/)\n\n# 优秀员工\n\n很快，2015 年过去了。\n部门年会在一家酒店吃年夜饭，那是难忘的一天。\n那一天，收到了一个肯定，「优秀员工奖」。\n是我们技术老大帮忙提名的，记得他年末跟我谈话的时候说的一句：「你是进步最快的，比其他人更靠谱些」。\n\n![优秀员工奖](/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg)\n\n# Segmentfault —— 魅族科技开发团队\n\n年后，经过半年的时间，我们组对于技术的积累，以及文笔的熟练度，有了一定的提升。\n于是乎，我们开始考虑换一个输出文章的地方。\n当时我的想法是，建立一个我们独立的博客站点，但我的只能算作提议，最终还是技术 leader 以他认可的方式行动了：在 Segmentfault 以团队的名义来输出内容。\n于是，我们在 SF 建立了专题：「[魅族科技开发团队](https://segmentfault.com/blog/meizu)」。\n现在回想起来，这的确是一个明智之举，借助更垂直化的社区，可以给我们带来更多的关注量，和曝光度。当时魅族内部，还没有以团队名义来对外输出内容，我们做了，而且还做得不错。\n同时，以团队为的姿势，也得到了 SF 社区的欢迎。\n\n还记得，曾经连续两个季度入选 Top Writer 之后，均收到社区寄过来的小礼物和卡片，那份激动的心情。\n以前也混过想 CNodeJS，V2EX，CSDN 之类的技术社区，但是从来没有遇到一个这么认真的技术社区。能感觉得到 SF 社区的那颗真诚在做社区的心。\n\n我经常说，程序员就像中欧的骑士一样， Fight For Honor。\n如果 SF 捉到了这一点，就可以留住更多的优秀产出者，就会吸引更多学习者，然后再反过来哺乳社区，形成一个良性循环。\n\n![SF Top Writer](/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg)\n\n# 凌晨六点的东岸牌坊\n\n2016 年 3 月份，我接到了一个很酷的工作。\n公司预定在 4 月 6 日开一场魅蓝新品发布会，而在发布会之前的预热活动，想搞一个抽奖，送特斯拉。\n我们 Web 组提供技术支持，设计以及策划的工作由市场部的其他部门协作完成。\n整个项目工期很赶，我们基本实行了临时的 996，加班加点赶工期，那时候很充实。\n\n就在 3 月 23 日上午，我们上线了「406魅蓝发布会」的项目。\n上线的前一天晚上大家通宵战到天亮，我们下班打卡的时候，已经连续工作了 29 个小时。\n\n项目上线的前几个小时，太阳刚从东边升起，我们眼睁睁的看着漆黑的夜，渐渐地明亮起来。\n珠海的三四月正是潮湿天气，空气中充满了水分子，初升的阳光很弱，还没有足够的能量消散这一层薄雾。\n走到办公室的窗前，一副迷人朦胧的景色映入眼帘。\n这是，凌晨 6 点钟的东岸牌坊。\n\n![东岸牌坊](/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg)\n\n因为公司动用了大部分的传播渠道来推广这个网站，当天的日 PV 突破 100W，让我激动了很久。\n整个项目我负责的不单单只是后端功能的开发，还需要在整个项目上把握进度，那时候能感觉到老大有放权给我们的意思，虽然没有明说。\n这让我们在项目上，进度上，站在更加有责任感的位置思考问题。\n技术上比较简单，前端页面提供几个 HTML 页面，服务器使用了阿里云，以及阿里云提供的 MySQL 。\n在单元测试上我比较重视，覆盖率 100%。\n安全性方面，使用了极验的验证码，绝大程度上避免了恶意的刷码行为。\n这一次的项目，让我在做一个高并发、高性能、高稳定、响应速度高要求的项目有了更多的经验。\n\n# 危机感\n\n本来一切都是很顺利，团队氛围很好，也很有干劲。\n加上之前的顺风顺水，我曾以为我能在公司干出一番成绩和事业。\n然而开始有了一些不好的变化，4 月份公司发生了一些不开心的事，于是乎，奇怪的味道慢慢蔓延开来，从最初的难以察觉到后面越发刺鼻。\n4 月，也正值跳槽旺季，我收到了几个猎头和一些公司的邀请。\n由于一个意外，老大知道了，就在这个大家嗅觉都特别敏感的时期。\n然后被约去喝咖啡了，我也正好把我所思所虑表达清楚。\n我们老大是一个平易近人，也很能理解下属的 leader。\n我说，魅玩帮 2.0 在即，我还可以提供一些推动力，最起码 2016 年还会留着，干完该干的事情。\n我这样说是给老大承诺，也给自己定心，我知道坚持的美。\n其实那时候，尽然有对薪资的不满意，但是对团队的感情，以及产品的感情更胜于此。\n噢，不舍的还有珠海安逸的生活。\n没有人不在意钱，我也在意。\n而大多数人赚钱，也是为了让生活更美好。\n但是如果一旦你的生活跟一家公司强关联起来，就没法确保你安逸的生活哪一天不会被毁掉。\n同时，你的决定和行动也会受到更加多因素的影响和束缚。\n\n无论怎么样，终究，我的危机感变得比以往更加强烈。\n\n# 魅玩帮 2.0\n\n魅玩帮尝试了最后一个转型，从「试玩」为主转向「内容输出」为主。\n于是，魅玩帮走向了 2.0。\n2.0 的功能点很多，需求也很多。\n但是对于我来说，技术上早已经轻车熟路，所以问题不大。\n大多都是业务，逻辑，API。\n值得写的东西也不多。\n\n# 西山日薄的魅玩帮\n\n经过两年的时间，魅玩帮的模式也玩的差不多了，功能也越发趋于完善，产品也越来越成熟。\n但是，我也渐渐地明白，魅玩帮的模式，有一个致命的弱点，没有直接的盈利模式。\n它的影响力，是附属在魅族品牌下的，只能是营销上的一个辅助性工具，就算我们技术上把项目做得再精，再出色。\n没有发现盈利点，就没能够在内部提高我们的不可割舍性，最直接的影响也就是我们的待遇和福利。\n我们没有给公司创造收入，那么我们的工资就像是在烧钱。（实际上，我们内部接的营销项目，也是间接帮公司省掉外包的支出）\n在年末，上层决定要把「魅玩帮」并入到「魅族社区」，我渐渐的意识到我们做了两年多的产品已经西山日薄了。\n\n我也发现，这时候离开，是对团队的影响最小的时候。\n\n\n# 成长\n\n从大学实习开始，直到毕业之后的一年半，已经在魅族度过了两年零三个月。\n在这里经历过很多的第一次，也认识了很棒很聪明的朋友和同事，从他们身上看到，也学到了很多东西。\n在这里，我的生活和工作是融合在一起的，但却没有一丝的违和感，融合的那么自然，有机。\n团队的大家除了是同事，还是一群好朋友，好基友。\n而技术老大，两年了，也像师傅一样，从最初的手把手教，到后面的信任，放手。\n慢慢的，忽然意识到，是时候出师了。\n\n在这里锻炼的不单单只有技术，\n还有做人、做事的道理，\n还有职场上处事的道理，\n还有眼界和认识，\n还有思维方式，思考方法\n等等......\n\n是的，感谢魅族。\n今天，我毕业了，从魅族。\n\n\n# 夏天\n魅族，诞生在一个南方的海滨城市——珠海。\n这里一年中似乎只有夏天与冬天，秋天和春天短到以至于你感觉不到他们来过。\n魅族科技楼的前面，立着一颗树。\n我依然清晰的记得，那一年，我来的时候，它满载绿油油的叶子。\n在阳光下，温暖且湿润的风吹过，叶子唰唰的响，切出无数缕光束，打到我的脸上。\n\n![夏天](/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg)","slug":"the-winter-and-summer-of-Meizu","published":1,"updated":"2017-02-04T14:02:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwq7001m15hl16ruk1dx","content":"<h1 id=\"冬天\"><a href=\"#冬天\" class=\"headerlink\" title=\"冬天\"></a>冬天</h1><p>我在离职协议书上面，签下了名字。<br>犹如当年签订实习协议一样的字迹，不同的只是那份心情。</p>\n<p>我坐在魅族大楼前面围绕着一颗树而摆成的弧形长椅子，喝了口小卖部买来的咖啡。<br>两年半之间，偶尔在午后偷得一丝慵懒，来到这里喝杯咖啡，感受着珠海的安静。</p>\n<p>抬头45度，当年满载绿叶的树，已经被寒风吹散，只剩下枝与干。<br>我曾经幻想过很多次，会有一个两鬓斑白的老人坐在我身旁，告诉我这棵树的名字和故事。</p>\n<p>如此我的故事就会变得更具戏剧性，但现在我只能叫它「一棵树」。<br>一棵树先生，花开花落，经历过多少个珠海的冬与夏。<br>我两年半的魅族生涯，也被他看在眼里。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg\" alt=\"冬天\"></p>\n<h1 id=\"实习\"><a href=\"#实习\" class=\"headerlink\" title=\"实习\"></a>实习</h1><p>2014 年的暑假过后，跟我一起在大学做了不少项目的死党糖水哥找到了深圳的实习。<br>他总是什么都比我快一步，也是从他话语中知道了珠海魅族下的笔戈科技在招「前端开发」。</p>\n<p>同时，带我入坑前端开发以及给予我第一个实战机会的师兄，邀请我到他的公司工作。<br>在投简历的前两天，我去拜访以前实习的公司。因为那里是我成长过的地方，那时候公司不大，几个人，但是气氛很好。虽然短短的两个月，但是对这家公司的感情还是蛮深刻的。<br>师兄知道我正在找实习，就邀请我来一起干，让我负责主要的 NodeJS 和前端开发。<br>一时间，我下不了决定。一方面难以拒绝师兄的热情相邀，一方面又放不下自己准备良久的面试。我当时就实说了，正在准备面试一家公司，待我回去考虑过再给答复。<br>回去后，我思考了一个晚上，也用笔和纸列举了去两家公司的利与弊。<br>最终，我还是决定了先去魅族试一下。</p>\n<p>我很感激师兄的邀请和对我的欣赏，但是那时候的我就一心想见识更多的人与事。<br>我记得跟他说了一句话：「我想试一下魅族」。<br>是的，我只投了一封简历，只投给了魅族笔戈科技。</p>\n<p>很快就收到了面试官回复的邮件。大概内容就是很高兴收到简历，然后约定电话面试的时间。<br>在经过一个多小时的电话面试，以及一个面对面面试。<br>我终于收到了魅族的 Offer 邮件。</p>\n<p>同时，还收到了总监盖文张的额外邮件，邮件内容主要介绍了魅族科技、笔戈科技、还有简单的个人简介，还扔了一大堆文献资料要我去阅读。最后还不忘布置一个家庭作业：一份关于我自身的全面社交账号列表，以及详细的自我简介，以及我未来想要做的事情。</p>\n<p>从邮件的文字中，能深刻的感受盖文张对于每个成员负责的态度。<br>那时候我很高兴，能和一位如此有亲和力和有想法的人工作，那是多么幸运的事情。</p>\n<p>所以，尽然我语文作文能力低弱，也是使劲的憋出了一篇2000字的感想。</p>\n<h1 id=\"笔戈科技\"><a href=\"#笔戈科技\" class=\"headerlink\" title=\"笔戈科技\"></a>笔戈科技</h1><p>我记得第一次踏入魅族科技楼的一瞬间，看到一楼大厅的装横的那份感动。<br>就像那时候魅族设计出来的手机一样，那么的简洁，那么的灵动。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg\" alt=\"魅族一楼大厅\"></p>\n<p>我在笔戈科技，所属于 Web 开发组，组内只有老大一个 NodeJS 开发，再加上包括我在内的三个前端实习生。<br>老大跟我说，你看这么多前端实习生，本来不打算再招前端实习生了，但是看到你以前做的项目蛮多的，就破例了。这句话，让我心里偷偷窃喜了好一段时间。</p>\n<p>当时我们组主要是负责笔戈博客项目，以及一些营销导向型的短期项目。<br>笔戈博客是在 Ghost 的基础上构建的，修修补补源代码，加上了一些业务性的定制功能。<br>我记得那时候看 Ghost 的源码，因为不懂 Promise ，看的非常吃力。<br>Ghost 的前端部分使用的是 EmberJS，在2014年前端的 MVC 框架比较流行的是 AngularJS、EmberJS、BackboneJS。<br>构建项目的用的是 Grunt，CSS 部分的 sass、less 在当年也已经开始普及起来。<br>对于我一个只懂 jQuery、BootStrap 、以及前端三项基本功的实习生，掌握前端工程化技术是一项让人充满新鲜感与兴奋的挑战。</p>\n<p>当时技术团队的人员配置很不平衡，一个后端对应三个前端，所以后端的工作强度很大，前端反而显得清闲。<br>不出半个月，一个午饭时分，老大跟我说：「你不是会 NodeJS 吗，要不尝试转后端？」<br>我思考了很久，大学立下的职业规划是成为一名出色的前端工程师。<br>但是要做好前端，首先是成为一名合格的软件工程师。我觉得是一次机会，所以就答应了，后面的两年的时间，工作上就绝大部分从事着后端开发。<br>随后我也感激我当时的选择，后端的工作能让我从不同的角度来了解软件开发。<br>在我转型不久，很快又来了一位 NodeJS 实习生。从现在来看，他也是我们组最后的一位实习生。</p>\n<p>在笔戈科技，虽然有不同的职能组，但是那时候人还少，不同职能的大家都可以混在一起，而且管理上也十分的扁平化。我们使用很多优秀的工具来进行团队合作，例如 Teambition、Google Docs，还统一购买科学上网服务。</p>\n<p>就像我在入职前写给盖文张对于笔戈的看法所描述的，笔戈科技就像魅族的一个特种部队，效率和敏捷性都很高。</p>\n<h1 id=\"笔戈玩\"><a href=\"#笔戈玩\" class=\"headerlink\" title=\"笔戈玩\"></a>笔戈玩</h1><p>在入职直到 2014 年末之前，我都一直做着一些琐碎的事情，笔戈博客的维护，以及一些营销导向性的短期项目，就像内部的一个外包技术团队。<br>我想，如果那时候没有魅玩帮的立项，估计我半年之后就不会在魅族了。</p>\n<p>就趋近于年末的时候，盖文张召集我们技术组开会，谈论一个新项目的想法。<br>要做一个魅族旗下推广型的平台，推广方向就是我们所从事的「智能硬件」方向。<br>这时候，一个智能硬件试玩网站的雏形诞生了，叫「笔戈玩」。</p>\n<p>项目立项了，就要撸起袖子开始干了。<br>团队的主要技术栈是 NodeJS，我们需要一个能快速搭建项目的 NodeJS 企业级开发框架。<br>我们对比了 Meteor、Strongloop、SailsJS，最后被 SailsJS 清晰的 MVC 分层所吸引，选择了 SailsJS 框架来开发。当然，框架的功能性，扩展性，和社区活跃度都是需要被考虑的，记得当年我写了一篇 <a href=\"http://huang-jerryc.com/2015/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Sails/\">《为什么使用 SailsJS》</a>，现在看回去，有不少的东西可以补充。</p>\n<p>就这样，一个老大带着四个实习生，三个 NodeJS，两个前端，从项目分析、概要设计、详细设计、数据库设计、再到编码实现，在农历年之前完成了「笔戈玩」的第一版本。<br>年后，由于之前对框架的不熟悉，导致产出的代码欠佳，然后重新推翻，再次重构。<br>又一个月的时间，发布了第一个内部测试版本。<br>经过一段时间的测试、修复、运营准备，终于在 2015 年 5 月 21 日，「笔戈玩」正式上线。</p>\n<h1 id=\"简书-——-笔戈-Web-Team\"><a href=\"#简书-——-笔戈-Web-Team\" class=\"headerlink\" title=\"简书 —— 笔戈 Web Team\"></a>简书 —— 笔戈 Web Team</h1><p>在「笔戈玩」第一版本上线之后，我也迎来了我的毕业。</p>\n<p>盖文张是很注重团队成员自身发展的，他也很鼓励我们多看书多涉猎，也建立了读书经费。<br>在我们办公室的角落，就有一个小小的书柜，都放满了大家要求买的书。<br>除了看书，多写作也是被鼓励的。<br>笔戈博客是我们部门的业余产出，写作就像笔戈不成形的团队文化，当时就在全部门内推行了这样的制度：每人每月定额产出文章，产出不奖励，不产出要罚钱。<br>产出的文章，经过筛选，会发表在笔戈博客。<br>我们写代码的人要求低一点，一个月一篇，写不出要罚 100 块，罚的钱，用来补贴部门经费。<br>我那时候的实习工资 2000 加上补贴，一个月不缺勤到手也就 2700。罚 100 块，是多么痛心的事情。<br>所以我们憋也要憋出来几个字。</p>\n<p>如果我们写一些技术类的，倒是没那么痛苦。<br>可偏偏那时候我们技术老大说，尽量不要写技术类的。理由是笔戈博客的读者并不是技术向的。<br>其实对于我们这群纯理科生，是有点为难的。<br>我在笔戈的第一篇文章，是使劲憋出来的：<a href=\"http://huang-jerryc.com/2015/03/03/%E7%9B%98%E7%82%B9%E5%9B%BD%E5%86%85%E7%9A%84%E9%82%A3%E4%BA%9BROM/\">《盘点国内的那些ROM》</a></p>\n<p>之后我就在思考，有什么办法可以发挥我们的所长，并且符合这个制度。<br>我的想法是，我们团队应该是作为一个技术团队的名义来抛头露面，我们的产出可以是纯技术导向，我们把内容聚合起来，作为一个专题，或一个频道，或者其他什么样的形式。</p>\n<p>正好笔戈当时也在简书上面发表文章，以增加曝光度。<br>我就回学校毕业之前，给盖文张发了一封邮件，把我对团队文化建设的构思路描述了一遍。<br>大概就是先从简书开始，建立一个「笔戈 Web Team」的专题，以笔戈的名义为依托，来给我们技术人提供练笔和展示的地方。<br>因为简书并不是纯粹的技术社区，受众并不多，我们可以肆无忌惮的写一点东西，而不怕被人鄙视水平不够。<br>待我们的水平和产出上来了，考虑转移更纯粹的技术社区，或者建立团队的技术博客。<br>我举例了 AlloyTeam，Taobao FED 这些大厂出名的博客。<br>同时还说明了这样做的好处，一是写作会逼迫我们思考和总结，对我们技术水平提升有明显的作用。二是可以打响名声，提高成员自豪感，提升凝聚力，同时也有助于招聘。</p>\n<p>盖文张很快回复了邮件，他赞同这样的做法，另外给了我笔戈科技在简书的账号密码，让我来创建这个专题。<br>同时，我也把这个想法跟技术老大说。我们老大是很进步向的，也很赞成这样的做法。</p>\n<p>自此，我们开始以团队的名义进行技术文章的产出，一点一点的积累和提升。<br>截止现在，尽管我们已经转移产出的场地，但是简书上面的 「<a href=\"http://www.jianshu.com/c/2a4335808d4c\" target=\"_blank\" rel=\"external\">笔戈 Web Team</a>」，已经有103篇文章。</p>\n<h1 id=\"第一次出省\"><a href=\"#第一次出省\" class=\"headerlink\" title=\"第一次出省\"></a>第一次出省</h1><p>从大学毕业之后，我和魅族签订了我人生的第一份劳动合同。正式成为了魅族的员工，虽然之前实习的日子都是被当做正式员工来用。但是不同的是，我终于可以领着符合水平的薪水了。</p>\n<p>毕业回来正好碰上了 MX5 的发布会，公司需要征集员工志愿者，我就应征了。<br>于是乎，人生第一次出差，也是这个稚嫩的广东人的第一次出省。</p>\n<p>我们订的是动卧票，晚上从广州出发， 第二天就能到北京。<br>看着地图的定位慢慢的越过广东的边界，心头涌上莫名的一股激动。<br>记得那天晚上，躺在摇晃的车厢中，闭上眼，脑海晃出了很多画面，一场星际旅行。</p>\n<p>然后，打开当时很流行的「足记」，写下了一些胡思乱想。<br>现在看回去，自己还真像个小孩。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg\" alt=\"出省\"></p>\n<p>同行的还有几个要好的同事，我们是提前一天到达的。<br>在空闲的时间，我们相约去了北京的「798艺术区」。<br>我想，每一个来到这里的年轻人，都会爱上这里弥漫着创意以及艺术气息的空气。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg\" alt=\"798艺术区\"></p>\n<h1 id=\"第一次出国\"><a href=\"#第一次出国\" class=\"headerlink\" title=\"第一次出国\"></a>第一次出国</h1><p>在北京回来之后，正好碰上公司的年度旅游。<br>听一些老员工说「今年开始才有旅游经费的，你碰到好时候了」，比较遗憾的是，那也是唯一一年有旅游经费的。<br>公司的旅游经费只够短距离玩个三四天左右，以自行组织报销的形式，然后部门的一些土豪君给出一种方案，就是自己多掏腰包，然后一起去泰国玩一转。<br>听到这方案，心里埋藏已久的射手座的心，再出跳出来作祟。<br>花光了一年实习的积蓄，跟着土豪同事们去泰国了，那也是我第一次踏出中国的大陆。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg\" alt=\"泰旅\"><br><img src=\"/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg\" alt=\"泰旅\"></p>\n<h1 id=\"魅玩帮\"><a href=\"#魅玩帮\" class=\"headerlink\" title=\"魅玩帮\"></a>魅玩帮</h1><p>2015 年 9 月，「笔戈玩」更名「魅玩帮」，明确定位「魅族旗下新品分享平台」，由新的总监接手这个项目，帮团队理了至关重要的一件事：产品要和魅族价值挂钩。</p>\n<p>Web 开发组，自然而然也就划分到新总监门下。<br>这时候我们小组已经从当初的 5 人小团队，增加到 11 人了，<br>继我们组最后一个实习生之后， 又来了一个测试妹子，后来转运维去了。<br>然后，又来了一个 NodeJS 的后端，除了帅人品还很好。<br>然后，又来了一个测试妹子，爱吃爱玩，还会卖萌，我经常说：「你要是瘦了肯定是个美女」。<br>同时间来的还有一个香港硕士生，做前端开发，人帅，逼格比我还高。<br>再后来，又来了一个 JAVA 的后端，也是硕士毕业，基础很赞，人很接地气。<br>最后，再来了一个项目经理。<br>再加上原来项目整合分配到的一位御用设计师，和一位会卖萌的产品经理。<br>于是乎，「魅玩帮」团队，从一个实习生团队，慢慢的增长到一个成型的小团队，配置到位。<br>卖萌产经经常说，她遇到一群聪明的人。</p>\n<p>项目重定位之后的一系列工作就是接入魅族用户中心，魅族论坛，Flyme 论坛。<br>这涉及到跨部门之间的合作，由于技术上是由我一直跟对方沟通的。<br>后来，老大跟我说：「你参与的比较多，由你来主导这次开发吧」，喜出望外。<br>随后被打了鸡血一样，事无巨细，从设计、文档、技术方案给理了清楚，再加上一群很棒的伙伴，功能很快就做完了。</p>\n<p>随着「魅玩帮」的用户量上升，产品想要一个「消息提醒」的功能。之前的工作给老大留下了不错的印象，这个任务就被分给我了。<br>消息系统的开发，也是我觉得工作内做的比较有条理性的工作之一。<br>经常性，产品想要一个东西，但是并不能完全的描述这个东西的细节，消息提醒也是一样。<br>开发需要做的是，帮忙缕清整个东西的逻辑和业务，我首先是分析业内的一些成型的产品，例如知乎、简书的消息提醒功能。<br>通过分析，抽象本质，整理业务功能，写出大概的功能设计，以及实现思路，然后再开会沟通。<br>经过多次沟通和修改，然后编码实现。<br>那时候明白了一个道理，一项功能或者一个项目，最费时间和精力的是在前期的沟通和设计上面，编码实现在一个熟练的开发者手上，反而是最简单的事情。<br>最后内部整理文档，外部输出思路：<a href=\"http://huang-jerryc.com/2015/10/14/%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8C%E4%B8%8A%E7%AF%87%E3%80%8D/\">《消息系统设计与实现》</a></p>\n<h1 id=\"优秀员工\"><a href=\"#优秀员工\" class=\"headerlink\" title=\"优秀员工\"></a>优秀员工</h1><p>很快，2015 年过去了。<br>部门年会在一家酒店吃年夜饭，那是难忘的一天。<br>那一天，收到了一个肯定，「优秀员工奖」。<br>是我们技术老大帮忙提名的，记得他年末跟我谈话的时候说的一句：「你是进步最快的，比其他人更靠谱些」。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg\" alt=\"优秀员工奖\"></p>\n<h1 id=\"Segmentfault-——-魅族科技开发团队\"><a href=\"#Segmentfault-——-魅族科技开发团队\" class=\"headerlink\" title=\"Segmentfault —— 魅族科技开发团队\"></a>Segmentfault —— 魅族科技开发团队</h1><p>年后，经过半年的时间，我们组对于技术的积累，以及文笔的熟练度，有了一定的提升。<br>于是乎，我们开始考虑换一个输出文章的地方。<br>当时我的想法是，建立一个我们独立的博客站点，但我的只能算作提议，最终还是技术 leader 以他认可的方式行动了：在 Segmentfault 以团队的名义来输出内容。<br>于是，我们在 SF 建立了专题：「<a href=\"https://segmentfault.com/blog/meizu\" target=\"_blank\" rel=\"external\">魅族科技开发团队</a>」。<br>现在回想起来，这的确是一个明智之举，借助更垂直化的社区，可以给我们带来更多的关注量，和曝光度。当时魅族内部，还没有以团队名义来对外输出内容，我们做了，而且还做得不错。<br>同时，以团队为的姿势，也得到了 SF 社区的欢迎。</p>\n<p>还记得，曾经连续两个季度入选 Top Writer 之后，均收到社区寄过来的小礼物和卡片，那份激动的心情。<br>以前也混过想 CNodeJS，V2EX，CSDN 之类的技术社区，但是从来没有遇到一个这么认真的技术社区。能感觉得到 SF 社区的那颗真诚在做社区的心。</p>\n<p>我经常说，程序员就像中欧的骑士一样， Fight For Honor。<br>如果 SF 捉到了这一点，就可以留住更多的优秀产出者，就会吸引更多学习者，然后再反过来哺乳社区，形成一个良性循环。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg\" alt=\"SF Top Writer\"></p>\n<h1 id=\"凌晨六点的东岸牌坊\"><a href=\"#凌晨六点的东岸牌坊\" class=\"headerlink\" title=\"凌晨六点的东岸牌坊\"></a>凌晨六点的东岸牌坊</h1><p>2016 年 3 月份，我接到了一个很酷的工作。<br>公司预定在 4 月 6 日开一场魅蓝新品发布会，而在发布会之前的预热活动，想搞一个抽奖，送特斯拉。<br>我们 Web 组提供技术支持，设计以及策划的工作由市场部的其他部门协作完成。<br>整个项目工期很赶，我们基本实行了临时的 996，加班加点赶工期，那时候很充实。</p>\n<p>就在 3 月 23 日上午，我们上线了「406魅蓝发布会」的项目。<br>上线的前一天晚上大家通宵战到天亮，我们下班打卡的时候，已经连续工作了 29 个小时。</p>\n<p>项目上线的前几个小时，太阳刚从东边升起，我们眼睁睁的看着漆黑的夜，渐渐地明亮起来。<br>珠海的三四月正是潮湿天气，空气中充满了水分子，初升的阳光很弱，还没有足够的能量消散这一层薄雾。<br>走到办公室的窗前，一副迷人朦胧的景色映入眼帘。<br>这是，凌晨 6 点钟的东岸牌坊。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg\" alt=\"东岸牌坊\"></p>\n<p>因为公司动用了大部分的传播渠道来推广这个网站，当天的日 PV 突破 100W，让我激动了很久。<br>整个项目我负责的不单单只是后端功能的开发，还需要在整个项目上把握进度，那时候能感觉到老大有放权给我们的意思，虽然没有明说。<br>这让我们在项目上，进度上，站在更加有责任感的位置思考问题。<br>技术上比较简单，前端页面提供几个 HTML 页面，服务器使用了阿里云，以及阿里云提供的 MySQL 。<br>在单元测试上我比较重视，覆盖率 100%。<br>安全性方面，使用了极验的验证码，绝大程度上避免了恶意的刷码行为。<br>这一次的项目，让我在做一个高并发、高性能、高稳定、响应速度高要求的项目有了更多的经验。</p>\n<h1 id=\"危机感\"><a href=\"#危机感\" class=\"headerlink\" title=\"危机感\"></a>危机感</h1><p>本来一切都是很顺利，团队氛围很好，也很有干劲。<br>加上之前的顺风顺水，我曾以为我能在公司干出一番成绩和事业。<br>然而开始有了一些不好的变化，4 月份公司发生了一些不开心的事，于是乎，奇怪的味道慢慢蔓延开来，从最初的难以察觉到后面越发刺鼻。<br>4 月，也正值跳槽旺季，我收到了几个猎头和一些公司的邀请。<br>由于一个意外，老大知道了，就在这个大家嗅觉都特别敏感的时期。<br>然后被约去喝咖啡了，我也正好把我所思所虑表达清楚。<br>我们老大是一个平易近人，也很能理解下属的 leader。<br>我说，魅玩帮 2.0 在即，我还可以提供一些推动力，最起码 2016 年还会留着，干完该干的事情。<br>我这样说是给老大承诺，也给自己定心，我知道坚持的美。<br>其实那时候，尽然有对薪资的不满意，但是对团队的感情，以及产品的感情更胜于此。<br>噢，不舍的还有珠海安逸的生活。<br>没有人不在意钱，我也在意。<br>而大多数人赚钱，也是为了让生活更美好。<br>但是如果一旦你的生活跟一家公司强关联起来，就没法确保你安逸的生活哪一天不会被毁掉。<br>同时，你的决定和行动也会受到更加多因素的影响和束缚。</p>\n<p>无论怎么样，终究，我的危机感变得比以往更加强烈。</p>\n<h1 id=\"魅玩帮-2-0\"><a href=\"#魅玩帮-2-0\" class=\"headerlink\" title=\"魅玩帮 2.0\"></a>魅玩帮 2.0</h1><p>魅玩帮尝试了最后一个转型，从「试玩」为主转向「内容输出」为主。<br>于是，魅玩帮走向了 2.0。<br>2.0 的功能点很多，需求也很多。<br>但是对于我来说，技术上早已经轻车熟路，所以问题不大。<br>大多都是业务，逻辑，API。<br>值得写的东西也不多。</p>\n<h1 id=\"西山日薄的魅玩帮\"><a href=\"#西山日薄的魅玩帮\" class=\"headerlink\" title=\"西山日薄的魅玩帮\"></a>西山日薄的魅玩帮</h1><p>经过两年的时间，魅玩帮的模式也玩的差不多了，功能也越发趋于完善，产品也越来越成熟。<br>但是，我也渐渐地明白，魅玩帮的模式，有一个致命的弱点，没有直接的盈利模式。<br>它的影响力，是附属在魅族品牌下的，只能是营销上的一个辅助性工具，就算我们技术上把项目做得再精，再出色。<br>没有发现盈利点，就没能够在内部提高我们的不可割舍性，最直接的影响也就是我们的待遇和福利。<br>我们没有给公司创造收入，那么我们的工资就像是在烧钱。（实际上，我们内部接的营销项目，也是间接帮公司省掉外包的支出）<br>在年末，上层决定要把「魅玩帮」并入到「魅族社区」，我渐渐的意识到我们做了两年多的产品已经西山日薄了。</p>\n<p>我也发现，这时候离开，是对团队的影响最小的时候。</p>\n<h1 id=\"成长\"><a href=\"#成长\" class=\"headerlink\" title=\"成长\"></a>成长</h1><p>从大学实习开始，直到毕业之后的一年半，已经在魅族度过了两年零三个月。<br>在这里经历过很多的第一次，也认识了很棒很聪明的朋友和同事，从他们身上看到，也学到了很多东西。<br>在这里，我的生活和工作是融合在一起的，但却没有一丝的违和感，融合的那么自然，有机。<br>团队的大家除了是同事，还是一群好朋友，好基友。<br>而技术老大，两年了，也像师傅一样，从最初的手把手教，到后面的信任，放手。<br>慢慢的，忽然意识到，是时候出师了。</p>\n<p>在这里锻炼的不单单只有技术，<br>还有做人、做事的道理，<br>还有职场上处事的道理，<br>还有眼界和认识，<br>还有思维方式，思考方法<br>等等……</p>\n<p>是的，感谢魅族。<br>今天，我毕业了，从魅族。</p>\n<h1 id=\"夏天\"><a href=\"#夏天\" class=\"headerlink\" title=\"夏天\"></a>夏天</h1><p>魅族，诞生在一个南方的海滨城市——珠海。<br>这里一年中似乎只有夏天与冬天，秋天和春天短到以至于你感觉不到他们来过。<br>魅族科技楼的前面，立着一颗树。<br>我依然清晰的记得，那一年，我来的时候，它满载绿油油的叶子。<br>在阳光下，温暖且湿润的风吹过，叶子唰唰的响，切出无数缕光束，打到我的脸上。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg\" alt=\"夏天\"></p>\n","excerpt":"","more":"<h1 id=\"冬天\"><a href=\"#冬天\" class=\"headerlink\" title=\"冬天\"></a>冬天</h1><p>我在离职协议书上面，签下了名字。<br>犹如当年签订实习协议一样的字迹，不同的只是那份心情。</p>\n<p>我坐在魅族大楼前面围绕着一颗树而摆成的弧形长椅子，喝了口小卖部买来的咖啡。<br>两年半之间，偶尔在午后偷得一丝慵懒，来到这里喝杯咖啡，感受着珠海的安静。</p>\n<p>抬头45度，当年满载绿叶的树，已经被寒风吹散，只剩下枝与干。<br>我曾经幻想过很多次，会有一个两鬓斑白的老人坐在我身旁，告诉我这棵树的名字和故事。</p>\n<p>如此我的故事就会变得更具戏剧性，但现在我只能叫它「一棵树」。<br>一棵树先生，花开花落，经历过多少个珠海的冬与夏。<br>我两年半的魅族生涯，也被他看在眼里。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/6E9C0DA7E8F9CD9967F7F5E3D8862D3F.jpg\" alt=\"冬天\"></p>\n<h1 id=\"实习\"><a href=\"#实习\" class=\"headerlink\" title=\"实习\"></a>实习</h1><p>2014 年的暑假过后，跟我一起在大学做了不少项目的死党糖水哥找到了深圳的实习。<br>他总是什么都比我快一步，也是从他话语中知道了珠海魅族下的笔戈科技在招「前端开发」。</p>\n<p>同时，带我入坑前端开发以及给予我第一个实战机会的师兄，邀请我到他的公司工作。<br>在投简历的前两天，我去拜访以前实习的公司。因为那里是我成长过的地方，那时候公司不大，几个人，但是气氛很好。虽然短短的两个月，但是对这家公司的感情还是蛮深刻的。<br>师兄知道我正在找实习，就邀请我来一起干，让我负责主要的 NodeJS 和前端开发。<br>一时间，我下不了决定。一方面难以拒绝师兄的热情相邀，一方面又放不下自己准备良久的面试。我当时就实说了，正在准备面试一家公司，待我回去考虑过再给答复。<br>回去后，我思考了一个晚上，也用笔和纸列举了去两家公司的利与弊。<br>最终，我还是决定了先去魅族试一下。</p>\n<p>我很感激师兄的邀请和对我的欣赏，但是那时候的我就一心想见识更多的人与事。<br>我记得跟他说了一句话：「我想试一下魅族」。<br>是的，我只投了一封简历，只投给了魅族笔戈科技。</p>\n<p>很快就收到了面试官回复的邮件。大概内容就是很高兴收到简历，然后约定电话面试的时间。<br>在经过一个多小时的电话面试，以及一个面对面面试。<br>我终于收到了魅族的 Offer 邮件。</p>\n<p>同时，还收到了总监盖文张的额外邮件，邮件内容主要介绍了魅族科技、笔戈科技、还有简单的个人简介，还扔了一大堆文献资料要我去阅读。最后还不忘布置一个家庭作业：一份关于我自身的全面社交账号列表，以及详细的自我简介，以及我未来想要做的事情。</p>\n<p>从邮件的文字中，能深刻的感受盖文张对于每个成员负责的态度。<br>那时候我很高兴，能和一位如此有亲和力和有想法的人工作，那是多么幸运的事情。</p>\n<p>所以，尽然我语文作文能力低弱，也是使劲的憋出了一篇2000字的感想。</p>\n<h1 id=\"笔戈科技\"><a href=\"#笔戈科技\" class=\"headerlink\" title=\"笔戈科技\"></a>笔戈科技</h1><p>我记得第一次踏入魅族科技楼的一瞬间，看到一楼大厅的装横的那份感动。<br>就像那时候魅族设计出来的手机一样，那么的简洁，那么的灵动。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/0918068D666624C5EC2CDCFB650FBEC9.jpg\" alt=\"魅族一楼大厅\"></p>\n<p>我在笔戈科技，所属于 Web 开发组，组内只有老大一个 NodeJS 开发，再加上包括我在内的三个前端实习生。<br>老大跟我说，你看这么多前端实习生，本来不打算再招前端实习生了，但是看到你以前做的项目蛮多的，就破例了。这句话，让我心里偷偷窃喜了好一段时间。</p>\n<p>当时我们组主要是负责笔戈博客项目，以及一些营销导向型的短期项目。<br>笔戈博客是在 Ghost 的基础上构建的，修修补补源代码，加上了一些业务性的定制功能。<br>我记得那时候看 Ghost 的源码，因为不懂 Promise ，看的非常吃力。<br>Ghost 的前端部分使用的是 EmberJS，在2014年前端的 MVC 框架比较流行的是 AngularJS、EmberJS、BackboneJS。<br>构建项目的用的是 Grunt，CSS 部分的 sass、less 在当年也已经开始普及起来。<br>对于我一个只懂 jQuery、BootStrap 、以及前端三项基本功的实习生，掌握前端工程化技术是一项让人充满新鲜感与兴奋的挑战。</p>\n<p>当时技术团队的人员配置很不平衡，一个后端对应三个前端，所以后端的工作强度很大，前端反而显得清闲。<br>不出半个月，一个午饭时分，老大跟我说：「你不是会 NodeJS 吗，要不尝试转后端？」<br>我思考了很久，大学立下的职业规划是成为一名出色的前端工程师。<br>但是要做好前端，首先是成为一名合格的软件工程师。我觉得是一次机会，所以就答应了，后面的两年的时间，工作上就绝大部分从事着后端开发。<br>随后我也感激我当时的选择，后端的工作能让我从不同的角度来了解软件开发。<br>在我转型不久，很快又来了一位 NodeJS 实习生。从现在来看，他也是我们组最后的一位实习生。</p>\n<p>在笔戈科技，虽然有不同的职能组，但是那时候人还少，不同职能的大家都可以混在一起，而且管理上也十分的扁平化。我们使用很多优秀的工具来进行团队合作，例如 Teambition、Google Docs，还统一购买科学上网服务。</p>\n<p>就像我在入职前写给盖文张对于笔戈的看法所描述的，笔戈科技就像魅族的一个特种部队，效率和敏捷性都很高。</p>\n<h1 id=\"笔戈玩\"><a href=\"#笔戈玩\" class=\"headerlink\" title=\"笔戈玩\"></a>笔戈玩</h1><p>在入职直到 2014 年末之前，我都一直做着一些琐碎的事情，笔戈博客的维护，以及一些营销导向性的短期项目，就像内部的一个外包技术团队。<br>我想，如果那时候没有魅玩帮的立项，估计我半年之后就不会在魅族了。</p>\n<p>就趋近于年末的时候，盖文张召集我们技术组开会，谈论一个新项目的想法。<br>要做一个魅族旗下推广型的平台，推广方向就是我们所从事的「智能硬件」方向。<br>这时候，一个智能硬件试玩网站的雏形诞生了，叫「笔戈玩」。</p>\n<p>项目立项了，就要撸起袖子开始干了。<br>团队的主要技术栈是 NodeJS，我们需要一个能快速搭建项目的 NodeJS 企业级开发框架。<br>我们对比了 Meteor、Strongloop、SailsJS，最后被 SailsJS 清晰的 MVC 分层所吸引，选择了 SailsJS 框架来开发。当然，框架的功能性，扩展性，和社区活跃度都是需要被考虑的，记得当年我写了一篇 <a href=\"http://huang-jerryc.com/2015/04/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Sails/\">《为什么使用 SailsJS》</a>，现在看回去，有不少的东西可以补充。</p>\n<p>就这样，一个老大带着四个实习生，三个 NodeJS，两个前端，从项目分析、概要设计、详细设计、数据库设计、再到编码实现，在农历年之前完成了「笔戈玩」的第一版本。<br>年后，由于之前对框架的不熟悉，导致产出的代码欠佳，然后重新推翻，再次重构。<br>又一个月的时间，发布了第一个内部测试版本。<br>经过一段时间的测试、修复、运营准备，终于在 2015 年 5 月 21 日，「笔戈玩」正式上线。</p>\n<h1 id=\"简书-——-笔戈-Web-Team\"><a href=\"#简书-——-笔戈-Web-Team\" class=\"headerlink\" title=\"简书 —— 笔戈 Web Team\"></a>简书 —— 笔戈 Web Team</h1><p>在「笔戈玩」第一版本上线之后，我也迎来了我的毕业。</p>\n<p>盖文张是很注重团队成员自身发展的，他也很鼓励我们多看书多涉猎，也建立了读书经费。<br>在我们办公室的角落，就有一个小小的书柜，都放满了大家要求买的书。<br>除了看书，多写作也是被鼓励的。<br>笔戈博客是我们部门的业余产出，写作就像笔戈不成形的团队文化，当时就在全部门内推行了这样的制度：每人每月定额产出文章，产出不奖励，不产出要罚钱。<br>产出的文章，经过筛选，会发表在笔戈博客。<br>我们写代码的人要求低一点，一个月一篇，写不出要罚 100 块，罚的钱，用来补贴部门经费。<br>我那时候的实习工资 2000 加上补贴，一个月不缺勤到手也就 2700。罚 100 块，是多么痛心的事情。<br>所以我们憋也要憋出来几个字。</p>\n<p>如果我们写一些技术类的，倒是没那么痛苦。<br>可偏偏那时候我们技术老大说，尽量不要写技术类的。理由是笔戈博客的读者并不是技术向的。<br>其实对于我们这群纯理科生，是有点为难的。<br>我在笔戈的第一篇文章，是使劲憋出来的：<a href=\"http://huang-jerryc.com/2015/03/03/%E7%9B%98%E7%82%B9%E5%9B%BD%E5%86%85%E7%9A%84%E9%82%A3%E4%BA%9BROM/\">《盘点国内的那些ROM》</a></p>\n<p>之后我就在思考，有什么办法可以发挥我们的所长，并且符合这个制度。<br>我的想法是，我们团队应该是作为一个技术团队的名义来抛头露面，我们的产出可以是纯技术导向，我们把内容聚合起来，作为一个专题，或一个频道，或者其他什么样的形式。</p>\n<p>正好笔戈当时也在简书上面发表文章，以增加曝光度。<br>我就回学校毕业之前，给盖文张发了一封邮件，把我对团队文化建设的构思路描述了一遍。<br>大概就是先从简书开始，建立一个「笔戈 Web Team」的专题，以笔戈的名义为依托，来给我们技术人提供练笔和展示的地方。<br>因为简书并不是纯粹的技术社区，受众并不多，我们可以肆无忌惮的写一点东西，而不怕被人鄙视水平不够。<br>待我们的水平和产出上来了，考虑转移更纯粹的技术社区，或者建立团队的技术博客。<br>我举例了 AlloyTeam，Taobao FED 这些大厂出名的博客。<br>同时还说明了这样做的好处，一是写作会逼迫我们思考和总结，对我们技术水平提升有明显的作用。二是可以打响名声，提高成员自豪感，提升凝聚力，同时也有助于招聘。</p>\n<p>盖文张很快回复了邮件，他赞同这样的做法，另外给了我笔戈科技在简书的账号密码，让我来创建这个专题。<br>同时，我也把这个想法跟技术老大说。我们老大是很进步向的，也很赞成这样的做法。</p>\n<p>自此，我们开始以团队的名义进行技术文章的产出，一点一点的积累和提升。<br>截止现在，尽管我们已经转移产出的场地，但是简书上面的 「<a href=\"http://www.jianshu.com/c/2a4335808d4c\">笔戈 Web Team</a>」，已经有103篇文章。</p>\n<h1 id=\"第一次出省\"><a href=\"#第一次出省\" class=\"headerlink\" title=\"第一次出省\"></a>第一次出省</h1><p>从大学毕业之后，我和魅族签订了我人生的第一份劳动合同。正式成为了魅族的员工，虽然之前实习的日子都是被当做正式员工来用。但是不同的是，我终于可以领着符合水平的薪水了。</p>\n<p>毕业回来正好碰上了 MX5 的发布会，公司需要征集员工志愿者，我就应征了。<br>于是乎，人生第一次出差，也是这个稚嫩的广东人的第一次出省。</p>\n<p>我们订的是动卧票，晚上从广州出发， 第二天就能到北京。<br>看着地图的定位慢慢的越过广东的边界，心头涌上莫名的一股激动。<br>记得那天晚上，躺在摇晃的车厢中，闭上眼，脑海晃出了很多画面，一场星际旅行。</p>\n<p>然后，打开当时很流行的「足记」，写下了一些胡思乱想。<br>现在看回去，自己还真像个小孩。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/6AB4BEF134889910000956F9ECF6A7F7.jpg\" alt=\"出省\"></p>\n<p>同行的还有几个要好的同事，我们是提前一天到达的。<br>在空闲的时间，我们相约去了北京的「798艺术区」。<br>我想，每一个来到这里的年轻人，都会爱上这里弥漫着创意以及艺术气息的空气。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/9B43630C96E81A487603CEBC8EAE4A7C.jpg\" alt=\"798艺术区\"></p>\n<h1 id=\"第一次出国\"><a href=\"#第一次出国\" class=\"headerlink\" title=\"第一次出国\"></a>第一次出国</h1><p>在北京回来之后，正好碰上公司的年度旅游。<br>听一些老员工说「今年开始才有旅游经费的，你碰到好时候了」，比较遗憾的是，那也是唯一一年有旅游经费的。<br>公司的旅游经费只够短距离玩个三四天左右，以自行组织报销的形式，然后部门的一些土豪君给出一种方案，就是自己多掏腰包，然后一起去泰国玩一转。<br>听到这方案，心里埋藏已久的射手座的心，再出跳出来作祟。<br>花光了一年实习的积蓄，跟着土豪同事们去泰国了，那也是我第一次踏出中国的大陆。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/B4225EC487B6365A0E8AB811C601B67F.jpg\" alt=\"泰旅\"><br><img src=\"/image/blog/the-winter-and-summer-of-Meizu/139D3521EE1F173F438595B46FBB3730.jpg\" alt=\"泰旅\"></p>\n<h1 id=\"魅玩帮\"><a href=\"#魅玩帮\" class=\"headerlink\" title=\"魅玩帮\"></a>魅玩帮</h1><p>2015 年 9 月，「笔戈玩」更名「魅玩帮」，明确定位「魅族旗下新品分享平台」，由新的总监接手这个项目，帮团队理了至关重要的一件事：产品要和魅族价值挂钩。</p>\n<p>Web 开发组，自然而然也就划分到新总监门下。<br>这时候我们小组已经从当初的 5 人小团队，增加到 11 人了，<br>继我们组最后一个实习生之后， 又来了一个测试妹子，后来转运维去了。<br>然后，又来了一个 NodeJS 的后端，除了帅人品还很好。<br>然后，又来了一个测试妹子，爱吃爱玩，还会卖萌，我经常说：「你要是瘦了肯定是个美女」。<br>同时间来的还有一个香港硕士生，做前端开发，人帅，逼格比我还高。<br>再后来，又来了一个 JAVA 的后端，也是硕士毕业，基础很赞，人很接地气。<br>最后，再来了一个项目经理。<br>再加上原来项目整合分配到的一位御用设计师，和一位会卖萌的产品经理。<br>于是乎，「魅玩帮」团队，从一个实习生团队，慢慢的增长到一个成型的小团队，配置到位。<br>卖萌产经经常说，她遇到一群聪明的人。</p>\n<p>项目重定位之后的一系列工作就是接入魅族用户中心，魅族论坛，Flyme 论坛。<br>这涉及到跨部门之间的合作，由于技术上是由我一直跟对方沟通的。<br>后来，老大跟我说：「你参与的比较多，由你来主导这次开发吧」，喜出望外。<br>随后被打了鸡血一样，事无巨细，从设计、文档、技术方案给理了清楚，再加上一群很棒的伙伴，功能很快就做完了。</p>\n<p>随着「魅玩帮」的用户量上升，产品想要一个「消息提醒」的功能。之前的工作给老大留下了不错的印象，这个任务就被分给我了。<br>消息系统的开发，也是我觉得工作内做的比较有条理性的工作之一。<br>经常性，产品想要一个东西，但是并不能完全的描述这个东西的细节，消息提醒也是一样。<br>开发需要做的是，帮忙缕清整个东西的逻辑和业务，我首先是分析业内的一些成型的产品，例如知乎、简书的消息提醒功能。<br>通过分析，抽象本质，整理业务功能，写出大概的功能设计，以及实现思路，然后再开会沟通。<br>经过多次沟通和修改，然后编码实现。<br>那时候明白了一个道理，一项功能或者一个项目，最费时间和精力的是在前期的沟通和设计上面，编码实现在一个熟练的开发者手上，反而是最简单的事情。<br>最后内部整理文档，外部输出思路：<a href=\"http://huang-jerryc.com/2015/10/14/%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8C%E4%B8%8A%E7%AF%87%E3%80%8D/\">《消息系统设计与实现》</a></p>\n<h1 id=\"优秀员工\"><a href=\"#优秀员工\" class=\"headerlink\" title=\"优秀员工\"></a>优秀员工</h1><p>很快，2015 年过去了。<br>部门年会在一家酒店吃年夜饭，那是难忘的一天。<br>那一天，收到了一个肯定，「优秀员工奖」。<br>是我们技术老大帮忙提名的，记得他年末跟我谈话的时候说的一句：「你是进步最快的，比其他人更靠谱些」。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/6A0335C2EA04E1BFC3398B4C31132522.jpg\" alt=\"优秀员工奖\"></p>\n<h1 id=\"Segmentfault-——-魅族科技开发团队\"><a href=\"#Segmentfault-——-魅族科技开发团队\" class=\"headerlink\" title=\"Segmentfault —— 魅族科技开发团队\"></a>Segmentfault —— 魅族科技开发团队</h1><p>年后，经过半年的时间，我们组对于技术的积累，以及文笔的熟练度，有了一定的提升。<br>于是乎，我们开始考虑换一个输出文章的地方。<br>当时我的想法是，建立一个我们独立的博客站点，但我的只能算作提议，最终还是技术 leader 以他认可的方式行动了：在 Segmentfault 以团队的名义来输出内容。<br>于是，我们在 SF 建立了专题：「<a href=\"https://segmentfault.com/blog/meizu\">魅族科技开发团队</a>」。<br>现在回想起来，这的确是一个明智之举，借助更垂直化的社区，可以给我们带来更多的关注量，和曝光度。当时魅族内部，还没有以团队名义来对外输出内容，我们做了，而且还做得不错。<br>同时，以团队为的姿势，也得到了 SF 社区的欢迎。</p>\n<p>还记得，曾经连续两个季度入选 Top Writer 之后，均收到社区寄过来的小礼物和卡片，那份激动的心情。<br>以前也混过想 CNodeJS，V2EX，CSDN 之类的技术社区，但是从来没有遇到一个这么认真的技术社区。能感觉得到 SF 社区的那颗真诚在做社区的心。</p>\n<p>我经常说，程序员就像中欧的骑士一样， Fight For Honor。<br>如果 SF 捉到了这一点，就可以留住更多的优秀产出者，就会吸引更多学习者，然后再反过来哺乳社区，形成一个良性循环。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/029BC994FC1C0E81AD1E54CA2A868A90.jpg\" alt=\"SF Top Writer\"></p>\n<h1 id=\"凌晨六点的东岸牌坊\"><a href=\"#凌晨六点的东岸牌坊\" class=\"headerlink\" title=\"凌晨六点的东岸牌坊\"></a>凌晨六点的东岸牌坊</h1><p>2016 年 3 月份，我接到了一个很酷的工作。<br>公司预定在 4 月 6 日开一场魅蓝新品发布会，而在发布会之前的预热活动，想搞一个抽奖，送特斯拉。<br>我们 Web 组提供技术支持，设计以及策划的工作由市场部的其他部门协作完成。<br>整个项目工期很赶，我们基本实行了临时的 996，加班加点赶工期，那时候很充实。</p>\n<p>就在 3 月 23 日上午，我们上线了「406魅蓝发布会」的项目。<br>上线的前一天晚上大家通宵战到天亮，我们下班打卡的时候，已经连续工作了 29 个小时。</p>\n<p>项目上线的前几个小时，太阳刚从东边升起，我们眼睁睁的看着漆黑的夜，渐渐地明亮起来。<br>珠海的三四月正是潮湿天气，空气中充满了水分子，初升的阳光很弱，还没有足够的能量消散这一层薄雾。<br>走到办公室的窗前，一副迷人朦胧的景色映入眼帘。<br>这是，凌晨 6 点钟的东岸牌坊。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/EABF83CE3EB684F88BD7A55480188FF9.jpg\" alt=\"东岸牌坊\"></p>\n<p>因为公司动用了大部分的传播渠道来推广这个网站，当天的日 PV 突破 100W，让我激动了很久。<br>整个项目我负责的不单单只是后端功能的开发，还需要在整个项目上把握进度，那时候能感觉到老大有放权给我们的意思，虽然没有明说。<br>这让我们在项目上，进度上，站在更加有责任感的位置思考问题。<br>技术上比较简单，前端页面提供几个 HTML 页面，服务器使用了阿里云，以及阿里云提供的 MySQL 。<br>在单元测试上我比较重视，覆盖率 100%。<br>安全性方面，使用了极验的验证码，绝大程度上避免了恶意的刷码行为。<br>这一次的项目，让我在做一个高并发、高性能、高稳定、响应速度高要求的项目有了更多的经验。</p>\n<h1 id=\"危机感\"><a href=\"#危机感\" class=\"headerlink\" title=\"危机感\"></a>危机感</h1><p>本来一切都是很顺利，团队氛围很好，也很有干劲。<br>加上之前的顺风顺水，我曾以为我能在公司干出一番成绩和事业。<br>然而开始有了一些不好的变化，4 月份公司发生了一些不开心的事，于是乎，奇怪的味道慢慢蔓延开来，从最初的难以察觉到后面越发刺鼻。<br>4 月，也正值跳槽旺季，我收到了几个猎头和一些公司的邀请。<br>由于一个意外，老大知道了，就在这个大家嗅觉都特别敏感的时期。<br>然后被约去喝咖啡了，我也正好把我所思所虑表达清楚。<br>我们老大是一个平易近人，也很能理解下属的 leader。<br>我说，魅玩帮 2.0 在即，我还可以提供一些推动力，最起码 2016 年还会留着，干完该干的事情。<br>我这样说是给老大承诺，也给自己定心，我知道坚持的美。<br>其实那时候，尽然有对薪资的不满意，但是对团队的感情，以及产品的感情更胜于此。<br>噢，不舍的还有珠海安逸的生活。<br>没有人不在意钱，我也在意。<br>而大多数人赚钱，也是为了让生活更美好。<br>但是如果一旦你的生活跟一家公司强关联起来，就没法确保你安逸的生活哪一天不会被毁掉。<br>同时，你的决定和行动也会受到更加多因素的影响和束缚。</p>\n<p>无论怎么样，终究，我的危机感变得比以往更加强烈。</p>\n<h1 id=\"魅玩帮-2-0\"><a href=\"#魅玩帮-2-0\" class=\"headerlink\" title=\"魅玩帮 2.0\"></a>魅玩帮 2.0</h1><p>魅玩帮尝试了最后一个转型，从「试玩」为主转向「内容输出」为主。<br>于是，魅玩帮走向了 2.0。<br>2.0 的功能点很多，需求也很多。<br>但是对于我来说，技术上早已经轻车熟路，所以问题不大。<br>大多都是业务，逻辑，API。<br>值得写的东西也不多。</p>\n<h1 id=\"西山日薄的魅玩帮\"><a href=\"#西山日薄的魅玩帮\" class=\"headerlink\" title=\"西山日薄的魅玩帮\"></a>西山日薄的魅玩帮</h1><p>经过两年的时间，魅玩帮的模式也玩的差不多了，功能也越发趋于完善，产品也越来越成熟。<br>但是，我也渐渐地明白，魅玩帮的模式，有一个致命的弱点，没有直接的盈利模式。<br>它的影响力，是附属在魅族品牌下的，只能是营销上的一个辅助性工具，就算我们技术上把项目做得再精，再出色。<br>没有发现盈利点，就没能够在内部提高我们的不可割舍性，最直接的影响也就是我们的待遇和福利。<br>我们没有给公司创造收入，那么我们的工资就像是在烧钱。（实际上，我们内部接的营销项目，也是间接帮公司省掉外包的支出）<br>在年末，上层决定要把「魅玩帮」并入到「魅族社区」，我渐渐的意识到我们做了两年多的产品已经西山日薄了。</p>\n<p>我也发现，这时候离开，是对团队的影响最小的时候。</p>\n<h1 id=\"成长\"><a href=\"#成长\" class=\"headerlink\" title=\"成长\"></a>成长</h1><p>从大学实习开始，直到毕业之后的一年半，已经在魅族度过了两年零三个月。<br>在这里经历过很多的第一次，也认识了很棒很聪明的朋友和同事，从他们身上看到，也学到了很多东西。<br>在这里，我的生活和工作是融合在一起的，但却没有一丝的违和感，融合的那么自然，有机。<br>团队的大家除了是同事，还是一群好朋友，好基友。<br>而技术老大，两年了，也像师傅一样，从最初的手把手教，到后面的信任，放手。<br>慢慢的，忽然意识到，是时候出师了。</p>\n<p>在这里锻炼的不单单只有技术，<br>还有做人、做事的道理，<br>还有职场上处事的道理，<br>还有眼界和认识，<br>还有思维方式，思考方法<br>等等……</p>\n<p>是的，感谢魅族。<br>今天，我毕业了，从魅族。</p>\n<h1 id=\"夏天\"><a href=\"#夏天\" class=\"headerlink\" title=\"夏天\"></a>夏天</h1><p>魅族，诞生在一个南方的海滨城市——珠海。<br>这里一年中似乎只有夏天与冬天，秋天和春天短到以至于你感觉不到他们来过。<br>魅族科技楼的前面，立着一颗树。<br>我依然清晰的记得，那一年，我来的时候，它满载绿油油的叶子。<br>在阳光下，温暖且湿润的风吹过，叶子唰唰的响，切出无数缕光束，打到我的脸上。</p>\n<p><img src=\"/image/blog/the-winter-and-summer-of-Meizu/7B794993F312F1BD9EB15917B658E9FE.jpg\" alt=\"夏天\"></p>\n"},{"title":"为什么使用Sails","date":"2015-04-25T08:35:04.000Z","_content":"\n## 前言\n入手Node.js半年，从用Express开发自己的博客到用Sails开发公司项目，深深被Sails震撼了。Sails是Balderdash团队的产品，快速的项目构建、优秀的框架结构还有众多的扩展，让我有种相见恨晚的感觉。在Koa流行之前，个人认为Sails的用户量还是挺可观的。今天，我想写一写Sails那些让我感动的地方，顺便理顺一下Sails的架构。\n\n#### 目录\n\n> * 一步搭建项目\n> * 项目架构\n> * ORM\n> * MVC的实现\n> * 路由\n> * 安全\n> * 日志\n> * 单元测试\n> * WebSocket\n\n## 一步搭建项目\n> 在安装了Node.js 和 Sails的环境下，只需要一条命令，就能够搭建一个拥有完整架构的项目，尽管这很简单，我还是觉得有必要说一下。\n\n在已经安装了Node.js和npm的前提下，首先你需要全局下安装Sails\n`$ sudo npm install sails -g`\n\n其次在一个空路径下，新建一个项目\n`$ sails new newApp`\n\n最后，只需要前往项目路径，把项目运行起来\n`$ cd testProject`\n`$ sails lift`\n\n访问 `http://localhost:1337`就能看到一个新的项目\n\n![new app](http://xia-dev.b0.upaiyun.com/64f9a65d-294f-43e6-984a-77dc2818ecc4.png)\n\n## 项目架构\n```\n.\n├── api\n│   ├── controllers\n│   ├── models\n│   ├── policies\n│   ├── responses\n│   └── services\n├── views\n├── assets\n├── config\n├── tasks\n├── node_modules\n├── package.json\n├── Gruntfile.js\n├── README.md\n└── app.js\n```\n\n### `api/`\n`api` 目录下是你要构建应用的核心所在，常说的MVC的设计结构就体现在这里\n`api/controllers` ：控制层，该层是Http请求的入口。Sails官方建议该层只处理请求的转发和页面的渲染，具体的逻辑实现应该交给Service层。\n`api/models`：模型层，在Sails中，对于Model采用的是充血模型，除了可以在模型中定于属性之外，还可以定义包含逻辑处理的函数。在Sails中，所有Model都可以全局性访问。\n`api/policies`：过滤层，该层在Controller层之前对Http请求做处理，在这一层中，可以定于一些规则来过滤Http请求，比如身份认证什么的。\n`api/responses`：http响应的方法都放这里，例如服务器错误、请求错误、404错误等，定义在responses文件夹里面的方法，都会赋值到controller层的req对象中。\n`api/services`：服务层，该层包含逻辑处理的方法，在Sails中，所有Service都可以全局性访问。\n\n### `views/`\n视图层，存放视图模版文件的地方，Sails默认是提供ejs模版引擎的，如果你愿意，你可以换成jade、handlebars或者任何你喜欢的模版引擎。\n\n### `assets/`\n资源文件夹，在Sails启动的时候，会启动某一个Grunt任务，把assets文件夹里的内容或压缩或编译或复制到根目录下的`.tmp`目录，这是前端可以直接通过路由访问的资源，HTML、JS、CSS以及图片等静态资源都放在这里了。\n\n### `config/`\n配置文件夹，在Sails启动的时候，会加载该文件夹里的文件，并赋值在全局对象`sails.config`中，所以能够在任何一个地方都能用到。在用Sails开发，会经常跟这个文件夹里的文件打交道，从config的构成很容易知道Sails都提供哪方面的功能。\n\n### `tasks/`\nSails自带的项目自动化工具是`Grunt`，而Grunt的配置和任务注册都放在这个文件夹里了。这里已经提供了通常会用到的CSS编译、JS压缩、文件合并，更改检测等等任务，当然如果没有自己需要的，还能扩展。\n\n### `app.js`\nSails的启动文件，无论是`$ sails lift`命令或者`$ npm start`命令都会运行该文件。\n\n## ORM\n开发了Sails的团队Balderdash，还开发了一套ORM框架：Waterline。    \nWaterline在Sails主要的舞台是在`/api/models`目录里，在这里定义的模型文件，在Sails启动的时候，都要经由Waterline的洗礼。    \nWaterline 是通过Adapter关联数据库的，不同的Adapter关联不同的数据库。    \nWaterline 能适配绝对部分数据库，大致分类两类，一类是官方团队开发的 Adapter适配的，一类是民间开发者开发的Adapter适配的：    \n官方支持的:    \n* PostgreSQL    \n* MySQL    \n* MongoDB    \n* Redis    \n* Disk    \n* Memory    \n\n民间开发的：    \n* SQLServer    \n* OrientDB  \n* Oracle    \n* Cassandra    \n\n关于Waterline的更多信息可以关注：    \n[github:waterline](https://github.com/balderdashy/waterline)    \n[github:waterline-docs](https://github.com/balderdashy/waterline)\n\n## MVC的实现\n在这一段我想不仅仅要谈论到Model层、View层和Controller层，我认为还有必要谈到Service层、和Policy层。\n\n##### Model层\n模型文件定义到`/api/models`中，由Waterline驱动，所有model都能全局访问。Sails提供命令行创建model的命令：`$ sails generate model MODEL_NAME`\n##### View层\n实现在`/views`中，除了默认提供的ejs模版引擎之外，还能更换成jade、handlebars等模版引擎\n##### Controller层\n在`/api/controller`目录里，Sails中提供创建controller的命令：`$ sails generate controller CONTROLLER_NAME`。Sails也提供同时创建model和对应的Controller的命令：`$ sails generate api API_NAME`。\n##### Service层\n在`/api/services`目录里，存放自定义的服务，所有service都能够全局访问，Sails官方的建议是把逻辑处理都放在该层中，Controller层只做路由的分发和轻逻辑的处理。\n##### Policy层\n在`/api/policies`目录里，存放自定义的过滤器。该层是一条请求在到达Controller之前根据需求过滤请求的中间层。在`/api/policies`目录中定义的文件，还需要在`config/policies.js`文件中为需求应用到某一过滤器的Action配置。\n\n\n## 路由\nSails中要理解路由，首先要记得这个名词`blueprint`，中文翻译为：蓝图。我不知道官方是否解释过为什么要用个单词，但以我的理解，Sails的blueprint是负责指挥每一条客户端请求应该分配到服务器端的哪个Action去，所以叫蓝图吧。\nblueprint主要分为三种：`RESTful routes`、`Shortcut routes`、`Action routes`。\n\n##### RESTful routes\n当路径诸如：`/:modelIdentity` 或者 `/:modelIdentity/:id`的时候，blueprint会根据HTTP的动作（GET、POST、DELETE、PUT等）来分配到相应的Controller下相应的Action来处理。例如一个POST请求`/user`会创建一个用户，一个DELETE请求`/user/123`会删除`id`为123的用户。\n\n##### Shortcut routes\n这种路由主要是方便开发，请求的参数可以直接写在请求路径中，例如`/user/create?name=joe`会创建一个新的用户，`/user/update/1?name=mike`会更新`id`为1的用户的名字。shortcut routes在开发环境很便利，但是在生产环境下需要关闭。\n\n##### Action routes\n这种路由会自动的为Controller层的每一个Action创建一个路由，例如你的Controller层有一个`FooController.js`，里面有一个Action`bar`，那么请求`/foo/bar`就会分配到`bar`Action。\n\n当然Sails也会提供自定义的路由，用户可以在`config/routes.js`和`config/polices.js`这两个配置文件中选择关闭或者打开blueprint提供的路由，和定义自己的路由。\n\n## 安全\n要确保产品的安全性，要对几种常见的攻击和安全策略了如指掌，诸如CORS、CSRF、DDOS、XSS等。Sails对于常见的安全策略都有提供支持，且只需要通过相关的配置文件就可以控制安全策略的等级。深入探讨Web的安全策略，并不在本文的范畴内，日后我会以这个为题写一篇文章聊聊Web的安全。\n想要了解更多Sails的安全策略可以看看这里：[sails: security](http://sailsjs.org/#!/documentation/concepts/Security)\n## 日志\nSails提供了一个全局对象`sails.log`用来处理日志信息的输出，日志是分level的，在`config/log.js`中配置日志输出的level，而level的作用看下表：\n\n| Priority              | level                  | Log fns visible |\n| :------------- |:-------------:| :-----:|\n| 0\t|silent\t|N/A |\n|1\t|error\t|.error()|\n|2\t|warn\t|.warn(), .error()|\n|3\t|debug\t|.debug(), .warn(), .error()|\n|4\t|info         |.info(), .debug(), .warn(), .error()|\n|5\t|verbose\t|.verbose(), .info(), .debug(), .warn(), .error()|\n|6\t|silly\t        |.silly(), .verbose(), .info(), .debug(), .warn(), .error()|\n\nSails的日志管理默认是info层的，既会输出.info(), .debug(), .warn(), .error()的信息。\n\n## 单元测试\nSails使用了mocha进行单元测试，在新建Sails项目的时候，没有创建单元测试的文件夹，需要自己手动构造单元测试目录，官方建议的目录是这样的：\n\n```\n.\n├── api\n├── assets\n├── ...\n├── test\n│  ├── unit\n│  │  ├── controllers\n│  │  │  └── UsersController.test.js\n│  │  ├── models\n│  │  │  └── Users.test.js\n│  │  └── ...\n│  ├── fixtures\n│  ├── ...\n│  ├── bootstrap.test.js\n│  └── mocha.opts\n└── views\n```\n而我在单元测试常用的组合是：[mocha](https://github.com/mochajs/mocha)、[should](https://github.com/tj/should.js)、[supertest](https://github.com/visionmedia/supertest)、 [istanbul](https://github.com/gotwarlost/istanbul) \n其中should是提供断言，supertest是用于测试Controller层的时候伪造http请求的，而istanbul则是提供测试代码覆盖率的。\n关于怎么在Sails中编写测试代码，可以参考 [sails:testing](http://sailsjs.org/#!/documentation/concepts/Testing)\n\n## WebSocket\n对于有即时性通讯需求的Web应用，我们会用Socket，Sails也为这方面提供了支持。在客户端提供js文件：`sails.io.js`，而在服务器端提供全局对象：`sails.sockets`。通过这两个对象，就可以进行客户端和服务器端即时性通讯的开发了。\nSails默认会启动WebSocket功能，在客户端访问服务器端的时候，会自动尝试在同域名下连接socket。\n值得注意的是，这样会对AngularJS、EmberJS等前端MVVC开发产生一些障碍。\n比如进行AngularJS开发的时候，我们在`http://localhost:9000`跑AngularJS项目，而服务器端却跑在`http://localhost:1337`。\n当访问`http://localhost:9000`的时候，`sails.io.js`会尝试于当前路径下进行socket连接，也就是`http://localhost:9000`，这时会出错，因为服务器是跑在`http://localhost:1337`的。\n在开发的时候要解决这样的问题的时候，我们只需要在AngularJS这边引入`sails.io.js`之后定义连接路径就行了：\n\n``` javascript\n<script src=\"scripts/lib/sails.io.js\"></script>\n<script>io.sails.url = \"http://localhost:1337\";</script>\n```\n\n## 结语\n可以说Sails涵盖了Web开发中会遇到的绝大部分需求和问题，如果深入研究Sails的话，是受益匪浅的。\n\n","source":"_posts/为什么使用Sails.md","raw":"---\ntitle: 为什么使用Sails\ncategory: 搬砖码农\ndate: 2015-04-25 16:35:04\ntags: \n- SailsJS\n- Nodejs\n---\n\n## 前言\n入手Node.js半年，从用Express开发自己的博客到用Sails开发公司项目，深深被Sails震撼了。Sails是Balderdash团队的产品，快速的项目构建、优秀的框架结构还有众多的扩展，让我有种相见恨晚的感觉。在Koa流行之前，个人认为Sails的用户量还是挺可观的。今天，我想写一写Sails那些让我感动的地方，顺便理顺一下Sails的架构。\n\n#### 目录\n\n> * 一步搭建项目\n> * 项目架构\n> * ORM\n> * MVC的实现\n> * 路由\n> * 安全\n> * 日志\n> * 单元测试\n> * WebSocket\n\n## 一步搭建项目\n> 在安装了Node.js 和 Sails的环境下，只需要一条命令，就能够搭建一个拥有完整架构的项目，尽管这很简单，我还是觉得有必要说一下。\n\n在已经安装了Node.js和npm的前提下，首先你需要全局下安装Sails\n`$ sudo npm install sails -g`\n\n其次在一个空路径下，新建一个项目\n`$ sails new newApp`\n\n最后，只需要前往项目路径，把项目运行起来\n`$ cd testProject`\n`$ sails lift`\n\n访问 `http://localhost:1337`就能看到一个新的项目\n\n![new app](http://xia-dev.b0.upaiyun.com/64f9a65d-294f-43e6-984a-77dc2818ecc4.png)\n\n## 项目架构\n```\n.\n├── api\n│   ├── controllers\n│   ├── models\n│   ├── policies\n│   ├── responses\n│   └── services\n├── views\n├── assets\n├── config\n├── tasks\n├── node_modules\n├── package.json\n├── Gruntfile.js\n├── README.md\n└── app.js\n```\n\n### `api/`\n`api` 目录下是你要构建应用的核心所在，常说的MVC的设计结构就体现在这里\n`api/controllers` ：控制层，该层是Http请求的入口。Sails官方建议该层只处理请求的转发和页面的渲染，具体的逻辑实现应该交给Service层。\n`api/models`：模型层，在Sails中，对于Model采用的是充血模型，除了可以在模型中定于属性之外，还可以定义包含逻辑处理的函数。在Sails中，所有Model都可以全局性访问。\n`api/policies`：过滤层，该层在Controller层之前对Http请求做处理，在这一层中，可以定于一些规则来过滤Http请求，比如身份认证什么的。\n`api/responses`：http响应的方法都放这里，例如服务器错误、请求错误、404错误等，定义在responses文件夹里面的方法，都会赋值到controller层的req对象中。\n`api/services`：服务层，该层包含逻辑处理的方法，在Sails中，所有Service都可以全局性访问。\n\n### `views/`\n视图层，存放视图模版文件的地方，Sails默认是提供ejs模版引擎的，如果你愿意，你可以换成jade、handlebars或者任何你喜欢的模版引擎。\n\n### `assets/`\n资源文件夹，在Sails启动的时候，会启动某一个Grunt任务，把assets文件夹里的内容或压缩或编译或复制到根目录下的`.tmp`目录，这是前端可以直接通过路由访问的资源，HTML、JS、CSS以及图片等静态资源都放在这里了。\n\n### `config/`\n配置文件夹，在Sails启动的时候，会加载该文件夹里的文件，并赋值在全局对象`sails.config`中，所以能够在任何一个地方都能用到。在用Sails开发，会经常跟这个文件夹里的文件打交道，从config的构成很容易知道Sails都提供哪方面的功能。\n\n### `tasks/`\nSails自带的项目自动化工具是`Grunt`，而Grunt的配置和任务注册都放在这个文件夹里了。这里已经提供了通常会用到的CSS编译、JS压缩、文件合并，更改检测等等任务，当然如果没有自己需要的，还能扩展。\n\n### `app.js`\nSails的启动文件，无论是`$ sails lift`命令或者`$ npm start`命令都会运行该文件。\n\n## ORM\n开发了Sails的团队Balderdash，还开发了一套ORM框架：Waterline。    \nWaterline在Sails主要的舞台是在`/api/models`目录里，在这里定义的模型文件，在Sails启动的时候，都要经由Waterline的洗礼。    \nWaterline 是通过Adapter关联数据库的，不同的Adapter关联不同的数据库。    \nWaterline 能适配绝对部分数据库，大致分类两类，一类是官方团队开发的 Adapter适配的，一类是民间开发者开发的Adapter适配的：    \n官方支持的:    \n* PostgreSQL    \n* MySQL    \n* MongoDB    \n* Redis    \n* Disk    \n* Memory    \n\n民间开发的：    \n* SQLServer    \n* OrientDB  \n* Oracle    \n* Cassandra    \n\n关于Waterline的更多信息可以关注：    \n[github:waterline](https://github.com/balderdashy/waterline)    \n[github:waterline-docs](https://github.com/balderdashy/waterline)\n\n## MVC的实现\n在这一段我想不仅仅要谈论到Model层、View层和Controller层，我认为还有必要谈到Service层、和Policy层。\n\n##### Model层\n模型文件定义到`/api/models`中，由Waterline驱动，所有model都能全局访问。Sails提供命令行创建model的命令：`$ sails generate model MODEL_NAME`\n##### View层\n实现在`/views`中，除了默认提供的ejs模版引擎之外，还能更换成jade、handlebars等模版引擎\n##### Controller层\n在`/api/controller`目录里，Sails中提供创建controller的命令：`$ sails generate controller CONTROLLER_NAME`。Sails也提供同时创建model和对应的Controller的命令：`$ sails generate api API_NAME`。\n##### Service层\n在`/api/services`目录里，存放自定义的服务，所有service都能够全局访问，Sails官方的建议是把逻辑处理都放在该层中，Controller层只做路由的分发和轻逻辑的处理。\n##### Policy层\n在`/api/policies`目录里，存放自定义的过滤器。该层是一条请求在到达Controller之前根据需求过滤请求的中间层。在`/api/policies`目录中定义的文件，还需要在`config/policies.js`文件中为需求应用到某一过滤器的Action配置。\n\n\n## 路由\nSails中要理解路由，首先要记得这个名词`blueprint`，中文翻译为：蓝图。我不知道官方是否解释过为什么要用个单词，但以我的理解，Sails的blueprint是负责指挥每一条客户端请求应该分配到服务器端的哪个Action去，所以叫蓝图吧。\nblueprint主要分为三种：`RESTful routes`、`Shortcut routes`、`Action routes`。\n\n##### RESTful routes\n当路径诸如：`/:modelIdentity` 或者 `/:modelIdentity/:id`的时候，blueprint会根据HTTP的动作（GET、POST、DELETE、PUT等）来分配到相应的Controller下相应的Action来处理。例如一个POST请求`/user`会创建一个用户，一个DELETE请求`/user/123`会删除`id`为123的用户。\n\n##### Shortcut routes\n这种路由主要是方便开发，请求的参数可以直接写在请求路径中，例如`/user/create?name=joe`会创建一个新的用户，`/user/update/1?name=mike`会更新`id`为1的用户的名字。shortcut routes在开发环境很便利，但是在生产环境下需要关闭。\n\n##### Action routes\n这种路由会自动的为Controller层的每一个Action创建一个路由，例如你的Controller层有一个`FooController.js`，里面有一个Action`bar`，那么请求`/foo/bar`就会分配到`bar`Action。\n\n当然Sails也会提供自定义的路由，用户可以在`config/routes.js`和`config/polices.js`这两个配置文件中选择关闭或者打开blueprint提供的路由，和定义自己的路由。\n\n## 安全\n要确保产品的安全性，要对几种常见的攻击和安全策略了如指掌，诸如CORS、CSRF、DDOS、XSS等。Sails对于常见的安全策略都有提供支持，且只需要通过相关的配置文件就可以控制安全策略的等级。深入探讨Web的安全策略，并不在本文的范畴内，日后我会以这个为题写一篇文章聊聊Web的安全。\n想要了解更多Sails的安全策略可以看看这里：[sails: security](http://sailsjs.org/#!/documentation/concepts/Security)\n## 日志\nSails提供了一个全局对象`sails.log`用来处理日志信息的输出，日志是分level的，在`config/log.js`中配置日志输出的level，而level的作用看下表：\n\n| Priority              | level                  | Log fns visible |\n| :------------- |:-------------:| :-----:|\n| 0\t|silent\t|N/A |\n|1\t|error\t|.error()|\n|2\t|warn\t|.warn(), .error()|\n|3\t|debug\t|.debug(), .warn(), .error()|\n|4\t|info         |.info(), .debug(), .warn(), .error()|\n|5\t|verbose\t|.verbose(), .info(), .debug(), .warn(), .error()|\n|6\t|silly\t        |.silly(), .verbose(), .info(), .debug(), .warn(), .error()|\n\nSails的日志管理默认是info层的，既会输出.info(), .debug(), .warn(), .error()的信息。\n\n## 单元测试\nSails使用了mocha进行单元测试，在新建Sails项目的时候，没有创建单元测试的文件夹，需要自己手动构造单元测试目录，官方建议的目录是这样的：\n\n```\n.\n├── api\n├── assets\n├── ...\n├── test\n│  ├── unit\n│  │  ├── controllers\n│  │  │  └── UsersController.test.js\n│  │  ├── models\n│  │  │  └── Users.test.js\n│  │  └── ...\n│  ├── fixtures\n│  ├── ...\n│  ├── bootstrap.test.js\n│  └── mocha.opts\n└── views\n```\n而我在单元测试常用的组合是：[mocha](https://github.com/mochajs/mocha)、[should](https://github.com/tj/should.js)、[supertest](https://github.com/visionmedia/supertest)、 [istanbul](https://github.com/gotwarlost/istanbul) \n其中should是提供断言，supertest是用于测试Controller层的时候伪造http请求的，而istanbul则是提供测试代码覆盖率的。\n关于怎么在Sails中编写测试代码，可以参考 [sails:testing](http://sailsjs.org/#!/documentation/concepts/Testing)\n\n## WebSocket\n对于有即时性通讯需求的Web应用，我们会用Socket，Sails也为这方面提供了支持。在客户端提供js文件：`sails.io.js`，而在服务器端提供全局对象：`sails.sockets`。通过这两个对象，就可以进行客户端和服务器端即时性通讯的开发了。\nSails默认会启动WebSocket功能，在客户端访问服务器端的时候，会自动尝试在同域名下连接socket。\n值得注意的是，这样会对AngularJS、EmberJS等前端MVVC开发产生一些障碍。\n比如进行AngularJS开发的时候，我们在`http://localhost:9000`跑AngularJS项目，而服务器端却跑在`http://localhost:1337`。\n当访问`http://localhost:9000`的时候，`sails.io.js`会尝试于当前路径下进行socket连接，也就是`http://localhost:9000`，这时会出错，因为服务器是跑在`http://localhost:1337`的。\n在开发的时候要解决这样的问题的时候，我们只需要在AngularJS这边引入`sails.io.js`之后定义连接路径就行了：\n\n``` javascript\n<script src=\"scripts/lib/sails.io.js\"></script>\n<script>io.sails.url = \"http://localhost:1337\";</script>\n```\n\n## 结语\n可以说Sails涵盖了Web开发中会遇到的绝大部分需求和问题，如果深入研究Sails的话，是受益匪浅的。\n\n","slug":"为什么使用Sails","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwq9001p15hlvl8zgw0h","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>入手Node.js半年，从用Express开发自己的博客到用Sails开发公司项目，深深被Sails震撼了。Sails是Balderdash团队的产品，快速的项目构建、优秀的框架结构还有众多的扩展，让我有种相见恨晚的感觉。在Koa流行之前，个人认为Sails的用户量还是挺可观的。今天，我想写一写Sails那些让我感动的地方，顺便理顺一下Sails的架构。</p>\n<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<ul>\n<li>一步搭建项目</li>\n<li>项目架构</li>\n<li>ORM</li>\n<li>MVC的实现</li>\n<li>路由</li>\n<li>安全</li>\n<li>日志</li>\n<li>单元测试</li>\n<li>WebSocket</li>\n</ul>\n</blockquote>\n<h2 id=\"一步搭建项目\"><a href=\"#一步搭建项目\" class=\"headerlink\" title=\"一步搭建项目\"></a>一步搭建项目</h2><blockquote>\n<p>在安装了Node.js 和 Sails的环境下，只需要一条命令，就能够搭建一个拥有完整架构的项目，尽管这很简单，我还是觉得有必要说一下。</p>\n</blockquote>\n<p>在已经安装了Node.js和npm的前提下，首先你需要全局下安装Sails<br><code>$ sudo npm install sails -g</code></p>\n<p>其次在一个空路径下，新建一个项目<br><code>$ sails new newApp</code></p>\n<p>最后，只需要前往项目路径，把项目运行起来<br><code>$ cd testProject</code><br><code>$ sails lift</code></p>\n<p>访问 <code>http://localhost:1337</code>就能看到一个新的项目</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/64f9a65d-294f-43e6-984a-77dc2818ecc4.png\" alt=\"new app\"></p>\n<h2 id=\"项目架构\"><a href=\"#项目架构\" class=\"headerlink\" title=\"项目架构\"></a>项目架构</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── api</div><div class=\"line\">│   ├── controllers</div><div class=\"line\">│   ├── models</div><div class=\"line\">│   ├── policies</div><div class=\"line\">│   ├── responses</div><div class=\"line\">│   └── services</div><div class=\"line\">├── views</div><div class=\"line\">├── assets</div><div class=\"line\">├── config</div><div class=\"line\">├── tasks</div><div class=\"line\">├── node_modules</div><div class=\"line\">├── package.json</div><div class=\"line\">├── Gruntfile.js</div><div class=\"line\">├── README.md</div><div class=\"line\">└── app.js</div></pre></td></tr></table></figure>\n<h3 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api/\"></a><code>api/</code></h3><p><code>api</code> 目录下是你要构建应用的核心所在，常说的MVC的设计结构就体现在这里<br><code>api/controllers</code> ：控制层，该层是Http请求的入口。Sails官方建议该层只处理请求的转发和页面的渲染，具体的逻辑实现应该交给Service层。<br><code>api/models</code>：模型层，在Sails中，对于Model采用的是充血模型，除了可以在模型中定于属性之外，还可以定义包含逻辑处理的函数。在Sails中，所有Model都可以全局性访问。<br><code>api/policies</code>：过滤层，该层在Controller层之前对Http请求做处理，在这一层中，可以定于一些规则来过滤Http请求，比如身份认证什么的。<br><code>api/responses</code>：http响应的方法都放这里，例如服务器错误、请求错误、404错误等，定义在responses文件夹里面的方法，都会赋值到controller层的req对象中。<br><code>api/services</code>：服务层，该层包含逻辑处理的方法，在Sails中，所有Service都可以全局性访问。</p>\n<h3 id=\"views\"><a href=\"#views\" class=\"headerlink\" title=\"views/\"></a><code>views/</code></h3><p>视图层，存放视图模版文件的地方，Sails默认是提供ejs模版引擎的，如果你愿意，你可以换成jade、handlebars或者任何你喜欢的模版引擎。</p>\n<h3 id=\"assets\"><a href=\"#assets\" class=\"headerlink\" title=\"assets/\"></a><code>assets/</code></h3><p>资源文件夹，在Sails启动的时候，会启动某一个Grunt任务，把assets文件夹里的内容或压缩或编译或复制到根目录下的<code>.tmp</code>目录，这是前端可以直接通过路由访问的资源，HTML、JS、CSS以及图片等静态资源都放在这里了。</p>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config/\"></a><code>config/</code></h3><p>配置文件夹，在Sails启动的时候，会加载该文件夹里的文件，并赋值在全局对象<code>sails.config</code>中，所以能够在任何一个地方都能用到。在用Sails开发，会经常跟这个文件夹里的文件打交道，从config的构成很容易知道Sails都提供哪方面的功能。</p>\n<h3 id=\"tasks\"><a href=\"#tasks\" class=\"headerlink\" title=\"tasks/\"></a><code>tasks/</code></h3><p>Sails自带的项目自动化工具是<code>Grunt</code>，而Grunt的配置和任务注册都放在这个文件夹里了。这里已经提供了通常会用到的CSS编译、JS压缩、文件合并，更改检测等等任务，当然如果没有自己需要的，还能扩展。</p>\n<h3 id=\"app-js\"><a href=\"#app-js\" class=\"headerlink\" title=\"app.js\"></a><code>app.js</code></h3><p>Sails的启动文件，无论是<code>$ sails lift</code>命令或者<code>$ npm start</code>命令都会运行该文件。</p>\n<h2 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a>ORM</h2><p>开发了Sails的团队Balderdash，还开发了一套ORM框架：Waterline。<br>Waterline在Sails主要的舞台是在<code>/api/models</code>目录里，在这里定义的模型文件，在Sails启动的时候，都要经由Waterline的洗礼。<br>Waterline 是通过Adapter关联数据库的，不同的Adapter关联不同的数据库。<br>Waterline 能适配绝对部分数据库，大致分类两类，一类是官方团队开发的 Adapter适配的，一类是民间开发者开发的Adapter适配的：<br>官方支持的:    </p>\n<ul>\n<li>PostgreSQL    </li>\n<li>MySQL    </li>\n<li>MongoDB    </li>\n<li>Redis    </li>\n<li>Disk    </li>\n<li>Memory    </li>\n</ul>\n<p>民间开发的：    </p>\n<ul>\n<li>SQLServer    </li>\n<li>OrientDB  </li>\n<li>Oracle    </li>\n<li>Cassandra    </li>\n</ul>\n<p>关于Waterline的更多信息可以关注：<br><a href=\"https://github.com/balderdashy/waterline\" target=\"_blank\" rel=\"external\">github:waterline</a><br><a href=\"https://github.com/balderdashy/waterline\" target=\"_blank\" rel=\"external\">github:waterline-docs</a></p>\n<h2 id=\"MVC的实现\"><a href=\"#MVC的实现\" class=\"headerlink\" title=\"MVC的实现\"></a>MVC的实现</h2><p>在这一段我想不仅仅要谈论到Model层、View层和Controller层，我认为还有必要谈到Service层、和Policy层。</p>\n<h5 id=\"Model层\"><a href=\"#Model层\" class=\"headerlink\" title=\"Model层\"></a>Model层</h5><p>模型文件定义到<code>/api/models</code>中，由Waterline驱动，所有model都能全局访问。Sails提供命令行创建model的命令：<code>$ sails generate model MODEL_NAME</code></p>\n<h5 id=\"View层\"><a href=\"#View层\" class=\"headerlink\" title=\"View层\"></a>View层</h5><p>实现在<code>/views</code>中，除了默认提供的ejs模版引擎之外，还能更换成jade、handlebars等模版引擎</p>\n<h5 id=\"Controller层\"><a href=\"#Controller层\" class=\"headerlink\" title=\"Controller层\"></a>Controller层</h5><p>在<code>/api/controller</code>目录里，Sails中提供创建controller的命令：<code>$ sails generate controller CONTROLLER_NAME</code>。Sails也提供同时创建model和对应的Controller的命令：<code>$ sails generate api API_NAME</code>。</p>\n<h5 id=\"Service层\"><a href=\"#Service层\" class=\"headerlink\" title=\"Service层\"></a>Service层</h5><p>在<code>/api/services</code>目录里，存放自定义的服务，所有service都能够全局访问，Sails官方的建议是把逻辑处理都放在该层中，Controller层只做路由的分发和轻逻辑的处理。</p>\n<h5 id=\"Policy层\"><a href=\"#Policy层\" class=\"headerlink\" title=\"Policy层\"></a>Policy层</h5><p>在<code>/api/policies</code>目录里，存放自定义的过滤器。该层是一条请求在到达Controller之前根据需求过滤请求的中间层。在<code>/api/policies</code>目录中定义的文件，还需要在<code>config/policies.js</code>文件中为需求应用到某一过滤器的Action配置。</p>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>Sails中要理解路由，首先要记得这个名词<code>blueprint</code>，中文翻译为：蓝图。我不知道官方是否解释过为什么要用个单词，但以我的理解，Sails的blueprint是负责指挥每一条客户端请求应该分配到服务器端的哪个Action去，所以叫蓝图吧。<br>blueprint主要分为三种：<code>RESTful routes</code>、<code>Shortcut routes</code>、<code>Action routes</code>。</p>\n<h5 id=\"RESTful-routes\"><a href=\"#RESTful-routes\" class=\"headerlink\" title=\"RESTful routes\"></a>RESTful routes</h5><p>当路径诸如：<code>/:modelIdentity</code> 或者 <code>/:modelIdentity/:id</code>的时候，blueprint会根据HTTP的动作（GET、POST、DELETE、PUT等）来分配到相应的Controller下相应的Action来处理。例如一个POST请求<code>/user</code>会创建一个用户，一个DELETE请求<code>/user/123</code>会删除<code>id</code>为123的用户。</p>\n<h5 id=\"Shortcut-routes\"><a href=\"#Shortcut-routes\" class=\"headerlink\" title=\"Shortcut routes\"></a>Shortcut routes</h5><p>这种路由主要是方便开发，请求的参数可以直接写在请求路径中，例如<code>/user/create?name=joe</code>会创建一个新的用户，<code>/user/update/1?name=mike</code>会更新<code>id</code>为1的用户的名字。shortcut routes在开发环境很便利，但是在生产环境下需要关闭。</p>\n<h5 id=\"Action-routes\"><a href=\"#Action-routes\" class=\"headerlink\" title=\"Action routes\"></a>Action routes</h5><p>这种路由会自动的为Controller层的每一个Action创建一个路由，例如你的Controller层有一个<code>FooController.js</code>，里面有一个Action<code>bar</code>，那么请求<code>/foo/bar</code>就会分配到<code>bar</code>Action。</p>\n<p>当然Sails也会提供自定义的路由，用户可以在<code>config/routes.js</code>和<code>config/polices.js</code>这两个配置文件中选择关闭或者打开blueprint提供的路由，和定义自己的路由。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>要确保产品的安全性，要对几种常见的攻击和安全策略了如指掌，诸如CORS、CSRF、DDOS、XSS等。Sails对于常见的安全策略都有提供支持，且只需要通过相关的配置文件就可以控制安全策略的等级。深入探讨Web的安全策略，并不在本文的范畴内，日后我会以这个为题写一篇文章聊聊Web的安全。<br>想要了解更多Sails的安全策略可以看看这里：<a href=\"http://sailsjs.org/#!/documentation/concepts/Security\" target=\"_blank\" rel=\"external\">sails: security</a></p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><p>Sails提供了一个全局对象<code>sails.log</code>用来处理日志信息的输出，日志是分level的，在<code>config/log.js</code>中配置日志输出的level，而level的作用看下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Priority</th>\n<th style=\"text-align:center\">level</th>\n<th style=\"text-align:center\">Log fns visible</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:center\">silent</td>\n<td style=\"text-align:center\">N/A</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:center\">error</td>\n<td style=\"text-align:center\">.error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:center\">warn</td>\n<td style=\"text-align:center\">.warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:center\">debug</td>\n<td style=\"text-align:center\">.debug(), .warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:center\">info</td>\n<td style=\"text-align:center\">.info(), .debug(), .warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:center\">verbose</td>\n<td style=\"text-align:center\">.verbose(), .info(), .debug(), .warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:center\">silly</td>\n<td style=\"text-align:center\">.silly(), .verbose(), .info(), .debug(), .warn(), .error()</td>\n</tr>\n</tbody>\n</table>\n<p>Sails的日志管理默认是info层的，既会输出.info(), .debug(), .warn(), .error()的信息。</p>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><p>Sails使用了mocha进行单元测试，在新建Sails项目的时候，没有创建单元测试的文件夹，需要自己手动构造单元测试目录，官方建议的目录是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── api</div><div class=\"line\">├── assets</div><div class=\"line\">├── ...</div><div class=\"line\">├── test</div><div class=\"line\">│  ├── unit</div><div class=\"line\">│  │  ├── controllers</div><div class=\"line\">│  │  │  └── UsersController.test.js</div><div class=\"line\">│  │  ├── models</div><div class=\"line\">│  │  │  └── Users.test.js</div><div class=\"line\">│  │  └── ...</div><div class=\"line\">│  ├── fixtures</div><div class=\"line\">│  ├── ...</div><div class=\"line\">│  ├── bootstrap.test.js</div><div class=\"line\">│  └── mocha.opts</div><div class=\"line\">└── views</div></pre></td></tr></table></figure>\n<p>而我在单元测试常用的组合是：<a href=\"https://github.com/mochajs/mocha\" target=\"_blank\" rel=\"external\">mocha</a>、<a href=\"https://github.com/tj/should.js\" target=\"_blank\" rel=\"external\">should</a>、<a href=\"https://github.com/visionmedia/supertest\" target=\"_blank\" rel=\"external\">supertest</a>、 <a href=\"https://github.com/gotwarlost/istanbul\" target=\"_blank\" rel=\"external\">istanbul</a><br>其中should是提供断言，supertest是用于测试Controller层的时候伪造http请求的，而istanbul则是提供测试代码覆盖率的。<br>关于怎么在Sails中编写测试代码，可以参考 <a href=\"http://sailsjs.org/#!/documentation/concepts/Testing\" target=\"_blank\" rel=\"external\">sails:testing</a></p>\n<h2 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h2><p>对于有即时性通讯需求的Web应用，我们会用Socket，Sails也为这方面提供了支持。在客户端提供js文件：<code>sails.io.js</code>，而在服务器端提供全局对象：<code>sails.sockets</code>。通过这两个对象，就可以进行客户端和服务器端即时性通讯的开发了。<br>Sails默认会启动WebSocket功能，在客户端访问服务器端的时候，会自动尝试在同域名下连接socket。<br>值得注意的是，这样会对AngularJS、EmberJS等前端MVVC开发产生一些障碍。<br>比如进行AngularJS开发的时候，我们在<code>http://localhost:9000</code>跑AngularJS项目，而服务器端却跑在<code>http://localhost:1337</code>。<br>当访问<code>http://localhost:9000</code>的时候，<code>sails.io.js</code>会尝试于当前路径下进行socket连接，也就是<code>http://localhost:9000</code>，这时会出错，因为服务器是跑在<code>http://localhost:1337</code>的。<br>在开发的时候要解决这样的问题的时候，我们只需要在AngularJS这边引入<code>sails.io.js</code>之后定义连接路径就行了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=<span class=\"string\">\"scripts/lib/sails.io.js\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></div><div class=\"line\">&lt;script&gt;io.sails.url = <span class=\"string\">\"http://localhost:1337\"</span>;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>可以说Sails涵盖了Web开发中会遇到的绝大部分需求和问题，如果深入研究Sails的话，是受益匪浅的。</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>入手Node.js半年，从用Express开发自己的博客到用Sails开发公司项目，深深被Sails震撼了。Sails是Balderdash团队的产品，快速的项目构建、优秀的框架结构还有众多的扩展，让我有种相见恨晚的感觉。在Koa流行之前，个人认为Sails的用户量还是挺可观的。今天，我想写一写Sails那些让我感动的地方，顺便理顺一下Sails的架构。</p>\n<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><blockquote>\n<ul>\n<li>一步搭建项目</li>\n<li>项目架构</li>\n<li>ORM</li>\n<li>MVC的实现</li>\n<li>路由</li>\n<li>安全</li>\n<li>日志</li>\n<li>单元测试</li>\n<li>WebSocket</li>\n</ul>\n</blockquote>\n<h2 id=\"一步搭建项目\"><a href=\"#一步搭建项目\" class=\"headerlink\" title=\"一步搭建项目\"></a>一步搭建项目</h2><blockquote>\n<p>在安装了Node.js 和 Sails的环境下，只需要一条命令，就能够搭建一个拥有完整架构的项目，尽管这很简单，我还是觉得有必要说一下。</p>\n</blockquote>\n<p>在已经安装了Node.js和npm的前提下，首先你需要全局下安装Sails<br><code>$ sudo npm install sails -g</code></p>\n<p>其次在一个空路径下，新建一个项目<br><code>$ sails new newApp</code></p>\n<p>最后，只需要前往项目路径，把项目运行起来<br><code>$ cd testProject</code><br><code>$ sails lift</code></p>\n<p>访问 <code>http://localhost:1337</code>就能看到一个新的项目</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/64f9a65d-294f-43e6-984a-77dc2818ecc4.png\" alt=\"new app\"></p>\n<h2 id=\"项目架构\"><a href=\"#项目架构\" class=\"headerlink\" title=\"项目架构\"></a>项目架构</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── api</div><div class=\"line\">│   ├── controllers</div><div class=\"line\">│   ├── models</div><div class=\"line\">│   ├── policies</div><div class=\"line\">│   ├── responses</div><div class=\"line\">│   └── services</div><div class=\"line\">├── views</div><div class=\"line\">├── assets</div><div class=\"line\">├── config</div><div class=\"line\">├── tasks</div><div class=\"line\">├── node_modules</div><div class=\"line\">├── package.json</div><div class=\"line\">├── Gruntfile.js</div><div class=\"line\">├── README.md</div><div class=\"line\">└── app.js</div></pre></td></tr></table></figure>\n<h3 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api/\"></a><code>api/</code></h3><p><code>api</code> 目录下是你要构建应用的核心所在，常说的MVC的设计结构就体现在这里<br><code>api/controllers</code> ：控制层，该层是Http请求的入口。Sails官方建议该层只处理请求的转发和页面的渲染，具体的逻辑实现应该交给Service层。<br><code>api/models</code>：模型层，在Sails中，对于Model采用的是充血模型，除了可以在模型中定于属性之外，还可以定义包含逻辑处理的函数。在Sails中，所有Model都可以全局性访问。<br><code>api/policies</code>：过滤层，该层在Controller层之前对Http请求做处理，在这一层中，可以定于一些规则来过滤Http请求，比如身份认证什么的。<br><code>api/responses</code>：http响应的方法都放这里，例如服务器错误、请求错误、404错误等，定义在responses文件夹里面的方法，都会赋值到controller层的req对象中。<br><code>api/services</code>：服务层，该层包含逻辑处理的方法，在Sails中，所有Service都可以全局性访问。</p>\n<h3 id=\"views\"><a href=\"#views\" class=\"headerlink\" title=\"views/\"></a><code>views/</code></h3><p>视图层，存放视图模版文件的地方，Sails默认是提供ejs模版引擎的，如果你愿意，你可以换成jade、handlebars或者任何你喜欢的模版引擎。</p>\n<h3 id=\"assets\"><a href=\"#assets\" class=\"headerlink\" title=\"assets/\"></a><code>assets/</code></h3><p>资源文件夹，在Sails启动的时候，会启动某一个Grunt任务，把assets文件夹里的内容或压缩或编译或复制到根目录下的<code>.tmp</code>目录，这是前端可以直接通过路由访问的资源，HTML、JS、CSS以及图片等静态资源都放在这里了。</p>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config/\"></a><code>config/</code></h3><p>配置文件夹，在Sails启动的时候，会加载该文件夹里的文件，并赋值在全局对象<code>sails.config</code>中，所以能够在任何一个地方都能用到。在用Sails开发，会经常跟这个文件夹里的文件打交道，从config的构成很容易知道Sails都提供哪方面的功能。</p>\n<h3 id=\"tasks\"><a href=\"#tasks\" class=\"headerlink\" title=\"tasks/\"></a><code>tasks/</code></h3><p>Sails自带的项目自动化工具是<code>Grunt</code>，而Grunt的配置和任务注册都放在这个文件夹里了。这里已经提供了通常会用到的CSS编译、JS压缩、文件合并，更改检测等等任务，当然如果没有自己需要的，还能扩展。</p>\n<h3 id=\"app-js\"><a href=\"#app-js\" class=\"headerlink\" title=\"app.js\"></a><code>app.js</code></h3><p>Sails的启动文件，无论是<code>$ sails lift</code>命令或者<code>$ npm start</code>命令都会运行该文件。</p>\n<h2 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a>ORM</h2><p>开发了Sails的团队Balderdash，还开发了一套ORM框架：Waterline。<br>Waterline在Sails主要的舞台是在<code>/api/models</code>目录里，在这里定义的模型文件，在Sails启动的时候，都要经由Waterline的洗礼。<br>Waterline 是通过Adapter关联数据库的，不同的Adapter关联不同的数据库。<br>Waterline 能适配绝对部分数据库，大致分类两类，一类是官方团队开发的 Adapter适配的，一类是民间开发者开发的Adapter适配的：<br>官方支持的:    </p>\n<ul>\n<li>PostgreSQL    </li>\n<li>MySQL    </li>\n<li>MongoDB    </li>\n<li>Redis    </li>\n<li>Disk    </li>\n<li>Memory    </li>\n</ul>\n<p>民间开发的：    </p>\n<ul>\n<li>SQLServer    </li>\n<li>OrientDB  </li>\n<li>Oracle    </li>\n<li>Cassandra    </li>\n</ul>\n<p>关于Waterline的更多信息可以关注：<br><a href=\"https://github.com/balderdashy/waterline\">github:waterline</a><br><a href=\"https://github.com/balderdashy/waterline\">github:waterline-docs</a></p>\n<h2 id=\"MVC的实现\"><a href=\"#MVC的实现\" class=\"headerlink\" title=\"MVC的实现\"></a>MVC的实现</h2><p>在这一段我想不仅仅要谈论到Model层、View层和Controller层，我认为还有必要谈到Service层、和Policy层。</p>\n<h5 id=\"Model层\"><a href=\"#Model层\" class=\"headerlink\" title=\"Model层\"></a>Model层</h5><p>模型文件定义到<code>/api/models</code>中，由Waterline驱动，所有model都能全局访问。Sails提供命令行创建model的命令：<code>$ sails generate model MODEL_NAME</code></p>\n<h5 id=\"View层\"><a href=\"#View层\" class=\"headerlink\" title=\"View层\"></a>View层</h5><p>实现在<code>/views</code>中，除了默认提供的ejs模版引擎之外，还能更换成jade、handlebars等模版引擎</p>\n<h5 id=\"Controller层\"><a href=\"#Controller层\" class=\"headerlink\" title=\"Controller层\"></a>Controller层</h5><p>在<code>/api/controller</code>目录里，Sails中提供创建controller的命令：<code>$ sails generate controller CONTROLLER_NAME</code>。Sails也提供同时创建model和对应的Controller的命令：<code>$ sails generate api API_NAME</code>。</p>\n<h5 id=\"Service层\"><a href=\"#Service层\" class=\"headerlink\" title=\"Service层\"></a>Service层</h5><p>在<code>/api/services</code>目录里，存放自定义的服务，所有service都能够全局访问，Sails官方的建议是把逻辑处理都放在该层中，Controller层只做路由的分发和轻逻辑的处理。</p>\n<h5 id=\"Policy层\"><a href=\"#Policy层\" class=\"headerlink\" title=\"Policy层\"></a>Policy层</h5><p>在<code>/api/policies</code>目录里，存放自定义的过滤器。该层是一条请求在到达Controller之前根据需求过滤请求的中间层。在<code>/api/policies</code>目录中定义的文件，还需要在<code>config/policies.js</code>文件中为需求应用到某一过滤器的Action配置。</p>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>Sails中要理解路由，首先要记得这个名词<code>blueprint</code>，中文翻译为：蓝图。我不知道官方是否解释过为什么要用个单词，但以我的理解，Sails的blueprint是负责指挥每一条客户端请求应该分配到服务器端的哪个Action去，所以叫蓝图吧。<br>blueprint主要分为三种：<code>RESTful routes</code>、<code>Shortcut routes</code>、<code>Action routes</code>。</p>\n<h5 id=\"RESTful-routes\"><a href=\"#RESTful-routes\" class=\"headerlink\" title=\"RESTful routes\"></a>RESTful routes</h5><p>当路径诸如：<code>/:modelIdentity</code> 或者 <code>/:modelIdentity/:id</code>的时候，blueprint会根据HTTP的动作（GET、POST、DELETE、PUT等）来分配到相应的Controller下相应的Action来处理。例如一个POST请求<code>/user</code>会创建一个用户，一个DELETE请求<code>/user/123</code>会删除<code>id</code>为123的用户。</p>\n<h5 id=\"Shortcut-routes\"><a href=\"#Shortcut-routes\" class=\"headerlink\" title=\"Shortcut routes\"></a>Shortcut routes</h5><p>这种路由主要是方便开发，请求的参数可以直接写在请求路径中，例如<code>/user/create?name=joe</code>会创建一个新的用户，<code>/user/update/1?name=mike</code>会更新<code>id</code>为1的用户的名字。shortcut routes在开发环境很便利，但是在生产环境下需要关闭。</p>\n<h5 id=\"Action-routes\"><a href=\"#Action-routes\" class=\"headerlink\" title=\"Action routes\"></a>Action routes</h5><p>这种路由会自动的为Controller层的每一个Action创建一个路由，例如你的Controller层有一个<code>FooController.js</code>，里面有一个Action<code>bar</code>，那么请求<code>/foo/bar</code>就会分配到<code>bar</code>Action。</p>\n<p>当然Sails也会提供自定义的路由，用户可以在<code>config/routes.js</code>和<code>config/polices.js</code>这两个配置文件中选择关闭或者打开blueprint提供的路由，和定义自己的路由。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>要确保产品的安全性，要对几种常见的攻击和安全策略了如指掌，诸如CORS、CSRF、DDOS、XSS等。Sails对于常见的安全策略都有提供支持，且只需要通过相关的配置文件就可以控制安全策略的等级。深入探讨Web的安全策略，并不在本文的范畴内，日后我会以这个为题写一篇文章聊聊Web的安全。<br>想要了解更多Sails的安全策略可以看看这里：<a href=\"http://sailsjs.org/#!/documentation/concepts/Security\">sails: security</a></p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><p>Sails提供了一个全局对象<code>sails.log</code>用来处理日志信息的输出，日志是分level的，在<code>config/log.js</code>中配置日志输出的level，而level的作用看下表：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Priority</th>\n<th style=\"text-align:center\">level</th>\n<th style=\"text-align:center\">Log fns visible</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:center\">silent</td>\n<td style=\"text-align:center\">N/A</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:center\">error</td>\n<td style=\"text-align:center\">.error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:center\">warn</td>\n<td style=\"text-align:center\">.warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:center\">debug</td>\n<td style=\"text-align:center\">.debug(), .warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:center\">info</td>\n<td style=\"text-align:center\">.info(), .debug(), .warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:center\">verbose</td>\n<td style=\"text-align:center\">.verbose(), .info(), .debug(), .warn(), .error()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:center\">silly</td>\n<td style=\"text-align:center\">.silly(), .verbose(), .info(), .debug(), .warn(), .error()</td>\n</tr>\n</tbody>\n</table>\n<p>Sails的日志管理默认是info层的，既会输出.info(), .debug(), .warn(), .error()的信息。</p>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><p>Sails使用了mocha进行单元测试，在新建Sails项目的时候，没有创建单元测试的文件夹，需要自己手动构造单元测试目录，官方建议的目录是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── api</div><div class=\"line\">├── assets</div><div class=\"line\">├── ...</div><div class=\"line\">├── test</div><div class=\"line\">│  ├── unit</div><div class=\"line\">│  │  ├── controllers</div><div class=\"line\">│  │  │  └── UsersController.test.js</div><div class=\"line\">│  │  ├── models</div><div class=\"line\">│  │  │  └── Users.test.js</div><div class=\"line\">│  │  └── ...</div><div class=\"line\">│  ├── fixtures</div><div class=\"line\">│  ├── ...</div><div class=\"line\">│  ├── bootstrap.test.js</div><div class=\"line\">│  └── mocha.opts</div><div class=\"line\">└── views</div></pre></td></tr></table></figure>\n<p>而我在单元测试常用的组合是：<a href=\"https://github.com/mochajs/mocha\">mocha</a>、<a href=\"https://github.com/tj/should.js\">should</a>、<a href=\"https://github.com/visionmedia/supertest\">supertest</a>、 <a href=\"https://github.com/gotwarlost/istanbul\">istanbul</a><br>其中should是提供断言，supertest是用于测试Controller层的时候伪造http请求的，而istanbul则是提供测试代码覆盖率的。<br>关于怎么在Sails中编写测试代码，可以参考 <a href=\"http://sailsjs.org/#!/documentation/concepts/Testing\">sails:testing</a></p>\n<h2 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h2><p>对于有即时性通讯需求的Web应用，我们会用Socket，Sails也为这方面提供了支持。在客户端提供js文件：<code>sails.io.js</code>，而在服务器端提供全局对象：<code>sails.sockets</code>。通过这两个对象，就可以进行客户端和服务器端即时性通讯的开发了。<br>Sails默认会启动WebSocket功能，在客户端访问服务器端的时候，会自动尝试在同域名下连接socket。<br>值得注意的是，这样会对AngularJS、EmberJS等前端MVVC开发产生一些障碍。<br>比如进行AngularJS开发的时候，我们在<code>http://localhost:9000</code>跑AngularJS项目，而服务器端却跑在<code>http://localhost:1337</code>。<br>当访问<code>http://localhost:9000</code>的时候，<code>sails.io.js</code>会尝试于当前路径下进行socket连接，也就是<code>http://localhost:9000</code>，这时会出错，因为服务器是跑在<code>http://localhost:1337</code>的。<br>在开发的时候要解决这样的问题的时候，我们只需要在AngularJS这边引入<code>sails.io.js</code>之后定义连接路径就行了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=<span class=\"string\">\"scripts/lib/sails.io.js\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></div><div class=\"line\">&lt;script&gt;io.sails.url = <span class=\"string\">\"http://localhost:1337\"</span>;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>可以说Sails涵盖了Web开发中会遇到的绝大部分需求和问题，如果深入研究Sails的话，是受益匪浅的。</p>\n"},{"title":"二零一六年一月二十八日，于珠海","date":"2016-01-28T07:40:25.000Z","_content":"\n> 从什么时候开始，我开始迷茫了。\n\n在这里做了一年多的Node.js后端，但是现在业界都是把这门语言归并到前端技术中。    \n我知道自己的前端技术水平很烂，基本功一开始没有练好，在后续也没有继续去锻炼。    \n今天看了由「阿当」发起的前端届撕逼大战。\n\n在有过一年多的后端以及一年多的前端经验的我，是否能更好的跟进这个前端工程化的时代呢。如果除开基本的CSS、HTML之外，我应该对比那些从ccser和设计师转型过来的前端，有着更不一样的思维。\n\n如果我自己进行前端的技能修炼的话，是否可以当一个小全栈呢。\n\n现在的我，处在一个高不成低不就的地步。如果继续往后端发展，明显Node.js是还不够的，要做真正的大项目，大Project的后端的时候，还需要成熟的技术与框架。只是继续Node.js的修炼下去的话，很快就能看到天花板了。\n\n> 回过头来思考，自己并不能限定在一个方向中，应该往一个更广的范畴发展，但我还有很多缺点。\n\n我现在最大的缺点，就是基础不扎实，这在日常工作中，很多情况都能感受的到。    \n书到用时方恨少，当需要用到的时候，总觉得有些乏力。例如在要写一些查询数据库的语句，例如在写算法的时候，写加密解密的时候，缺少了专业的知识做支撑。    \n还有英文能力不太好，在读一些英文的文献的时候，经常感觉到乏力，与效率缓慢。    \n还有自己在知识的广度上，也还不够，没法把握技术的动态。没有足够的关注。\n\n> 忙碌的时期过后，迎来了平静的夜晚，我停下急躁的脚步，思考自己的人生。\n\n今年刚毕业，却已经24岁了，比起很多同龄人，我读书晚了几年，还有6年，就是30岁了。    \n我想要在28岁(2020)时候，能有自己的房子，老婆、车子，在一个城市稳定下来。从现在开始算，剩下给我的只有不到四年的时间。\n今年(2016)可能会买车，然后成了车奴，\n两年后(2018)就可能是结婚了，虽然可能还没有房子，但是我会有一个爱我以及我爱的人。\n然后我们一起努力，在四年后(2020)在一个城市拥有我们的家，然后我们开始生个娃娃。\n\n梦想很丰满，实现很露骨，实现这一切，我要思考该怎么去创造财富。\n从职业上，干几年，以现在自己的状况来说，可能是干到一个leader，领导项目。在这个行业，在这个弱肉强食，优胜劣汰的社会，你负责的项目垮了，就可能面临被裁员的危险。\n\n或者干到几年，在圈子中，有些名气，有些地位，出一两本书。    \n又或者，转型，转到产品岗、项目经理岗、架构师、技术顾问等等。    \n又或者，去读研，考取研究生，提高自己的学历，出国深造等等。    \n又或者，从草根干起，自学成才，厚积薄发。    \n\n其实，这些从现在看来，都未必不可实现，关键还是自己是否有这样的决心和勇气，以及坚持下去的毅力。\n\n> 现在我没有很清晰长远的计划，但我知道一定不要停止前进，至少大方向上，我知道是对还是错的。\n\n2016年，给自己定下要实现的目标：\n\n1. 积累技术的基础，包括但不限于：Nodejs、JS、CSS、HTML5、前端工程化、软件工程化、设计模式、数据库、算法、密码学等等。\n2. 积累阅读量，不单单限于技术书籍，各种书籍都需要接触，提高自己的文笔，以及语言表达能力。\n3. 积累创作文章，勤思考，然后把自己的东西写下来，分享给别人。\n4. 锻炼英语能力，勤于阅读英文类文章、杂志、原版技术书籍。\n5. 关注技术的动态，整理圈子的人物，关注他们。\n\n全部坚持下来的话，是一个艰巨的任务，但是我愿意为了以后的梦想而奋斗，我适应不了无所事事的日子。\n这些积累，不是一朝一日就可以的，是要长年累月，不单单是2016年这一年，而是我要养成这样的习惯，并长期的执行下去。\n相信，积累下去了，在未来的某个时候，我会感谢以前的我是多么的远见。","source":"_posts/二零一六年一月二十八日，于珠海.md","raw":"---\ntitle: 二零一六年一月二十八日，于珠海\ncategory: 三省吾身\ndate: 2016-01-28 15:40:25\ntags:\n---\n\n> 从什么时候开始，我开始迷茫了。\n\n在这里做了一年多的Node.js后端，但是现在业界都是把这门语言归并到前端技术中。    \n我知道自己的前端技术水平很烂，基本功一开始没有练好，在后续也没有继续去锻炼。    \n今天看了由「阿当」发起的前端届撕逼大战。\n\n在有过一年多的后端以及一年多的前端经验的我，是否能更好的跟进这个前端工程化的时代呢。如果除开基本的CSS、HTML之外，我应该对比那些从ccser和设计师转型过来的前端，有着更不一样的思维。\n\n如果我自己进行前端的技能修炼的话，是否可以当一个小全栈呢。\n\n现在的我，处在一个高不成低不就的地步。如果继续往后端发展，明显Node.js是还不够的，要做真正的大项目，大Project的后端的时候，还需要成熟的技术与框架。只是继续Node.js的修炼下去的话，很快就能看到天花板了。\n\n> 回过头来思考，自己并不能限定在一个方向中，应该往一个更广的范畴发展，但我还有很多缺点。\n\n我现在最大的缺点，就是基础不扎实，这在日常工作中，很多情况都能感受的到。    \n书到用时方恨少，当需要用到的时候，总觉得有些乏力。例如在要写一些查询数据库的语句，例如在写算法的时候，写加密解密的时候，缺少了专业的知识做支撑。    \n还有英文能力不太好，在读一些英文的文献的时候，经常感觉到乏力，与效率缓慢。    \n还有自己在知识的广度上，也还不够，没法把握技术的动态。没有足够的关注。\n\n> 忙碌的时期过后，迎来了平静的夜晚，我停下急躁的脚步，思考自己的人生。\n\n今年刚毕业，却已经24岁了，比起很多同龄人，我读书晚了几年，还有6年，就是30岁了。    \n我想要在28岁(2020)时候，能有自己的房子，老婆、车子，在一个城市稳定下来。从现在开始算，剩下给我的只有不到四年的时间。\n今年(2016)可能会买车，然后成了车奴，\n两年后(2018)就可能是结婚了，虽然可能还没有房子，但是我会有一个爱我以及我爱的人。\n然后我们一起努力，在四年后(2020)在一个城市拥有我们的家，然后我们开始生个娃娃。\n\n梦想很丰满，实现很露骨，实现这一切，我要思考该怎么去创造财富。\n从职业上，干几年，以现在自己的状况来说，可能是干到一个leader，领导项目。在这个行业，在这个弱肉强食，优胜劣汰的社会，你负责的项目垮了，就可能面临被裁员的危险。\n\n或者干到几年，在圈子中，有些名气，有些地位，出一两本书。    \n又或者，转型，转到产品岗、项目经理岗、架构师、技术顾问等等。    \n又或者，去读研，考取研究生，提高自己的学历，出国深造等等。    \n又或者，从草根干起，自学成才，厚积薄发。    \n\n其实，这些从现在看来，都未必不可实现，关键还是自己是否有这样的决心和勇气，以及坚持下去的毅力。\n\n> 现在我没有很清晰长远的计划，但我知道一定不要停止前进，至少大方向上，我知道是对还是错的。\n\n2016年，给自己定下要实现的目标：\n\n1. 积累技术的基础，包括但不限于：Nodejs、JS、CSS、HTML5、前端工程化、软件工程化、设计模式、数据库、算法、密码学等等。\n2. 积累阅读量，不单单限于技术书籍，各种书籍都需要接触，提高自己的文笔，以及语言表达能力。\n3. 积累创作文章，勤思考，然后把自己的东西写下来，分享给别人。\n4. 锻炼英语能力，勤于阅读英文类文章、杂志、原版技术书籍。\n5. 关注技术的动态，整理圈子的人物，关注他们。\n\n全部坚持下来的话，是一个艰巨的任务，但是我愿意为了以后的梦想而奋斗，我适应不了无所事事的日子。\n这些积累，不是一朝一日就可以的，是要长年累月，不单单是2016年这一年，而是我要养成这样的习惯，并长期的执行下去。\n相信，积累下去了，在未来的某个时候，我会感谢以前的我是多么的远见。","slug":"二零一六年一月二十八日，于珠海","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqb001t15hl5jflzero","content":"<blockquote>\n<p>从什么时候开始，我开始迷茫了。</p>\n</blockquote>\n<p>在这里做了一年多的Node.js后端，但是现在业界都是把这门语言归并到前端技术中。<br>我知道自己的前端技术水平很烂，基本功一开始没有练好，在后续也没有继续去锻炼。<br>今天看了由「阿当」发起的前端届撕逼大战。</p>\n<p>在有过一年多的后端以及一年多的前端经验的我，是否能更好的跟进这个前端工程化的时代呢。如果除开基本的CSS、HTML之外，我应该对比那些从ccser和设计师转型过来的前端，有着更不一样的思维。</p>\n<p>如果我自己进行前端的技能修炼的话，是否可以当一个小全栈呢。</p>\n<p>现在的我，处在一个高不成低不就的地步。如果继续往后端发展，明显Node.js是还不够的，要做真正的大项目，大Project的后端的时候，还需要成熟的技术与框架。只是继续Node.js的修炼下去的话，很快就能看到天花板了。</p>\n<blockquote>\n<p>回过头来思考，自己并不能限定在一个方向中，应该往一个更广的范畴发展，但我还有很多缺点。</p>\n</blockquote>\n<p>我现在最大的缺点，就是基础不扎实，这在日常工作中，很多情况都能感受的到。<br>书到用时方恨少，当需要用到的时候，总觉得有些乏力。例如在要写一些查询数据库的语句，例如在写算法的时候，写加密解密的时候，缺少了专业的知识做支撑。<br>还有英文能力不太好，在读一些英文的文献的时候，经常感觉到乏力，与效率缓慢。<br>还有自己在知识的广度上，也还不够，没法把握技术的动态。没有足够的关注。</p>\n<blockquote>\n<p>忙碌的时期过后，迎来了平静的夜晚，我停下急躁的脚步，思考自己的人生。</p>\n</blockquote>\n<p>今年刚毕业，却已经24岁了，比起很多同龄人，我读书晚了几年，还有6年，就是30岁了。<br>我想要在28岁(2020)时候，能有自己的房子，老婆、车子，在一个城市稳定下来。从现在开始算，剩下给我的只有不到四年的时间。<br>今年(2016)可能会买车，然后成了车奴，<br>两年后(2018)就可能是结婚了，虽然可能还没有房子，但是我会有一个爱我以及我爱的人。<br>然后我们一起努力，在四年后(2020)在一个城市拥有我们的家，然后我们开始生个娃娃。</p>\n<p>梦想很丰满，实现很露骨，实现这一切，我要思考该怎么去创造财富。<br>从职业上，干几年，以现在自己的状况来说，可能是干到一个leader，领导项目。在这个行业，在这个弱肉强食，优胜劣汰的社会，你负责的项目垮了，就可能面临被裁员的危险。</p>\n<p>或者干到几年，在圈子中，有些名气，有些地位，出一两本书。<br>又或者，转型，转到产品岗、项目经理岗、架构师、技术顾问等等。<br>又或者，去读研，考取研究生，提高自己的学历，出国深造等等。<br>又或者，从草根干起，自学成才，厚积薄发。    </p>\n<p>其实，这些从现在看来，都未必不可实现，关键还是自己是否有这样的决心和勇气，以及坚持下去的毅力。</p>\n<blockquote>\n<p>现在我没有很清晰长远的计划，但我知道一定不要停止前进，至少大方向上，我知道是对还是错的。</p>\n</blockquote>\n<p>2016年，给自己定下要实现的目标：</p>\n<ol>\n<li>积累技术的基础，包括但不限于：Nodejs、JS、CSS、HTML5、前端工程化、软件工程化、设计模式、数据库、算法、密码学等等。</li>\n<li>积累阅读量，不单单限于技术书籍，各种书籍都需要接触，提高自己的文笔，以及语言表达能力。</li>\n<li>积累创作文章，勤思考，然后把自己的东西写下来，分享给别人。</li>\n<li>锻炼英语能力，勤于阅读英文类文章、杂志、原版技术书籍。</li>\n<li>关注技术的动态，整理圈子的人物，关注他们。</li>\n</ol>\n<p>全部坚持下来的话，是一个艰巨的任务，但是我愿意为了以后的梦想而奋斗，我适应不了无所事事的日子。<br>这些积累，不是一朝一日就可以的，是要长年累月，不单单是2016年这一年，而是我要养成这样的习惯，并长期的执行下去。<br>相信，积累下去了，在未来的某个时候，我会感谢以前的我是多么的远见。</p>\n","excerpt":"","more":"<blockquote>\n<p>从什么时候开始，我开始迷茫了。</p>\n</blockquote>\n<p>在这里做了一年多的Node.js后端，但是现在业界都是把这门语言归并到前端技术中。<br>我知道自己的前端技术水平很烂，基本功一开始没有练好，在后续也没有继续去锻炼。<br>今天看了由「阿当」发起的前端届撕逼大战。</p>\n<p>在有过一年多的后端以及一年多的前端经验的我，是否能更好的跟进这个前端工程化的时代呢。如果除开基本的CSS、HTML之外，我应该对比那些从ccser和设计师转型过来的前端，有着更不一样的思维。</p>\n<p>如果我自己进行前端的技能修炼的话，是否可以当一个小全栈呢。</p>\n<p>现在的我，处在一个高不成低不就的地步。如果继续往后端发展，明显Node.js是还不够的，要做真正的大项目，大Project的后端的时候，还需要成熟的技术与框架。只是继续Node.js的修炼下去的话，很快就能看到天花板了。</p>\n<blockquote>\n<p>回过头来思考，自己并不能限定在一个方向中，应该往一个更广的范畴发展，但我还有很多缺点。</p>\n</blockquote>\n<p>我现在最大的缺点，就是基础不扎实，这在日常工作中，很多情况都能感受的到。<br>书到用时方恨少，当需要用到的时候，总觉得有些乏力。例如在要写一些查询数据库的语句，例如在写算法的时候，写加密解密的时候，缺少了专业的知识做支撑。<br>还有英文能力不太好，在读一些英文的文献的时候，经常感觉到乏力，与效率缓慢。<br>还有自己在知识的广度上，也还不够，没法把握技术的动态。没有足够的关注。</p>\n<blockquote>\n<p>忙碌的时期过后，迎来了平静的夜晚，我停下急躁的脚步，思考自己的人生。</p>\n</blockquote>\n<p>今年刚毕业，却已经24岁了，比起很多同龄人，我读书晚了几年，还有6年，就是30岁了。<br>我想要在28岁(2020)时候，能有自己的房子，老婆、车子，在一个城市稳定下来。从现在开始算，剩下给我的只有不到四年的时间。<br>今年(2016)可能会买车，然后成了车奴，<br>两年后(2018)就可能是结婚了，虽然可能还没有房子，但是我会有一个爱我以及我爱的人。<br>然后我们一起努力，在四年后(2020)在一个城市拥有我们的家，然后我们开始生个娃娃。</p>\n<p>梦想很丰满，实现很露骨，实现这一切，我要思考该怎么去创造财富。<br>从职业上，干几年，以现在自己的状况来说，可能是干到一个leader，领导项目。在这个行业，在这个弱肉强食，优胜劣汰的社会，你负责的项目垮了，就可能面临被裁员的危险。</p>\n<p>或者干到几年，在圈子中，有些名气，有些地位，出一两本书。<br>又或者，转型，转到产品岗、项目经理岗、架构师、技术顾问等等。<br>又或者，去读研，考取研究生，提高自己的学历，出国深造等等。<br>又或者，从草根干起，自学成才，厚积薄发。    </p>\n<p>其实，这些从现在看来，都未必不可实现，关键还是自己是否有这样的决心和勇气，以及坚持下去的毅力。</p>\n<blockquote>\n<p>现在我没有很清晰长远的计划，但我知道一定不要停止前进，至少大方向上，我知道是对还是错的。</p>\n</blockquote>\n<p>2016年，给自己定下要实现的目标：</p>\n<ol>\n<li>积累技术的基础，包括但不限于：Nodejs、JS、CSS、HTML5、前端工程化、软件工程化、设计模式、数据库、算法、密码学等等。</li>\n<li>积累阅读量，不单单限于技术书籍，各种书籍都需要接触，提高自己的文笔，以及语言表达能力。</li>\n<li>积累创作文章，勤思考，然后把自己的东西写下来，分享给别人。</li>\n<li>锻炼英语能力，勤于阅读英文类文章、杂志、原版技术书籍。</li>\n<li>关注技术的动态，整理圈子的人物，关注他们。</li>\n</ol>\n<p>全部坚持下来的话，是一个艰巨的任务，但是我愿意为了以后的梦想而奋斗，我适应不了无所事事的日子。<br>这些积累，不是一朝一日就可以的，是要长年累月，不单单是2016年这一年，而是我要养成这样的习惯，并长期的执行下去。<br>相信，积累下去了，在未来的某个时候，我会感谢以前的我是多么的远见。</p>\n"},{"title":"下雨天的夜晚，特别容易失眠","date":"2016-05-28T14:22:25.000Z","_content":"\n陷入迷茫期已经有差不多2个月了，\n这一次比以往的迷茫都更长一些。\n\n我应该庆幸，一些事情一杆棒打醒了我，明白了自己的懒惰以及安逸。我过去，并不是没有认真的工作，但那单单只是工作，虽然最后是能不错的完成。但那只是仅仅不错，离优秀甚远。自己并没有去主动的接触新的东西，寻找新的事物，主动且持续的保持学习。而是沉浸在那些已过去的虚荣感中。\n\n最近，想了很多，渐渐得到一些释怀。\n一是因为开始锻炼身体了，\n二是因为开始好好读一本书了。\n这两个加起来就是一剂神奇的药方。\n内心平静了许多，才会平心静气的坐下来，泡杯铁观音，好好想想自己真正想要的是什么？\n\n**事业 or 工作 or 兴趣**\n我一直很庆幸，我喜欢的东西变成了我的工作乃至事业。\n这比起很多人，已经很幸福了。\n我是真的享受作为一个技术人的快乐，\n这种快乐来自于\n发现新的好玩的东西所带来新鲜感，\n写博客分享知识所带来的认同感，\n做的产品被很多人使用并且创造价值的自豪感，\n还有是对知识的满足感。\n\n**生活**\n做为一个人，除了工作，你还有生活。\n你还有你爱以及爱你的人，这是泛指，包括父母，伴侣，朋友。\n活着，也并不是为了自己一个人而活，\n每一个年轻人，在年轻气盛的时候，都会拥抱着一个梦想，也许它是清晰可见，但更多只是一个模糊不清，你往往用它来给你的任性寻找借口。\n也许在将来，某个机会出现的时候，我会考虑去追逐那个朦胧的梦想，但并不是在抛弃那些我应当背起责任的前提下。\n\n在这个寂静的夜晚，\n窗外的雨不知不觉停了，\n多少因为不能抱着雨睡觉，而有些许失望。\n想要的比较庸俗，只是想事业更顺利，生活更美好。\n而如果这两者出现冲突了，那就和相关者商量好，取个平衡点，修改好了，再commit。\n\n此时，忽然想起一句TVB经典的台词\n「呐！做人最紧要就系开心」","source":"_posts/下雨天的夜晚，特别容易失眠.md","raw":"---\ntitle: 下雨天的夜晚，特别容易失眠\ncategory: 三省吾身\ndate: 2016-05-28 22:22:25\n---\n\n陷入迷茫期已经有差不多2个月了，\n这一次比以往的迷茫都更长一些。\n\n我应该庆幸，一些事情一杆棒打醒了我，明白了自己的懒惰以及安逸。我过去，并不是没有认真的工作，但那单单只是工作，虽然最后是能不错的完成。但那只是仅仅不错，离优秀甚远。自己并没有去主动的接触新的东西，寻找新的事物，主动且持续的保持学习。而是沉浸在那些已过去的虚荣感中。\n\n最近，想了很多，渐渐得到一些释怀。\n一是因为开始锻炼身体了，\n二是因为开始好好读一本书了。\n这两个加起来就是一剂神奇的药方。\n内心平静了许多，才会平心静气的坐下来，泡杯铁观音，好好想想自己真正想要的是什么？\n\n**事业 or 工作 or 兴趣**\n我一直很庆幸，我喜欢的东西变成了我的工作乃至事业。\n这比起很多人，已经很幸福了。\n我是真的享受作为一个技术人的快乐，\n这种快乐来自于\n发现新的好玩的东西所带来新鲜感，\n写博客分享知识所带来的认同感，\n做的产品被很多人使用并且创造价值的自豪感，\n还有是对知识的满足感。\n\n**生活**\n做为一个人，除了工作，你还有生活。\n你还有你爱以及爱你的人，这是泛指，包括父母，伴侣，朋友。\n活着，也并不是为了自己一个人而活，\n每一个年轻人，在年轻气盛的时候，都会拥抱着一个梦想，也许它是清晰可见，但更多只是一个模糊不清，你往往用它来给你的任性寻找借口。\n也许在将来，某个机会出现的时候，我会考虑去追逐那个朦胧的梦想，但并不是在抛弃那些我应当背起责任的前提下。\n\n在这个寂静的夜晚，\n窗外的雨不知不觉停了，\n多少因为不能抱着雨睡觉，而有些许失望。\n想要的比较庸俗，只是想事业更顺利，生活更美好。\n而如果这两者出现冲突了，那就和相关者商量好，取个平衡点，修改好了，再commit。\n\n此时，忽然想起一句TVB经典的台词\n「呐！做人最紧要就系开心」","slug":"下雨天的夜晚，特别容易失眠","published":1,"updated":"2017-02-04T13:36:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqd001w15hl0afb02b2","content":"<p>陷入迷茫期已经有差不多2个月了，<br>这一次比以往的迷茫都更长一些。</p>\n<p>我应该庆幸，一些事情一杆棒打醒了我，明白了自己的懒惰以及安逸。我过去，并不是没有认真的工作，但那单单只是工作，虽然最后是能不错的完成。但那只是仅仅不错，离优秀甚远。自己并没有去主动的接触新的东西，寻找新的事物，主动且持续的保持学习。而是沉浸在那些已过去的虚荣感中。</p>\n<p>最近，想了很多，渐渐得到一些释怀。<br>一是因为开始锻炼身体了，<br>二是因为开始好好读一本书了。<br>这两个加起来就是一剂神奇的药方。<br>内心平静了许多，才会平心静气的坐下来，泡杯铁观音，好好想想自己真正想要的是什么？</p>\n<p><strong>事业 or 工作 or 兴趣</strong><br>我一直很庆幸，我喜欢的东西变成了我的工作乃至事业。<br>这比起很多人，已经很幸福了。<br>我是真的享受作为一个技术人的快乐，<br>这种快乐来自于<br>发现新的好玩的东西所带来新鲜感，<br>写博客分享知识所带来的认同感，<br>做的产品被很多人使用并且创造价值的自豪感，<br>还有是对知识的满足感。</p>\n<p><strong>生活</strong><br>做为一个人，除了工作，你还有生活。<br>你还有你爱以及爱你的人，这是泛指，包括父母，伴侣，朋友。<br>活着，也并不是为了自己一个人而活，<br>每一个年轻人，在年轻气盛的时候，都会拥抱着一个梦想，也许它是清晰可见，但更多只是一个模糊不清，你往往用它来给你的任性寻找借口。<br>也许在将来，某个机会出现的时候，我会考虑去追逐那个朦胧的梦想，但并不是在抛弃那些我应当背起责任的前提下。</p>\n<p>在这个寂静的夜晚，<br>窗外的雨不知不觉停了，<br>多少因为不能抱着雨睡觉，而有些许失望。<br>想要的比较庸俗，只是想事业更顺利，生活更美好。<br>而如果这两者出现冲突了，那就和相关者商量好，取个平衡点，修改好了，再commit。</p>\n<p>此时，忽然想起一句TVB经典的台词<br>「呐！做人最紧要就系开心」</p>\n","excerpt":"","more":"<p>陷入迷茫期已经有差不多2个月了，<br>这一次比以往的迷茫都更长一些。</p>\n<p>我应该庆幸，一些事情一杆棒打醒了我，明白了自己的懒惰以及安逸。我过去，并不是没有认真的工作，但那单单只是工作，虽然最后是能不错的完成。但那只是仅仅不错，离优秀甚远。自己并没有去主动的接触新的东西，寻找新的事物，主动且持续的保持学习。而是沉浸在那些已过去的虚荣感中。</p>\n<p>最近，想了很多，渐渐得到一些释怀。<br>一是因为开始锻炼身体了，<br>二是因为开始好好读一本书了。<br>这两个加起来就是一剂神奇的药方。<br>内心平静了许多，才会平心静气的坐下来，泡杯铁观音，好好想想自己真正想要的是什么？</p>\n<p><strong>事业 or 工作 or 兴趣</strong><br>我一直很庆幸，我喜欢的东西变成了我的工作乃至事业。<br>这比起很多人，已经很幸福了。<br>我是真的享受作为一个技术人的快乐，<br>这种快乐来自于<br>发现新的好玩的东西所带来新鲜感，<br>写博客分享知识所带来的认同感，<br>做的产品被很多人使用并且创造价值的自豪感，<br>还有是对知识的满足感。</p>\n<p><strong>生活</strong><br>做为一个人，除了工作，你还有生活。<br>你还有你爱以及爱你的人，这是泛指，包括父母，伴侣，朋友。<br>活着，也并不是为了自己一个人而活，<br>每一个年轻人，在年轻气盛的时候，都会拥抱着一个梦想，也许它是清晰可见，但更多只是一个模糊不清，你往往用它来给你的任性寻找借口。<br>也许在将来，某个机会出现的时候，我会考虑去追逐那个朦胧的梦想，但并不是在抛弃那些我应当背起责任的前提下。</p>\n<p>在这个寂静的夜晚，<br>窗外的雨不知不觉停了，<br>多少因为不能抱着雨睡觉，而有些许失望。<br>想要的比较庸俗，只是想事业更顺利，生活更美好。<br>而如果这两者出现冲突了，那就和相关者商量好，取个平衡点，修改好了，再commit。</p>\n<p>此时，忽然想起一句TVB经典的台词<br>「呐！做人最紧要就系开心」</p>\n"},{"title":"何为技术人的核心竞争力","date":"2016-08-30T15:05:25.000Z","_content":"\n在寂静的夜晚上，独自一人在书房中，望着窗外，一片灯火阑珊，一条车水马龙。\n不禁让我抬头四十五度，望着那轮朦胧泛黄的新月，又开始思考起自己的人生。\n\n最初接触编程的是高中碰到的谭浩强的那本《C程序设计》，是不是一本好书，我不想做评价。\n可能是因为我天资愚钝，没能通过自学看懂这本书。\n如果说从大学开始真正拥有编程技能，到现在，已经过去五年光阴，毕业也已经有一年有余。\n虽然自小对计算机(或者说是电脑)感兴趣，但是也因为自身贪玩，兴趣泛滥，好奇心爆棚的个人属性，以致并没有把大部分时间投入这个编程兴趣中。\n要说我编程的功底，也就只有两年的功力。\n\n在一件事情上投入的越多，就会让我更加思考自己正在做的，正在走的方向。\n在高速发展，日新月异的技术圈子中，到底哪些是不变的，或可沉淀的东西。\n渐渐的会想到这样的一个问题：\n**技术人的核心竞争力到底是什么？**\n\n今天受**刘未鹏**先生在书中《暗时间》的介绍，阅读了**孟岩**老师的「[技术路线的选择重要但不具有决定性](http://blog.csdn.net/myan/article/details/3247071)」，这篇文章正好给最近被这个问题困扰的我拨开了一些迷雾。\n这是一篇2008年发表的旧文，文中的观点给了我很多启发，但我也不会有相见恨晚的感觉。就算很早遇到这篇文章，也不会有经历过的事情以及思考过的问题作为基础，故也不能理解体会其中的意思。现在时机正好。\n\n文中把技术人大致的分了四类：\n\n1. 把命运寄托在**事业**上的人\n2. 把命运寄托在**组织**上的人\n3. 把命运寄托在**技术**上的人\n4. 仍然处于出卖劳动力的人\n\n# 做技术的几类人\n\n**第一类是把自己的命运寄托在一项事业上。**\n他们会想着改变一些东西，而技术只是作为其中的手段，他们有能力通过技术实现自己的想法和事业。事业并不是指的创业做老板，而是一件他们认可的事情。比如促进人们交流和言论自由，带给大家更多娱乐，提升大众身心健康水平，增强国家国防实力，或者提升某个行业的信息化水平，能够以技术为手段，在这个事情上做出成绩。他们往往可以终其一生投入到自己的事业中去，在短短的人生中实现价值。到两鬓斑白时，能够回首往事而悠然自得。\n\n**第二类是把自己的命运寄托在组织和团队上**\n他们技术水平出色，综合素质突出，勇于变化，以团队的目标为目标，依据团队的需求而转型或者坚持，跟团队一起干出一番成绩。这些人往往拥有高薪厚禄，以及舒适生活。\n但是中年以后会经常自问到底做了什么自己想做的事情，为自己过于风平浪静的人生感到惆怅。\n\n**第三类是把命运寄托在技术上。**\n他们有能力成为技术的专家，希望把技能当做商品出售，从而谋求富足人生。不想把自己命运跟企业和组织绑定在一起，也不愿意做什么改变，只是满足于技术高手的层面，寄希望于其技术专长能够长期值钱。\n\n**第四种就是处于出卖劳动力的阶段**\n他们往往疲于做业务，单纯积极完成上级或产经下达的任务，鲜有思考需求合理性，或者在大局上关注项目及其进度。他们往往加班成自然，表面上形成勤奋工作的现象，最终却只是为了业绩好些，年终奖多些。\n\n第一类，是做技术的最高层次，终其一生投入到一项事业中，为人类和社会创造价值，这并不是一般人能够做到。而第二类总的来说，层次还是比较高的。在自己的专业领域中颇有建树，并且利用技术给团队带来生产力提高和经济的效益，是真正为团队创造价值的人。而第三类人，却是最危险的。技术的发展与变迁是必然发生的事情，年轻的时候还有能力追逐新技术，但当老了追不动了，很容易就被淘汰了。**被淘汰只是时间问题。如果你认为某个软件技术的兴起或者衰落对你个人的职业生涯构成了决定性的影响，那么你可能正走在错误的路线上，应当尽快改弦更张。**\n\n# 核心竞争力\n\n关于核心竞争力，孟岩先生有这样一段话：\n\n那么核心竞争力是什么？我观察圈子里很多成功和不成功的技术人，提出一个观点，那就是个人的核心竞争力是他**独特的个性知识经验组合**。这个行业里拥挤着上百万聪明人，彼此之间真正的不同在哪里？不在于你学的是什么技术，学得多深，IQ多少，而在于你身上有别人没有的独特的个性、背景、知识和经验的组合。如果这种组合，**1，绝无仅有；2，在实践中有价值，3，具有可持续发展性**，那你就具备核心竞争力。因此，当设计自己的发展路线时，应当最大限度地加强和发挥自己独特的组合，而不是寻求单项的超越。而构建自己独特组合的方式，主要是通过实践，其次是要有意识地构造。关于这个观点，话题太大，我不打算赘述。\n\n个人核心竞争力，并不是对某技术、框架、平台的熟烂于心，也不是什么样的开发思想，更加不是所谓的个人智商问题。而是**独特的个性、知识、经验之间的组合**。\n\n# 不可替代性\n\n孟岩先生在文中并没有对这个问题展开来描述，那么到底什么样的知识技能组合符合下面几种条件的：\n**1. 绝无仅有**\n**2. 在实践中有价值**\n**3. 具有可持续发展性**\n\n**刘未鹏**先生在书中《暗时间》给出了他对这个问题的补充：\n\n我相信以下的知识技能组合是具有相当程度的不可替代性的：\n**1. 专业领域技能。**\n成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。\n**2. 跨领域的技能。**\n解决问题的能力，创新思维，判断与决策能力，批判性思维，表达沟通能力，等等。\n**3. 学习能力。**\n严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是**持续学习**和**思考知识**。\n**4. 性格要素。**\n严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的），等等。\n\n除了**刘未鹏**先生上面的四点，我需要补充的还有一点：\n**5. 学历与背景**\n虽然在技术圈子不太看重学历，学历并不是能代表一切，但「受教育程度高的人能力也高」是一个高概率事件，这也是各大公司招聘都会以学历来筛选简历的原因之一。而背景就更加重要了，一个人经历了什么，做过什么，都会对个人的价值观、世界观等造成一定量的影响。一个优秀的学历和丰富的背景，并不是别人能轻而易举复制的。\n\n# 最后\n\n我一直很庆幸能接触到计算机领域，然后学会了编程，对其燃起兴趣，并且刚好这门兴趣能成为我的职业，在我享受其带来的乐趣之余，可以提供给我一些物质上的条件。\n**我喜欢的东西变成了我的工作乃至事业**，这比起很多人，已经很幸福了。\n这种幸福来自于：\n发现新的好玩的东西所带来的新鲜感，\n写博客分享知识所带来的认同感，\n做的产品被很多人使用并且创造价值的自豪感，\n还有是对知识的不满足感。\n\n而思考与探索以后是否可以继续让兴趣支持事业成为可能，也是我这个多虑症患者一直在思考的事情。","source":"_posts/何为技术人的核心竞争力.md","raw":"---\ntitle: 何为技术人的核心竞争力\ncategory: 三省吾身\ndate: 2016-08-30 23:05:25\ntags:\n---\n\n在寂静的夜晚上，独自一人在书房中，望着窗外，一片灯火阑珊，一条车水马龙。\n不禁让我抬头四十五度，望着那轮朦胧泛黄的新月，又开始思考起自己的人生。\n\n最初接触编程的是高中碰到的谭浩强的那本《C程序设计》，是不是一本好书，我不想做评价。\n可能是因为我天资愚钝，没能通过自学看懂这本书。\n如果说从大学开始真正拥有编程技能，到现在，已经过去五年光阴，毕业也已经有一年有余。\n虽然自小对计算机(或者说是电脑)感兴趣，但是也因为自身贪玩，兴趣泛滥，好奇心爆棚的个人属性，以致并没有把大部分时间投入这个编程兴趣中。\n要说我编程的功底，也就只有两年的功力。\n\n在一件事情上投入的越多，就会让我更加思考自己正在做的，正在走的方向。\n在高速发展，日新月异的技术圈子中，到底哪些是不变的，或可沉淀的东西。\n渐渐的会想到这样的一个问题：\n**技术人的核心竞争力到底是什么？**\n\n今天受**刘未鹏**先生在书中《暗时间》的介绍，阅读了**孟岩**老师的「[技术路线的选择重要但不具有决定性](http://blog.csdn.net/myan/article/details/3247071)」，这篇文章正好给最近被这个问题困扰的我拨开了一些迷雾。\n这是一篇2008年发表的旧文，文中的观点给了我很多启发，但我也不会有相见恨晚的感觉。就算很早遇到这篇文章，也不会有经历过的事情以及思考过的问题作为基础，故也不能理解体会其中的意思。现在时机正好。\n\n文中把技术人大致的分了四类：\n\n1. 把命运寄托在**事业**上的人\n2. 把命运寄托在**组织**上的人\n3. 把命运寄托在**技术**上的人\n4. 仍然处于出卖劳动力的人\n\n# 做技术的几类人\n\n**第一类是把自己的命运寄托在一项事业上。**\n他们会想着改变一些东西，而技术只是作为其中的手段，他们有能力通过技术实现自己的想法和事业。事业并不是指的创业做老板，而是一件他们认可的事情。比如促进人们交流和言论自由，带给大家更多娱乐，提升大众身心健康水平，增强国家国防实力，或者提升某个行业的信息化水平，能够以技术为手段，在这个事情上做出成绩。他们往往可以终其一生投入到自己的事业中去，在短短的人生中实现价值。到两鬓斑白时，能够回首往事而悠然自得。\n\n**第二类是把自己的命运寄托在组织和团队上**\n他们技术水平出色，综合素质突出，勇于变化，以团队的目标为目标，依据团队的需求而转型或者坚持，跟团队一起干出一番成绩。这些人往往拥有高薪厚禄，以及舒适生活。\n但是中年以后会经常自问到底做了什么自己想做的事情，为自己过于风平浪静的人生感到惆怅。\n\n**第三类是把命运寄托在技术上。**\n他们有能力成为技术的专家，希望把技能当做商品出售，从而谋求富足人生。不想把自己命运跟企业和组织绑定在一起，也不愿意做什么改变，只是满足于技术高手的层面，寄希望于其技术专长能够长期值钱。\n\n**第四种就是处于出卖劳动力的阶段**\n他们往往疲于做业务，单纯积极完成上级或产经下达的任务，鲜有思考需求合理性，或者在大局上关注项目及其进度。他们往往加班成自然，表面上形成勤奋工作的现象，最终却只是为了业绩好些，年终奖多些。\n\n第一类，是做技术的最高层次，终其一生投入到一项事业中，为人类和社会创造价值，这并不是一般人能够做到。而第二类总的来说，层次还是比较高的。在自己的专业领域中颇有建树，并且利用技术给团队带来生产力提高和经济的效益，是真正为团队创造价值的人。而第三类人，却是最危险的。技术的发展与变迁是必然发生的事情，年轻的时候还有能力追逐新技术，但当老了追不动了，很容易就被淘汰了。**被淘汰只是时间问题。如果你认为某个软件技术的兴起或者衰落对你个人的职业生涯构成了决定性的影响，那么你可能正走在错误的路线上，应当尽快改弦更张。**\n\n# 核心竞争力\n\n关于核心竞争力，孟岩先生有这样一段话：\n\n那么核心竞争力是什么？我观察圈子里很多成功和不成功的技术人，提出一个观点，那就是个人的核心竞争力是他**独特的个性知识经验组合**。这个行业里拥挤着上百万聪明人，彼此之间真正的不同在哪里？不在于你学的是什么技术，学得多深，IQ多少，而在于你身上有别人没有的独特的个性、背景、知识和经验的组合。如果这种组合，**1，绝无仅有；2，在实践中有价值，3，具有可持续发展性**，那你就具备核心竞争力。因此，当设计自己的发展路线时，应当最大限度地加强和发挥自己独特的组合，而不是寻求单项的超越。而构建自己独特组合的方式，主要是通过实践，其次是要有意识地构造。关于这个观点，话题太大，我不打算赘述。\n\n个人核心竞争力，并不是对某技术、框架、平台的熟烂于心，也不是什么样的开发思想，更加不是所谓的个人智商问题。而是**独特的个性、知识、经验之间的组合**。\n\n# 不可替代性\n\n孟岩先生在文中并没有对这个问题展开来描述，那么到底什么样的知识技能组合符合下面几种条件的：\n**1. 绝无仅有**\n**2. 在实践中有价值**\n**3. 具有可持续发展性**\n\n**刘未鹏**先生在书中《暗时间》给出了他对这个问题的补充：\n\n我相信以下的知识技能组合是具有相当程度的不可替代性的：\n**1. 专业领域技能。**\n成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。\n**2. 跨领域的技能。**\n解决问题的能力，创新思维，判断与决策能力，批判性思维，表达沟通能力，等等。\n**3. 学习能力。**\n严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是**持续学习**和**思考知识**。\n**4. 性格要素。**\n严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的），等等。\n\n除了**刘未鹏**先生上面的四点，我需要补充的还有一点：\n**5. 学历与背景**\n虽然在技术圈子不太看重学历，学历并不是能代表一切，但「受教育程度高的人能力也高」是一个高概率事件，这也是各大公司招聘都会以学历来筛选简历的原因之一。而背景就更加重要了，一个人经历了什么，做过什么，都会对个人的价值观、世界观等造成一定量的影响。一个优秀的学历和丰富的背景，并不是别人能轻而易举复制的。\n\n# 最后\n\n我一直很庆幸能接触到计算机领域，然后学会了编程，对其燃起兴趣，并且刚好这门兴趣能成为我的职业，在我享受其带来的乐趣之余，可以提供给我一些物质上的条件。\n**我喜欢的东西变成了我的工作乃至事业**，这比起很多人，已经很幸福了。\n这种幸福来自于：\n发现新的好玩的东西所带来的新鲜感，\n写博客分享知识所带来的认同感，\n做的产品被很多人使用并且创造价值的自豪感，\n还有是对知识的不满足感。\n\n而思考与探索以后是否可以继续让兴趣支持事业成为可能，也是我这个多虑症患者一直在思考的事情。","slug":"何为技术人的核心竞争力","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqe002015hloto4hiko","content":"<p>在寂静的夜晚上，独自一人在书房中，望着窗外，一片灯火阑珊，一条车水马龙。<br>不禁让我抬头四十五度，望着那轮朦胧泛黄的新月，又开始思考起自己的人生。</p>\n<p>最初接触编程的是高中碰到的谭浩强的那本《C程序设计》，是不是一本好书，我不想做评价。<br>可能是因为我天资愚钝，没能通过自学看懂这本书。<br>如果说从大学开始真正拥有编程技能，到现在，已经过去五年光阴，毕业也已经有一年有余。<br>虽然自小对计算机(或者说是电脑)感兴趣，但是也因为自身贪玩，兴趣泛滥，好奇心爆棚的个人属性，以致并没有把大部分时间投入这个编程兴趣中。<br>要说我编程的功底，也就只有两年的功力。</p>\n<p>在一件事情上投入的越多，就会让我更加思考自己正在做的，正在走的方向。<br>在高速发展，日新月异的技术圈子中，到底哪些是不变的，或可沉淀的东西。<br>渐渐的会想到这样的一个问题：<br><strong>技术人的核心竞争力到底是什么？</strong></p>\n<p>今天受<strong>刘未鹏</strong>先生在书中《暗时间》的介绍，阅读了<strong>孟岩</strong>老师的「<a href=\"http://blog.csdn.net/myan/article/details/3247071\" target=\"_blank\" rel=\"external\">技术路线的选择重要但不具有决定性</a>」，这篇文章正好给最近被这个问题困扰的我拨开了一些迷雾。<br>这是一篇2008年发表的旧文，文中的观点给了我很多启发，但我也不会有相见恨晚的感觉。就算很早遇到这篇文章，也不会有经历过的事情以及思考过的问题作为基础，故也不能理解体会其中的意思。现在时机正好。</p>\n<p>文中把技术人大致的分了四类：</p>\n<ol>\n<li>把命运寄托在<strong>事业</strong>上的人</li>\n<li>把命运寄托在<strong>组织</strong>上的人</li>\n<li>把命运寄托在<strong>技术</strong>上的人</li>\n<li>仍然处于出卖劳动力的人</li>\n</ol>\n<h1 id=\"做技术的几类人\"><a href=\"#做技术的几类人\" class=\"headerlink\" title=\"做技术的几类人\"></a>做技术的几类人</h1><p><strong>第一类是把自己的命运寄托在一项事业上。</strong><br>他们会想着改变一些东西，而技术只是作为其中的手段，他们有能力通过技术实现自己的想法和事业。事业并不是指的创业做老板，而是一件他们认可的事情。比如促进人们交流和言论自由，带给大家更多娱乐，提升大众身心健康水平，增强国家国防实力，或者提升某个行业的信息化水平，能够以技术为手段，在这个事情上做出成绩。他们往往可以终其一生投入到自己的事业中去，在短短的人生中实现价值。到两鬓斑白时，能够回首往事而悠然自得。</p>\n<p><strong>第二类是把自己的命运寄托在组织和团队上</strong><br>他们技术水平出色，综合素质突出，勇于变化，以团队的目标为目标，依据团队的需求而转型或者坚持，跟团队一起干出一番成绩。这些人往往拥有高薪厚禄，以及舒适生活。<br>但是中年以后会经常自问到底做了什么自己想做的事情，为自己过于风平浪静的人生感到惆怅。</p>\n<p><strong>第三类是把命运寄托在技术上。</strong><br>他们有能力成为技术的专家，希望把技能当做商品出售，从而谋求富足人生。不想把自己命运跟企业和组织绑定在一起，也不愿意做什么改变，只是满足于技术高手的层面，寄希望于其技术专长能够长期值钱。</p>\n<p><strong>第四种就是处于出卖劳动力的阶段</strong><br>他们往往疲于做业务，单纯积极完成上级或产经下达的任务，鲜有思考需求合理性，或者在大局上关注项目及其进度。他们往往加班成自然，表面上形成勤奋工作的现象，最终却只是为了业绩好些，年终奖多些。</p>\n<p>第一类，是做技术的最高层次，终其一生投入到一项事业中，为人类和社会创造价值，这并不是一般人能够做到。而第二类总的来说，层次还是比较高的。在自己的专业领域中颇有建树，并且利用技术给团队带来生产力提高和经济的效益，是真正为团队创造价值的人。而第三类人，却是最危险的。技术的发展与变迁是必然发生的事情，年轻的时候还有能力追逐新技术，但当老了追不动了，很容易就被淘汰了。<strong>被淘汰只是时间问题。如果你认为某个软件技术的兴起或者衰落对你个人的职业生涯构成了决定性的影响，那么你可能正走在错误的路线上，应当尽快改弦更张。</strong></p>\n<h1 id=\"核心竞争力\"><a href=\"#核心竞争力\" class=\"headerlink\" title=\"核心竞争力\"></a>核心竞争力</h1><p>关于核心竞争力，孟岩先生有这样一段话：</p>\n<p>那么核心竞争力是什么？我观察圈子里很多成功和不成功的技术人，提出一个观点，那就是个人的核心竞争力是他<strong>独特的个性知识经验组合</strong>。这个行业里拥挤着上百万聪明人，彼此之间真正的不同在哪里？不在于你学的是什么技术，学得多深，IQ多少，而在于你身上有别人没有的独特的个性、背景、知识和经验的组合。如果这种组合，<strong>1，绝无仅有；2，在实践中有价值，3，具有可持续发展性</strong>，那你就具备核心竞争力。因此，当设计自己的发展路线时，应当最大限度地加强和发挥自己独特的组合，而不是寻求单项的超越。而构建自己独特组合的方式，主要是通过实践，其次是要有意识地构造。关于这个观点，话题太大，我不打算赘述。</p>\n<p>个人核心竞争力，并不是对某技术、框架、平台的熟烂于心，也不是什么样的开发思想，更加不是所谓的个人智商问题。而是<strong>独特的个性、知识、经验之间的组合</strong>。</p>\n<h1 id=\"不可替代性\"><a href=\"#不可替代性\" class=\"headerlink\" title=\"不可替代性\"></a>不可替代性</h1><p>孟岩先生在文中并没有对这个问题展开来描述，那么到底什么样的知识技能组合符合下面几种条件的：<br><strong>1. 绝无仅有</strong><br><strong>2. 在实践中有价值</strong><br><strong>3. 具有可持续发展性</strong></p>\n<p><strong>刘未鹏</strong>先生在书中《暗时间》给出了他对这个问题的补充：</p>\n<p>我相信以下的知识技能组合是具有相当程度的不可替代性的：<br><strong>1. 专业领域技能。</strong><br>成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。<br><strong>2. 跨领域的技能。</strong><br>解决问题的能力，创新思维，判断与决策能力，批判性思维，表达沟通能力，等等。<br><strong>3. 学习能力。</strong><br>严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是<strong>持续学习</strong>和<strong>思考知识</strong>。<br><strong>4. 性格要素。</strong><br>严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的），等等。</p>\n<p>除了<strong>刘未鹏</strong>先生上面的四点，我需要补充的还有一点：<br><strong>5. 学历与背景</strong><br>虽然在技术圈子不太看重学历，学历并不是能代表一切，但「受教育程度高的人能力也高」是一个高概率事件，这也是各大公司招聘都会以学历来筛选简历的原因之一。而背景就更加重要了，一个人经历了什么，做过什么，都会对个人的价值观、世界观等造成一定量的影响。一个优秀的学历和丰富的背景，并不是别人能轻而易举复制的。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>我一直很庆幸能接触到计算机领域，然后学会了编程，对其燃起兴趣，并且刚好这门兴趣能成为我的职业，在我享受其带来的乐趣之余，可以提供给我一些物质上的条件。<br><strong>我喜欢的东西变成了我的工作乃至事业</strong>，这比起很多人，已经很幸福了。<br>这种幸福来自于：<br>发现新的好玩的东西所带来的新鲜感，<br>写博客分享知识所带来的认同感，<br>做的产品被很多人使用并且创造价值的自豪感，<br>还有是对知识的不满足感。</p>\n<p>而思考与探索以后是否可以继续让兴趣支持事业成为可能，也是我这个多虑症患者一直在思考的事情。</p>\n","excerpt":"","more":"<p>在寂静的夜晚上，独自一人在书房中，望着窗外，一片灯火阑珊，一条车水马龙。<br>不禁让我抬头四十五度，望着那轮朦胧泛黄的新月，又开始思考起自己的人生。</p>\n<p>最初接触编程的是高中碰到的谭浩强的那本《C程序设计》，是不是一本好书，我不想做评价。<br>可能是因为我天资愚钝，没能通过自学看懂这本书。<br>如果说从大学开始真正拥有编程技能，到现在，已经过去五年光阴，毕业也已经有一年有余。<br>虽然自小对计算机(或者说是电脑)感兴趣，但是也因为自身贪玩，兴趣泛滥，好奇心爆棚的个人属性，以致并没有把大部分时间投入这个编程兴趣中。<br>要说我编程的功底，也就只有两年的功力。</p>\n<p>在一件事情上投入的越多，就会让我更加思考自己正在做的，正在走的方向。<br>在高速发展，日新月异的技术圈子中，到底哪些是不变的，或可沉淀的东西。<br>渐渐的会想到这样的一个问题：<br><strong>技术人的核心竞争力到底是什么？</strong></p>\n<p>今天受<strong>刘未鹏</strong>先生在书中《暗时间》的介绍，阅读了<strong>孟岩</strong>老师的「<a href=\"http://blog.csdn.net/myan/article/details/3247071\">技术路线的选择重要但不具有决定性</a>」，这篇文章正好给最近被这个问题困扰的我拨开了一些迷雾。<br>这是一篇2008年发表的旧文，文中的观点给了我很多启发，但我也不会有相见恨晚的感觉。就算很早遇到这篇文章，也不会有经历过的事情以及思考过的问题作为基础，故也不能理解体会其中的意思。现在时机正好。</p>\n<p>文中把技术人大致的分了四类：</p>\n<ol>\n<li>把命运寄托在<strong>事业</strong>上的人</li>\n<li>把命运寄托在<strong>组织</strong>上的人</li>\n<li>把命运寄托在<strong>技术</strong>上的人</li>\n<li>仍然处于出卖劳动力的人</li>\n</ol>\n<h1 id=\"做技术的几类人\"><a href=\"#做技术的几类人\" class=\"headerlink\" title=\"做技术的几类人\"></a>做技术的几类人</h1><p><strong>第一类是把自己的命运寄托在一项事业上。</strong><br>他们会想着改变一些东西，而技术只是作为其中的手段，他们有能力通过技术实现自己的想法和事业。事业并不是指的创业做老板，而是一件他们认可的事情。比如促进人们交流和言论自由，带给大家更多娱乐，提升大众身心健康水平，增强国家国防实力，或者提升某个行业的信息化水平，能够以技术为手段，在这个事情上做出成绩。他们往往可以终其一生投入到自己的事业中去，在短短的人生中实现价值。到两鬓斑白时，能够回首往事而悠然自得。</p>\n<p><strong>第二类是把自己的命运寄托在组织和团队上</strong><br>他们技术水平出色，综合素质突出，勇于变化，以团队的目标为目标，依据团队的需求而转型或者坚持，跟团队一起干出一番成绩。这些人往往拥有高薪厚禄，以及舒适生活。<br>但是中年以后会经常自问到底做了什么自己想做的事情，为自己过于风平浪静的人生感到惆怅。</p>\n<p><strong>第三类是把命运寄托在技术上。</strong><br>他们有能力成为技术的专家，希望把技能当做商品出售，从而谋求富足人生。不想把自己命运跟企业和组织绑定在一起，也不愿意做什么改变，只是满足于技术高手的层面，寄希望于其技术专长能够长期值钱。</p>\n<p><strong>第四种就是处于出卖劳动力的阶段</strong><br>他们往往疲于做业务，单纯积极完成上级或产经下达的任务，鲜有思考需求合理性，或者在大局上关注项目及其进度。他们往往加班成自然，表面上形成勤奋工作的现象，最终却只是为了业绩好些，年终奖多些。</p>\n<p>第一类，是做技术的最高层次，终其一生投入到一项事业中，为人类和社会创造价值，这并不是一般人能够做到。而第二类总的来说，层次还是比较高的。在自己的专业领域中颇有建树，并且利用技术给团队带来生产力提高和经济的效益，是真正为团队创造价值的人。而第三类人，却是最危险的。技术的发展与变迁是必然发生的事情，年轻的时候还有能力追逐新技术，但当老了追不动了，很容易就被淘汰了。<strong>被淘汰只是时间问题。如果你认为某个软件技术的兴起或者衰落对你个人的职业生涯构成了决定性的影响，那么你可能正走在错误的路线上，应当尽快改弦更张。</strong></p>\n<h1 id=\"核心竞争力\"><a href=\"#核心竞争力\" class=\"headerlink\" title=\"核心竞争力\"></a>核心竞争力</h1><p>关于核心竞争力，孟岩先生有这样一段话：</p>\n<p>那么核心竞争力是什么？我观察圈子里很多成功和不成功的技术人，提出一个观点，那就是个人的核心竞争力是他<strong>独特的个性知识经验组合</strong>。这个行业里拥挤着上百万聪明人，彼此之间真正的不同在哪里？不在于你学的是什么技术，学得多深，IQ多少，而在于你身上有别人没有的独特的个性、背景、知识和经验的组合。如果这种组合，<strong>1，绝无仅有；2，在实践中有价值，3，具有可持续发展性</strong>，那你就具备核心竞争力。因此，当设计自己的发展路线时，应当最大限度地加强和发挥自己独特的组合，而不是寻求单项的超越。而构建自己独特组合的方式，主要是通过实践，其次是要有意识地构造。关于这个观点，话题太大，我不打算赘述。</p>\n<p>个人核心竞争力，并不是对某技术、框架、平台的熟烂于心，也不是什么样的开发思想，更加不是所谓的个人智商问题。而是<strong>独特的个性、知识、经验之间的组合</strong>。</p>\n<h1 id=\"不可替代性\"><a href=\"#不可替代性\" class=\"headerlink\" title=\"不可替代性\"></a>不可替代性</h1><p>孟岩先生在文中并没有对这个问题展开来描述，那么到底什么样的知识技能组合符合下面几种条件的：<br><strong>1. 绝无仅有</strong><br><strong>2. 在实践中有价值</strong><br><strong>3. 具有可持续发展性</strong></p>\n<p><strong>刘未鹏</strong>先生在书中《暗时间》给出了他对这个问题的补充：</p>\n<p>我相信以下的知识技能组合是具有相当程度的不可替代性的：<br><strong>1. 专业领域技能。</strong><br>成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。<br><strong>2. 跨领域的技能。</strong><br>解决问题的能力，创新思维，判断与决策能力，批判性思维，表达沟通能力，等等。<br><strong>3. 学习能力。</strong><br>严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是<strong>持续学习</strong>和<strong>思考知识</strong>。<br><strong>4. 性格要素。</strong><br>严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的），等等。</p>\n<p>除了<strong>刘未鹏</strong>先生上面的四点，我需要补充的还有一点：<br><strong>5. 学历与背景</strong><br>虽然在技术圈子不太看重学历，学历并不是能代表一切，但「受教育程度高的人能力也高」是一个高概率事件，这也是各大公司招聘都会以学历来筛选简历的原因之一。而背景就更加重要了，一个人经历了什么，做过什么，都会对个人的价值观、世界观等造成一定量的影响。一个优秀的学历和丰富的背景，并不是别人能轻而易举复制的。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>我一直很庆幸能接触到计算机领域，然后学会了编程，对其燃起兴趣，并且刚好这门兴趣能成为我的职业，在我享受其带来的乐趣之余，可以提供给我一些物质上的条件。<br><strong>我喜欢的东西变成了我的工作乃至事业</strong>，这比起很多人，已经很幸福了。<br>这种幸福来自于：<br>发现新的好玩的东西所带来的新鲜感，<br>写博客分享知识所带来的认同感，<br>做的产品被很多人使用并且创造价值的自豪感，<br>还有是对知识的不满足感。</p>\n<p>而思考与探索以后是否可以继续让兴趣支持事业成为可能，也是我这个多虑症患者一直在思考的事情。</p>\n"},{"title":"何为语法树","date":"2016-03-14T16:04:49.000Z","_content":"\n## 什么是语法树？\n\n> 你是否曾想过，这个世界存在这么多语言的意义。\n\n假如现在你面前有一个物体，它是一个不规则的圆体，整个身体通红，头部还有一根细长稍微弯曲偏右呈棕色的圆柱体。    \n在中文我们称之为「苹果」，    \n在英文我们称之为「Apple」，    \n在日文中我们称之为「アップル」，    \n在法语中我们称之为「pomme」，    \n在德语中我们称之为「Apfel」，    \n无论用不同的语言，针对这个物体在文字上、发音上都完全不一样，但这个物体确确实实的存在这个时空上，颜色、气味、形状都不曾因为语言而改变过。    \n\n> 无论这个世界存在多少语言，它们所描述的真理都不曾改变过。\n\n或者说，真理就存在那里，可以用不同的语言的不同表达方式描述出来。那么计算机的世界，这么多编程的语言，C、C++、Java、C#、JavaScript、Python、Go、Ruby等等等，它们共同所描述的真理是什么？\n\n我们知道人类语言上，无论什么语种，都会有「主语」「动词」「宾语」「标点符号」来描述一个现实世界所发生的事件。\n而在计算机编程语言上，无论什么语种，都会有「类型」「运算符」「流程语句」「函数」「对象」等概念来表达计算机中存在内存中的0和1，以及背后运算与逻辑。\n\n> 语法树，计算机描述世界真理的树状结构。\n\n不同的语言，都会配之不同的语法分析器，而语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。语法的设计和语法分析器的实现是决定语言外在表现的重要因素。    \n什么是语法树？摘自Wiki一段：\n\n> 在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。\n\n## 一则简单的例子\n如果我们需要让计算机帮忙算一下 「1加2再乘以3」 的结果，该怎么表达呢？    \n现在我们大多数的现代编程语言，都是使用「中缀表达式」的方式来编写运算，比如JavaScript：\n\n```\n(1 + 2) * 3\n```\n\n而FORTH语言则使用「后缀表达式」，这基本上与日语中的语序是一致的：\n\n```\n1 2 + 3 *\n```\n\nLISP语言使用的「前缀表达式」：\n\n```\n( * (+ 1 2) 3)\n```\n\n我们再看一下这三种表达式的语法树：\n\n![表达式语法树比较](/image/blog/whatisAST/表达式语法树比较.png)\n\n可以看出，对于这三种简单的语言，它们只是在这个语法树上按不同的规则遍历而已。三者的代码看起来差别很大，但实际上所用的树结构是相同的。\n\n## 先来看看Python的语法树\n通过Python语言自带的库文件ast，我们可以查看特定的代码被转换成怎样的语法树。\n\n```\n>>> import ast\n>>> ast.dump(ast.parse(\"(1 + 2) * 3\"))\n'Module(\n\tbody=[\n\t\tExpr(\n\t\t\tvalue=BinOp(\n\t\t\t\tleft=BinOp(\n\t\t\t\t\tleft=Num(n=1), \n\t\t\t\t\top=Add(), \n\t\t\t\t\tright=Num(n=2)\n\t\t\t\t), \n\t\t\t\top=Mult(), \n\t\t\t\tright=Num(n=3)\n\t\t\t)\n\t\t)\n\t]\n)'\n```\n\n\n`BinOp op = Mult()`表示乘法运算，与`*`相对应；    \n`BinOp op = Add()`表示加法运算，与`+`相对应；    \n`Num n = 1`既为数值1。\n\n![Python语法树](/image/blog/whatisAST/Python语法树.png)\n\n\n## 再窥视一下JavaScript的语法树\n> 在语法复杂的语言中，语法树是包含很多细节的语法结果表达式，我们需要靠语法树把这种形式以更简洁的形式表达出来。\n\nJavascript 有不少工具可以把代码构造出清晰的语法树，比如 [esprima](http://esprima.org/ )、[v8](https://code.google.com/p/v8/source/browse/branches/bleeding_edge/src/ast.h)、[SpiderMonkey](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API)、[UglifyJS](http://lisperator.net/uglifyjs/)、[AST explorer](http://astexplorer.net/)等。\n\n这里，我使用「esprima」来探讨一下JavaScript运算`(1 + 2) * 3`的语法树。\n\njavascript code: \n\n```\n(1 + 2)* 3;\n```\n\nast for json:\n\n```\n{\n    \"type\": \"Program\",\n    \"body\": [\n        {\n            \"type\": \"ExpressionStatement\",\n            \"expression\": {\n                \"type\": \"BinaryExpression\",\n                \"operator\": \"*\",\n                \"left\": {\n                    \"type\": \"BinaryExpression\",\n                    \"operator\": \"+\",\n                    \"left\": {\n                        \"type\": \"Literal\",\n                        \"value\": 1,\n                        \"raw\": \"1\"\n                    },\n                    \"right\": {\n                        \"type\": \"Literal\",\n                        \"value\": 2,\n                        \"raw\": \"2\"\n                    }\n                },\n                \"right\": {\n                    \"type\": \"Literal\",\n                    \"value\": 3,\n                    \"raw\": \"3\"\n                }\n            }\n        }\n    ],\n    \"sourceType\": \"script\"\n}\n```\n\n`body`表示程序体，而程序体中包含了一则表达式`ExpressionStatement`, 表达式体里包含了操作符 `*`,以及左右两边表达式，其中右边是数字`3`,而左边表达式还包含一层表达式，里面是一个`+` 操作符，以及左右两边分别为`1`和`2`的数字。\n\n![javascript语法树](/image/blog/whatisAST/javascript语法树.png)\n\n\n如果还没有看懂，你可以到这里看一下这段代码所生成的语法树：[AST for (1 + 2)* 3;](http://esprima.org/demo/parse.html?code=%2F%2F%20Life%2C%20Universe%2C%20and%20Everything%0A(1%20%2B%202)*%203%0A)\n\n\n## 我们可以利用语法树做些什么？\n看到这里你可能会问，知道语法是又有什么用呢？跟我日常编写代码貌似半毛钱关系都没有。其实语法树还是很有用的，想一下如果想做「语法高亮」、「关键字匹配」、「作用域判断」、以及「代码压缩」等等，都是最好把代码解构成语法树之后再去各种操作，当然仅仅解构还不够，还需要提供各种函数去遍历与修改语法树。\n\n另一方面，去研究、去探讨计算机真实的世界不是一个很精彩很刺激的过程么？\n\n\n\n","source":"_posts/何为语法树.md","raw":"---\ntitle: 何为语法树\ncategory: 搬砖码农\ndate: 2016-3-15 00:04:49\ntags:\n- 语法树\n---\n\n## 什么是语法树？\n\n> 你是否曾想过，这个世界存在这么多语言的意义。\n\n假如现在你面前有一个物体，它是一个不规则的圆体，整个身体通红，头部还有一根细长稍微弯曲偏右呈棕色的圆柱体。    \n在中文我们称之为「苹果」，    \n在英文我们称之为「Apple」，    \n在日文中我们称之为「アップル」，    \n在法语中我们称之为「pomme」，    \n在德语中我们称之为「Apfel」，    \n无论用不同的语言，针对这个物体在文字上、发音上都完全不一样，但这个物体确确实实的存在这个时空上，颜色、气味、形状都不曾因为语言而改变过。    \n\n> 无论这个世界存在多少语言，它们所描述的真理都不曾改变过。\n\n或者说，真理就存在那里，可以用不同的语言的不同表达方式描述出来。那么计算机的世界，这么多编程的语言，C、C++、Java、C#、JavaScript、Python、Go、Ruby等等等，它们共同所描述的真理是什么？\n\n我们知道人类语言上，无论什么语种，都会有「主语」「动词」「宾语」「标点符号」来描述一个现实世界所发生的事件。\n而在计算机编程语言上，无论什么语种，都会有「类型」「运算符」「流程语句」「函数」「对象」等概念来表达计算机中存在内存中的0和1，以及背后运算与逻辑。\n\n> 语法树，计算机描述世界真理的树状结构。\n\n不同的语言，都会配之不同的语法分析器，而语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。语法的设计和语法分析器的实现是决定语言外在表现的重要因素。    \n什么是语法树？摘自Wiki一段：\n\n> 在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。\n\n## 一则简单的例子\n如果我们需要让计算机帮忙算一下 「1加2再乘以3」 的结果，该怎么表达呢？    \n现在我们大多数的现代编程语言，都是使用「中缀表达式」的方式来编写运算，比如JavaScript：\n\n```\n(1 + 2) * 3\n```\n\n而FORTH语言则使用「后缀表达式」，这基本上与日语中的语序是一致的：\n\n```\n1 2 + 3 *\n```\n\nLISP语言使用的「前缀表达式」：\n\n```\n( * (+ 1 2) 3)\n```\n\n我们再看一下这三种表达式的语法树：\n\n![表达式语法树比较](/image/blog/whatisAST/表达式语法树比较.png)\n\n可以看出，对于这三种简单的语言，它们只是在这个语法树上按不同的规则遍历而已。三者的代码看起来差别很大，但实际上所用的树结构是相同的。\n\n## 先来看看Python的语法树\n通过Python语言自带的库文件ast，我们可以查看特定的代码被转换成怎样的语法树。\n\n```\n>>> import ast\n>>> ast.dump(ast.parse(\"(1 + 2) * 3\"))\n'Module(\n\tbody=[\n\t\tExpr(\n\t\t\tvalue=BinOp(\n\t\t\t\tleft=BinOp(\n\t\t\t\t\tleft=Num(n=1), \n\t\t\t\t\top=Add(), \n\t\t\t\t\tright=Num(n=2)\n\t\t\t\t), \n\t\t\t\top=Mult(), \n\t\t\t\tright=Num(n=3)\n\t\t\t)\n\t\t)\n\t]\n)'\n```\n\n\n`BinOp op = Mult()`表示乘法运算，与`*`相对应；    \n`BinOp op = Add()`表示加法运算，与`+`相对应；    \n`Num n = 1`既为数值1。\n\n![Python语法树](/image/blog/whatisAST/Python语法树.png)\n\n\n## 再窥视一下JavaScript的语法树\n> 在语法复杂的语言中，语法树是包含很多细节的语法结果表达式，我们需要靠语法树把这种形式以更简洁的形式表达出来。\n\nJavascript 有不少工具可以把代码构造出清晰的语法树，比如 [esprima](http://esprima.org/ )、[v8](https://code.google.com/p/v8/source/browse/branches/bleeding_edge/src/ast.h)、[SpiderMonkey](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API)、[UglifyJS](http://lisperator.net/uglifyjs/)、[AST explorer](http://astexplorer.net/)等。\n\n这里，我使用「esprima」来探讨一下JavaScript运算`(1 + 2) * 3`的语法树。\n\njavascript code: \n\n```\n(1 + 2)* 3;\n```\n\nast for json:\n\n```\n{\n    \"type\": \"Program\",\n    \"body\": [\n        {\n            \"type\": \"ExpressionStatement\",\n            \"expression\": {\n                \"type\": \"BinaryExpression\",\n                \"operator\": \"*\",\n                \"left\": {\n                    \"type\": \"BinaryExpression\",\n                    \"operator\": \"+\",\n                    \"left\": {\n                        \"type\": \"Literal\",\n                        \"value\": 1,\n                        \"raw\": \"1\"\n                    },\n                    \"right\": {\n                        \"type\": \"Literal\",\n                        \"value\": 2,\n                        \"raw\": \"2\"\n                    }\n                },\n                \"right\": {\n                    \"type\": \"Literal\",\n                    \"value\": 3,\n                    \"raw\": \"3\"\n                }\n            }\n        }\n    ],\n    \"sourceType\": \"script\"\n}\n```\n\n`body`表示程序体，而程序体中包含了一则表达式`ExpressionStatement`, 表达式体里包含了操作符 `*`,以及左右两边表达式，其中右边是数字`3`,而左边表达式还包含一层表达式，里面是一个`+` 操作符，以及左右两边分别为`1`和`2`的数字。\n\n![javascript语法树](/image/blog/whatisAST/javascript语法树.png)\n\n\n如果还没有看懂，你可以到这里看一下这段代码所生成的语法树：[AST for (1 + 2)* 3;](http://esprima.org/demo/parse.html?code=%2F%2F%20Life%2C%20Universe%2C%20and%20Everything%0A(1%20%2B%202)*%203%0A)\n\n\n## 我们可以利用语法树做些什么？\n看到这里你可能会问，知道语法是又有什么用呢？跟我日常编写代码貌似半毛钱关系都没有。其实语法树还是很有用的，想一下如果想做「语法高亮」、「关键字匹配」、「作用域判断」、以及「代码压缩」等等，都是最好把代码解构成语法树之后再去各种操作，当然仅仅解构还不够，还需要提供各种函数去遍历与修改语法树。\n\n另一方面，去研究、去探讨计算机真实的世界不是一个很精彩很刺激的过程么？\n\n\n\n","slug":"何为语法树","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqf002215hlrjxf7h6i","content":"<h2 id=\"什么是语法树？\"><a href=\"#什么是语法树？\" class=\"headerlink\" title=\"什么是语法树？\"></a>什么是语法树？</h2><blockquote>\n<p>你是否曾想过，这个世界存在这么多语言的意义。</p>\n</blockquote>\n<p>假如现在你面前有一个物体，它是一个不规则的圆体，整个身体通红，头部还有一根细长稍微弯曲偏右呈棕色的圆柱体。<br>在中文我们称之为「苹果」，<br>在英文我们称之为「Apple」，<br>在日文中我们称之为「アップル」，<br>在法语中我们称之为「pomme」，<br>在德语中我们称之为「Apfel」，<br>无论用不同的语言，针对这个物体在文字上、发音上都完全不一样，但这个物体确确实实的存在这个时空上，颜色、气味、形状都不曾因为语言而改变过。    </p>\n<blockquote>\n<p>无论这个世界存在多少语言，它们所描述的真理都不曾改变过。</p>\n</blockquote>\n<p>或者说，真理就存在那里，可以用不同的语言的不同表达方式描述出来。那么计算机的世界，这么多编程的语言，C、C++、Java、C#、JavaScript、Python、Go、Ruby等等等，它们共同所描述的真理是什么？</p>\n<p>我们知道人类语言上，无论什么语种，都会有「主语」「动词」「宾语」「标点符号」来描述一个现实世界所发生的事件。<br>而在计算机编程语言上，无论什么语种，都会有「类型」「运算符」「流程语句」「函数」「对象」等概念来表达计算机中存在内存中的0和1，以及背后运算与逻辑。</p>\n<blockquote>\n<p>语法树，计算机描述世界真理的树状结构。</p>\n</blockquote>\n<p>不同的语言，都会配之不同的语法分析器，而语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。语法的设计和语法分析器的实现是决定语言外在表现的重要因素。<br>什么是语法树？摘自Wiki一段：</p>\n<blockquote>\n<p>在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p>\n</blockquote>\n<h2 id=\"一则简单的例子\"><a href=\"#一则简单的例子\" class=\"headerlink\" title=\"一则简单的例子\"></a>一则简单的例子</h2><p>如果我们需要让计算机帮忙算一下 「1加2再乘以3」 的结果，该怎么表达呢？<br>现在我们大多数的现代编程语言，都是使用「中缀表达式」的方式来编写运算，比如JavaScript：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(1 + 2) * 3</div></pre></td></tr></table></figure>\n<p>而FORTH语言则使用「后缀表达式」，这基本上与日语中的语序是一致的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">1 2 + 3 *</div></pre></td></tr></table></figure>\n<p>LISP语言使用的「前缀表达式」：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">( * (+ 1 2) 3)</div></pre></td></tr></table></figure>\n<p>我们再看一下这三种表达式的语法树：</p>\n<p><img src=\"/image/blog/whatisAST/表达式语法树比较.png\" alt=\"表达式语法树比较\"></p>\n<p>可以看出，对于这三种简单的语言，它们只是在这个语法树上按不同的规则遍历而已。三者的代码看起来差别很大，但实际上所用的树结构是相同的。</p>\n<h2 id=\"先来看看Python的语法树\"><a href=\"#先来看看Python的语法树\" class=\"headerlink\" title=\"先来看看Python的语法树\"></a>先来看看Python的语法树</h2><p>通过Python语言自带的库文件ast，我们可以查看特定的代码被转换成怎样的语法树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; import ast</div><div class=\"line\">&gt;&gt;&gt; ast.dump(ast.parse(&quot;(1 + 2) * 3&quot;))</div><div class=\"line\">&apos;Module(</div><div class=\"line\">\tbody=[</div><div class=\"line\">\t\tExpr(</div><div class=\"line\">\t\t\tvalue=BinOp(</div><div class=\"line\">\t\t\t\tleft=BinOp(</div><div class=\"line\">\t\t\t\t\tleft=Num(n=1), </div><div class=\"line\">\t\t\t\t\top=Add(), </div><div class=\"line\">\t\t\t\t\tright=Num(n=2)</div><div class=\"line\">\t\t\t\t), </div><div class=\"line\">\t\t\t\top=Mult(), </div><div class=\"line\">\t\t\t\tright=Num(n=3)</div><div class=\"line\">\t\t\t)</div><div class=\"line\">\t\t)</div><div class=\"line\">\t]</div><div class=\"line\">)&apos;</div></pre></td></tr></table></figure>\n<p><code>BinOp op = Mult()</code>表示乘法运算，与<code>*</code>相对应；<br><code>BinOp op = Add()</code>表示加法运算，与<code>+</code>相对应；<br><code>Num n = 1</code>既为数值1。</p>\n<p><img src=\"/image/blog/whatisAST/Python语法树.png\" alt=\"Python语法树\"></p>\n<h2 id=\"再窥视一下JavaScript的语法树\"><a href=\"#再窥视一下JavaScript的语法树\" class=\"headerlink\" title=\"再窥视一下JavaScript的语法树\"></a>再窥视一下JavaScript的语法树</h2><blockquote>\n<p>在语法复杂的语言中，语法树是包含很多细节的语法结果表达式，我们需要靠语法树把这种形式以更简洁的形式表达出来。</p>\n</blockquote>\n<p>Javascript 有不少工具可以把代码构造出清晰的语法树，比如 <a href=\"http://esprima.org/\" target=\"_blank\" rel=\"external\">esprima</a>、<a href=\"https://code.google.com/p/v8/source/browse/branches/bleeding_edge/src/ast.h\" target=\"_blank\" rel=\"external\">v8</a>、<a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API\" target=\"_blank\" rel=\"external\">SpiderMonkey</a>、<a href=\"http://lisperator.net/uglifyjs/\" target=\"_blank\" rel=\"external\">UglifyJS</a>、<a href=\"http://astexplorer.net/\" target=\"_blank\" rel=\"external\">AST explorer</a>等。</p>\n<p>这里，我使用「esprima」来探讨一下JavaScript运算<code>(1 + 2) * 3</code>的语法树。</p>\n<p>javascript code: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(1 + 2)* 3;</div></pre></td></tr></table></figure>\n<p>ast for json:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;type&quot;: &quot;Program&quot;,</div><div class=\"line\">    &quot;body&quot;: [</div><div class=\"line\">        &#123;</div><div class=\"line\">            &quot;type&quot;: &quot;ExpressionStatement&quot;,</div><div class=\"line\">            &quot;expression&quot;: &#123;</div><div class=\"line\">                &quot;type&quot;: &quot;BinaryExpression&quot;,</div><div class=\"line\">                &quot;operator&quot;: &quot;*&quot;,</div><div class=\"line\">                &quot;left&quot;: &#123;</div><div class=\"line\">                    &quot;type&quot;: &quot;BinaryExpression&quot;,</div><div class=\"line\">                    &quot;operator&quot;: &quot;+&quot;,</div><div class=\"line\">                    &quot;left&quot;: &#123;</div><div class=\"line\">                        &quot;type&quot;: &quot;Literal&quot;,</div><div class=\"line\">                        &quot;value&quot;: 1,</div><div class=\"line\">                        &quot;raw&quot;: &quot;1&quot;</div><div class=\"line\">                    &#125;,</div><div class=\"line\">                    &quot;right&quot;: &#123;</div><div class=\"line\">                        &quot;type&quot;: &quot;Literal&quot;,</div><div class=\"line\">                        &quot;value&quot;: 2,</div><div class=\"line\">                        &quot;raw&quot;: &quot;2&quot;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;,</div><div class=\"line\">                &quot;right&quot;: &#123;</div><div class=\"line\">                    &quot;type&quot;: &quot;Literal&quot;,</div><div class=\"line\">                    &quot;value&quot;: 3,</div><div class=\"line\">                    &quot;raw&quot;: &quot;3&quot;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;sourceType&quot;: &quot;script&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>body</code>表示程序体，而程序体中包含了一则表达式<code>ExpressionStatement</code>, 表达式体里包含了操作符 <code>*</code>,以及左右两边表达式，其中右边是数字<code>3</code>,而左边表达式还包含一层表达式，里面是一个<code>+</code> 操作符，以及左右两边分别为<code>1</code>和<code>2</code>的数字。</p>\n<p><img src=\"/image/blog/whatisAST/javascript语法树.png\" alt=\"javascript语法树\"></p>\n<p>如果还没有看懂，你可以到这里看一下这段代码所生成的语法树：<a href=\"http://esprima.org/demo/parse.html?code=%2F%2F%20Life%2C%20Universe%2C%20and%20Everything%0A(1%20%2B%202\" target=\"_blank\" rel=\"external\">AST for (1 + 2)* 3;</a>*%203%0A)</p>\n<h2 id=\"我们可以利用语法树做些什么？\"><a href=\"#我们可以利用语法树做些什么？\" class=\"headerlink\" title=\"我们可以利用语法树做些什么？\"></a>我们可以利用语法树做些什么？</h2><p>看到这里你可能会问，知道语法是又有什么用呢？跟我日常编写代码貌似半毛钱关系都没有。其实语法树还是很有用的，想一下如果想做「语法高亮」、「关键字匹配」、「作用域判断」、以及「代码压缩」等等，都是最好把代码解构成语法树之后再去各种操作，当然仅仅解构还不够，还需要提供各种函数去遍历与修改语法树。</p>\n<p>另一方面，去研究、去探讨计算机真实的世界不是一个很精彩很刺激的过程么？</p>\n","excerpt":"","more":"<h2 id=\"什么是语法树？\"><a href=\"#什么是语法树？\" class=\"headerlink\" title=\"什么是语法树？\"></a>什么是语法树？</h2><blockquote>\n<p>你是否曾想过，这个世界存在这么多语言的意义。</p>\n</blockquote>\n<p>假如现在你面前有一个物体，它是一个不规则的圆体，整个身体通红，头部还有一根细长稍微弯曲偏右呈棕色的圆柱体。<br>在中文我们称之为「苹果」，<br>在英文我们称之为「Apple」，<br>在日文中我们称之为「アップル」，<br>在法语中我们称之为「pomme」，<br>在德语中我们称之为「Apfel」，<br>无论用不同的语言，针对这个物体在文字上、发音上都完全不一样，但这个物体确确实实的存在这个时空上，颜色、气味、形状都不曾因为语言而改变过。    </p>\n<blockquote>\n<p>无论这个世界存在多少语言，它们所描述的真理都不曾改变过。</p>\n</blockquote>\n<p>或者说，真理就存在那里，可以用不同的语言的不同表达方式描述出来。那么计算机的世界，这么多编程的语言，C、C++、Java、C#、JavaScript、Python、Go、Ruby等等等，它们共同所描述的真理是什么？</p>\n<p>我们知道人类语言上，无论什么语种，都会有「主语」「动词」「宾语」「标点符号」来描述一个现实世界所发生的事件。<br>而在计算机编程语言上，无论什么语种，都会有「类型」「运算符」「流程语句」「函数」「对象」等概念来表达计算机中存在内存中的0和1，以及背后运算与逻辑。</p>\n<blockquote>\n<p>语法树，计算机描述世界真理的树状结构。</p>\n</blockquote>\n<p>不同的语言，都会配之不同的语法分析器，而语法分析器是把源代码作为字符串读入、解析，并建立语法树的程序。语法的设计和语法分析器的实现是决定语言外在表现的重要因素。<br>什么是语法树？摘自Wiki一段：</p>\n<blockquote>\n<p>在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p>\n</blockquote>\n<h2 id=\"一则简单的例子\"><a href=\"#一则简单的例子\" class=\"headerlink\" title=\"一则简单的例子\"></a>一则简单的例子</h2><p>如果我们需要让计算机帮忙算一下 「1加2再乘以3」 的结果，该怎么表达呢？<br>现在我们大多数的现代编程语言，都是使用「中缀表达式」的方式来编写运算，比如JavaScript：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(1 + 2) * 3</div></pre></td></tr></table></figure>\n<p>而FORTH语言则使用「后缀表达式」，这基本上与日语中的语序是一致的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">1 2 + 3 *</div></pre></td></tr></table></figure>\n<p>LISP语言使用的「前缀表达式」：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">( * (+ 1 2) 3)</div></pre></td></tr></table></figure>\n<p>我们再看一下这三种表达式的语法树：</p>\n<p><img src=\"/image/blog/whatisAST/表达式语法树比较.png\" alt=\"表达式语法树比较\"></p>\n<p>可以看出，对于这三种简单的语言，它们只是在这个语法树上按不同的规则遍历而已。三者的代码看起来差别很大，但实际上所用的树结构是相同的。</p>\n<h2 id=\"先来看看Python的语法树\"><a href=\"#先来看看Python的语法树\" class=\"headerlink\" title=\"先来看看Python的语法树\"></a>先来看看Python的语法树</h2><p>通过Python语言自带的库文件ast，我们可以查看特定的代码被转换成怎样的语法树。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; import ast</div><div class=\"line\">&gt;&gt;&gt; ast.dump(ast.parse(&quot;(1 + 2) * 3&quot;))</div><div class=\"line\">&apos;Module(</div><div class=\"line\">\tbody=[</div><div class=\"line\">\t\tExpr(</div><div class=\"line\">\t\t\tvalue=BinOp(</div><div class=\"line\">\t\t\t\tleft=BinOp(</div><div class=\"line\">\t\t\t\t\tleft=Num(n=1), </div><div class=\"line\">\t\t\t\t\top=Add(), </div><div class=\"line\">\t\t\t\t\tright=Num(n=2)</div><div class=\"line\">\t\t\t\t), </div><div class=\"line\">\t\t\t\top=Mult(), </div><div class=\"line\">\t\t\t\tright=Num(n=3)</div><div class=\"line\">\t\t\t)</div><div class=\"line\">\t\t)</div><div class=\"line\">\t]</div><div class=\"line\">)&apos;</div></pre></td></tr></table></figure>\n<p><code>BinOp op = Mult()</code>表示乘法运算，与<code>*</code>相对应；<br><code>BinOp op = Add()</code>表示加法运算，与<code>+</code>相对应；<br><code>Num n = 1</code>既为数值1。</p>\n<p><img src=\"/image/blog/whatisAST/Python语法树.png\" alt=\"Python语法树\"></p>\n<h2 id=\"再窥视一下JavaScript的语法树\"><a href=\"#再窥视一下JavaScript的语法树\" class=\"headerlink\" title=\"再窥视一下JavaScript的语法树\"></a>再窥视一下JavaScript的语法树</h2><blockquote>\n<p>在语法复杂的语言中，语法树是包含很多细节的语法结果表达式，我们需要靠语法树把这种形式以更简洁的形式表达出来。</p>\n</blockquote>\n<p>Javascript 有不少工具可以把代码构造出清晰的语法树，比如 <a href=\"http://esprima.org/\">esprima</a>、<a href=\"https://code.google.com/p/v8/source/browse/branches/bleeding_edge/src/ast.h\">v8</a>、<a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API\">SpiderMonkey</a>、<a href=\"http://lisperator.net/uglifyjs/\">UglifyJS</a>、<a href=\"http://astexplorer.net/\">AST explorer</a>等。</p>\n<p>这里，我使用「esprima」来探讨一下JavaScript运算<code>(1 + 2) * 3</code>的语法树。</p>\n<p>javascript code: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(1 + 2)* 3;</div></pre></td></tr></table></figure>\n<p>ast for json:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;type&quot;: &quot;Program&quot;,</div><div class=\"line\">    &quot;body&quot;: [</div><div class=\"line\">        &#123;</div><div class=\"line\">            &quot;type&quot;: &quot;ExpressionStatement&quot;,</div><div class=\"line\">            &quot;expression&quot;: &#123;</div><div class=\"line\">                &quot;type&quot;: &quot;BinaryExpression&quot;,</div><div class=\"line\">                &quot;operator&quot;: &quot;*&quot;,</div><div class=\"line\">                &quot;left&quot;: &#123;</div><div class=\"line\">                    &quot;type&quot;: &quot;BinaryExpression&quot;,</div><div class=\"line\">                    &quot;operator&quot;: &quot;+&quot;,</div><div class=\"line\">                    &quot;left&quot;: &#123;</div><div class=\"line\">                        &quot;type&quot;: &quot;Literal&quot;,</div><div class=\"line\">                        &quot;value&quot;: 1,</div><div class=\"line\">                        &quot;raw&quot;: &quot;1&quot;</div><div class=\"line\">                    &#125;,</div><div class=\"line\">                    &quot;right&quot;: &#123;</div><div class=\"line\">                        &quot;type&quot;: &quot;Literal&quot;,</div><div class=\"line\">                        &quot;value&quot;: 2,</div><div class=\"line\">                        &quot;raw&quot;: &quot;2&quot;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;,</div><div class=\"line\">                &quot;right&quot;: &#123;</div><div class=\"line\">                    &quot;type&quot;: &quot;Literal&quot;,</div><div class=\"line\">                    &quot;value&quot;: 3,</div><div class=\"line\">                    &quot;raw&quot;: &quot;3&quot;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;sourceType&quot;: &quot;script&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>body</code>表示程序体，而程序体中包含了一则表达式<code>ExpressionStatement</code>, 表达式体里包含了操作符 <code>*</code>,以及左右两边表达式，其中右边是数字<code>3</code>,而左边表达式还包含一层表达式，里面是一个<code>+</code> 操作符，以及左右两边分别为<code>1</code>和<code>2</code>的数字。</p>\n<p><img src=\"/image/blog/whatisAST/javascript语法树.png\" alt=\"javascript语法树\"></p>\n<p>如果还没有看懂，你可以到这里看一下这段代码所生成的语法树：<a href=\"http://esprima.org/demo/parse.html?code=%2F%2F%20Life%2C%20Universe%2C%20and%20Everything%0A(1%20%2B%202\">AST for (1 + 2)* 3;</a>*%203%0A)</p>\n<h2 id=\"我们可以利用语法树做些什么？\"><a href=\"#我们可以利用语法树做些什么？\" class=\"headerlink\" title=\"我们可以利用语法树做些什么？\"></a>我们可以利用语法树做些什么？</h2><p>看到这里你可能会问，知道语法是又有什么用呢？跟我日常编写代码貌似半毛钱关系都没有。其实语法树还是很有用的，想一下如果想做「语法高亮」、「关键字匹配」、「作用域判断」、以及「代码压缩」等等，都是最好把代码解构成语法树之后再去各种操作，当然仅仅解构还不够，还需要提供各种函数去遍历与修改语法树。</p>\n<p>另一方面，去研究、去探讨计算机真实的世界不是一个很精彩很刺激的过程么？</p>\n"},{"title":"原生JavaScript实现拖拽效果","date":"2014-07-12T07:45:37.000Z","_content":"\n## 前言\n\n闲着无事干，突然想做一个类Q+ Web桌面的东西，当然那是一个大工程（对本菜鸟来说）。那么，这个Demo就是第一步，起码可以实现图标的拖拽效果。\n截图：\n\n\n\n\n```HTML\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title>Drag Demo</title>\n    <style>\n        body{\n            background:url(images/bg.jpg) no-repeat;\n            background-size:100%;\n            padding: 20px ;\n        }\n        .icon{\n            width: 100px;height: 100px;margin-bottom:15px;position: absolute;cursor: move;\n        }\n        .icon-0{\n            background: url(\"images/png/0.png\") no-repeat;background-size: 100%;\n            top: 20px;\n            left: 20px;\n        }\n        .icon-1{\n            background: url(\"images/png/1.png\") no-repeat;background-size: 100%;\n            top: 140px;\n            left: 20px;\n        }\n        .icon-2{\n            background: url(\"images/png/2.png\") no-repeat;background-size: 100%;\n            top: 260px;\n            left: 20px;\n        }\n        .icon-3{\n            background: url(\"images/png/3.png\") no-repeat;background-size: 100%;\n            top: 380px;\n            left: 20px;\n        }\n        .icon-4{\n             background: url(\"images/png/4.png\") no-repeat;background-size: 100%;\n             top: 500px;\n             left: 20px;\n        }\n\n\n    </style>\n</head>\n\n<body>\n    <div class=\"icon icon-0\"></div>\n    <div class=\"icon icon-1\"></div>\n    <div class=\"icon icon-2\"></div>\n    <div class=\"icon icon-3\"></div>\n    <div class=\"icon icon-4\"></div>\n</body>\n\n<script type=\"text/javascript\">\n    function g(el){ return document.getElementsByClassName(el);}\n\n    var icons = g('icon');\n    var instace = false; //存放当前移动对象信息\n\n    for(var i =0 ; i<icons.length ; i++){\n        if(icons[i]) {\n            icons[i].addEventListener('mousedown', function (e) {\n\n                instace = {};\n                var e = e || window.event;\n                var el = e.toElement || e.target;\n                console.log(e);\n                instace.moveElement = el;\n\n                //  获取鼠标的坐标\n                var mouseX = e.pageX;\n                var mouseY = e.pageY;\n\n                //  获取元素左上角的坐标\n                var elX = el.offsetLeft;\n                var elY = el.offsetTop;\n\n                //  计算出偏移量\n                instace.offSetX = mouseX - elX;\n                instace.offSetY = mouseY - elY;\n\n                instace.moveElement.style.zIndex = 9000;\n            });\n        }\n    }\n\n    document.onmouseup = function(e){\n        instace.moveElement.style.zIndex = 2;\n        instace = false;\n    };\n\n    document.onmousemove = function(e){\n\n        if(instace){\n\n            //  获取当前鼠标坐标\n            var mouseX = e.pageX;\n            var mouseY = e.pageY;\n\n            //  计算元素移动坐标\n            var moveX = mouseX - instace.offSetX;\n            var moveY = mouseY - instace.offSetY;\n\n            //  计算最大移动坐标\n            var maxX = document.documentElement.clientWidth  - instace.moveElement.offsetWidth;\n            var maxY = document.documentElement.clientHeight - instace.moveElement.offsetHeight;\n\n            //  设置元素的坐标\n            instace.moveElement.style.left = Math.max(0,Math.min(maxX,moveX)) + 'px';\n            instace.moveElement.style.top  = Math.max(0,Math.min(maxY,moveY)) + 'px';\n        }\n    };\n</script>\n</html>\n```\n\n\n演示地址：http://jerryc8080.github.io/dragDemo/\n项目地址：https://github.com/JerryC8080/dragDemo/\n","source":"_posts/原生JavaScript实现拖拽效果.md","raw":"---\ntitle: 原生JavaScript实现拖拽效果\ncategory: 搬砖码农\ndate: 2014-07-12 15:45:37\ntags:\n- Javascript\n---\n\n## 前言\n\n闲着无事干，突然想做一个类Q+ Web桌面的东西，当然那是一个大工程（对本菜鸟来说）。那么，这个Demo就是第一步，起码可以实现图标的拖拽效果。\n截图：\n\n\n\n\n```HTML\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title>Drag Demo</title>\n    <style>\n        body{\n            background:url(images/bg.jpg) no-repeat;\n            background-size:100%;\n            padding: 20px ;\n        }\n        .icon{\n            width: 100px;height: 100px;margin-bottom:15px;position: absolute;cursor: move;\n        }\n        .icon-0{\n            background: url(\"images/png/0.png\") no-repeat;background-size: 100%;\n            top: 20px;\n            left: 20px;\n        }\n        .icon-1{\n            background: url(\"images/png/1.png\") no-repeat;background-size: 100%;\n            top: 140px;\n            left: 20px;\n        }\n        .icon-2{\n            background: url(\"images/png/2.png\") no-repeat;background-size: 100%;\n            top: 260px;\n            left: 20px;\n        }\n        .icon-3{\n            background: url(\"images/png/3.png\") no-repeat;background-size: 100%;\n            top: 380px;\n            left: 20px;\n        }\n        .icon-4{\n             background: url(\"images/png/4.png\") no-repeat;background-size: 100%;\n             top: 500px;\n             left: 20px;\n        }\n\n\n    </style>\n</head>\n\n<body>\n    <div class=\"icon icon-0\"></div>\n    <div class=\"icon icon-1\"></div>\n    <div class=\"icon icon-2\"></div>\n    <div class=\"icon icon-3\"></div>\n    <div class=\"icon icon-4\"></div>\n</body>\n\n<script type=\"text/javascript\">\n    function g(el){ return document.getElementsByClassName(el);}\n\n    var icons = g('icon');\n    var instace = false; //存放当前移动对象信息\n\n    for(var i =0 ; i<icons.length ; i++){\n        if(icons[i]) {\n            icons[i].addEventListener('mousedown', function (e) {\n\n                instace = {};\n                var e = e || window.event;\n                var el = e.toElement || e.target;\n                console.log(e);\n                instace.moveElement = el;\n\n                //  获取鼠标的坐标\n                var mouseX = e.pageX;\n                var mouseY = e.pageY;\n\n                //  获取元素左上角的坐标\n                var elX = el.offsetLeft;\n                var elY = el.offsetTop;\n\n                //  计算出偏移量\n                instace.offSetX = mouseX - elX;\n                instace.offSetY = mouseY - elY;\n\n                instace.moveElement.style.zIndex = 9000;\n            });\n        }\n    }\n\n    document.onmouseup = function(e){\n        instace.moveElement.style.zIndex = 2;\n        instace = false;\n    };\n\n    document.onmousemove = function(e){\n\n        if(instace){\n\n            //  获取当前鼠标坐标\n            var mouseX = e.pageX;\n            var mouseY = e.pageY;\n\n            //  计算元素移动坐标\n            var moveX = mouseX - instace.offSetX;\n            var moveY = mouseY - instace.offSetY;\n\n            //  计算最大移动坐标\n            var maxX = document.documentElement.clientWidth  - instace.moveElement.offsetWidth;\n            var maxY = document.documentElement.clientHeight - instace.moveElement.offsetHeight;\n\n            //  设置元素的坐标\n            instace.moveElement.style.left = Math.max(0,Math.min(maxX,moveX)) + 'px';\n            instace.moveElement.style.top  = Math.max(0,Math.min(maxY,moveY)) + 'px';\n        }\n    };\n</script>\n</html>\n```\n\n\n演示地址：http://jerryc8080.github.io/dragDemo/\n项目地址：https://github.com/JerryC8080/dragDemo/\n","slug":"原生JavaScript实现拖拽效果","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqg002515hlpia7ek45","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>闲着无事干，突然想做一个类Q+ Web桌面的东西，当然那是一个大工程（对本菜鸟来说）。那么，这个Demo就是第一步，起码可以实现图标的拖拽效果。<br>截图：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Drag Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">        body&#123;</div><div class=\"line\">            background:url(images/bg.jpg) no-repeat;</div><div class=\"line\">            background-size:100%;</div><div class=\"line\">            padding: 20px ;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .icon&#123;</div><div class=\"line\">            width: 100px;height: 100px;margin-bottom:15px;position: absolute;cursor: move;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .icon-0&#123;</div><div class=\"line\">            background: url(\"images/png/0.png\") no-repeat;background-size: 100%;</div><div class=\"line\">            top: 20px;</div><div class=\"line\">            left: 20px;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .icon-1&#123;</div><div class=\"line\">            background: url(\"images/png/1.png\") no-repeat;background-size: 100%;</div><div class=\"line\">            top: 140px;</div><div class=\"line\">            left: 20px;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .icon-2&#123;</div><div class=\"line\">            background: url(\"images/png/2.png\") no-repeat;background-size: 100%;</div><div class=\"line\">            top: 260px;</div><div class=\"line\">            left: 20px;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .icon-3&#123;</div><div class=\"line\">            background: url(\"images/png/3.png\") no-repeat;background-size: 100%;</div><div class=\"line\">            top: 380px;</div><div class=\"line\">            left: 20px;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .icon-4&#123;</div><div class=\"line\">             background: url(\"images/png/4.png\") no-repeat;background-size: 100%;</div><div class=\"line\">             top: 500px;</div><div class=\"line\">             left: 20px;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-0\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-3\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-4\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\">el</span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementsByClassName(el);&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> icons = g(<span class=\"string\">'icon'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> instace = <span class=\"literal\">false</span>; <span class=\"comment\">//存放当前移动对象信息</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i =<span class=\"number\">0</span> ; i&lt;icons.length ; i++)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(icons[i]) &#123;</div><div class=\"line\">            icons[i].addEventListener(<span class=\"string\">'mousedown'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">                instace = &#123;&#125;;</div><div class=\"line\">                <span class=\"keyword\">var</span> e = e || <span class=\"built_in\">window</span>.event;</div><div class=\"line\">                <span class=\"keyword\">var</span> el = e.toElement || e.target;</div><div class=\"line\">                <span class=\"built_in\">console</span>.log(e);</div><div class=\"line\">                instace.moveElement = el;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">//  获取鼠标的坐标</span></div><div class=\"line\">                <span class=\"keyword\">var</span> mouseX = e.pageX;</div><div class=\"line\">                <span class=\"keyword\">var</span> mouseY = e.pageY;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">//  获取元素左上角的坐标</span></div><div class=\"line\">                <span class=\"keyword\">var</span> elX = el.offsetLeft;</div><div class=\"line\">                <span class=\"keyword\">var</span> elY = el.offsetTop;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">//  计算出偏移量</span></div><div class=\"line\">                instace.offSetX = mouseX - elX;</div><div class=\"line\">                instace.offSetY = mouseY - elY;</div><div class=\"line\"></div><div class=\"line\">                instace.moveElement.style.zIndex = <span class=\"number\">9000</span>;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">document</span>.onmouseup = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">        instace.moveElement.style.zIndex = <span class=\"number\">2</span>;</div><div class=\"line\">        instace = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">document</span>.onmousemove = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span>(instace)&#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//  获取当前鼠标坐标</span></div><div class=\"line\">            <span class=\"keyword\">var</span> mouseX = e.pageX;</div><div class=\"line\">            <span class=\"keyword\">var</span> mouseY = e.pageY;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//  计算元素移动坐标</span></div><div class=\"line\">            <span class=\"keyword\">var</span> moveX = mouseX - instace.offSetX;</div><div class=\"line\">            <span class=\"keyword\">var</span> moveY = mouseY - instace.offSetY;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//  计算最大移动坐标</span></div><div class=\"line\">            <span class=\"keyword\">var</span> maxX = <span class=\"built_in\">document</span>.documentElement.clientWidth  - instace.moveElement.offsetWidth;</div><div class=\"line\">            <span class=\"keyword\">var</span> maxY = <span class=\"built_in\">document</span>.documentElement.clientHeight - instace.moveElement.offsetHeight;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//  设置元素的坐标</span></div><div class=\"line\">            instace.moveElement.style.left = <span class=\"built_in\">Math</span>.max(<span class=\"number\">0</span>,<span class=\"built_in\">Math</span>.min(maxX,moveX)) + <span class=\"string\">'px'</span>;</div><div class=\"line\">            instace.moveElement.style.top  = <span class=\"built_in\">Math</span>.max(<span class=\"number\">0</span>,<span class=\"built_in\">Math</span>.min(maxY,moveY)) + <span class=\"string\">'px'</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>演示地址：<a href=\"http://jerryc8080.github.io/dragDemo/\" target=\"_blank\" rel=\"external\">http://jerryc8080.github.io/dragDemo/</a><br>项目地址：<a href=\"https://github.com/JerryC8080/dragDemo/\" target=\"_blank\" rel=\"external\">https://github.com/JerryC8080/dragDemo/</a></p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>闲着无事干，突然想做一个类Q+ Web桌面的东西，当然那是一个大工程（对本菜鸟来说）。那么，这个Demo就是第一步，起码可以实现图标的拖拽效果。<br>截图：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Drag Demo<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></div><div class=\"line\">        body&#123;</div><div class=\"line\">            background:url(images/bg.jpg) no-repeat;</div><div class=\"line\">            background-size:100%;</div><div class=\"line\">            padding: 20px ;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .icon&#123;</div><div class=\"line\">            width: 100px;height: 100px;margin-bottom:15px;position: absolute;cursor: move;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .icon-0&#123;</div><div class=\"line\">            background: url(\"images/png/0.png\") no-repeat;background-size: 100%;</div><div class=\"line\">            top: 20px;</div><div class=\"line\">            left: 20px;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .icon-1&#123;</div><div class=\"line\">            background: url(\"images/png/1.png\") no-repeat;background-size: 100%;</div><div class=\"line\">            top: 140px;</div><div class=\"line\">            left: 20px;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .icon-2&#123;</div><div class=\"line\">            background: url(\"images/png/2.png\") no-repeat;background-size: 100%;</div><div class=\"line\">            top: 260px;</div><div class=\"line\">            left: 20px;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .icon-3&#123;</div><div class=\"line\">            background: url(\"images/png/3.png\") no-repeat;background-size: 100%;</div><div class=\"line\">            top: 380px;</div><div class=\"line\">            left: 20px;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .icon-4&#123;</div><div class=\"line\">             background: url(\"images/png/4.png\") no-repeat;background-size: 100%;</div><div class=\"line\">             top: 500px;</div><div class=\"line\">             left: 20px;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-0\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-3\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon icon-4\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\">el</span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.getElementsByClassName(el);&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> icons = g(<span class=\"string\">'icon'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> instace = <span class=\"literal\">false</span>; <span class=\"comment\">//存放当前移动对象信息</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i =<span class=\"number\">0</span> ; i&lt;icons.length ; i++)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(icons[i]) &#123;</div><div class=\"line\">            icons[i].addEventListener(<span class=\"string\">'mousedown'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">                instace = &#123;&#125;;</div><div class=\"line\">                <span class=\"keyword\">var</span> e = e || <span class=\"built_in\">window</span>.event;</div><div class=\"line\">                <span class=\"keyword\">var</span> el = e.toElement || e.target;</div><div class=\"line\">                <span class=\"built_in\">console</span>.log(e);</div><div class=\"line\">                instace.moveElement = el;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">//  获取鼠标的坐标</span></div><div class=\"line\">                <span class=\"keyword\">var</span> mouseX = e.pageX;</div><div class=\"line\">                <span class=\"keyword\">var</span> mouseY = e.pageY;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">//  获取元素左上角的坐标</span></div><div class=\"line\">                <span class=\"keyword\">var</span> elX = el.offsetLeft;</div><div class=\"line\">                <span class=\"keyword\">var</span> elY = el.offsetTop;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">//  计算出偏移量</span></div><div class=\"line\">                instace.offSetX = mouseX - elX;</div><div class=\"line\">                instace.offSetY = mouseY - elY;</div><div class=\"line\"></div><div class=\"line\">                instace.moveElement.style.zIndex = <span class=\"number\">9000</span>;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">document</span>.onmouseup = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">        instace.moveElement.style.zIndex = <span class=\"number\">2</span>;</div><div class=\"line\">        instace = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">document</span>.onmousemove = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span>(instace)&#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//  获取当前鼠标坐标</span></div><div class=\"line\">            <span class=\"keyword\">var</span> mouseX = e.pageX;</div><div class=\"line\">            <span class=\"keyword\">var</span> mouseY = e.pageY;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//  计算元素移动坐标</span></div><div class=\"line\">            <span class=\"keyword\">var</span> moveX = mouseX - instace.offSetX;</div><div class=\"line\">            <span class=\"keyword\">var</span> moveY = mouseY - instace.offSetY;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//  计算最大移动坐标</span></div><div class=\"line\">            <span class=\"keyword\">var</span> maxX = <span class=\"built_in\">document</span>.documentElement.clientWidth  - instace.moveElement.offsetWidth;</div><div class=\"line\">            <span class=\"keyword\">var</span> maxY = <span class=\"built_in\">document</span>.documentElement.clientHeight - instace.moveElement.offsetHeight;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//  设置元素的坐标</span></div><div class=\"line\">            instace.moveElement.style.left = <span class=\"built_in\">Math</span>.max(<span class=\"number\">0</span>,<span class=\"built_in\">Math</span>.min(maxX,moveX)) + <span class=\"string\">'px'</span>;</div><div class=\"line\">            instace.moveElement.style.top  = <span class=\"built_in\">Math</span>.max(<span class=\"number\">0</span>,<span class=\"built_in\">Math</span>.min(maxY,moveY)) + <span class=\"string\">'px'</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>演示地址：<a href=\"http://jerryc8080.github.io/dragDemo/\">http://jerryc8080.github.io/dragDemo/</a><br>项目地址：<a href=\"https://github.com/JerryC8080/dragDemo/\">https://github.com/JerryC8080/dragDemo/</a></p>\n"},{"title":"单点登录的三种实现方式","date":"2015-09-14T09:18:40.000Z","_content":"\n\n单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。单点登录在大型网站里使用得非常频繁，例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯掉。实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，因此要点也就以下两个：\n* 存储信任\n* 验证信任\n\n如果一个系统做到了开头所讲的效果，也就算单点登录，单点登录有不同的实现方式，本文就罗列我开发中所遇见过的实现方式。\n\n## 以Cookie作为凭证媒介\n最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。\n用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。\n\n![Auth via cookie](http://xia-dev.b0.upaiyun.com/a74461c3-991b-4c93-9e12-fdc26b43dfd1.jpg)\n\n不难发现以上方式把信任存储在客户端的Cookie中，这种方式很容易令人质疑：\n* Cookie不安全\n* 不能跨域实现免登\n\n对于第一个问题，通过加密Cookie可以保证安全性，当然这是在源代码不泄露的前提下。如果Cookie的加密算法泄露，攻击者通过伪造Cookie则可以伪造特定用户身份，这是很危险的。\n对于第二个问题，更是硬伤。\n\n## 通过JSONP实现\n对于跨域问题，可以使用JSONP实现。\n用户在父应用中登录后，跟Session匹配的Cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。\n\n![Auth via jsonp](http://xia-dev.b0.upaiyun.com/895dc67a-788d-4542-a34c-6b0b6cd7b25b.jpg)\n\n这种方式虽然能解决跨域问题，但是安全性其实跟把信任存储到Cookie是差不多的。如果一旦加密算法泄露了，攻击者可以在本地建立一个实现了登录接口的假冒父应用，通过绑定Host来把子应用发起的请求指向本地的假冒父应用，并作出回应。\n因为攻击者完全可以按照加密算法来伪造响应请求，子应用接收到这个响应之后一样可以通过验证，并且登录特定用户。\n\n## 通过页面重定向的方式\n最后一种介绍的方式，是通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。\n父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。\n\n![Auth via redirect](http://xia-dev.b0.upaiyun.com/47034c1e-afd7-4cdf-a1d9-0976cfe263f4.jpg)\n\n这种方式较前面两种方式，接解决了上面两种方法暴露出来的安全性问题和跨域的问题，但是并没有前面两种方式方便。\n安全与方便，本来就是一对矛盾。\n\n## 使用独立登录系统\n一般说来，大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。\n用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。\n","source":"_posts/单点登录的三种实现方式.md","raw":"---\ntitle: 单点登录的三种实现方式\ncategory: 搬砖码农\ndate: 2015-09-14 17:18:40\ntags:\n- 单点登录\n- cookie\n- session\n- 架构\n---\n\n\n单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。单点登录在大型网站里使用得非常频繁，例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯掉。实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，因此要点也就以下两个：\n* 存储信任\n* 验证信任\n\n如果一个系统做到了开头所讲的效果，也就算单点登录，单点登录有不同的实现方式，本文就罗列我开发中所遇见过的实现方式。\n\n## 以Cookie作为凭证媒介\n最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。\n用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。\n\n![Auth via cookie](http://xia-dev.b0.upaiyun.com/a74461c3-991b-4c93-9e12-fdc26b43dfd1.jpg)\n\n不难发现以上方式把信任存储在客户端的Cookie中，这种方式很容易令人质疑：\n* Cookie不安全\n* 不能跨域实现免登\n\n对于第一个问题，通过加密Cookie可以保证安全性，当然这是在源代码不泄露的前提下。如果Cookie的加密算法泄露，攻击者通过伪造Cookie则可以伪造特定用户身份，这是很危险的。\n对于第二个问题，更是硬伤。\n\n## 通过JSONP实现\n对于跨域问题，可以使用JSONP实现。\n用户在父应用中登录后，跟Session匹配的Cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。\n\n![Auth via jsonp](http://xia-dev.b0.upaiyun.com/895dc67a-788d-4542-a34c-6b0b6cd7b25b.jpg)\n\n这种方式虽然能解决跨域问题，但是安全性其实跟把信任存储到Cookie是差不多的。如果一旦加密算法泄露了，攻击者可以在本地建立一个实现了登录接口的假冒父应用，通过绑定Host来把子应用发起的请求指向本地的假冒父应用，并作出回应。\n因为攻击者完全可以按照加密算法来伪造响应请求，子应用接收到这个响应之后一样可以通过验证，并且登录特定用户。\n\n## 通过页面重定向的方式\n最后一种介绍的方式，是通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。\n父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。\n\n![Auth via redirect](http://xia-dev.b0.upaiyun.com/47034c1e-afd7-4cdf-a1d9-0976cfe263f4.jpg)\n\n这种方式较前面两种方式，接解决了上面两种方法暴露出来的安全性问题和跨域的问题，但是并没有前面两种方式方便。\n安全与方便，本来就是一对矛盾。\n\n## 使用独立登录系统\n一般说来，大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。\n用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。\n","slug":"单点登录的三种实现方式","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqi002815hlwf5wlejx","content":"<p>单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。单点登录在大型网站里使用得非常频繁，例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯掉。实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，因此要点也就以下两个：</p>\n<ul>\n<li>存储信任</li>\n<li>验证信任</li>\n</ul>\n<p>如果一个系统做到了开头所讲的效果，也就算单点登录，单点登录有不同的实现方式，本文就罗列我开发中所遇见过的实现方式。</p>\n<h2 id=\"以Cookie作为凭证媒介\"><a href=\"#以Cookie作为凭证媒介\" class=\"headerlink\" title=\"以Cookie作为凭证媒介\"></a>以Cookie作为凭证媒介</h2><p>最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。<br>用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/a74461c3-991b-4c93-9e12-fdc26b43dfd1.jpg\" alt=\"Auth via cookie\"></p>\n<p>不难发现以上方式把信任存储在客户端的Cookie中，这种方式很容易令人质疑：</p>\n<ul>\n<li>Cookie不安全</li>\n<li>不能跨域实现免登</li>\n</ul>\n<p>对于第一个问题，通过加密Cookie可以保证安全性，当然这是在源代码不泄露的前提下。如果Cookie的加密算法泄露，攻击者通过伪造Cookie则可以伪造特定用户身份，这是很危险的。<br>对于第二个问题，更是硬伤。</p>\n<h2 id=\"通过JSONP实现\"><a href=\"#通过JSONP实现\" class=\"headerlink\" title=\"通过JSONP实现\"></a>通过JSONP实现</h2><p>对于跨域问题，可以使用JSONP实现。<br>用户在父应用中登录后，跟Session匹配的Cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/895dc67a-788d-4542-a34c-6b0b6cd7b25b.jpg\" alt=\"Auth via jsonp\"></p>\n<p>这种方式虽然能解决跨域问题，但是安全性其实跟把信任存储到Cookie是差不多的。如果一旦加密算法泄露了，攻击者可以在本地建立一个实现了登录接口的假冒父应用，通过绑定Host来把子应用发起的请求指向本地的假冒父应用，并作出回应。<br>因为攻击者完全可以按照加密算法来伪造响应请求，子应用接收到这个响应之后一样可以通过验证，并且登录特定用户。</p>\n<h2 id=\"通过页面重定向的方式\"><a href=\"#通过页面重定向的方式\" class=\"headerlink\" title=\"通过页面重定向的方式\"></a>通过页面重定向的方式</h2><p>最后一种介绍的方式，是通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。<br>父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/47034c1e-afd7-4cdf-a1d9-0976cfe263f4.jpg\" alt=\"Auth via redirect\"></p>\n<p>这种方式较前面两种方式，接解决了上面两种方法暴露出来的安全性问题和跨域的问题，但是并没有前面两种方式方便。<br>安全与方便，本来就是一对矛盾。</p>\n<h2 id=\"使用独立登录系统\"><a href=\"#使用独立登录系统\" class=\"headerlink\" title=\"使用独立登录系统\"></a>使用独立登录系统</h2><p>一般说来，大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。<br>用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。</p>\n","excerpt":"","more":"<p>单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。单点登录在大型网站里使用得非常频繁，例如像阿里巴巴这样的网站，在网站的背后是成百上千的子系统，用户一次操作或交易可能涉及到几十个子系统的协作，如果每个子系统都需要用户认证，不仅用户会疯掉，各子系统也会为这种重复认证授权的逻辑搞疯掉。实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，因此要点也就以下两个：</p>\n<ul>\n<li>存储信任</li>\n<li>验证信任</li>\n</ul>\n<p>如果一个系统做到了开头所讲的效果，也就算单点登录，单点登录有不同的实现方式，本文就罗列我开发中所遇见过的实现方式。</p>\n<h2 id=\"以Cookie作为凭证媒介\"><a href=\"#以Cookie作为凭证媒介\" class=\"headerlink\" title=\"以Cookie作为凭证媒介\"></a>以Cookie作为凭证媒介</h2><p>最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。<br>用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/a74461c3-991b-4c93-9e12-fdc26b43dfd1.jpg\" alt=\"Auth via cookie\"></p>\n<p>不难发现以上方式把信任存储在客户端的Cookie中，这种方式很容易令人质疑：</p>\n<ul>\n<li>Cookie不安全</li>\n<li>不能跨域实现免登</li>\n</ul>\n<p>对于第一个问题，通过加密Cookie可以保证安全性，当然这是在源代码不泄露的前提下。如果Cookie的加密算法泄露，攻击者通过伪造Cookie则可以伪造特定用户身份，这是很危险的。<br>对于第二个问题，更是硬伤。</p>\n<h2 id=\"通过JSONP实现\"><a href=\"#通过JSONP实现\" class=\"headerlink\" title=\"通过JSONP实现\"></a>通过JSONP实现</h2><p>对于跨域问题，可以使用JSONP实现。<br>用户在父应用中登录后，跟Session匹配的Cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/895dc67a-788d-4542-a34c-6b0b6cd7b25b.jpg\" alt=\"Auth via jsonp\"></p>\n<p>这种方式虽然能解决跨域问题，但是安全性其实跟把信任存储到Cookie是差不多的。如果一旦加密算法泄露了，攻击者可以在本地建立一个实现了登录接口的假冒父应用，通过绑定Host来把子应用发起的请求指向本地的假冒父应用，并作出回应。<br>因为攻击者完全可以按照加密算法来伪造响应请求，子应用接收到这个响应之后一样可以通过验证，并且登录特定用户。</p>\n<h2 id=\"通过页面重定向的方式\"><a href=\"#通过页面重定向的方式\" class=\"headerlink\" title=\"通过页面重定向的方式\"></a>通过页面重定向的方式</h2><p>最后一种介绍的方式，是通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。<br>父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/47034c1e-afd7-4cdf-a1d9-0976cfe263f4.jpg\" alt=\"Auth via redirect\"></p>\n<p>这种方式较前面两种方式，接解决了上面两种方法暴露出来的安全性问题和跨域的问题，但是并没有前面两种方式方便。<br>安全与方便，本来就是一对矛盾。</p>\n<h2 id=\"使用独立登录系统\"><a href=\"#使用独立登录系统\" class=\"headerlink\" title=\"使用独立登录系统\"></a>使用独立登录系统</h2><p>一般说来，大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。<br>用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。</p>\n"},{"title":"基于RESTful-API-怎么设计用户权限控制","date":"2015-03-29T13:38:59.000Z","_content":"\n\n## 前言\n\n有人说，每个人都是平等的；\n也有人说，人生来就是不平等的；\n在人类社会中，并没有绝对的公平，\n一件事，并不是所有人都能去做；\n一样物，并不是所有人都能够拥有。\n每个人都有自己的角色，每种角色都有对某种资源的一定权利，或许是拥有，或许只能是远观而不可亵玩。\n把这种人类社会中如此抽象的事实，提取出来，然后写成程序，还原本质的工作，就是我们程序员该做的事了。\n有了一个这么有范儿的开头，下面便来谈谈基于RESTful，如何实现不同的人不同的角色对于不同的资源不同的操作的权限控制。\n\n## RESTful简述\n\n本文是基于RESTful描述的，需要你对这个有初步的了解。\nRESTful是什么？\n**Representational State Transfer**，简称**REST**，是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。\nREST比较重要的点是**资源**和**状态转换**，\n所谓\"**资源**\"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。\n而 \"**状态转换**\"，则是把对应的HTTP协议里面，四个表示操作方式的动词分别对应四种基本操作：\n\n1.  GET，用来浏览(browse)资源    \n2.  POST，用来新建(create)资源    \n3.  PUT，用来更新(update)资源    \n4.  DELETE，用来删除(delete)资源        \n\n![RESTful CURD](http://xia-dev.b0.upaiyun.com/7860df36-189a-4f33-a884-156b4e0cb32d.png)\n\n## 资源的分类及操作\n\n清楚了资源的概念，然后再来对资源进行一下分类，我把资源分为下面三类：\n\n1.  私人资源 (Personal Source)\n2.  角色资源 (Roles Source)\n3.  公共资源 (Public Source)\n\n![Sources](http://xia-dev.b0.upaiyun.com/966064e4-b954-4aab-8cec-f0a9513835b2.png)\n\n**\"私人资源\"**：是属于某一个用户所有的资源，只有用户本人才能操作，其他用户不能操作。例如用户的个人信息、订单、收货地址等等。 \n**\"角色资源\"**：与私人资源不同，角色资源范畴更大，一个角色可以对应多个人，也就是一群人。如果给某角色分配了权限，那么只有身为该角色的用户才能拥有这些权限。例如系统资源只能够管理员操作，一般用户不能操作。 \n**\"公共资源\"**：所有人无论角色都能够访问并操作的资源。 \n\n而对资源的操作，无非就是分为四种：\n\n1.  浏览 (browse)    \n2.  新增 (create)    \n3.  更新 (update)    \n4.  删除 (delete)    \n\n## 角色、用户、权限之间的关系\n\n角色和用户的概念，自不用多说，大家都懂，但是权限的概念需要提一提。    \n**\"权限\"**，就是资源与操作的一套组合，例如\"增加用户\"是一种权限，\"删除用户\"是一种权限，所以对于一种资源所对应的权限有且只有四种。\n\n![Permissions](http://xia-dev.b0.upaiyun.com/3f78aa79-82ae-40d1-9691-976e007dcfd3.png)\n\n**角色**与**用户**的关系：一个角色对应一群用户，一个用户也可以扮演多个角色，所以它们是多对多的关系。    \n**角色**与**权限**的关系：一个角色拥有一堆权限，一个权限却只能属于一个角色，所以它们是一(角色)对多(权限)的关系    \n**权限**与**用户**的关系：由于一个用户可以扮演多个角色，一个角色拥有多个权限，所以用户与权限是间接的多对多关系。\n\n![Relations](http://xia-dev.b0.upaiyun.com/0c724f72-aa01-44b8-9540-f463e50924d0.png)\n\n需要注意两种特别情况：\n\n1.  私人资源与用户的关系，一种私人资源对应的四种权限只能属于一个用户，所以这种情况下，用户和权限是一(用户)对多(权限)的关系。\n2.  超级管理员的角色，这个角色是神一般的存在，能无视一切阻碍，对所有资源拥有绝对权限，甭管你是私人资源还是角色资源。\n\n## 数据库表的设计\n\n角色、用户、权限的模型应该怎么样设计，才能满足它们之间的关系？\n\n![Models](http://xia-dev.b0.upaiyun.com/b3c4a7ba-6ec8-4530-b576-ecbae2d9b239.png)\n\n对上图的一些关键字段进行说明：\n\n###### Source\n\n*   name: 资源的名称，也就是其他模型的名称，例如：user、role等等。\n*   identity: 资源的唯一标识，可以像uuid，shortid这些字符串，也可以是model的名称。\n*   permissions : 一种资源对应有四种权限，分别对这种资源的browse、create、update、delete\n\n###### Permission\n\n*   source : 该权限对应的资源，也就是Source的某一条记录的唯一标识\n*   action ：对应资源的操作，只能是browse、create、update、delete四个之一\n*   relation：用来标记该权限是属于私人的，还是角色的，用于OwnerPolicy检测\n*   roles: 拥有该权限的角色\n\n###### Role\n\n*   users : 角色所对应的用户群，一个角色可以对应多个用户\n*   permissions: 权限列表，一个角色拥有多项权利\n\n###### User\n\n*   createBy : 该记录的拥有者，在user标里，一般等于该记录的唯一标识，这一属性用于OwnerPolicy的检测，其他私有资源的模型设计，也需要加上这一字段来标识资源的拥有者。\n*   roles : 用户所拥有的角色\n\n## 策略/过滤器\n\n在sails下称为策略(Policy)，在java SSH下称为过滤器(Filter)，无论名称如何，他们工作原理是大同小异的，主要是在一条HTTP请求访问一个Controller下的action之前进行检测。所以在这一层，我们可以自定义一些策略/过滤器来实现权限控制。    \n为行文方便，下面姑且允许我使用策略这一词。\n\n** 策略 (Policy) **\n> 下面排版顺序对应Policy的运行顺序\n\n1.  **SessionAuthPolicy**：    \n检测用户是否已经登录，用户登录是进行下面检测的前提。\n2.  **SourcePolicy**：    \n检测访问的资源是否存在，主要检测Source表的记录\n3.  **PermissionPolicy**：    \n检测该用户所属的角色，是否有对所访问资源进行对应操作的权限。\n4.  **OwnerPolicy**：    \n如果所访问的资源属于私人资源，则检测当前用户是否该资源的拥有者。\n\n如果通过所有policy的检测，则把请求转发到目标action。\n\n![Policies](http://xia-dev.b0.upaiyun.com/73b94749-99ba-4e35-a9a3-42604ecb7af9.png)\n\n## Sails下的权限控制实现\n\n在Sails下，有一个很方便的套件[sails-permissions](https://github.com/tjwebb/sails-permissions)，集成了一套权限管理的方案，本文也是基于该套件的源码所引出来的权限管理解决方案。\n\n## 结语\n\n对程序员最大的挑战，并不是能否掌握了哪些编程语言，哪些软件框架，而是对业务和需求的理解，然后在此基础上，把要点抽象出来，写成计算机能理解的语言。    \n最后，希望这篇文章，能够帮助你对权限管理这一课题增加多一点点理解。\n\n## 写作参考\n\n*   [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n*   [REST wiki](http://zh.wikipedia.org/wiki/REST)\n*   [sails-permissions 源码](https://github.com/tjwebb/sails-permissions)\n","source":"_posts/基于RESTful-API-怎么设计用户权限控制.md","raw":"---\ntitle: 基于RESTful-API-怎么设计用户权限控制\ncategory: 搬砖码农\ndate: 2015-03-29 21:38:59\ntags:\n- RESTful\n- 权限系统\n- 架构\n---\n\n\n## 前言\n\n有人说，每个人都是平等的；\n也有人说，人生来就是不平等的；\n在人类社会中，并没有绝对的公平，\n一件事，并不是所有人都能去做；\n一样物，并不是所有人都能够拥有。\n每个人都有自己的角色，每种角色都有对某种资源的一定权利，或许是拥有，或许只能是远观而不可亵玩。\n把这种人类社会中如此抽象的事实，提取出来，然后写成程序，还原本质的工作，就是我们程序员该做的事了。\n有了一个这么有范儿的开头，下面便来谈谈基于RESTful，如何实现不同的人不同的角色对于不同的资源不同的操作的权限控制。\n\n## RESTful简述\n\n本文是基于RESTful描述的，需要你对这个有初步的了解。\nRESTful是什么？\n**Representational State Transfer**，简称**REST**，是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。\nREST比较重要的点是**资源**和**状态转换**，\n所谓\"**资源**\"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。\n而 \"**状态转换**\"，则是把对应的HTTP协议里面，四个表示操作方式的动词分别对应四种基本操作：\n\n1.  GET，用来浏览(browse)资源    \n2.  POST，用来新建(create)资源    \n3.  PUT，用来更新(update)资源    \n4.  DELETE，用来删除(delete)资源        \n\n![RESTful CURD](http://xia-dev.b0.upaiyun.com/7860df36-189a-4f33-a884-156b4e0cb32d.png)\n\n## 资源的分类及操作\n\n清楚了资源的概念，然后再来对资源进行一下分类，我把资源分为下面三类：\n\n1.  私人资源 (Personal Source)\n2.  角色资源 (Roles Source)\n3.  公共资源 (Public Source)\n\n![Sources](http://xia-dev.b0.upaiyun.com/966064e4-b954-4aab-8cec-f0a9513835b2.png)\n\n**\"私人资源\"**：是属于某一个用户所有的资源，只有用户本人才能操作，其他用户不能操作。例如用户的个人信息、订单、收货地址等等。 \n**\"角色资源\"**：与私人资源不同，角色资源范畴更大，一个角色可以对应多个人，也就是一群人。如果给某角色分配了权限，那么只有身为该角色的用户才能拥有这些权限。例如系统资源只能够管理员操作，一般用户不能操作。 \n**\"公共资源\"**：所有人无论角色都能够访问并操作的资源。 \n\n而对资源的操作，无非就是分为四种：\n\n1.  浏览 (browse)    \n2.  新增 (create)    \n3.  更新 (update)    \n4.  删除 (delete)    \n\n## 角色、用户、权限之间的关系\n\n角色和用户的概念，自不用多说，大家都懂，但是权限的概念需要提一提。    \n**\"权限\"**，就是资源与操作的一套组合，例如\"增加用户\"是一种权限，\"删除用户\"是一种权限，所以对于一种资源所对应的权限有且只有四种。\n\n![Permissions](http://xia-dev.b0.upaiyun.com/3f78aa79-82ae-40d1-9691-976e007dcfd3.png)\n\n**角色**与**用户**的关系：一个角色对应一群用户，一个用户也可以扮演多个角色，所以它们是多对多的关系。    \n**角色**与**权限**的关系：一个角色拥有一堆权限，一个权限却只能属于一个角色，所以它们是一(角色)对多(权限)的关系    \n**权限**与**用户**的关系：由于一个用户可以扮演多个角色，一个角色拥有多个权限，所以用户与权限是间接的多对多关系。\n\n![Relations](http://xia-dev.b0.upaiyun.com/0c724f72-aa01-44b8-9540-f463e50924d0.png)\n\n需要注意两种特别情况：\n\n1.  私人资源与用户的关系，一种私人资源对应的四种权限只能属于一个用户，所以这种情况下，用户和权限是一(用户)对多(权限)的关系。\n2.  超级管理员的角色，这个角色是神一般的存在，能无视一切阻碍，对所有资源拥有绝对权限，甭管你是私人资源还是角色资源。\n\n## 数据库表的设计\n\n角色、用户、权限的模型应该怎么样设计，才能满足它们之间的关系？\n\n![Models](http://xia-dev.b0.upaiyun.com/b3c4a7ba-6ec8-4530-b576-ecbae2d9b239.png)\n\n对上图的一些关键字段进行说明：\n\n###### Source\n\n*   name: 资源的名称，也就是其他模型的名称，例如：user、role等等。\n*   identity: 资源的唯一标识，可以像uuid，shortid这些字符串，也可以是model的名称。\n*   permissions : 一种资源对应有四种权限，分别对这种资源的browse、create、update、delete\n\n###### Permission\n\n*   source : 该权限对应的资源，也就是Source的某一条记录的唯一标识\n*   action ：对应资源的操作，只能是browse、create、update、delete四个之一\n*   relation：用来标记该权限是属于私人的，还是角色的，用于OwnerPolicy检测\n*   roles: 拥有该权限的角色\n\n###### Role\n\n*   users : 角色所对应的用户群，一个角色可以对应多个用户\n*   permissions: 权限列表，一个角色拥有多项权利\n\n###### User\n\n*   createBy : 该记录的拥有者，在user标里，一般等于该记录的唯一标识，这一属性用于OwnerPolicy的检测，其他私有资源的模型设计，也需要加上这一字段来标识资源的拥有者。\n*   roles : 用户所拥有的角色\n\n## 策略/过滤器\n\n在sails下称为策略(Policy)，在java SSH下称为过滤器(Filter)，无论名称如何，他们工作原理是大同小异的，主要是在一条HTTP请求访问一个Controller下的action之前进行检测。所以在这一层，我们可以自定义一些策略/过滤器来实现权限控制。    \n为行文方便，下面姑且允许我使用策略这一词。\n\n** 策略 (Policy) **\n> 下面排版顺序对应Policy的运行顺序\n\n1.  **SessionAuthPolicy**：    \n检测用户是否已经登录，用户登录是进行下面检测的前提。\n2.  **SourcePolicy**：    \n检测访问的资源是否存在，主要检测Source表的记录\n3.  **PermissionPolicy**：    \n检测该用户所属的角色，是否有对所访问资源进行对应操作的权限。\n4.  **OwnerPolicy**：    \n如果所访问的资源属于私人资源，则检测当前用户是否该资源的拥有者。\n\n如果通过所有policy的检测，则把请求转发到目标action。\n\n![Policies](http://xia-dev.b0.upaiyun.com/73b94749-99ba-4e35-a9a3-42604ecb7af9.png)\n\n## Sails下的权限控制实现\n\n在Sails下，有一个很方便的套件[sails-permissions](https://github.com/tjwebb/sails-permissions)，集成了一套权限管理的方案，本文也是基于该套件的源码所引出来的权限管理解决方案。\n\n## 结语\n\n对程序员最大的挑战，并不是能否掌握了哪些编程语言，哪些软件框架，而是对业务和需求的理解，然后在此基础上，把要点抽象出来，写成计算机能理解的语言。    \n最后，希望这篇文章，能够帮助你对权限管理这一课题增加多一点点理解。\n\n## 写作参考\n\n*   [理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n*   [REST wiki](http://zh.wikipedia.org/wiki/REST)\n*   [sails-permissions 源码](https://github.com/tjwebb/sails-permissions)\n","slug":"基于RESTful-API-怎么设计用户权限控制","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwql002c15hlak36388n","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有人说，每个人都是平等的；<br>也有人说，人生来就是不平等的；<br>在人类社会中，并没有绝对的公平，<br>一件事，并不是所有人都能去做；<br>一样物，并不是所有人都能够拥有。<br>每个人都有自己的角色，每种角色都有对某种资源的一定权利，或许是拥有，或许只能是远观而不可亵玩。<br>把这种人类社会中如此抽象的事实，提取出来，然后写成程序，还原本质的工作，就是我们程序员该做的事了。<br>有了一个这么有范儿的开头，下面便来谈谈基于RESTful，如何实现不同的人不同的角色对于不同的资源不同的操作的权限控制。</p>\n<h2 id=\"RESTful简述\"><a href=\"#RESTful简述\" class=\"headerlink\" title=\"RESTful简述\"></a>RESTful简述</h2><p>本文是基于RESTful描述的，需要你对这个有初步的了解。<br>RESTful是什么？<br><strong>Representational State Transfer</strong>，简称<strong>REST</strong>，是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。<br>REST比较重要的点是<strong>资源</strong>和<strong>状态转换</strong>，<br>所谓”<strong>资源</strong>“，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。<br>而 “<strong>状态转换</strong>“，则是把对应的HTTP协议里面，四个表示操作方式的动词分别对应四种基本操作：</p>\n<ol>\n<li>GET，用来浏览(browse)资源    </li>\n<li>POST，用来新建(create)资源    </li>\n<li>PUT，用来更新(update)资源    </li>\n<li>DELETE，用来删除(delete)资源        </li>\n</ol>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/7860df36-189a-4f33-a884-156b4e0cb32d.png\" alt=\"RESTful CURD\"></p>\n<h2 id=\"资源的分类及操作\"><a href=\"#资源的分类及操作\" class=\"headerlink\" title=\"资源的分类及操作\"></a>资源的分类及操作</h2><p>清楚了资源的概念，然后再来对资源进行一下分类，我把资源分为下面三类：</p>\n<ol>\n<li>私人资源 (Personal Source)</li>\n<li>角色资源 (Roles Source)</li>\n<li>公共资源 (Public Source)</li>\n</ol>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/966064e4-b954-4aab-8cec-f0a9513835b2.png\" alt=\"Sources\"></p>\n<p><strong>“私人资源”</strong>：是属于某一个用户所有的资源，只有用户本人才能操作，其他用户不能操作。例如用户的个人信息、订单、收货地址等等。<br><strong>“角色资源”</strong>：与私人资源不同，角色资源范畴更大，一个角色可以对应多个人，也就是一群人。如果给某角色分配了权限，那么只有身为该角色的用户才能拥有这些权限。例如系统资源只能够管理员操作，一般用户不能操作。<br><strong>“公共资源”</strong>：所有人无论角色都能够访问并操作的资源。 </p>\n<p>而对资源的操作，无非就是分为四种：</p>\n<ol>\n<li>浏览 (browse)    </li>\n<li>新增 (create)    </li>\n<li>更新 (update)    </li>\n<li>删除 (delete)    </li>\n</ol>\n<h2 id=\"角色、用户、权限之间的关系\"><a href=\"#角色、用户、权限之间的关系\" class=\"headerlink\" title=\"角色、用户、权限之间的关系\"></a>角色、用户、权限之间的关系</h2><p>角色和用户的概念，自不用多说，大家都懂，但是权限的概念需要提一提。<br><strong>“权限”</strong>，就是资源与操作的一套组合，例如”增加用户”是一种权限，”删除用户”是一种权限，所以对于一种资源所对应的权限有且只有四种。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/3f78aa79-82ae-40d1-9691-976e007dcfd3.png\" alt=\"Permissions\"></p>\n<p><strong>角色</strong>与<strong>用户</strong>的关系：一个角色对应一群用户，一个用户也可以扮演多个角色，所以它们是多对多的关系。<br><strong>角色</strong>与<strong>权限</strong>的关系：一个角色拥有一堆权限，一个权限却只能属于一个角色，所以它们是一(角色)对多(权限)的关系<br><strong>权限</strong>与<strong>用户</strong>的关系：由于一个用户可以扮演多个角色，一个角色拥有多个权限，所以用户与权限是间接的多对多关系。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/0c724f72-aa01-44b8-9540-f463e50924d0.png\" alt=\"Relations\"></p>\n<p>需要注意两种特别情况：</p>\n<ol>\n<li>私人资源与用户的关系，一种私人资源对应的四种权限只能属于一个用户，所以这种情况下，用户和权限是一(用户)对多(权限)的关系。</li>\n<li>超级管理员的角色，这个角色是神一般的存在，能无视一切阻碍，对所有资源拥有绝对权限，甭管你是私人资源还是角色资源。</li>\n</ol>\n<h2 id=\"数据库表的设计\"><a href=\"#数据库表的设计\" class=\"headerlink\" title=\"数据库表的设计\"></a>数据库表的设计</h2><p>角色、用户、权限的模型应该怎么样设计，才能满足它们之间的关系？</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/b3c4a7ba-6ec8-4530-b576-ecbae2d9b239.png\" alt=\"Models\"></p>\n<p>对上图的一些关键字段进行说明：</p>\n<h6 id=\"Source\"><a href=\"#Source\" class=\"headerlink\" title=\"Source\"></a>Source</h6><ul>\n<li>name: 资源的名称，也就是其他模型的名称，例如：user、role等等。</li>\n<li>identity: 资源的唯一标识，可以像uuid，shortid这些字符串，也可以是model的名称。</li>\n<li>permissions : 一种资源对应有四种权限，分别对这种资源的browse、create、update、delete</li>\n</ul>\n<h6 id=\"Permission\"><a href=\"#Permission\" class=\"headerlink\" title=\"Permission\"></a>Permission</h6><ul>\n<li>source : 该权限对应的资源，也就是Source的某一条记录的唯一标识</li>\n<li>action ：对应资源的操作，只能是browse、create、update、delete四个之一</li>\n<li>relation：用来标记该权限是属于私人的，还是角色的，用于OwnerPolicy检测</li>\n<li>roles: 拥有该权限的角色</li>\n</ul>\n<h6 id=\"Role\"><a href=\"#Role\" class=\"headerlink\" title=\"Role\"></a>Role</h6><ul>\n<li>users : 角色所对应的用户群，一个角色可以对应多个用户</li>\n<li>permissions: 权限列表，一个角色拥有多项权利</li>\n</ul>\n<h6 id=\"User\"><a href=\"#User\" class=\"headerlink\" title=\"User\"></a>User</h6><ul>\n<li>createBy : 该记录的拥有者，在user标里，一般等于该记录的唯一标识，这一属性用于OwnerPolicy的检测，其他私有资源的模型设计，也需要加上这一字段来标识资源的拥有者。</li>\n<li>roles : 用户所拥有的角色</li>\n</ul>\n<h2 id=\"策略-过滤器\"><a href=\"#策略-过滤器\" class=\"headerlink\" title=\"策略/过滤器\"></a>策略/过滤器</h2><p>在sails下称为策略(Policy)，在java SSH下称为过滤器(Filter)，无论名称如何，他们工作原理是大同小异的，主要是在一条HTTP请求访问一个Controller下的action之前进行检测。所以在这一层，我们可以自定义一些策略/过滤器来实现权限控制。<br>为行文方便，下面姑且允许我使用策略这一词。</p>\n<p><strong> 策略 (Policy) </strong></p>\n<blockquote>\n<p>下面排版顺序对应Policy的运行顺序</p>\n</blockquote>\n<ol>\n<li><strong>SessionAuthPolicy</strong>：<br>检测用户是否已经登录，用户登录是进行下面检测的前提。</li>\n<li><strong>SourcePolicy</strong>：<br>检测访问的资源是否存在，主要检测Source表的记录</li>\n<li><strong>PermissionPolicy</strong>：<br>检测该用户所属的角色，是否有对所访问资源进行对应操作的权限。</li>\n<li><strong>OwnerPolicy</strong>：<br>如果所访问的资源属于私人资源，则检测当前用户是否该资源的拥有者。</li>\n</ol>\n<p>如果通过所有policy的检测，则把请求转发到目标action。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/73b94749-99ba-4e35-a9a3-42604ecb7af9.png\" alt=\"Policies\"></p>\n<h2 id=\"Sails下的权限控制实现\"><a href=\"#Sails下的权限控制实现\" class=\"headerlink\" title=\"Sails下的权限控制实现\"></a>Sails下的权限控制实现</h2><p>在Sails下，有一个很方便的套件<a href=\"https://github.com/tjwebb/sails-permissions\" target=\"_blank\" rel=\"external\">sails-permissions</a>，集成了一套权限管理的方案，本文也是基于该套件的源码所引出来的权限管理解决方案。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>对程序员最大的挑战，并不是能否掌握了哪些编程语言，哪些软件框架，而是对业务和需求的理解，然后在此基础上，把要点抽象出来，写成计算机能理解的语言。<br>最后，希望这篇文章，能够帮助你对权限管理这一课题增加多一点点理解。</p>\n<h2 id=\"写作参考\"><a href=\"#写作参考\" class=\"headerlink\" title=\"写作参考\"></a>写作参考</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">理解RESTful架构</a></li>\n<li><a href=\"http://zh.wikipedia.org/wiki/REST\" target=\"_blank\" rel=\"external\">REST wiki</a></li>\n<li><a href=\"https://github.com/tjwebb/sails-permissions\" target=\"_blank\" rel=\"external\">sails-permissions 源码</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有人说，每个人都是平等的；<br>也有人说，人生来就是不平等的；<br>在人类社会中，并没有绝对的公平，<br>一件事，并不是所有人都能去做；<br>一样物，并不是所有人都能够拥有。<br>每个人都有自己的角色，每种角色都有对某种资源的一定权利，或许是拥有，或许只能是远观而不可亵玩。<br>把这种人类社会中如此抽象的事实，提取出来，然后写成程序，还原本质的工作，就是我们程序员该做的事了。<br>有了一个这么有范儿的开头，下面便来谈谈基于RESTful，如何实现不同的人不同的角色对于不同的资源不同的操作的权限控制。</p>\n<h2 id=\"RESTful简述\"><a href=\"#RESTful简述\" class=\"headerlink\" title=\"RESTful简述\"></a>RESTful简述</h2><p>本文是基于RESTful描述的，需要你对这个有初步的了解。<br>RESTful是什么？<br><strong>Representational State Transfer</strong>，简称<strong>REST</strong>，是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。<br>REST比较重要的点是<strong>资源</strong>和<strong>状态转换</strong>，<br>所谓”<strong>资源</strong>“，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。<br>而 “<strong>状态转换</strong>“，则是把对应的HTTP协议里面，四个表示操作方式的动词分别对应四种基本操作：</p>\n<ol>\n<li>GET，用来浏览(browse)资源    </li>\n<li>POST，用来新建(create)资源    </li>\n<li>PUT，用来更新(update)资源    </li>\n<li>DELETE，用来删除(delete)资源        </li>\n</ol>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/7860df36-189a-4f33-a884-156b4e0cb32d.png\" alt=\"RESTful CURD\"></p>\n<h2 id=\"资源的分类及操作\"><a href=\"#资源的分类及操作\" class=\"headerlink\" title=\"资源的分类及操作\"></a>资源的分类及操作</h2><p>清楚了资源的概念，然后再来对资源进行一下分类，我把资源分为下面三类：</p>\n<ol>\n<li>私人资源 (Personal Source)</li>\n<li>角色资源 (Roles Source)</li>\n<li>公共资源 (Public Source)</li>\n</ol>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/966064e4-b954-4aab-8cec-f0a9513835b2.png\" alt=\"Sources\"></p>\n<p><strong>“私人资源”</strong>：是属于某一个用户所有的资源，只有用户本人才能操作，其他用户不能操作。例如用户的个人信息、订单、收货地址等等。<br><strong>“角色资源”</strong>：与私人资源不同，角色资源范畴更大，一个角色可以对应多个人，也就是一群人。如果给某角色分配了权限，那么只有身为该角色的用户才能拥有这些权限。例如系统资源只能够管理员操作，一般用户不能操作。<br><strong>“公共资源”</strong>：所有人无论角色都能够访问并操作的资源。 </p>\n<p>而对资源的操作，无非就是分为四种：</p>\n<ol>\n<li>浏览 (browse)    </li>\n<li>新增 (create)    </li>\n<li>更新 (update)    </li>\n<li>删除 (delete)    </li>\n</ol>\n<h2 id=\"角色、用户、权限之间的关系\"><a href=\"#角色、用户、权限之间的关系\" class=\"headerlink\" title=\"角色、用户、权限之间的关系\"></a>角色、用户、权限之间的关系</h2><p>角色和用户的概念，自不用多说，大家都懂，但是权限的概念需要提一提。<br><strong>“权限”</strong>，就是资源与操作的一套组合，例如”增加用户”是一种权限，”删除用户”是一种权限，所以对于一种资源所对应的权限有且只有四种。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/3f78aa79-82ae-40d1-9691-976e007dcfd3.png\" alt=\"Permissions\"></p>\n<p><strong>角色</strong>与<strong>用户</strong>的关系：一个角色对应一群用户，一个用户也可以扮演多个角色，所以它们是多对多的关系。<br><strong>角色</strong>与<strong>权限</strong>的关系：一个角色拥有一堆权限，一个权限却只能属于一个角色，所以它们是一(角色)对多(权限)的关系<br><strong>权限</strong>与<strong>用户</strong>的关系：由于一个用户可以扮演多个角色，一个角色拥有多个权限，所以用户与权限是间接的多对多关系。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/0c724f72-aa01-44b8-9540-f463e50924d0.png\" alt=\"Relations\"></p>\n<p>需要注意两种特别情况：</p>\n<ol>\n<li>私人资源与用户的关系，一种私人资源对应的四种权限只能属于一个用户，所以这种情况下，用户和权限是一(用户)对多(权限)的关系。</li>\n<li>超级管理员的角色，这个角色是神一般的存在，能无视一切阻碍，对所有资源拥有绝对权限，甭管你是私人资源还是角色资源。</li>\n</ol>\n<h2 id=\"数据库表的设计\"><a href=\"#数据库表的设计\" class=\"headerlink\" title=\"数据库表的设计\"></a>数据库表的设计</h2><p>角色、用户、权限的模型应该怎么样设计，才能满足它们之间的关系？</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/b3c4a7ba-6ec8-4530-b576-ecbae2d9b239.png\" alt=\"Models\"></p>\n<p>对上图的一些关键字段进行说明：</p>\n<h6 id=\"Source\"><a href=\"#Source\" class=\"headerlink\" title=\"Source\"></a>Source</h6><ul>\n<li>name: 资源的名称，也就是其他模型的名称，例如：user、role等等。</li>\n<li>identity: 资源的唯一标识，可以像uuid，shortid这些字符串，也可以是model的名称。</li>\n<li>permissions : 一种资源对应有四种权限，分别对这种资源的browse、create、update、delete</li>\n</ul>\n<h6 id=\"Permission\"><a href=\"#Permission\" class=\"headerlink\" title=\"Permission\"></a>Permission</h6><ul>\n<li>source : 该权限对应的资源，也就是Source的某一条记录的唯一标识</li>\n<li>action ：对应资源的操作，只能是browse、create、update、delete四个之一</li>\n<li>relation：用来标记该权限是属于私人的，还是角色的，用于OwnerPolicy检测</li>\n<li>roles: 拥有该权限的角色</li>\n</ul>\n<h6 id=\"Role\"><a href=\"#Role\" class=\"headerlink\" title=\"Role\"></a>Role</h6><ul>\n<li>users : 角色所对应的用户群，一个角色可以对应多个用户</li>\n<li>permissions: 权限列表，一个角色拥有多项权利</li>\n</ul>\n<h6 id=\"User\"><a href=\"#User\" class=\"headerlink\" title=\"User\"></a>User</h6><ul>\n<li>createBy : 该记录的拥有者，在user标里，一般等于该记录的唯一标识，这一属性用于OwnerPolicy的检测，其他私有资源的模型设计，也需要加上这一字段来标识资源的拥有者。</li>\n<li>roles : 用户所拥有的角色</li>\n</ul>\n<h2 id=\"策略-过滤器\"><a href=\"#策略-过滤器\" class=\"headerlink\" title=\"策略/过滤器\"></a>策略/过滤器</h2><p>在sails下称为策略(Policy)，在java SSH下称为过滤器(Filter)，无论名称如何，他们工作原理是大同小异的，主要是在一条HTTP请求访问一个Controller下的action之前进行检测。所以在这一层，我们可以自定义一些策略/过滤器来实现权限控制。<br>为行文方便，下面姑且允许我使用策略这一词。</p>\n<p><strong> 策略 (Policy) </strong></p>\n<blockquote>\n<p>下面排版顺序对应Policy的运行顺序</p>\n</blockquote>\n<ol>\n<li><strong>SessionAuthPolicy</strong>：<br>检测用户是否已经登录，用户登录是进行下面检测的前提。</li>\n<li><strong>SourcePolicy</strong>：<br>检测访问的资源是否存在，主要检测Source表的记录</li>\n<li><strong>PermissionPolicy</strong>：<br>检测该用户所属的角色，是否有对所访问资源进行对应操作的权限。</li>\n<li><strong>OwnerPolicy</strong>：<br>如果所访问的资源属于私人资源，则检测当前用户是否该资源的拥有者。</li>\n</ol>\n<p>如果通过所有policy的检测，则把请求转发到目标action。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/73b94749-99ba-4e35-a9a3-42604ecb7af9.png\" alt=\"Policies\"></p>\n<h2 id=\"Sails下的权限控制实现\"><a href=\"#Sails下的权限控制实现\" class=\"headerlink\" title=\"Sails下的权限控制实现\"></a>Sails下的权限控制实现</h2><p>在Sails下，有一个很方便的套件<a href=\"https://github.com/tjwebb/sails-permissions\">sails-permissions</a>，集成了一套权限管理的方案，本文也是基于该套件的源码所引出来的权限管理解决方案。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>对程序员最大的挑战，并不是能否掌握了哪些编程语言，哪些软件框架，而是对业务和需求的理解，然后在此基础上，把要点抽象出来，写成计算机能理解的语言。<br>最后，希望这篇文章，能够帮助你对权限管理这一课题增加多一点点理解。</p>\n<h2 id=\"写作参考\"><a href=\"#写作参考\" class=\"headerlink\" title=\"写作参考\"></a>写作参考</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\">理解RESTful架构</a></li>\n<li><a href=\"http://zh.wikipedia.org/wiki/REST\">REST wiki</a></li>\n<li><a href=\"https://github.com/tjwebb/sails-permissions\">sails-permissions 源码</a></li>\n</ul>\n"},{"title":"打造高效个性Terminal（一）之 iTerm","date":"2016-08-11T13:16:00.000Z","_content":"\n# 前言\n作为一个集效率控、颜值控、强迫症患者标签于一身的患者，对待自己工作用到的Terminal，自然是诸多要求。本文首先会讲一下怎么弄一个高颜值、个性化的Terminal，然后再说说怎么利用一些工具来提高Terminal的效率。\n\n~~PS：文末有彩蛋。~~\n\n# iTerm\n## 简介 <small>Introduction</small>\n> iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with OS X 10.8 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted.\n\n**iTerm**是一款免费的，专为Mac OS用户打造的命令行应用。作为系统自带**Terminal**的替代，它提供了很多方便且极客的功能。诸如隔离的面板、透明窗口、强大的正则表达式搜索、自动补全等、剪贴板历史记录，快照返回等功能，更多iTerm的特性见[iTerm Feature](http://www.iterm2.com/features.html)。\n下载见官网([http://www.iterm2.com/](http://www.iterm2.com/))，如果你不是Mac用户，那就跳过**iTerm**，直接看提高效率的**oh-my-zsh**\n\n## 塑造高颜值Terminal\n**iTerm**吸引我的地方，除了各种方面的特性之外，就是炫酷可定制的界面。\n满足我的视觉强迫症之外还可以提供方便的功能，应当是每个MacOS程序员必备的利器。\n\n对于使用命令行，我一般会有两个这样的使用场景\n一、快速打开，执行一两条命令，然后关闭，诸如打开文件，启动服务等等。\n二、长时间使用命令行，诸如调试程序，VIM编程等等。\n\n对于第一种情况，我希望是可以通过快捷键快速的打开命令行，然后同样的快捷键快速的隐藏它，直到我需要的时候再次来到我面前。\n而第二种情况，我希望是可以和正常的命令窗口界面那样，让我安安静静的调试程序。\n\n所以，在iTerm，我会建两个Profile配置。\n\n**第一种Profile**\n![my terminal part 1.gif](/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif)\n\n**第二种Profile**\n![my terminal part 2.gif](/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif)\n\n## 一步一步往前走\n\n### Step.1 创建第一种Profile\n\n首先在`Preperence → Profiles`，建立一个`Profiles`， 取名`HotKey Window`\n\n![建立Profile](/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg)\n\n### Step.2 背景透明与模糊设置\n在`Preperence → Profiles → Window → Window Appearance` 进行设置\n\n![配置模糊透明背景](/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg)\n\n### Step.3 窗口风格配置\n在`Preperence → Profiles → Window → Settings for New Windows` 进行设置\n\n![窗口风格配置](/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg)\n\n### Step.4 设置HotKey\n在`Preperence → Profiles → Keys → HotKey` 进行设置\n\n![设置HotKey](/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg)\n\n到目前为止，第一种Profile配置完成，你可以按下你设置的`HotKey`来方便快速打开和隐藏命令行。\n如果你需要打开一个会长时间使用的命令行窗口的话，按下`cmd + n`，但是你会发现窗口的样式又回到默认的了，所以下面进行第二个Profiles的配置。\n\n### Step.5 创建第二个Profile\n我们只需要在第一个窗口的基础上，进行「窗口风格」配置就可以了。\n\n在`Preperence → Profiles`，复制`HotKey Window`， 取名`Default of Hotkey Window`\n\n![第二个Profile](/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg)\n\n### Step.6 窗口风格配置\n\n在`Preperence → Profiles → Window → Settings for New Windows` 进行设置\n\n![设置窗口风格配置](/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg)\n\n### Step.7 设置默认\n\n在`Preperence → Profiles` 中，选中 `Default of HotKey Window`, 并设置为默认\n\n![设置默认](/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg)\n\n自此，就完成了两种Profile的设置。\n\n\n## 常用功能快捷键\n在使用**iTerm**的过程中，下面对于控制窗口的快捷键使用频率会很高，不用记，用多了就形成肌肉记忆了。\n\n* cmd + n : 新建窗口\n* cmd + t : 新建TAB\n* cmd + d : 垂直新建TAB\n* cmd + shift + d : 水平新建TAB\n\n> [《打造高效个性Terminal（二）之 zsh》](/2016/08/11/打造高效个性Terminal（二）之%20zsh/)","source":"_posts/打造高效个性Terminal（一）之 iTerm.md","raw":"---\ntitle: 打造高效个性Terminal（一）之 iTerm\ncategory: 搬砖码农\ndate: 2016-08-11 21:16:00\ntags:\n- Tool Kit\n---\n\n# 前言\n作为一个集效率控、颜值控、强迫症患者标签于一身的患者，对待自己工作用到的Terminal，自然是诸多要求。本文首先会讲一下怎么弄一个高颜值、个性化的Terminal，然后再说说怎么利用一些工具来提高Terminal的效率。\n\n~~PS：文末有彩蛋。~~\n\n# iTerm\n## 简介 <small>Introduction</small>\n> iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with OS X 10.8 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted.\n\n**iTerm**是一款免费的，专为Mac OS用户打造的命令行应用。作为系统自带**Terminal**的替代，它提供了很多方便且极客的功能。诸如隔离的面板、透明窗口、强大的正则表达式搜索、自动补全等、剪贴板历史记录，快照返回等功能，更多iTerm的特性见[iTerm Feature](http://www.iterm2.com/features.html)。\n下载见官网([http://www.iterm2.com/](http://www.iterm2.com/))，如果你不是Mac用户，那就跳过**iTerm**，直接看提高效率的**oh-my-zsh**\n\n## 塑造高颜值Terminal\n**iTerm**吸引我的地方，除了各种方面的特性之外，就是炫酷可定制的界面。\n满足我的视觉强迫症之外还可以提供方便的功能，应当是每个MacOS程序员必备的利器。\n\n对于使用命令行，我一般会有两个这样的使用场景\n一、快速打开，执行一两条命令，然后关闭，诸如打开文件，启动服务等等。\n二、长时间使用命令行，诸如调试程序，VIM编程等等。\n\n对于第一种情况，我希望是可以通过快捷键快速的打开命令行，然后同样的快捷键快速的隐藏它，直到我需要的时候再次来到我面前。\n而第二种情况，我希望是可以和正常的命令窗口界面那样，让我安安静静的调试程序。\n\n所以，在iTerm，我会建两个Profile配置。\n\n**第一种Profile**\n![my terminal part 1.gif](/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif)\n\n**第二种Profile**\n![my terminal part 2.gif](/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif)\n\n## 一步一步往前走\n\n### Step.1 创建第一种Profile\n\n首先在`Preperence → Profiles`，建立一个`Profiles`， 取名`HotKey Window`\n\n![建立Profile](/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg)\n\n### Step.2 背景透明与模糊设置\n在`Preperence → Profiles → Window → Window Appearance` 进行设置\n\n![配置模糊透明背景](/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg)\n\n### Step.3 窗口风格配置\n在`Preperence → Profiles → Window → Settings for New Windows` 进行设置\n\n![窗口风格配置](/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg)\n\n### Step.4 设置HotKey\n在`Preperence → Profiles → Keys → HotKey` 进行设置\n\n![设置HotKey](/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg)\n\n到目前为止，第一种Profile配置完成，你可以按下你设置的`HotKey`来方便快速打开和隐藏命令行。\n如果你需要打开一个会长时间使用的命令行窗口的话，按下`cmd + n`，但是你会发现窗口的样式又回到默认的了，所以下面进行第二个Profiles的配置。\n\n### Step.5 创建第二个Profile\n我们只需要在第一个窗口的基础上，进行「窗口风格」配置就可以了。\n\n在`Preperence → Profiles`，复制`HotKey Window`， 取名`Default of Hotkey Window`\n\n![第二个Profile](/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg)\n\n### Step.6 窗口风格配置\n\n在`Preperence → Profiles → Window → Settings for New Windows` 进行设置\n\n![设置窗口风格配置](/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg)\n\n### Step.7 设置默认\n\n在`Preperence → Profiles` 中，选中 `Default of HotKey Window`, 并设置为默认\n\n![设置默认](/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg)\n\n自此，就完成了两种Profile的设置。\n\n\n## 常用功能快捷键\n在使用**iTerm**的过程中，下面对于控制窗口的快捷键使用频率会很高，不用记，用多了就形成肌肉记忆了。\n\n* cmd + n : 新建窗口\n* cmd + t : 新建TAB\n* cmd + d : 垂直新建TAB\n* cmd + shift + d : 水平新建TAB\n\n> [《打造高效个性Terminal（二）之 zsh》](/2016/08/11/打造高效个性Terminal（二）之%20zsh/)","slug":"打造高效个性Terminal（一）之 iTerm","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwql002f15hllv2kxddz","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一个集效率控、颜值控、强迫症患者标签于一身的患者，对待自己工作用到的Terminal，自然是诸多要求。本文首先会讲一下怎么弄一个高颜值、个性化的Terminal，然后再说说怎么利用一些工具来提高Terminal的效率。</p>\n<p><del>PS：文末有彩蛋。</del></p>\n<h1 id=\"iTerm\"><a href=\"#iTerm\" class=\"headerlink\" title=\"iTerm\"></a>iTerm</h1><h2 id=\"简介-Introduction\"><a href=\"#简介-Introduction\" class=\"headerlink\" title=\"简介 Introduction\"></a>简介 <small>Introduction</small></h2><blockquote>\n<p>iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with OS X 10.8 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted.</p>\n</blockquote>\n<p><strong>iTerm</strong>是一款免费的，专为Mac OS用户打造的命令行应用。作为系统自带<strong>Terminal</strong>的替代，它提供了很多方便且极客的功能。诸如隔离的面板、透明窗口、强大的正则表达式搜索、自动补全等、剪贴板历史记录，快照返回等功能，更多iTerm的特性见<a href=\"http://www.iterm2.com/features.html\" target=\"_blank\" rel=\"external\">iTerm Feature</a>。<br>下载见官网(<a href=\"http://www.iterm2.com/\" target=\"_blank\" rel=\"external\">http://www.iterm2.com/</a>)，如果你不是Mac用户，那就跳过<strong>iTerm</strong>，直接看提高效率的<strong>oh-my-zsh</strong></p>\n<h2 id=\"塑造高颜值Terminal\"><a href=\"#塑造高颜值Terminal\" class=\"headerlink\" title=\"塑造高颜值Terminal\"></a>塑造高颜值Terminal</h2><p><strong>iTerm</strong>吸引我的地方，除了各种方面的特性之外，就是炫酷可定制的界面。<br>满足我的视觉强迫症之外还可以提供方便的功能，应当是每个MacOS程序员必备的利器。</p>\n<p>对于使用命令行，我一般会有两个这样的使用场景<br>一、快速打开，执行一两条命令，然后关闭，诸如打开文件，启动服务等等。<br>二、长时间使用命令行，诸如调试程序，VIM编程等等。</p>\n<p>对于第一种情况，我希望是可以通过快捷键快速的打开命令行，然后同样的快捷键快速的隐藏它，直到我需要的时候再次来到我面前。<br>而第二种情况，我希望是可以和正常的命令窗口界面那样，让我安安静静的调试程序。</p>\n<p>所以，在iTerm，我会建两个Profile配置。</p>\n<p><strong>第一种Profile</strong><br><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif\" alt=\"my terminal part 1.gif\"></p>\n<p><strong>第二种Profile</strong><br><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif\" alt=\"my terminal part 2.gif\"></p>\n<h2 id=\"一步一步往前走\"><a href=\"#一步一步往前走\" class=\"headerlink\" title=\"一步一步往前走\"></a>一步一步往前走</h2><h3 id=\"Step-1-创建第一种Profile\"><a href=\"#Step-1-创建第一种Profile\" class=\"headerlink\" title=\"Step.1 创建第一种Profile\"></a>Step.1 创建第一种Profile</h3><p>首先在<code>Preperence → Profiles</code>，建立一个<code>Profiles</code>， 取名<code>HotKey Window</code></p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg\" alt=\"建立Profile\"></p>\n<h3 id=\"Step-2-背景透明与模糊设置\"><a href=\"#Step-2-背景透明与模糊设置\" class=\"headerlink\" title=\"Step.2 背景透明与模糊设置\"></a>Step.2 背景透明与模糊设置</h3><p>在<code>Preperence → Profiles → Window → Window Appearance</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg\" alt=\"配置模糊透明背景\"></p>\n<h3 id=\"Step-3-窗口风格配置\"><a href=\"#Step-3-窗口风格配置\" class=\"headerlink\" title=\"Step.3 窗口风格配置\"></a>Step.3 窗口风格配置</h3><p>在<code>Preperence → Profiles → Window → Settings for New Windows</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg\" alt=\"窗口风格配置\"></p>\n<h3 id=\"Step-4-设置HotKey\"><a href=\"#Step-4-设置HotKey\" class=\"headerlink\" title=\"Step.4 设置HotKey\"></a>Step.4 设置HotKey</h3><p>在<code>Preperence → Profiles → Keys → HotKey</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg\" alt=\"设置HotKey\"></p>\n<p>到目前为止，第一种Profile配置完成，你可以按下你设置的<code>HotKey</code>来方便快速打开和隐藏命令行。<br>如果你需要打开一个会长时间使用的命令行窗口的话，按下<code>cmd + n</code>，但是你会发现窗口的样式又回到默认的了，所以下面进行第二个Profiles的配置。</p>\n<h3 id=\"Step-5-创建第二个Profile\"><a href=\"#Step-5-创建第二个Profile\" class=\"headerlink\" title=\"Step.5 创建第二个Profile\"></a>Step.5 创建第二个Profile</h3><p>我们只需要在第一个窗口的基础上，进行「窗口风格」配置就可以了。</p>\n<p>在<code>Preperence → Profiles</code>，复制<code>HotKey Window</code>， 取名<code>Default of Hotkey Window</code></p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg\" alt=\"第二个Profile\"></p>\n<h3 id=\"Step-6-窗口风格配置\"><a href=\"#Step-6-窗口风格配置\" class=\"headerlink\" title=\"Step.6 窗口风格配置\"></a>Step.6 窗口风格配置</h3><p>在<code>Preperence → Profiles → Window → Settings for New Windows</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg\" alt=\"设置窗口风格配置\"></p>\n<h3 id=\"Step-7-设置默认\"><a href=\"#Step-7-设置默认\" class=\"headerlink\" title=\"Step.7 设置默认\"></a>Step.7 设置默认</h3><p>在<code>Preperence → Profiles</code> 中，选中 <code>Default of HotKey Window</code>, 并设置为默认</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg\" alt=\"设置默认\"></p>\n<p>自此，就完成了两种Profile的设置。</p>\n<h2 id=\"常用功能快捷键\"><a href=\"#常用功能快捷键\" class=\"headerlink\" title=\"常用功能快捷键\"></a>常用功能快捷键</h2><p>在使用<strong>iTerm</strong>的过程中，下面对于控制窗口的快捷键使用频率会很高，不用记，用多了就形成肌肉记忆了。</p>\n<ul>\n<li>cmd + n : 新建窗口</li>\n<li>cmd + t : 新建TAB</li>\n<li>cmd + d : 垂直新建TAB</li>\n<li>cmd + shift + d : 水平新建TAB</li>\n</ul>\n<blockquote>\n<p><a href=\"/2016/08/11/打造高效个性Terminal（二）之%20zsh/\">《打造高效个性Terminal（二）之 zsh》</a></p>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>作为一个集效率控、颜值控、强迫症患者标签于一身的患者，对待自己工作用到的Terminal，自然是诸多要求。本文首先会讲一下怎么弄一个高颜值、个性化的Terminal，然后再说说怎么利用一些工具来提高Terminal的效率。</p>\n<p><del>PS：文末有彩蛋。</del></p>\n<h1 id=\"iTerm\"><a href=\"#iTerm\" class=\"headerlink\" title=\"iTerm\"></a>iTerm</h1><h2 id=\"简介-Introduction\"><a href=\"#简介-Introduction\" class=\"headerlink\" title=\"简介 Introduction\"></a>简介 <small>Introduction</small></h2><blockquote>\n<p>iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with OS X 10.8 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted.</p>\n</blockquote>\n<p><strong>iTerm</strong>是一款免费的，专为Mac OS用户打造的命令行应用。作为系统自带<strong>Terminal</strong>的替代，它提供了很多方便且极客的功能。诸如隔离的面板、透明窗口、强大的正则表达式搜索、自动补全等、剪贴板历史记录，快照返回等功能，更多iTerm的特性见<a href=\"http://www.iterm2.com/features.html\">iTerm Feature</a>。<br>下载见官网(<a href=\"http://www.iterm2.com/\">http://www.iterm2.com/</a>)，如果你不是Mac用户，那就跳过<strong>iTerm</strong>，直接看提高效率的<strong>oh-my-zsh</strong></p>\n<h2 id=\"塑造高颜值Terminal\"><a href=\"#塑造高颜值Terminal\" class=\"headerlink\" title=\"塑造高颜值Terminal\"></a>塑造高颜值Terminal</h2><p><strong>iTerm</strong>吸引我的地方，除了各种方面的特性之外，就是炫酷可定制的界面。<br>满足我的视觉强迫症之外还可以提供方便的功能，应当是每个MacOS程序员必备的利器。</p>\n<p>对于使用命令行，我一般会有两个这样的使用场景<br>一、快速打开，执行一两条命令，然后关闭，诸如打开文件，启动服务等等。<br>二、长时间使用命令行，诸如调试程序，VIM编程等等。</p>\n<p>对于第一种情况，我希望是可以通过快捷键快速的打开命令行，然后同样的快捷键快速的隐藏它，直到我需要的时候再次来到我面前。<br>而第二种情况，我希望是可以和正常的命令窗口界面那样，让我安安静静的调试程序。</p>\n<p>所以，在iTerm，我会建两个Profile配置。</p>\n<p><strong>第一种Profile</strong><br><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/5961B48A3EE1C7C5AC59C7653ABBC9CF.gif\" alt=\"my terminal part 1.gif\"></p>\n<p><strong>第二种Profile</strong><br><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/1EA60589F1F6EC96B2F1BD36EF6DE854.gif\" alt=\"my terminal part 2.gif\"></p>\n<h2 id=\"一步一步往前走\"><a href=\"#一步一步往前走\" class=\"headerlink\" title=\"一步一步往前走\"></a>一步一步往前走</h2><h3 id=\"Step-1-创建第一种Profile\"><a href=\"#Step-1-创建第一种Profile\" class=\"headerlink\" title=\"Step.1 创建第一种Profile\"></a>Step.1 创建第一种Profile</h3><p>首先在<code>Preperence → Profiles</code>，建立一个<code>Profiles</code>， 取名<code>HotKey Window</code></p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/C19BBDC28A01A98CD1D202CBC94A6B29.jpg\" alt=\"建立Profile\"></p>\n<h3 id=\"Step-2-背景透明与模糊设置\"><a href=\"#Step-2-背景透明与模糊设置\" class=\"headerlink\" title=\"Step.2 背景透明与模糊设置\"></a>Step.2 背景透明与模糊设置</h3><p>在<code>Preperence → Profiles → Window → Window Appearance</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/4E35E0BAF7B7CA5EB11BE4BFF22977FD.jpg\" alt=\"配置模糊透明背景\"></p>\n<h3 id=\"Step-3-窗口风格配置\"><a href=\"#Step-3-窗口风格配置\" class=\"headerlink\" title=\"Step.3 窗口风格配置\"></a>Step.3 窗口风格配置</h3><p>在<code>Preperence → Profiles → Window → Settings for New Windows</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/46AD20F0070843F9804B1717D5CD6661.jpg\" alt=\"窗口风格配置\"></p>\n<h3 id=\"Step-4-设置HotKey\"><a href=\"#Step-4-设置HotKey\" class=\"headerlink\" title=\"Step.4 设置HotKey\"></a>Step.4 设置HotKey</h3><p>在<code>Preperence → Profiles → Keys → HotKey</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/526B5DF9BC09C70065BB863ABCDB942D.jpg\" alt=\"设置HotKey\"></p>\n<p>到目前为止，第一种Profile配置完成，你可以按下你设置的<code>HotKey</code>来方便快速打开和隐藏命令行。<br>如果你需要打开一个会长时间使用的命令行窗口的话，按下<code>cmd + n</code>，但是你会发现窗口的样式又回到默认的了，所以下面进行第二个Profiles的配置。</p>\n<h3 id=\"Step-5-创建第二个Profile\"><a href=\"#Step-5-创建第二个Profile\" class=\"headerlink\" title=\"Step.5 创建第二个Profile\"></a>Step.5 创建第二个Profile</h3><p>我们只需要在第一个窗口的基础上，进行「窗口风格」配置就可以了。</p>\n<p>在<code>Preperence → Profiles</code>，复制<code>HotKey Window</code>， 取名<code>Default of Hotkey Window</code></p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/5622AB0237BACE99D299D43D98D359DF.jpg\" alt=\"第二个Profile\"></p>\n<h3 id=\"Step-6-窗口风格配置\"><a href=\"#Step-6-窗口风格配置\" class=\"headerlink\" title=\"Step.6 窗口风格配置\"></a>Step.6 窗口风格配置</h3><p>在<code>Preperence → Profiles → Window → Settings for New Windows</code> 进行设置</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/32CFF9E358032E50DB87B07D6B6B0F9E.jpg\" alt=\"设置窗口风格配置\"></p>\n<h3 id=\"Step-7-设置默认\"><a href=\"#Step-7-设置默认\" class=\"headerlink\" title=\"Step.7 设置默认\"></a>Step.7 设置默认</h3><p>在<code>Preperence → Profiles</code> 中，选中 <code>Default of HotKey Window</code>, 并设置为默认</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part1/14C8AD735CDD1B4A0460FEF930AAB9F0.jpg\" alt=\"设置默认\"></p>\n<p>自此，就完成了两种Profile的设置。</p>\n<h2 id=\"常用功能快捷键\"><a href=\"#常用功能快捷键\" class=\"headerlink\" title=\"常用功能快捷键\"></a>常用功能快捷键</h2><p>在使用<strong>iTerm</strong>的过程中，下面对于控制窗口的快捷键使用频率会很高，不用记，用多了就形成肌肉记忆了。</p>\n<ul>\n<li>cmd + n : 新建窗口</li>\n<li>cmd + t : 新建TAB</li>\n<li>cmd + d : 垂直新建TAB</li>\n<li>cmd + shift + d : 水平新建TAB</li>\n</ul>\n<blockquote>\n<p><a href=\"/2016/08/11/打造高效个性Terminal（二）之%20zsh/\">《打造高效个性Terminal（二）之 zsh》</a></p>\n</blockquote>\n"},{"title":"打造高效个性Terminal（二）之 zsh","date":"2016-08-11T13:16:00.000Z","_content":"\n# oh-my-zsh\n如果说**iTerm**塑造了一个婀娜多姿颜值高的貌美姑娘，那么**zsh**就是给她塑造了一个柔情侠骨百事通的女汉子之心。\n\n## 简介 <small>Introduction</small>\n\n对于**zsh**的作用，摘自池建强老师的一段：\n> 目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史「终极 Shell」，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：[https://github.com/robbyrussell/oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)。\n\n**oh-my-zsh** 是一个社区驱动用于管理zsh的框架，囊括了140多个主题，200多个可选插件（如rails, git, OSX, hub, brew, ant, php, python etc.）。\n\n## 安装 <small>Installation</small>\n**via curl**\n```\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n**via wget**\n```\nsh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"\n```\n\n## 配置 <small>Configuration</small>\nzsh的配置主要集中在用户当前目录的`.zshrc`里，用vim或者你喜欢的其他编辑器打开这个文件，在里面可以修改主题、插件以及定义自己的环境变量等操作。\n\n## 主题 <small>Themes</small>\n\n用vim打开`~/.zshrc`中，可以看到这样配置\n```\n...\n# Set name of the theme to load.\n# Look in ~/.oh-my-zsh/themes/\n# Optionally, if you set this to \"random\", it'll load a random theme each\n# time that oh-my-zsh is loaded.\nZSH_THEME=\"robbyrussell\"\n...\n```\n修改`ZSH_THEME`的值就可以更换主题。\n\n默认的主题是`robbyrussell`，这个并不是最精彩，也并不是最简单的一个，只是对于其作者Robby来说最适合的一个。\n\n可以通过访问`~/.oh-my-zsh/themes/`目录查看哪些可选的主题\n\n```\n$ tree themes\nthemes\n├── 3den.zsh-theme\n├── Soliah.zsh-theme\n├── adben.zsh-theme\n├── af-magic.zsh-theme\n├── afowler.zsh-theme\n├── agnoster.zsh-theme\n...\n0 directories, 141 files\n```\n\n更多关于各个主题的详细介绍见 [zsh themes](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)，另外还有不少并不是自带的主题，见[more external themes](https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes)\n\n### Powerline Fonts\n如果你查看过zsh的主题列表的话，你会发现不少主题会有这样的样式，\n\n![混合](/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg)\n\n然而，当你选择了这样的主题，会发现实际是这样的\n\n![23.pic.jpg](/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg)\n\n因为，这些主题都依赖于一种字体[powerline fonts](https://github.com/powerline/fonts)，`powerline fonts`是vim增强组件[vim powerline](https://github.com/Lokaltog/vim-powerline)附属的字体，如果要使用依赖这种字体的主题，要在系统中安装该字体。\n\n### 安装 powerline fonts\n```\n// 下载powerline fonts项目\ngit clone https://github.com/powerline/fonts\n// 执行安装\n./fonts/install.sh\n```\n\n### 配置iTerm\n在`Preperence → Profiles → Text → Front` 中，\n和`Preperence → Profiles → Text → Non-ASCII Font`中\n改变字体为`Sauce Code Powerline`\n\n![改变字体](/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg)\n\n## 插件 <small>Plugins</small>\n用vim打开`~/.zshrc`中，可以看到这样配置\n```\n...\n# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)\n# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/\n# Example format: plugins=(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\nplugins=(git)\n...\n```\n修改`plugins`的值就可以修改或添加插件。\n\n下面介绍几款我常用的插件\n\n### [autojump](https://github.com/wting/autojump)\n> A cd command that learns - easily navigate directories from the command line\n\n一款快捷跳转目标路径的插件，支持模糊匹配，自动补全，历史记录等功能。\n\n![autojump](/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif)\n\n### [dirhistory](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#dirhistory)\n> This plugin allows you to navigate the history of previous current-working-directories using ALT-LEFT and ALT-RIGHT. ALT-LEFT moves back to directories that the user has changed to in the past, and ALT-RIGHT undoes ALT-LEFT.\n\n一款支持目录的上翻，下翻功能的插件。\n\n![dirhistory](/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif)\n\n### [osx](https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx)\n> This plugin provides a few utilities to make it more enjoyable on OSX.\n\n一款增加了一些在OSX上实用的命令插件。\n\n\n| Command       | Description                                    |\n|:--------------|:-----------------------------------------------|\n| `tab`         | Open the current directory in a new tab        |\n| `ofd`         | Open the current directory in a Finder window  |\n| `pfd`         | Return the path of the frontmost Finder window |\n| `pfs`         | Return the current Finder selection            |\n| `cdf`         | `cd` to the current Finder directory           |\n| `pushdf`      | `pushd` to the current Finder directory        |\n| `quick-look`  | Quick-Look a specified file                    |\n| `man-preview` | Open a specified man page in Preview app       |\n\n\n### [git](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git)\n> The git plugin provides many aliases and a few useful functions.\n\n一款提供git别名命令以及一些方法命令的插件\n\n\n### [git-extras](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#git-extras)\n\n一款扩展了不少方便快捷git命令的插件\n\n### More Plugins\n更多的插件介绍见 [zsh plugins](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins)\n\n## vi(vim) 基础\n使用命令行的时候，难免会遇到要编辑文档的时刻，尽管不是vim党，但是如果掌握vim的基本操作，对效率还是有大大提升的。\n\n### vi与vim的关系\n简单来说，vi是老师的文字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim则可以说是程序开发者的一项很好用的工具，就连vim的官方网站([http://www.vim.org/](http://www.vim.org/))自己也说vim是一个「程序开发工具」而不是文字处理软件。\n\n### 三种模式\n基本上vi中共分为3种模式，分别是「一般模式」，「编辑模式」与「命令行模式」\n\n* 一般模式\n以vi打开一个文件，默认就是一般模式，这个模式中，可以按下`i`来进入编辑模式，按下`ESC`则退出编辑模式回到一般模式。\n在这个模式中可以删除字符、删除行、复制、黏贴。\n\n* 编辑模式\n编辑模式能真正的编辑文本。\n\n* 命令模式\n在一般模式中，输入`:`,`/`,`?`中的一个可以进入命令行模式，进行诸如数据查找操作，读取、保存、离开vi等等操作。\n\n### 常用操作\n掌握下面的十一个命令，就足够你在vim中生存了。\n\n**移动光标**\n\n* hjkl : 你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。\n\n**行操作**\n\n* dd : 删除当前行，并把删除的行存到剪贴板里\n* yy : 复制当前行。\n* p  : 黏贴剪贴板\n\n**保存退出**\n\n* :w : 保存已编辑的文集\n* :q : 退出编辑\n* :wq : 保存并退出\n* :help : 显示相关命令的帮助(退出帮助需要输入:q)\n\n**搜索**\n* /word : 向下寻找一个名为word的字符串 \n* ?word : 向上寻找一个名为word的字符串\n* n : 重复前一个查找的操作\n\n# 文末福利，安抚你的强迫症\n感谢你能耐心的看到这里，给你安利一个强迫症患者福音的窗口控制工具：[Spectacle](https://www.spectacleapp.com/)\n\nSpectacle能通过快捷键，很轻易的排列好窗口的大小。\n\n![Spectacle](/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif)\n\n# 参考\nhttp://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively\nhttps://github.com/robbyrussell/oh-my-zsh/wiki/Plugins\nhttp://www.vim.org/\nhttp://macshuo.com/?p=676\nhttp://swiftcafe.io/2015/07/25/iterm/\n No newline at end of file\n","source":"_posts/打造高效个性Terminal（二）之 zsh.md","raw":"---\ntitle: 打造高效个性Terminal（二）之 zsh\ncategory: 搬砖码农\ndate: 2016-08-11 21:16:00\ntags:\n- Tool Kit\n---\n\n# oh-my-zsh\n如果说**iTerm**塑造了一个婀娜多姿颜值高的貌美姑娘，那么**zsh**就是给她塑造了一个柔情侠骨百事通的女汉子之心。\n\n## 简介 <small>Introduction</small>\n\n对于**zsh**的作用，摘自池建强老师的一段：\n> 目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史「终极 Shell」，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：[https://github.com/robbyrussell/oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)。\n\n**oh-my-zsh** 是一个社区驱动用于管理zsh的框架，囊括了140多个主题，200多个可选插件（如rails, git, OSX, hub, brew, ant, php, python etc.）。\n\n## 安装 <small>Installation</small>\n**via curl**\n```\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n```\n\n**via wget**\n```\nsh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"\n```\n\n## 配置 <small>Configuration</small>\nzsh的配置主要集中在用户当前目录的`.zshrc`里，用vim或者你喜欢的其他编辑器打开这个文件，在里面可以修改主题、插件以及定义自己的环境变量等操作。\n\n## 主题 <small>Themes</small>\n\n用vim打开`~/.zshrc`中，可以看到这样配置\n```\n...\n# Set name of the theme to load.\n# Look in ~/.oh-my-zsh/themes/\n# Optionally, if you set this to \"random\", it'll load a random theme each\n# time that oh-my-zsh is loaded.\nZSH_THEME=\"robbyrussell\"\n...\n```\n修改`ZSH_THEME`的值就可以更换主题。\n\n默认的主题是`robbyrussell`，这个并不是最精彩，也并不是最简单的一个，只是对于其作者Robby来说最适合的一个。\n\n可以通过访问`~/.oh-my-zsh/themes/`目录查看哪些可选的主题\n\n```\n$ tree themes\nthemes\n├── 3den.zsh-theme\n├── Soliah.zsh-theme\n├── adben.zsh-theme\n├── af-magic.zsh-theme\n├── afowler.zsh-theme\n├── agnoster.zsh-theme\n...\n0 directories, 141 files\n```\n\n更多关于各个主题的详细介绍见 [zsh themes](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)，另外还有不少并不是自带的主题，见[more external themes](https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes)\n\n### Powerline Fonts\n如果你查看过zsh的主题列表的话，你会发现不少主题会有这样的样式，\n\n![混合](/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg)\n\n然而，当你选择了这样的主题，会发现实际是这样的\n\n![23.pic.jpg](/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg)\n\n因为，这些主题都依赖于一种字体[powerline fonts](https://github.com/powerline/fonts)，`powerline fonts`是vim增强组件[vim powerline](https://github.com/Lokaltog/vim-powerline)附属的字体，如果要使用依赖这种字体的主题，要在系统中安装该字体。\n\n### 安装 powerline fonts\n```\n// 下载powerline fonts项目\ngit clone https://github.com/powerline/fonts\n// 执行安装\n./fonts/install.sh\n```\n\n### 配置iTerm\n在`Preperence → Profiles → Text → Front` 中，\n和`Preperence → Profiles → Text → Non-ASCII Font`中\n改变字体为`Sauce Code Powerline`\n\n![改变字体](/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg)\n\n## 插件 <small>Plugins</small>\n用vim打开`~/.zshrc`中，可以看到这样配置\n```\n...\n# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)\n# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/\n# Example format: plugins=(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\nplugins=(git)\n...\n```\n修改`plugins`的值就可以修改或添加插件。\n\n下面介绍几款我常用的插件\n\n### [autojump](https://github.com/wting/autojump)\n> A cd command that learns - easily navigate directories from the command line\n\n一款快捷跳转目标路径的插件，支持模糊匹配，自动补全，历史记录等功能。\n\n![autojump](/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif)\n\n### [dirhistory](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#dirhistory)\n> This plugin allows you to navigate the history of previous current-working-directories using ALT-LEFT and ALT-RIGHT. ALT-LEFT moves back to directories that the user has changed to in the past, and ALT-RIGHT undoes ALT-LEFT.\n\n一款支持目录的上翻，下翻功能的插件。\n\n![dirhistory](/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif)\n\n### [osx](https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx)\n> This plugin provides a few utilities to make it more enjoyable on OSX.\n\n一款增加了一些在OSX上实用的命令插件。\n\n\n| Command       | Description                                    |\n|:--------------|:-----------------------------------------------|\n| `tab`         | Open the current directory in a new tab        |\n| `ofd`         | Open the current directory in a Finder window  |\n| `pfd`         | Return the path of the frontmost Finder window |\n| `pfs`         | Return the current Finder selection            |\n| `cdf`         | `cd` to the current Finder directory           |\n| `pushdf`      | `pushd` to the current Finder directory        |\n| `quick-look`  | Quick-Look a specified file                    |\n| `man-preview` | Open a specified man page in Preview app       |\n\n\n### [git](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git)\n> The git plugin provides many aliases and a few useful functions.\n\n一款提供git别名命令以及一些方法命令的插件\n\n\n### [git-extras](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#git-extras)\n\n一款扩展了不少方便快捷git命令的插件\n\n### More Plugins\n更多的插件介绍见 [zsh plugins](https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins)\n\n## vi(vim) 基础\n使用命令行的时候，难免会遇到要编辑文档的时刻，尽管不是vim党，但是如果掌握vim的基本操作，对效率还是有大大提升的。\n\n### vi与vim的关系\n简单来说，vi是老师的文字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim则可以说是程序开发者的一项很好用的工具，就连vim的官方网站([http://www.vim.org/](http://www.vim.org/))自己也说vim是一个「程序开发工具」而不是文字处理软件。\n\n### 三种模式\n基本上vi中共分为3种模式，分别是「一般模式」，「编辑模式」与「命令行模式」\n\n* 一般模式\n以vi打开一个文件，默认就是一般模式，这个模式中，可以按下`i`来进入编辑模式，按下`ESC`则退出编辑模式回到一般模式。\n在这个模式中可以删除字符、删除行、复制、黏贴。\n\n* 编辑模式\n编辑模式能真正的编辑文本。\n\n* 命令模式\n在一般模式中，输入`:`,`/`,`?`中的一个可以进入命令行模式，进行诸如数据查找操作，读取、保存、离开vi等等操作。\n\n### 常用操作\n掌握下面的十一个命令，就足够你在vim中生存了。\n\n**移动光标**\n\n* hjkl : 你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。\n\n**行操作**\n\n* dd : 删除当前行，并把删除的行存到剪贴板里\n* yy : 复制当前行。\n* p  : 黏贴剪贴板\n\n**保存退出**\n\n* :w : 保存已编辑的文集\n* :q : 退出编辑\n* :wq : 保存并退出\n* :help : 显示相关命令的帮助(退出帮助需要输入:q)\n\n**搜索**\n* /word : 向下寻找一个名为word的字符串 \n* ?word : 向上寻找一个名为word的字符串\n* n : 重复前一个查找的操作\n\n# 文末福利，安抚你的强迫症\n感谢你能耐心的看到这里，给你安利一个强迫症患者福音的窗口控制工具：[Spectacle](https://www.spectacleapp.com/)\n\nSpectacle能通过快捷键，很轻易的排列好窗口的大小。\n\n![Spectacle](/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif)\n\n# 参考\nhttp://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively\nhttps://github.com/robbyrussell/oh-my-zsh/wiki/Plugins\nhttp://www.vim.org/\nhttp://macshuo.com/?p=676\nhttp://swiftcafe.io/2015/07/25/iterm/\n No newline at end of file\n","slug":"打造高效个性Terminal（二）之 zsh","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqm002j15hlefx13l6i","content":"<h1 id=\"oh-my-zsh\"><a href=\"#oh-my-zsh\" class=\"headerlink\" title=\"oh-my-zsh\"></a>oh-my-zsh</h1><p>如果说<strong>iTerm</strong>塑造了一个婀娜多姿颜值高的貌美姑娘，那么<strong>zsh</strong>就是给她塑造了一个柔情侠骨百事通的女汉子之心。</p>\n<h2 id=\"简介-Introduction\"><a href=\"#简介-Introduction\" class=\"headerlink\" title=\"简介 Introduction\"></a>简介 <small>Introduction</small></h2><p>对于<strong>zsh</strong>的作用，摘自池建强老师的一段：</p>\n<blockquote>\n<p>目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史「终极 Shell」，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：<a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"external\">https://github.com/robbyrussell/oh-my-zsh</a>。</p>\n</blockquote>\n<p><strong>oh-my-zsh</strong> 是一个社区驱动用于管理zsh的框架，囊括了140多个主题，200多个可选插件（如rails, git, OSX, hub, brew, ant, php, python etc.）。</p>\n<h2 id=\"安装-Installation\"><a href=\"#安装-Installation\" class=\"headerlink\" title=\"安装 Installation\"></a>安装 <small>Installation</small></h2><p><strong>via curl</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</div></pre></td></tr></table></figure></p>\n<p><strong>via wget</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</div></pre></td></tr></table></figure></p>\n<h2 id=\"配置-Configuration\"><a href=\"#配置-Configuration\" class=\"headerlink\" title=\"配置 Configuration\"></a>配置 <small>Configuration</small></h2><p>zsh的配置主要集中在用户当前目录的<code>.zshrc</code>里，用vim或者你喜欢的其他编辑器打开这个文件，在里面可以修改主题、插件以及定义自己的环境变量等操作。</p>\n<h2 id=\"主题-Themes\"><a href=\"#主题-Themes\" class=\"headerlink\" title=\"主题 Themes\"></a>主题 <small>Themes</small></h2><p>用vim打开<code>~/.zshrc</code>中，可以看到这样配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"># Set name of the theme to load.</div><div class=\"line\"># Look in ~/.oh-my-zsh/themes/</div><div class=\"line\"># Optionally, if you set this to &quot;random&quot;, it&apos;ll load a random theme each</div><div class=\"line\"># time that oh-my-zsh is loaded.</div><div class=\"line\">ZSH_THEME=&quot;robbyrussell&quot;</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<p>修改<code>ZSH_THEME</code>的值就可以更换主题。</p>\n<p>默认的主题是<code>robbyrussell</code>，这个并不是最精彩，也并不是最简单的一个，只是对于其作者Robby来说最适合的一个。</p>\n<p>可以通过访问<code>~/.oh-my-zsh/themes/</code>目录查看哪些可选的主题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ tree themes</div><div class=\"line\">themes</div><div class=\"line\">├── 3den.zsh-theme</div><div class=\"line\">├── Soliah.zsh-theme</div><div class=\"line\">├── adben.zsh-theme</div><div class=\"line\">├── af-magic.zsh-theme</div><div class=\"line\">├── afowler.zsh-theme</div><div class=\"line\">├── agnoster.zsh-theme</div><div class=\"line\">...</div><div class=\"line\">0 directories, 141 files</div></pre></td></tr></table></figure>\n<p>更多关于各个主题的详细介绍见 <a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/themes\" target=\"_blank\" rel=\"external\">zsh themes</a>，另外还有不少并不是自带的主题，见<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes\" target=\"_blank\" rel=\"external\">more external themes</a></p>\n<h3 id=\"Powerline-Fonts\"><a href=\"#Powerline-Fonts\" class=\"headerlink\" title=\"Powerline Fonts\"></a>Powerline Fonts</h3><p>如果你查看过zsh的主题列表的话，你会发现不少主题会有这样的样式，</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg\" alt=\"混合\"></p>\n<p>然而，当你选择了这样的主题，会发现实际是这样的</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg\" alt=\"23.pic.jpg\"></p>\n<p>因为，这些主题都依赖于一种字体<a href=\"https://github.com/powerline/fonts\" target=\"_blank\" rel=\"external\">powerline fonts</a>，<code>powerline fonts</code>是vim增强组件<a href=\"https://github.com/Lokaltog/vim-powerline\" target=\"_blank\" rel=\"external\">vim powerline</a>附属的字体，如果要使用依赖这种字体的主题，要在系统中安装该字体。</p>\n<h3 id=\"安装-powerline-fonts\"><a href=\"#安装-powerline-fonts\" class=\"headerlink\" title=\"安装 powerline fonts\"></a>安装 powerline fonts</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 下载powerline fonts项目</div><div class=\"line\">git clone https://github.com/powerline/fonts</div><div class=\"line\">// 执行安装</div><div class=\"line\">./fonts/install.sh</div></pre></td></tr></table></figure>\n<h3 id=\"配置iTerm\"><a href=\"#配置iTerm\" class=\"headerlink\" title=\"配置iTerm\"></a>配置iTerm</h3><p>在<code>Preperence → Profiles → Text → Front</code> 中，<br>和<code>Preperence → Profiles → Text → Non-ASCII Font</code>中<br>改变字体为<code>Sauce Code Powerline</code></p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg\" alt=\"改变字体\"></p>\n<h2 id=\"插件-Plugins\"><a href=\"#插件-Plugins\" class=\"headerlink\" title=\"插件 Plugins\"></a>插件 <small>Plugins</small></h2><p>用vim打开<code>~/.zshrc</code>中，可以看到这样配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"># Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)</div><div class=\"line\"># Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</div><div class=\"line\"># Example format: plugins=(rails git textmate ruby lighthouse)</div><div class=\"line\"># Add wisely, as too many plugins slow down shell startup.</div><div class=\"line\">plugins=(git)</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<p>修改<code>plugins</code>的值就可以修改或添加插件。</p>\n<p>下面介绍几款我常用的插件</p>\n<h3 id=\"autojump\"><a href=\"#autojump\" class=\"headerlink\" title=\"autojump\"></a><a href=\"https://github.com/wting/autojump\" target=\"_blank\" rel=\"external\">autojump</a></h3><blockquote>\n<p>A cd command that learns - easily navigate directories from the command line</p>\n</blockquote>\n<p>一款快捷跳转目标路径的插件，支持模糊匹配，自动补全，历史记录等功能。</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif\" alt=\"autojump\"></p>\n<h3 id=\"dirhistory\"><a href=\"#dirhistory\" class=\"headerlink\" title=\"dirhistory\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#dirhistory\" target=\"_blank\" rel=\"external\">dirhistory</a></h3><blockquote>\n<p>This plugin allows you to navigate the history of previous current-working-directories using ALT-LEFT and ALT-RIGHT. ALT-LEFT moves back to directories that the user has changed to in the past, and ALT-RIGHT undoes ALT-LEFT.</p>\n</blockquote>\n<p>一款支持目录的上翻，下翻功能的插件。</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif\" alt=\"dirhistory\"></p>\n<h3 id=\"osx\"><a href=\"#osx\" class=\"headerlink\" title=\"osx\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx\" target=\"_blank\" rel=\"external\">osx</a></h3><blockquote>\n<p>This plugin provides a few utilities to make it more enjoyable on OSX.</p>\n</blockquote>\n<p>一款增加了一些在OSX上实用的命令插件。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>tab</code></td>\n<td style=\"text-align:left\">Open the current directory in a new tab</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ofd</code></td>\n<td style=\"text-align:left\">Open the current directory in a Finder window</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pfd</code></td>\n<td style=\"text-align:left\">Return the path of the frontmost Finder window</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pfs</code></td>\n<td style=\"text-align:left\">Return the current Finder selection</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>cdf</code></td>\n<td style=\"text-align:left\"><code>cd</code> to the current Finder directory</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pushdf</code></td>\n<td style=\"text-align:left\"><code>pushd</code> to the current Finder directory</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>quick-look</code></td>\n<td style=\"text-align:left\">Quick-Look a specified file</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>man-preview</code></td>\n<td style=\"text-align:left\">Open a specified man page in Preview app</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git\" target=\"_blank\" rel=\"external\">git</a></h3><blockquote>\n<p>The git plugin provides many aliases and a few useful functions.</p>\n</blockquote>\n<p>一款提供git别名命令以及一些方法命令的插件</p>\n<h3 id=\"git-extras\"><a href=\"#git-extras\" class=\"headerlink\" title=\"git-extras\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#git-extras\" target=\"_blank\" rel=\"external\">git-extras</a></h3><p>一款扩展了不少方便快捷git命令的插件</p>\n<h3 id=\"More-Plugins\"><a href=\"#More-Plugins\" class=\"headerlink\" title=\"More Plugins\"></a>More Plugins</h3><p>更多的插件介绍见 <a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins\" target=\"_blank\" rel=\"external\">zsh plugins</a></p>\n<h2 id=\"vi-vim-基础\"><a href=\"#vi-vim-基础\" class=\"headerlink\" title=\"vi(vim) 基础\"></a>vi(vim) 基础</h2><p>使用命令行的时候，难免会遇到要编辑文档的时刻，尽管不是vim党，但是如果掌握vim的基本操作，对效率还是有大大提升的。</p>\n<h3 id=\"vi与vim的关系\"><a href=\"#vi与vim的关系\" class=\"headerlink\" title=\"vi与vim的关系\"></a>vi与vim的关系</h3><p>简单来说，vi是老师的文字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim则可以说是程序开发者的一项很好用的工具，就连vim的官方网站(<a href=\"http://www.vim.org/\" target=\"_blank\" rel=\"external\">http://www.vim.org/</a>)自己也说vim是一个「程序开发工具」而不是文字处理软件。</p>\n<h3 id=\"三种模式\"><a href=\"#三种模式\" class=\"headerlink\" title=\"三种模式\"></a>三种模式</h3><p>基本上vi中共分为3种模式，分别是「一般模式」，「编辑模式」与「命令行模式」</p>\n<ul>\n<li><p>一般模式<br>以vi打开一个文件，默认就是一般模式，这个模式中，可以按下<code>i</code>来进入编辑模式，按下<code>ESC</code>则退出编辑模式回到一般模式。<br>在这个模式中可以删除字符、删除行、复制、黏贴。</p>\n</li>\n<li><p>编辑模式<br>编辑模式能真正的编辑文本。</p>\n</li>\n<li><p>命令模式<br>在一般模式中，输入<code>:</code>,<code>/</code>,<code>?</code>中的一个可以进入命令行模式，进行诸如数据查找操作，读取、保存、离开vi等等操作。</p>\n</li>\n</ul>\n<h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><p>掌握下面的十一个命令，就足够你在vim中生存了。</p>\n<p><strong>移动光标</strong></p>\n<ul>\n<li>hjkl : 你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。</li>\n</ul>\n<p><strong>行操作</strong></p>\n<ul>\n<li>dd : 删除当前行，并把删除的行存到剪贴板里</li>\n<li>yy : 复制当前行。</li>\n<li>p  : 黏贴剪贴板</li>\n</ul>\n<p><strong>保存退出</strong></p>\n<ul>\n<li>:w : 保存已编辑的文集</li>\n<li>:q : 退出编辑</li>\n<li>:wq : 保存并退出</li>\n<li>:help : 显示相关命令的帮助(退出帮助需要输入:q)</li>\n</ul>\n<p><strong>搜索</strong></p>\n<ul>\n<li>/word : 向下寻找一个名为word的字符串 </li>\n<li>?word : 向上寻找一个名为word的字符串</li>\n<li>n : 重复前一个查找的操作</li>\n</ul>\n<h1 id=\"文末福利，安抚你的强迫症\"><a href=\"#文末福利，安抚你的强迫症\" class=\"headerlink\" title=\"文末福利，安抚你的强迫症\"></a>文末福利，安抚你的强迫症</h1><p>感谢你能耐心的看到这里，给你安利一个强迫症患者福音的窗口控制工具：<a href=\"https://www.spectacleapp.com/\" target=\"_blank\" rel=\"external\">Spectacle</a></p>\n<p>Spectacle能通过快捷键，很轻易的排列好窗口的大小。</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif\" alt=\"Spectacle\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively\" target=\"_blank\" rel=\"external\">http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively</a><br><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins\" target=\"_blank\" rel=\"external\">https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins</a><br><a href=\"http://www.vim.org/\" target=\"_blank\" rel=\"external\">http://www.vim.org/</a><br><a href=\"http://macshuo.com/?p=676\" target=\"_blank\" rel=\"external\">http://macshuo.com/?p=676</a><br><a href=\"http://swiftcafe.io/2015/07/25/iterm/\" target=\"_blank\" rel=\"external\">http://swiftcafe.io/2015/07/25/iterm/</a><br> No newline at end of file</p>\n","excerpt":"","more":"<h1 id=\"oh-my-zsh\"><a href=\"#oh-my-zsh\" class=\"headerlink\" title=\"oh-my-zsh\"></a>oh-my-zsh</h1><p>如果说<strong>iTerm</strong>塑造了一个婀娜多姿颜值高的貌美姑娘，那么<strong>zsh</strong>就是给她塑造了一个柔情侠骨百事通的女汉子之心。</p>\n<h2 id=\"简介-Introduction\"><a href=\"#简介-Introduction\" class=\"headerlink\" title=\"简介 Introduction\"></a>简介 <small>Introduction</small></h2><p>对于<strong>zsh</strong>的作用，摘自池建强老师的一段：</p>\n<blockquote>\n<p>目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史「终极 Shell」，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：<a href=\"https://github.com/robbyrussell/oh-my-zsh\">https://github.com/robbyrussell/oh-my-zsh</a>。</p>\n</blockquote>\n<p><strong>oh-my-zsh</strong> 是一个社区驱动用于管理zsh的框架，囊括了140多个主题，200多个可选插件（如rails, git, OSX, hub, brew, ant, php, python etc.）。</p>\n<h2 id=\"安装-Installation\"><a href=\"#安装-Installation\" class=\"headerlink\" title=\"安装 Installation\"></a>安装 <small>Installation</small></h2><p><strong>via curl</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</div></pre></td></tr></table></figure></p>\n<p><strong>via wget</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</div></pre></td></tr></table></figure></p>\n<h2 id=\"配置-Configuration\"><a href=\"#配置-Configuration\" class=\"headerlink\" title=\"配置 Configuration\"></a>配置 <small>Configuration</small></h2><p>zsh的配置主要集中在用户当前目录的<code>.zshrc</code>里，用vim或者你喜欢的其他编辑器打开这个文件，在里面可以修改主题、插件以及定义自己的环境变量等操作。</p>\n<h2 id=\"主题-Themes\"><a href=\"#主题-Themes\" class=\"headerlink\" title=\"主题 Themes\"></a>主题 <small>Themes</small></h2><p>用vim打开<code>~/.zshrc</code>中，可以看到这样配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"># Set name of the theme to load.</div><div class=\"line\"># Look in ~/.oh-my-zsh/themes/</div><div class=\"line\"># Optionally, if you set this to &quot;random&quot;, it&apos;ll load a random theme each</div><div class=\"line\"># time that oh-my-zsh is loaded.</div><div class=\"line\">ZSH_THEME=&quot;robbyrussell&quot;</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<p>修改<code>ZSH_THEME</code>的值就可以更换主题。</p>\n<p>默认的主题是<code>robbyrussell</code>，这个并不是最精彩，也并不是最简单的一个，只是对于其作者Robby来说最适合的一个。</p>\n<p>可以通过访问<code>~/.oh-my-zsh/themes/</code>目录查看哪些可选的主题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ tree themes</div><div class=\"line\">themes</div><div class=\"line\">├── 3den.zsh-theme</div><div class=\"line\">├── Soliah.zsh-theme</div><div class=\"line\">├── adben.zsh-theme</div><div class=\"line\">├── af-magic.zsh-theme</div><div class=\"line\">├── afowler.zsh-theme</div><div class=\"line\">├── agnoster.zsh-theme</div><div class=\"line\">...</div><div class=\"line\">0 directories, 141 files</div></pre></td></tr></table></figure>\n<p>更多关于各个主题的详细介绍见 <a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/themes\">zsh themes</a>，另外还有不少并不是自带的主题，见<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes\">more external themes</a></p>\n<h3 id=\"Powerline-Fonts\"><a href=\"#Powerline-Fonts\" class=\"headerlink\" title=\"Powerline Fonts\"></a>Powerline Fonts</h3><p>如果你查看过zsh的主题列表的话，你会发现不少主题会有这样的样式，</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/9A5F3A14AAB88648A5BF5397428A6F6B.jpg\" alt=\"混合\"></p>\n<p>然而，当你选择了这样的主题，会发现实际是这样的</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/4CF69060B9846B43DC49B616503E6FE9.jpg\" alt=\"23.pic.jpg\"></p>\n<p>因为，这些主题都依赖于一种字体<a href=\"https://github.com/powerline/fonts\">powerline fonts</a>，<code>powerline fonts</code>是vim增强组件<a href=\"https://github.com/Lokaltog/vim-powerline\">vim powerline</a>附属的字体，如果要使用依赖这种字体的主题，要在系统中安装该字体。</p>\n<h3 id=\"安装-powerline-fonts\"><a href=\"#安装-powerline-fonts\" class=\"headerlink\" title=\"安装 powerline fonts\"></a>安装 powerline fonts</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 下载powerline fonts项目</div><div class=\"line\">git clone https://github.com/powerline/fonts</div><div class=\"line\">// 执行安装</div><div class=\"line\">./fonts/install.sh</div></pre></td></tr></table></figure>\n<h3 id=\"配置iTerm\"><a href=\"#配置iTerm\" class=\"headerlink\" title=\"配置iTerm\"></a>配置iTerm</h3><p>在<code>Preperence → Profiles → Text → Front</code> 中，<br>和<code>Preperence → Profiles → Text → Non-ASCII Font</code>中<br>改变字体为<code>Sauce Code Powerline</code></p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/CBB6D3E305C5BF824C676EDEC38485D2.jpg\" alt=\"改变字体\"></p>\n<h2 id=\"插件-Plugins\"><a href=\"#插件-Plugins\" class=\"headerlink\" title=\"插件 Plugins\"></a>插件 <small>Plugins</small></h2><p>用vim打开<code>~/.zshrc</code>中，可以看到这样配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"># Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)</div><div class=\"line\"># Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</div><div class=\"line\"># Example format: plugins=(rails git textmate ruby lighthouse)</div><div class=\"line\"># Add wisely, as too many plugins slow down shell startup.</div><div class=\"line\">plugins=(git)</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<p>修改<code>plugins</code>的值就可以修改或添加插件。</p>\n<p>下面介绍几款我常用的插件</p>\n<h3 id=\"autojump\"><a href=\"#autojump\" class=\"headerlink\" title=\"autojump\"></a><a href=\"https://github.com/wting/autojump\">autojump</a></h3><blockquote>\n<p>A cd command that learns - easily navigate directories from the command line</p>\n</blockquote>\n<p>一款快捷跳转目标路径的插件，支持模糊匹配，自动补全，历史记录等功能。</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/5EF9E1CDFEF91CFDD426CBD029F36730.gif\" alt=\"autojump\"></p>\n<h3 id=\"dirhistory\"><a href=\"#dirhistory\" class=\"headerlink\" title=\"dirhistory\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#dirhistory\">dirhistory</a></h3><blockquote>\n<p>This plugin allows you to navigate the history of previous current-working-directories using ALT-LEFT and ALT-RIGHT. ALT-LEFT moves back to directories that the user has changed to in the past, and ALT-RIGHT undoes ALT-LEFT.</p>\n</blockquote>\n<p>一款支持目录的上翻，下翻功能的插件。</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/B046659B5B18FD6D356B18F4F089ADC6.gif\" alt=\"dirhistory\"></p>\n<h3 id=\"osx\"><a href=\"#osx\" class=\"headerlink\" title=\"osx\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx\">osx</a></h3><blockquote>\n<p>This plugin provides a few utilities to make it more enjoyable on OSX.</p>\n</blockquote>\n<p>一款增加了一些在OSX上实用的命令插件。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Command</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>tab</code></td>\n<td style=\"text-align:left\">Open the current directory in a new tab</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>ofd</code></td>\n<td style=\"text-align:left\">Open the current directory in a Finder window</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pfd</code></td>\n<td style=\"text-align:left\">Return the path of the frontmost Finder window</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pfs</code></td>\n<td style=\"text-align:left\">Return the current Finder selection</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>cdf</code></td>\n<td style=\"text-align:left\"><code>cd</code> to the current Finder directory</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>pushdf</code></td>\n<td style=\"text-align:left\"><code>pushd</code> to the current Finder directory</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>quick-look</code></td>\n<td style=\"text-align:left\">Quick-Look a specified file</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>man-preview</code></td>\n<td style=\"text-align:left\">Open a specified man page in Preview app</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git\">git</a></h3><blockquote>\n<p>The git plugin provides many aliases and a few useful functions.</p>\n</blockquote>\n<p>一款提供git别名命令以及一些方法命令的插件</p>\n<h3 id=\"git-extras\"><a href=\"#git-extras\" class=\"headerlink\" title=\"git-extras\"></a><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#git-extras\">git-extras</a></h3><p>一款扩展了不少方便快捷git命令的插件</p>\n<h3 id=\"More-Plugins\"><a href=\"#More-Plugins\" class=\"headerlink\" title=\"More Plugins\"></a>More Plugins</h3><p>更多的插件介绍见 <a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins\">zsh plugins</a></p>\n<h2 id=\"vi-vim-基础\"><a href=\"#vi-vim-基础\" class=\"headerlink\" title=\"vi(vim) 基础\"></a>vi(vim) 基础</h2><p>使用命令行的时候，难免会遇到要编辑文档的时刻，尽管不是vim党，但是如果掌握vim的基本操作，对效率还是有大大提升的。</p>\n<h3 id=\"vi与vim的关系\"><a href=\"#vi与vim的关系\" class=\"headerlink\" title=\"vi与vim的关系\"></a>vi与vim的关系</h3><p>简单来说，vi是老师的文字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim则可以说是程序开发者的一项很好用的工具，就连vim的官方网站(<a href=\"http://www.vim.org/\">http://www.vim.org/</a>)自己也说vim是一个「程序开发工具」而不是文字处理软件。</p>\n<h3 id=\"三种模式\"><a href=\"#三种模式\" class=\"headerlink\" title=\"三种模式\"></a>三种模式</h3><p>基本上vi中共分为3种模式，分别是「一般模式」，「编辑模式」与「命令行模式」</p>\n<ul>\n<li><p>一般模式<br>以vi打开一个文件，默认就是一般模式，这个模式中，可以按下<code>i</code>来进入编辑模式，按下<code>ESC</code>则退出编辑模式回到一般模式。<br>在这个模式中可以删除字符、删除行、复制、黏贴。</p>\n</li>\n<li><p>编辑模式<br>编辑模式能真正的编辑文本。</p>\n</li>\n<li><p>命令模式<br>在一般模式中，输入<code>:</code>,<code>/</code>,<code>?</code>中的一个可以进入命令行模式，进行诸如数据查找操作，读取、保存、离开vi等等操作。</p>\n</li>\n</ul>\n<h3 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h3><p>掌握下面的十一个命令，就足够你在vim中生存了。</p>\n<p><strong>移动光标</strong></p>\n<ul>\n<li>hjkl : 你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。</li>\n</ul>\n<p><strong>行操作</strong></p>\n<ul>\n<li>dd : 删除当前行，并把删除的行存到剪贴板里</li>\n<li>yy : 复制当前行。</li>\n<li>p  : 黏贴剪贴板</li>\n</ul>\n<p><strong>保存退出</strong></p>\n<ul>\n<li>:w : 保存已编辑的文集</li>\n<li>:q : 退出编辑</li>\n<li>:wq : 保存并退出</li>\n<li>:help : 显示相关命令的帮助(退出帮助需要输入:q)</li>\n</ul>\n<p><strong>搜索</strong></p>\n<ul>\n<li>/word : 向下寻找一个名为word的字符串 </li>\n<li>?word : 向上寻找一个名为word的字符串</li>\n<li>n : 重复前一个查找的操作</li>\n</ul>\n<h1 id=\"文末福利，安抚你的强迫症\"><a href=\"#文末福利，安抚你的强迫症\" class=\"headerlink\" title=\"文末福利，安抚你的强迫症\"></a>文末福利，安抚你的强迫症</h1><p>感谢你能耐心的看到这里，给你安利一个强迫症患者福音的窗口控制工具：<a href=\"https://www.spectacleapp.com/\">Spectacle</a></p>\n<p>Spectacle能通过快捷键，很轻易的排列好窗口的大小。</p>\n<p><img src=\"/image/blog/make-beauty-and-productify-terminal-part2/878986C0344538018F330B79A4C7F5FF.gif\" alt=\"Spectacle\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively\">http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively</a><br><a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins\">https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins</a><br><a href=\"http://www.vim.org/\">http://www.vim.org/</a><br><a href=\"http://macshuo.com/?p=676\">http://macshuo.com/?p=676</a><br><a href=\"http://swiftcafe.io/2015/07/25/iterm/\">http://swiftcafe.io/2015/07/25/iterm/</a><br> No newline at end of file</p>\n"},{"title":"在Nodejs中贯彻单元测试","date":"2015-07-30T08:32:34.000Z","_content":"\n在团队合作中，你写好了一个函数，供队友使用，跑去跟你的队友说，你传个A值进去，他就会返回B结果了。过了一会，你队友跑过来说，我传个A值却返回C结果，怎么回事？你丫的有没有测试过啊？\n\n大家一起写个项目，难免会有我要写的函数里面依赖别人的函数，但是这个函数到底值不值得信赖？单元测试是衡量代码质量的一重要标准，纵观Github的受欢迎项目，都是有test文件夹，并且buliding-pass的。如果你也为社区贡献过module，想更多人使用的话，加上单元测试吧，让你的module值得别人信赖。\n\n要在Nodejs中写单元测试的话，你需要知道用什么测试框架，怎么测试异步函数，怎么测试私有方法，怎么模拟测试环境，怎么测试依赖HTTP协议的web应用，需要了解TDD和BDD，还有需要提供测试的覆盖率。\n\n> 本文的示例代码会备份到 Github : [unittest-demo](https://github.com/JerryC8080/unittest-demo)\n\n## 目录\n\n1. 测试框架\n2. 断言库\n3. 需求变更\n4. 异步测试\n5. 异常测试\n6. 测试私有方法\n7. 测试Web应用\n8. 覆盖率\n9. 使用Makefile把测试串起来\n10. 持续集成，Travis-cli\n11. 一些观点\n12. 彩蛋\n13. 整理\n\n\n\n## 测试框架\n\nNodejs的测试框架还用说？大家都在用，Mocha。\n\nMocha 是一个功能丰富的Javascript测试框架，它能运行在Node.js和浏览器中，支持**BDD**、**TDD**、**QUnit**、**Exports**式的测试，本文主要示例是使用更接近与思考方式的BDD，\b如果了解更多可以访问Mocha的[官网](http://mochajs.org/)\n\n#### \b\n\n#### 测试接口\n\nMocha的BDD接口有：\n\n- `describe()`\n- `it()`\n- `before()`\n- `after()`\n- `beforeEach()`\n- `afterEach()`\n\n\n\n#### 安装\n\n`npm install mocha -g`\n\n\n\n#### 编写一个稳定可靠的模块\n\n模块具备limit方法，输入一个数值，小于0的时候返回0，其余正常返回\n\n``` javascript\nexports.limit = function (num) {\n  if (num < 0) {\n    return 0;\n  }\n  return num;\n};\n```\n\n\n\n#### 目录分配\n\n- `lib`，存放模块代码的地方\n- `test`，存放单元测试代码的地方\n- `index.js`，向外导出模块的地方\n- `package.json`，包描述文件\n\n\n\n#### 测试\n\n``` javascript\nvar lib = require('index');\n\ndescribe('module', function () {\n  describe('limit', function () {\n    it('limit should success', function () {\n      lib.limit(10);\n    });\n  });\n});\n```\n\n\n\n#### 结果\n\n在当前目录下执行`mocha`：\n\n``` \n$ mocha\n\n  ․\n\n  ✔ 1 test complete (2ms)\n```\n\n\n\n## 断言库\n\n上面的代码只是运行了代码，并没有对结果进行检查，这时候就要用到断言库了，Node.js中常用的断言库有：\n\n- should.js\n- expect.js\n- chai\n\n\n\n#### 加上断言\n\n使用`should`库为测试用例加上断言\n\n``` javascript\nit('limit should success', function () {\n  lib.limit(10).should.be.equal(10);\n});\n```\n\n\n\n## \b需求变更\n\n需求变更啦： `limit`这个方法还要求返回值大于100时返回100。\n\n针对需求重构代码之后，正是测试用例的价值所在了，\n\n它能确保你的改动对原有成果没有造成破坏。\n\n但是，你要多做的一些工作的是，需要为新的需求编写新的测试代码。\n\n\n\n## 异步测试\n\n#### 测试异步回调\n\nlib库中新增async函数：\n\n``` javascript\nexports.async = function (callback) {\n  setTimeout(function () {\n    callback(10);\n  }, 10);\n};\t\n```\n\n测试异步代码：\n\n``` javascript\ndescribe('async', function () {\n  it('async', function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n```\n\n\n\n#### 测试Promise\n\n使用should提供的Promise断言接口:\n\n- `finally` | `eventually`\n- `fulfilled`\n- `fulfilledWith`\n- `rejected`\n- `rejectedWith`\n- `then`\n\n测试代码\n\n``` javascript\ndescribe('should', function () {\n  describe('#Promise', function () {\n    it('should.reject', function () {\n      (new Promise(function (resolve, reject) {\n        reject(new Error('wrong'));\n      })).should.be.rejectedWith('wrong');\n    });\n\n    it('should.fulfilled', function () {\n      (new Promise(function (resolve, reject) {\n        resolve({username: 'jc', age: 18, gender: 'male'})\n      })).should.be.fulfilled().then(function (it) {\n          it.should.have.property('username', 'jc');\n        })\n    });\n  });\n});\n```\n\n\n\n#### 异步方法的超时支持\n\nMocha的超时设定默认是2s，如果执行的测试超过2s的话，就会报timeout错误。\n\n可以主动修改超时时间，有两种方法。\n\n\n\n#### 命令行式\n\n`mocha -t 10000`\n\n\n\n#### API式\n\n``` javascript\ndescribe('async', function () {\n  this.timeout(10000);\n  it('async', function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n```\n\n这样的话`async`执行时间不超过10s，就不会报错timeout错误了。\n\n\n\n## 异常测试\n\n异常应该怎么测试，现在有`getContent`方法，他会读取指定文件的内容，但是不一定会成功，会抛出异常。\n\n``` javascript\nexports.getContent = function (filename, callback) {\n  fs.readFile(filename, 'utf-8', callback);\n};\n```\n\n这时候就应该模拟(mock)错误环境了\n\n#### 简单Mock\n\n``` javascript\ndescribe(\"getContent\", function () {\n  var _readFile;\n  before(function () {\n    _readFile = fs.readFile;\n    fs.readFile = function (filename, encoding, callback) {\n      process.nextTick(function () {\n        callback(new Error(\"mock readFile error\"));\n      });\n    };\t\n  });\n  // it();\n  after(function () {\n    // 用完之后记得还原。否则影响其他case\n    fs.readFile = _readFile;\n  })\n});\n```\n\n\n\n#### \bMock库\n\nMock小模块：[`muk`](https://github.com/fent/node-muk) ，略微优美的写法：\n\n``` javascript\nvar fs = require('fs');\nvar muk = require('muk');\n\nbefore(function () {\n  muk(fs, 'readFile', function(path, encoding, callback) {\n    process.nextTick(function () {\n      callback(new Error(\"mock readFile error\"));\n    });\n  });\n});\n// it();\nafter(function () {\n  muk.restore();\n});\n```\n\n\n\n## 测试私有方法\n\n针对一些内部的方法，没有通过exports暴露出来，怎么测试它？\n\n``` javascript\nfunction _adding(num1, num2) {\n  return num1 + num2;\n}\n```\n\n#### 通过rewire导出方法\n\n模块：[`rewire`](http://jhnns.github.com/rewire/)\n\n``` \nit('limit should return success', function () {\n  var lib = rewire('../lib/index.js');\n  var litmit = lib.__get__('limit');\n  litmit(10);\n});\n```\n\n\n\n## 测试Web应用\n\n在开发Web项目的时候，要测试某一个API，如：`/user`，到底怎么编写测试用例呢？\n\n使用：[`supertest`](https://github.com/visionmedia/supertest)\n\n``` javascript\nvar express = require(\"express\");\nvar request = require(\"supertest\");\nvar app = express();\n\n// 定义路由\napp.get('/user', function(req, res){\n  res.send(200, { name: 'jerryc' });\n});\n\ndescribe('GET /user', function(){\n  it('respond with json', function(done){\n    request(app)\n      .get('/user')\n      .set('Accept', 'application/json')\n      .expect('Content-Type', /json/)\n      .expect(200)\n      .end(function (err, res) {\n        if (err){\n          done(err);\n        }\n        res.body.name.should.be.eql('jerryc');\n        done();\n      })\n  });\n});\n```\n\n\n\n## 覆盖率\n\n测试的时候，我们常常关心，是否所有代码都测试到了。\n\n这个指标就叫做[\"代码覆盖率\"](http://en.wikipedia.org/wiki/Code_coverage)（code coverage）。它有四个测量维度。\n\n> - **行覆盖率**（line coverage）：是否每一行都执行了？\n> - **函数覆盖率**（function coverage）：是否每个函数都调用了？\n> - **分支覆盖率**（branch coverage）：是否每个if代码块都执行了？\n> - **语句覆盖率**（statement coverage）：是否每个语句都执行了？\n\n[Istanbul](https://github.com/gotwarlost/istanbul) 是 JavaScript 程序的代码覆盖率工具。\n\n#### 安装\n\n`$ npm install -g istanbul`\n\n\n\n#### 覆盖率测试\n\n在编写过以上的测试用例之后，执行命令：\n\n`istanbul cover _mocha`\n\n就能得到覆盖率:\n\n``` javascript\nJerryC% istanbul cover _mocha                                                                                                                                                                \n\n\n  module\n    limit\n      ✓ limit should success\n    async\n      ✓ async\n    getContent\n      ✓ getContent\n    add\n      ✓ add\n\n  should\n    #Promise\n      ✓ should.reject\n      ✓ should fulfilled\n\n\n  6 passing (32ms)\n\n\n================== Coverage summary ======================\nStatements   : 100% ( 10/10 )\nBranches     : 100% ( 2/2 )\nFunctions    : 100% ( 5/5 )\nLines        : 100% ( 10/10 )\n==========================================================\n```\n\n这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。\n\n![覆盖率html](http://xia-dev.b0.upaiyun.com/eac87dbf-4e4b-426e-80ac-7c50e1b9a1cb.jpg)\n\n\n\n上面命令中，`istanbul cover` 命令后面跟的是 `_mocha` 命令，前面的下划线是不能省略的。\n\n因为，[mocha 和 _mocha 是两个不同的命令](https://github.com/gotwarlost/istanbul/issues/44)，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。\n\n如果要向 mocha 传入参数，可以写成下面的样子。\n\n``` \n$ istanbul cover _mocha -- tests/test.sqrt.js -R spec\n```\n\n上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接[1](http://www.clock.co.uk/blog/npm-module-code-coverage-in-2-simple-steps)，[2](http://www.vapidspace.com/coding/2014/10/29/code-coverage-metrics-with-mocha-and-istanbul/)）。\n\n\n\n## 使用Makefile串起项目 \n\n``` \nTESTS = test/*.test.js\nREPORTER = spec\nTIMEOUT = 10000\nJSCOVERAGE = ./node_modules/jscover/bin/jscover\n\ntest:\n    @NODE_ENV=test ./node_modules/mocha/bin/mocha -R $(REPORTER) -t $(TIMEOUT) $(TESTS)\n\ntest-cov: lib-cov\n    @LIB_COV=1 $(MAKE) test REPORTER=dot\n    @LIB_COV=1 $(MAKE) test REPORTER=html-cov > coverage.html\n\nlib-cov:\n    @rm -rf ./lib-cov\n    @$(JSCOVERAGE) lib lib-cov\n\n.PHONY: test test-cov lib-cov\n\nmake test\nmake test-cov\n\n```\n\n用项目自身的jscover和mocha，避免版本冲突和混乱\n\n\n\n## 持续集成，Travis-cli\n\n- [Travis-ci](https://travis-ci.org/)\n  - 绑定Github帐号\n  - 在Github仓库的Admin打开Services hook\n  - 打开Travis\n  - 每次push将会hook触发执行`npm test`命令\n\n注意：Travis会将未描述的项目当作Ruby项目。所以需要在根目录下加入`.travis.yml`文件。内容如下：\n\n``` yaml\nlanguage: node_js\nnode_js:\n  - \"0.12\"\n```\n\nTravis-cli还会对项目颁发标签，\n\n![/](https://camo.githubusercontent.com/f479d6cf4ac300093da5a90d70565cebf8c8ed40/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f4a61636b736f6e5469616e2f626167706970652e706e67)or ![/](https://camo.githubusercontent.com/08478cd5a732822aec47e6e60d5f823ef0898dec/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f54424544502f64617461766a732e706e67)\n\n如果项目通过所有测试，就会build-passing，\n\n如果项目没有通过所有测试，就会build-failing\n\n\n\n## 一些观点\n\n实施单元测试的时候, 如果没有一份经过实践证明的详细规范, 很难掌握测试的 \"度\", 范围太小施展不开, 太大又侵犯 \"别人的\" 地盘. 上帝的归上帝, 凯撒的归凯撒, 给单元测试念念紧箍咒不见得是件坏事, 反而更有利于发挥单元测试的威力, 为代码重构和提高代码质量提供动力.\n\n这份文档来自 Geotechnical, 是一份非常难得的经验准则. 你完全可以以这份准则作为模板, 结合所在团队的经验, 整理出一份内部单元测试准则.\n\n\n\n[单元测试准则](https://github.com/yangyubo/zh-unit-testing-guidelines)\n\n\n\n## 彩蛋\n\n最后，介绍一个库：[`faker`](https://github.com/Marak/Faker.js)\n\n他是一个能伪造用户数据的库，包括用户常包含的属性：个人信息、头像、地址等等。\n\n是一个开发初期，模拟用户数据的绝佳好库。\n\n支持Node.js和浏览器端。\n\n![生成用户](http://xia-dev.b0.upaiyun.com/43075e5e-026f-4acb-a51f-a998cf1a6e11.jpg)\n\n## 整理\n\n#### Nodejs的单元测试工具\n\n1. 测试框架 mocha\n2. 断言库：should.js、expect.js、chai\n3. 覆盖率：istanbul、jscover、blanket\n4. Mock库：muk\n5. 测试私有方法：rewire\n6. Web测试：supertest\n7. 持续集成：Travis-cli\n\n\n\n## 参考\n\n- [https://github.com/JacksonTian/unittesting](https://github.com/JacksonTian/unittesting)\n- []()[http://html5ify.com/unittesting/slides/index.html](http://html5ify.com/unittesting/slides/index.html)\n- [http://www.ruanyifeng.com/blog/2015/06/istanbul.html](http://www.ruanyifeng.com/blog/2015/06/istanbul.html)\n- [http://coolshell.cn/articles/8209.html](http://coolshell.cn/articles/8209.html)\n- [http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests](http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests)\n- [https://github.com/yangyubo/zh-unit-testing-guidelines](https://github.com/yangyubo/zh-unit-testing-guidelines)\n- [http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming](http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming)\n- [http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D](http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D)\n- [https://github.com/yangyubo/zh-unit-testing-guidelines](https://github.com/yangyubo/zh-unit-testing-guidelines)\n- [https://github.com/visionmedia/superagent/blob/master/Makefile](https://github.com/visionmedia/superagent/blob/master/Makefile)\n","source":"_posts/在Nodejs中贯彻单元测试.md","raw":"---\ntitle: 在Nodejs中贯彻单元测试\ncategory: 搬砖码农\ndate: 2015-07-30 16:32:34\ntags:\n- mocha\n- unit test\n- Nodejs\n---\n\n在团队合作中，你写好了一个函数，供队友使用，跑去跟你的队友说，你传个A值进去，他就会返回B结果了。过了一会，你队友跑过来说，我传个A值却返回C结果，怎么回事？你丫的有没有测试过啊？\n\n大家一起写个项目，难免会有我要写的函数里面依赖别人的函数，但是这个函数到底值不值得信赖？单元测试是衡量代码质量的一重要标准，纵观Github的受欢迎项目，都是有test文件夹，并且buliding-pass的。如果你也为社区贡献过module，想更多人使用的话，加上单元测试吧，让你的module值得别人信赖。\n\n要在Nodejs中写单元测试的话，你需要知道用什么测试框架，怎么测试异步函数，怎么测试私有方法，怎么模拟测试环境，怎么测试依赖HTTP协议的web应用，需要了解TDD和BDD，还有需要提供测试的覆盖率。\n\n> 本文的示例代码会备份到 Github : [unittest-demo](https://github.com/JerryC8080/unittest-demo)\n\n## 目录\n\n1. 测试框架\n2. 断言库\n3. 需求变更\n4. 异步测试\n5. 异常测试\n6. 测试私有方法\n7. 测试Web应用\n8. 覆盖率\n9. 使用Makefile把测试串起来\n10. 持续集成，Travis-cli\n11. 一些观点\n12. 彩蛋\n13. 整理\n\n\n\n## 测试框架\n\nNodejs的测试框架还用说？大家都在用，Mocha。\n\nMocha 是一个功能丰富的Javascript测试框架，它能运行在Node.js和浏览器中，支持**BDD**、**TDD**、**QUnit**、**Exports**式的测试，本文主要示例是使用更接近与思考方式的BDD，\b如果了解更多可以访问Mocha的[官网](http://mochajs.org/)\n\n#### \b\n\n#### 测试接口\n\nMocha的BDD接口有：\n\n- `describe()`\n- `it()`\n- `before()`\n- `after()`\n- `beforeEach()`\n- `afterEach()`\n\n\n\n#### 安装\n\n`npm install mocha -g`\n\n\n\n#### 编写一个稳定可靠的模块\n\n模块具备limit方法，输入一个数值，小于0的时候返回0，其余正常返回\n\n``` javascript\nexports.limit = function (num) {\n  if (num < 0) {\n    return 0;\n  }\n  return num;\n};\n```\n\n\n\n#### 目录分配\n\n- `lib`，存放模块代码的地方\n- `test`，存放单元测试代码的地方\n- `index.js`，向外导出模块的地方\n- `package.json`，包描述文件\n\n\n\n#### 测试\n\n``` javascript\nvar lib = require('index');\n\ndescribe('module', function () {\n  describe('limit', function () {\n    it('limit should success', function () {\n      lib.limit(10);\n    });\n  });\n});\n```\n\n\n\n#### 结果\n\n在当前目录下执行`mocha`：\n\n``` \n$ mocha\n\n  ․\n\n  ✔ 1 test complete (2ms)\n```\n\n\n\n## 断言库\n\n上面的代码只是运行了代码，并没有对结果进行检查，这时候就要用到断言库了，Node.js中常用的断言库有：\n\n- should.js\n- expect.js\n- chai\n\n\n\n#### 加上断言\n\n使用`should`库为测试用例加上断言\n\n``` javascript\nit('limit should success', function () {\n  lib.limit(10).should.be.equal(10);\n});\n```\n\n\n\n## \b需求变更\n\n需求变更啦： `limit`这个方法还要求返回值大于100时返回100。\n\n针对需求重构代码之后，正是测试用例的价值所在了，\n\n它能确保你的改动对原有成果没有造成破坏。\n\n但是，你要多做的一些工作的是，需要为新的需求编写新的测试代码。\n\n\n\n## 异步测试\n\n#### 测试异步回调\n\nlib库中新增async函数：\n\n``` javascript\nexports.async = function (callback) {\n  setTimeout(function () {\n    callback(10);\n  }, 10);\n};\t\n```\n\n测试异步代码：\n\n``` javascript\ndescribe('async', function () {\n  it('async', function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n```\n\n\n\n#### 测试Promise\n\n使用should提供的Promise断言接口:\n\n- `finally` | `eventually`\n- `fulfilled`\n- `fulfilledWith`\n- `rejected`\n- `rejectedWith`\n- `then`\n\n测试代码\n\n``` javascript\ndescribe('should', function () {\n  describe('#Promise', function () {\n    it('should.reject', function () {\n      (new Promise(function (resolve, reject) {\n        reject(new Error('wrong'));\n      })).should.be.rejectedWith('wrong');\n    });\n\n    it('should.fulfilled', function () {\n      (new Promise(function (resolve, reject) {\n        resolve({username: 'jc', age: 18, gender: 'male'})\n      })).should.be.fulfilled().then(function (it) {\n          it.should.have.property('username', 'jc');\n        })\n    });\n  });\n});\n```\n\n\n\n#### 异步方法的超时支持\n\nMocha的超时设定默认是2s，如果执行的测试超过2s的话，就会报timeout错误。\n\n可以主动修改超时时间，有两种方法。\n\n\n\n#### 命令行式\n\n`mocha -t 10000`\n\n\n\n#### API式\n\n``` javascript\ndescribe('async', function () {\n  this.timeout(10000);\n  it('async', function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n```\n\n这样的话`async`执行时间不超过10s，就不会报错timeout错误了。\n\n\n\n## 异常测试\n\n异常应该怎么测试，现在有`getContent`方法，他会读取指定文件的内容，但是不一定会成功，会抛出异常。\n\n``` javascript\nexports.getContent = function (filename, callback) {\n  fs.readFile(filename, 'utf-8', callback);\n};\n```\n\n这时候就应该模拟(mock)错误环境了\n\n#### 简单Mock\n\n``` javascript\ndescribe(\"getContent\", function () {\n  var _readFile;\n  before(function () {\n    _readFile = fs.readFile;\n    fs.readFile = function (filename, encoding, callback) {\n      process.nextTick(function () {\n        callback(new Error(\"mock readFile error\"));\n      });\n    };\t\n  });\n  // it();\n  after(function () {\n    // 用完之后记得还原。否则影响其他case\n    fs.readFile = _readFile;\n  })\n});\n```\n\n\n\n#### \bMock库\n\nMock小模块：[`muk`](https://github.com/fent/node-muk) ，略微优美的写法：\n\n``` javascript\nvar fs = require('fs');\nvar muk = require('muk');\n\nbefore(function () {\n  muk(fs, 'readFile', function(path, encoding, callback) {\n    process.nextTick(function () {\n      callback(new Error(\"mock readFile error\"));\n    });\n  });\n});\n// it();\nafter(function () {\n  muk.restore();\n});\n```\n\n\n\n## 测试私有方法\n\n针对一些内部的方法，没有通过exports暴露出来，怎么测试它？\n\n``` javascript\nfunction _adding(num1, num2) {\n  return num1 + num2;\n}\n```\n\n#### 通过rewire导出方法\n\n模块：[`rewire`](http://jhnns.github.com/rewire/)\n\n``` \nit('limit should return success', function () {\n  var lib = rewire('../lib/index.js');\n  var litmit = lib.__get__('limit');\n  litmit(10);\n});\n```\n\n\n\n## 测试Web应用\n\n在开发Web项目的时候，要测试某一个API，如：`/user`，到底怎么编写测试用例呢？\n\n使用：[`supertest`](https://github.com/visionmedia/supertest)\n\n``` javascript\nvar express = require(\"express\");\nvar request = require(\"supertest\");\nvar app = express();\n\n// 定义路由\napp.get('/user', function(req, res){\n  res.send(200, { name: 'jerryc' });\n});\n\ndescribe('GET /user', function(){\n  it('respond with json', function(done){\n    request(app)\n      .get('/user')\n      .set('Accept', 'application/json')\n      .expect('Content-Type', /json/)\n      .expect(200)\n      .end(function (err, res) {\n        if (err){\n          done(err);\n        }\n        res.body.name.should.be.eql('jerryc');\n        done();\n      })\n  });\n});\n```\n\n\n\n## 覆盖率\n\n测试的时候，我们常常关心，是否所有代码都测试到了。\n\n这个指标就叫做[\"代码覆盖率\"](http://en.wikipedia.org/wiki/Code_coverage)（code coverage）。它有四个测量维度。\n\n> - **行覆盖率**（line coverage）：是否每一行都执行了？\n> - **函数覆盖率**（function coverage）：是否每个函数都调用了？\n> - **分支覆盖率**（branch coverage）：是否每个if代码块都执行了？\n> - **语句覆盖率**（statement coverage）：是否每个语句都执行了？\n\n[Istanbul](https://github.com/gotwarlost/istanbul) 是 JavaScript 程序的代码覆盖率工具。\n\n#### 安装\n\n`$ npm install -g istanbul`\n\n\n\n#### 覆盖率测试\n\n在编写过以上的测试用例之后，执行命令：\n\n`istanbul cover _mocha`\n\n就能得到覆盖率:\n\n``` javascript\nJerryC% istanbul cover _mocha                                                                                                                                                                \n\n\n  module\n    limit\n      ✓ limit should success\n    async\n      ✓ async\n    getContent\n      ✓ getContent\n    add\n      ✓ add\n\n  should\n    #Promise\n      ✓ should.reject\n      ✓ should fulfilled\n\n\n  6 passing (32ms)\n\n\n================== Coverage summary ======================\nStatements   : 100% ( 10/10 )\nBranches     : 100% ( 2/2 )\nFunctions    : 100% ( 5/5 )\nLines        : 100% ( 10/10 )\n==========================================================\n```\n\n这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。\n\n![覆盖率html](http://xia-dev.b0.upaiyun.com/eac87dbf-4e4b-426e-80ac-7c50e1b9a1cb.jpg)\n\n\n\n上面命令中，`istanbul cover` 命令后面跟的是 `_mocha` 命令，前面的下划线是不能省略的。\n\n因为，[mocha 和 _mocha 是两个不同的命令](https://github.com/gotwarlost/istanbul/issues/44)，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。\n\n如果要向 mocha 传入参数，可以写成下面的样子。\n\n``` \n$ istanbul cover _mocha -- tests/test.sqrt.js -R spec\n```\n\n上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接[1](http://www.clock.co.uk/blog/npm-module-code-coverage-in-2-simple-steps)，[2](http://www.vapidspace.com/coding/2014/10/29/code-coverage-metrics-with-mocha-and-istanbul/)）。\n\n\n\n## 使用Makefile串起项目 \n\n``` \nTESTS = test/*.test.js\nREPORTER = spec\nTIMEOUT = 10000\nJSCOVERAGE = ./node_modules/jscover/bin/jscover\n\ntest:\n    @NODE_ENV=test ./node_modules/mocha/bin/mocha -R $(REPORTER) -t $(TIMEOUT) $(TESTS)\n\ntest-cov: lib-cov\n    @LIB_COV=1 $(MAKE) test REPORTER=dot\n    @LIB_COV=1 $(MAKE) test REPORTER=html-cov > coverage.html\n\nlib-cov:\n    @rm -rf ./lib-cov\n    @$(JSCOVERAGE) lib lib-cov\n\n.PHONY: test test-cov lib-cov\n\nmake test\nmake test-cov\n\n```\n\n用项目自身的jscover和mocha，避免版本冲突和混乱\n\n\n\n## 持续集成，Travis-cli\n\n- [Travis-ci](https://travis-ci.org/)\n  - 绑定Github帐号\n  - 在Github仓库的Admin打开Services hook\n  - 打开Travis\n  - 每次push将会hook触发执行`npm test`命令\n\n注意：Travis会将未描述的项目当作Ruby项目。所以需要在根目录下加入`.travis.yml`文件。内容如下：\n\n``` yaml\nlanguage: node_js\nnode_js:\n  - \"0.12\"\n```\n\nTravis-cli还会对项目颁发标签，\n\n![/](https://camo.githubusercontent.com/f479d6cf4ac300093da5a90d70565cebf8c8ed40/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f4a61636b736f6e5469616e2f626167706970652e706e67)or ![/](https://camo.githubusercontent.com/08478cd5a732822aec47e6e60d5f823ef0898dec/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f54424544502f64617461766a732e706e67)\n\n如果项目通过所有测试，就会build-passing，\n\n如果项目没有通过所有测试，就会build-failing\n\n\n\n## 一些观点\n\n实施单元测试的时候, 如果没有一份经过实践证明的详细规范, 很难掌握测试的 \"度\", 范围太小施展不开, 太大又侵犯 \"别人的\" 地盘. 上帝的归上帝, 凯撒的归凯撒, 给单元测试念念紧箍咒不见得是件坏事, 反而更有利于发挥单元测试的威力, 为代码重构和提高代码质量提供动力.\n\n这份文档来自 Geotechnical, 是一份非常难得的经验准则. 你完全可以以这份准则作为模板, 结合所在团队的经验, 整理出一份内部单元测试准则.\n\n\n\n[单元测试准则](https://github.com/yangyubo/zh-unit-testing-guidelines)\n\n\n\n## 彩蛋\n\n最后，介绍一个库：[`faker`](https://github.com/Marak/Faker.js)\n\n他是一个能伪造用户数据的库，包括用户常包含的属性：个人信息、头像、地址等等。\n\n是一个开发初期，模拟用户数据的绝佳好库。\n\n支持Node.js和浏览器端。\n\n![生成用户](http://xia-dev.b0.upaiyun.com/43075e5e-026f-4acb-a51f-a998cf1a6e11.jpg)\n\n## 整理\n\n#### Nodejs的单元测试工具\n\n1. 测试框架 mocha\n2. 断言库：should.js、expect.js、chai\n3. 覆盖率：istanbul、jscover、blanket\n4. Mock库：muk\n5. 测试私有方法：rewire\n6. Web测试：supertest\n7. 持续集成：Travis-cli\n\n\n\n## 参考\n\n- [https://github.com/JacksonTian/unittesting](https://github.com/JacksonTian/unittesting)\n- []()[http://html5ify.com/unittesting/slides/index.html](http://html5ify.com/unittesting/slides/index.html)\n- [http://www.ruanyifeng.com/blog/2015/06/istanbul.html](http://www.ruanyifeng.com/blog/2015/06/istanbul.html)\n- [http://coolshell.cn/articles/8209.html](http://coolshell.cn/articles/8209.html)\n- [http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests](http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests)\n- [https://github.com/yangyubo/zh-unit-testing-guidelines](https://github.com/yangyubo/zh-unit-testing-guidelines)\n- [http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming](http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming)\n- [http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D](http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D)\n- [https://github.com/yangyubo/zh-unit-testing-guidelines](https://github.com/yangyubo/zh-unit-testing-guidelines)\n- [https://github.com/visionmedia/superagent/blob/master/Makefile](https://github.com/visionmedia/superagent/blob/master/Makefile)\n","slug":"在Nodejs中贯彻单元测试","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqn002l15hln820y3xs","content":"<p>在团队合作中，你写好了一个函数，供队友使用，跑去跟你的队友说，你传个A值进去，他就会返回B结果了。过了一会，你队友跑过来说，我传个A值却返回C结果，怎么回事？你丫的有没有测试过啊？</p>\n<p>大家一起写个项目，难免会有我要写的函数里面依赖别人的函数，但是这个函数到底值不值得信赖？单元测试是衡量代码质量的一重要标准，纵观Github的受欢迎项目，都是有test文件夹，并且buliding-pass的。如果你也为社区贡献过module，想更多人使用的话，加上单元测试吧，让你的module值得别人信赖。</p>\n<p>要在Nodejs中写单元测试的话，你需要知道用什么测试框架，怎么测试异步函数，怎么测试私有方法，怎么模拟测试环境，怎么测试依赖HTTP协议的web应用，需要了解TDD和BDD，还有需要提供测试的覆盖率。</p>\n<blockquote>\n<p>本文的示例代码会备份到 Github : <a href=\"https://github.com/JerryC8080/unittest-demo\" target=\"_blank\" rel=\"external\">unittest-demo</a></p>\n</blockquote>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li>测试框架</li>\n<li>断言库</li>\n<li>需求变更</li>\n<li>异步测试</li>\n<li>异常测试</li>\n<li>测试私有方法</li>\n<li>测试Web应用</li>\n<li>覆盖率</li>\n<li>使用Makefile把测试串起来</li>\n<li>持续集成，Travis-cli</li>\n<li>一些观点</li>\n<li>彩蛋</li>\n<li>整理</li>\n</ol>\n<h2 id=\"测试框架\"><a href=\"#测试框架\" class=\"headerlink\" title=\"测试框架\"></a>测试框架</h2><p>Nodejs的测试框架还用说？大家都在用，Mocha。</p>\n<p>Mocha 是一个功能丰富的Javascript测试框架，它能运行在Node.js和浏览器中，支持<strong>BDD</strong>、<strong>TDD</strong>、<strong>QUnit</strong>、<strong>Exports</strong>式的测试，本文主要示例是使用更接近与思考方式的BDD，\b如果了解更多可以访问Mocha的<a href=\"http://mochajs.org/\" target=\"_blank\" rel=\"external\">官网</a></p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\b\"></a>\b</h4><h4 id=\"测试接口\"><a href=\"#测试接口\" class=\"headerlink\" title=\"测试接口\"></a>测试接口</h4><p>Mocha的BDD接口有：</p>\n<ul>\n<li><code>describe()</code></li>\n<li><code>it()</code></li>\n<li><code>before()</code></li>\n<li><code>after()</code></li>\n<li><code>beforeEach()</code></li>\n<li><code>afterEach()</code></li>\n</ul>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p><code>npm install mocha -g</code></p>\n<h4 id=\"编写一个稳定可靠的模块\"><a href=\"#编写一个稳定可靠的模块\" class=\"headerlink\" title=\"编写一个稳定可靠的模块\"></a>编写一个稳定可靠的模块</h4><p>模块具备limit方法，输入一个数值，小于0的时候返回0，其余正常返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports.limit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> num;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"目录分配\"><a href=\"#目录分配\" class=\"headerlink\" title=\"目录分配\"></a>目录分配</h4><ul>\n<li><code>lib</code>，存放模块代码的地方</li>\n<li><code>test</code>，存放单元测试代码的地方</li>\n<li><code>index.js</code>，向外导出模块的地方</li>\n<li><code>package.json</code>，包描述文件</li>\n</ul>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> lib = <span class=\"built_in\">require</span>(<span class=\"string\">'index'</span>);</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'module'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  describe(<span class=\"string\">'limit'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'limit should success'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      lib.limit(<span class=\"number\">10</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h4><p>在当前目录下执行<code>mocha</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mocha</div><div class=\"line\"></div><div class=\"line\">  ․</div><div class=\"line\"></div><div class=\"line\">  ✔ 1 test complete (2ms)</div></pre></td></tr></table></figure>\n<h2 id=\"断言库\"><a href=\"#断言库\" class=\"headerlink\" title=\"断言库\"></a>断言库</h2><p>上面的代码只是运行了代码，并没有对结果进行检查，这时候就要用到断言库了，Node.js中常用的断言库有：</p>\n<ul>\n<li>should.js</li>\n<li>expect.js</li>\n<li>chai</li>\n</ul>\n<h4 id=\"加上断言\"><a href=\"#加上断言\" class=\"headerlink\" title=\"加上断言\"></a>加上断言</h4><p>使用<code>should</code>库为测试用例加上断言</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">it(<span class=\"string\">'limit should success'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  lib.limit(<span class=\"number\">10</span>).should.be.equal(<span class=\"number\">10</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"需求变更\"><a href=\"#需求变更\" class=\"headerlink\" title=\"\b需求变更\"></a>\b需求变更</h2><p>需求变更啦： <code>limit</code>这个方法还要求返回值大于100时返回100。</p>\n<p>针对需求重构代码之后，正是测试用例的价值所在了，</p>\n<p>它能确保你的改动对原有成果没有造成破坏。</p>\n<p>但是，你要多做的一些工作的是，需要为新的需求编写新的测试代码。</p>\n<h2 id=\"异步测试\"><a href=\"#异步测试\" class=\"headerlink\" title=\"异步测试\"></a>异步测试</h2><h4 id=\"测试异步回调\"><a href=\"#测试异步回调\" class=\"headerlink\" title=\"测试异步回调\"></a>测试异步回调</h4><p>lib库中新增async函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports.async = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    callback(<span class=\"number\">10</span>);</div><div class=\"line\">  &#125;, <span class=\"number\">10</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>测试异步代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  it(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">done</span>) </span>&#123;</div><div class=\"line\">    lib.async(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">      done();</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"测试Promise\"><a href=\"#测试Promise\" class=\"headerlink\" title=\"测试Promise\"></a>测试Promise</h4><p>使用should提供的Promise断言接口:</p>\n<ul>\n<li><code>finally</code> | <code>eventually</code></li>\n<li><code>fulfilled</code></li>\n<li><code>fulfilledWith</code></li>\n<li><code>rejected</code></li>\n<li><code>rejectedWith</code></li>\n<li><code>then</code></li>\n</ul>\n<p>测试代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">'should'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  describe(<span class=\"string\">'#Promise'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'should.reject'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'wrong'</span>));</div><div class=\"line\">      &#125;)).should.be.rejectedWith(<span class=\"string\">'wrong'</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    it(<span class=\"string\">'should.fulfilled'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">        resolve(&#123;<span class=\"attr\">username</span>: <span class=\"string\">'jc'</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span>, <span class=\"attr\">gender</span>: <span class=\"string\">'male'</span>&#125;)</div><div class=\"line\">      &#125;)).should.be.fulfilled().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">it</span>) </span>&#123;</div><div class=\"line\">          it.should.have.property(<span class=\"string\">'username'</span>, <span class=\"string\">'jc'</span>);</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"异步方法的超时支持\"><a href=\"#异步方法的超时支持\" class=\"headerlink\" title=\"异步方法的超时支持\"></a>异步方法的超时支持</h4><p>Mocha的超时设定默认是2s，如果执行的测试超过2s的话，就会报timeout错误。</p>\n<p>可以主动修改超时时间，有两种方法。</p>\n<h4 id=\"命令行式\"><a href=\"#命令行式\" class=\"headerlink\" title=\"命令行式\"></a>命令行式</h4><p><code>mocha -t 10000</code></p>\n<h4 id=\"API式\"><a href=\"#API式\" class=\"headerlink\" title=\"API式\"></a>API式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.timeout(<span class=\"number\">10000</span>);</div><div class=\"line\">  it(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">done</span>) </span>&#123;</div><div class=\"line\">    lib.async(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">      done();</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这样的话<code>async</code>执行时间不超过10s，就不会报错timeout错误了。</p>\n<h2 id=\"异常测试\"><a href=\"#异常测试\" class=\"headerlink\" title=\"异常测试\"></a>异常测试</h2><p>异常应该怎么测试，现在有<code>getContent</code>方法，他会读取指定文件的内容，但是不一定会成功，会抛出异常。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports.getContent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">filename, callback</span>) </span>&#123;</div><div class=\"line\">  fs.readFile(filename, <span class=\"string\">'utf-8'</span>, callback);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这时候就应该模拟(mock)错误环境了</p>\n<h4 id=\"简单Mock\"><a href=\"#简单Mock\" class=\"headerlink\" title=\"简单Mock\"></a>简单Mock</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">\"getContent\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> _readFile;</div><div class=\"line\">  before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    _readFile = fs.readFile;</div><div class=\"line\">    fs.readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">filename, encoding, callback</span>) </span>&#123;</div><div class=\"line\">      process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        callback(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"mock readFile error\"</span>));</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;;\t</div><div class=\"line\">  &#125;);</div><div class=\"line\">  <span class=\"comment\">// it();</span></div><div class=\"line\">  after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 用完之后记得还原。否则影响其他case</span></div><div class=\"line\">    fs.readFile = _readFile;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"Mock库\"><a href=\"#Mock库\" class=\"headerlink\" title=\"\bMock库\"></a>\bMock库</h4><p>Mock小模块：<a href=\"https://github.com/fent/node-muk\" target=\"_blank\" rel=\"external\"><code>muk</code></a> ，略微优美的写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> muk = <span class=\"built_in\">require</span>(<span class=\"string\">'muk'</span>);</div><div class=\"line\"></div><div class=\"line\">before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  muk(fs, <span class=\"string\">'readFile'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, encoding, callback</span>) </span>&#123;</div><div class=\"line\">    process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      callback(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"mock readFile error\"</span>));</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">// it();</span></div><div class=\"line\">after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  muk.restore();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"测试私有方法\"><a href=\"#测试私有方法\" class=\"headerlink\" title=\"测试私有方法\"></a>测试私有方法</h2><p>针对一些内部的方法，没有通过exports暴露出来，怎么测试它？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_adding</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"通过rewire导出方法\"><a href=\"#通过rewire导出方法\" class=\"headerlink\" title=\"通过rewire导出方法\"></a>通过rewire导出方法</h4><p>模块：<a href=\"http://jhnns.github.com/rewire/\" target=\"_blank\" rel=\"external\"><code>rewire</code></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">it(&apos;limit should return success&apos;, function () &#123;</div><div class=\"line\">  var lib = rewire(&apos;../lib/index.js&apos;);</div><div class=\"line\">  var litmit = lib.__get__(&apos;limit&apos;);</div><div class=\"line\">  litmit(10);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"测试Web应用\"><a href=\"#测试Web应用\" class=\"headerlink\" title=\"测试Web应用\"></a>测试Web应用</h2><p>在开发Web项目的时候，要测试某一个API，如：<code>/user</code>，到底怎么编写测试用例呢？</p>\n<p>使用：<a href=\"https://github.com/visionmedia/supertest\" target=\"_blank\" rel=\"external\"><code>supertest</code></a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">\"express\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">\"supertest\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> app = express();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义路由</span></div><div class=\"line\">app.get(<span class=\"string\">'/user'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</div><div class=\"line\">  res.send(<span class=\"number\">200</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'jerryc'</span> &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'GET /user'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  it(<span class=\"string\">'respond with json'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>)</span>&#123;</div><div class=\"line\">    request(app)</div><div class=\"line\">      .get(<span class=\"string\">'/user'</span>)</div><div class=\"line\">      .set(<span class=\"string\">'Accept'</span>, <span class=\"string\">'application/json'</span>)</div><div class=\"line\">      .expect(<span class=\"string\">'Content-Type'</span>, /json/)</div><div class=\"line\">      .expect(<span class=\"number\">200</span>)</div><div class=\"line\">      .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err)&#123;</div><div class=\"line\">          done(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        res.body.name.should.be.eql(<span class=\"string\">'jerryc'</span>);</div><div class=\"line\">        done();</div><div class=\"line\">      &#125;)</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"覆盖率\"><a href=\"#覆盖率\" class=\"headerlink\" title=\"覆盖率\"></a>覆盖率</h2><p>测试的时候，我们常常关心，是否所有代码都测试到了。</p>\n<p>这个指标就叫做<a href=\"http://en.wikipedia.org/wiki/Code_coverage\" target=\"_blank\" rel=\"external\">“代码覆盖率”</a>（code coverage）。它有四个测量维度。</p>\n<blockquote>\n<ul>\n<li><strong>行覆盖率</strong>（line coverage）：是否每一行都执行了？</li>\n<li><strong>函数覆盖率</strong>（function coverage）：是否每个函数都调用了？</li>\n<li><strong>分支覆盖率</strong>（branch coverage）：是否每个if代码块都执行了？</li>\n<li><strong>语句覆盖率</strong>（statement coverage）：是否每个语句都执行了？</li>\n</ul>\n</blockquote>\n<p><a href=\"https://github.com/gotwarlost/istanbul\" target=\"_blank\" rel=\"external\">Istanbul</a> 是 JavaScript 程序的代码覆盖率工具。</p>\n<h4 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p><code>$ npm install -g istanbul</code></p>\n<h4 id=\"覆盖率测试\"><a href=\"#覆盖率测试\" class=\"headerlink\" title=\"覆盖率测试\"></a>覆盖率测试</h4><p>在编写过以上的测试用例之后，执行命令：</p>\n<p><code>istanbul cover _mocha</code></p>\n<p>就能得到覆盖率:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">JerryC% istanbul cover _mocha                                                                                                                                                                </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  module</div><div class=\"line\">    limit</div><div class=\"line\">      ✓ limit should success</div><div class=\"line\">    async</div><div class=\"line\">      ✓ async</div><div class=\"line\">    getContent</div><div class=\"line\">      ✓ getContent</div><div class=\"line\">    add</div><div class=\"line\">      ✓ add</div><div class=\"line\"></div><div class=\"line\">  should</div><div class=\"line\">    #Promise</div><div class=\"line\">      ✓ should.reject</div><div class=\"line\">      ✓ should fulfilled</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  6 passing (32ms)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">================== Coverage summary ======================</div><div class=\"line\">Statements   : 100% ( 10/10 )</div><div class=\"line\">Branches     : 100% ( 2/2 )</div><div class=\"line\">Functions    : 100% ( 5/5 )</div><div class=\"line\">Lines        : 100% ( 10/10 )</div><div class=\"line\">==========================================================</div></pre></td></tr></table></figure>\n<p>这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/eac87dbf-4e4b-426e-80ac-7c50e1b9a1cb.jpg\" alt=\"覆盖率html\"></p>\n<p>上面命令中，<code>istanbul cover</code> 命令后面跟的是 <code>_mocha</code> 命令，前面的下划线是不能省略的。</p>\n<p>因为，<a href=\"https://github.com/gotwarlost/istanbul/issues/44\" target=\"_blank\" rel=\"external\">mocha 和 _mocha 是两个不同的命令</a>，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。</p>\n<p>如果要向 mocha 传入参数，可以写成下面的样子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ istanbul cover _mocha -- tests/test.sqrt.js -R spec</div></pre></td></tr></table></figure>\n<p>上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接<a href=\"http://www.clock.co.uk/blog/npm-module-code-coverage-in-2-simple-steps\" target=\"_blank\" rel=\"external\">1</a>，<a href=\"http://www.vapidspace.com/coding/2014/10/29/code-coverage-metrics-with-mocha-and-istanbul/\" target=\"_blank\" rel=\"external\">2</a>）。</p>\n<h2 id=\"使用Makefile串起项目\"><a href=\"#使用Makefile串起项目\" class=\"headerlink\" title=\"使用Makefile串起项目\"></a>使用Makefile串起项目</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">TESTS = test/*.test.js</div><div class=\"line\">REPORTER = spec</div><div class=\"line\">TIMEOUT = 10000</div><div class=\"line\">JSCOVERAGE = ./node_modules/jscover/bin/jscover</div><div class=\"line\"></div><div class=\"line\">test:</div><div class=\"line\">    @NODE_ENV=test ./node_modules/mocha/bin/mocha -R $(REPORTER) -t $(TIMEOUT) $(TESTS)</div><div class=\"line\"></div><div class=\"line\">test-cov: lib-cov</div><div class=\"line\">    @LIB_COV=1 $(MAKE) test REPORTER=dot</div><div class=\"line\">    @LIB_COV=1 $(MAKE) test REPORTER=html-cov &gt; coverage.html</div><div class=\"line\"></div><div class=\"line\">lib-cov:</div><div class=\"line\">    @rm -rf ./lib-cov</div><div class=\"line\">    @$(JSCOVERAGE) lib lib-cov</div><div class=\"line\"></div><div class=\"line\">.PHONY: test test-cov lib-cov</div><div class=\"line\"></div><div class=\"line\">make test</div><div class=\"line\">make test-cov</div></pre></td></tr></table></figure>\n<p>用项目自身的jscover和mocha，避免版本冲突和混乱</p>\n<h2 id=\"持续集成，Travis-cli\"><a href=\"#持续集成，Travis-cli\" class=\"headerlink\" title=\"持续集成，Travis-cli\"></a>持续集成，Travis-cli</h2><ul>\n<li><a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"external\">Travis-ci</a><ul>\n<li>绑定Github帐号</li>\n<li>在Github仓库的Admin打开Services hook</li>\n<li>打开Travis</li>\n<li>每次push将会hook触发执行<code>npm test</code>命令</li>\n</ul>\n</li>\n</ul>\n<p>注意：Travis会将未描述的项目当作Ruby项目。所以需要在根目录下加入<code>.travis.yml</code>文件。内容如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">language:</span> node_js</div><div class=\"line\"><span class=\"attr\">node_js:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">\"0.12\"</span></div></pre></td></tr></table></figure>\n<p>Travis-cli还会对项目颁发标签，</p>\n<p><img src=\"https://camo.githubusercontent.com/f479d6cf4ac300093da5a90d70565cebf8c8ed40/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f4a61636b736f6e5469616e2f626167706970652e706e67\" alt=\"/\">or <img src=\"https://camo.githubusercontent.com/08478cd5a732822aec47e6e60d5f823ef0898dec/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f54424544502f64617461766a732e706e67\" alt=\"/\"></p>\n<p>如果项目通过所有测试，就会build-passing，</p>\n<p>如果项目没有通过所有测试，就会build-failing</p>\n<h2 id=\"一些观点\"><a href=\"#一些观点\" class=\"headerlink\" title=\"一些观点\"></a>一些观点</h2><p>实施单元测试的时候, 如果没有一份经过实践证明的详细规范, 很难掌握测试的 “度”, 范围太小施展不开, 太大又侵犯 “别人的” 地盘. 上帝的归上帝, 凯撒的归凯撒, 给单元测试念念紧箍咒不见得是件坏事, 反而更有利于发挥单元测试的威力, 为代码重构和提高代码质量提供动力.</p>\n<p>这份文档来自 Geotechnical, 是一份非常难得的经验准则. 你完全可以以这份准则作为模板, 结合所在团队的经验, 整理出一份内部单元测试准则.</p>\n<p><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\" target=\"_blank\" rel=\"external\">单元测试准则</a></p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><p>最后，介绍一个库：<a href=\"https://github.com/Marak/Faker.js\" target=\"_blank\" rel=\"external\"><code>faker</code></a></p>\n<p>他是一个能伪造用户数据的库，包括用户常包含的属性：个人信息、头像、地址等等。</p>\n<p>是一个开发初期，模拟用户数据的绝佳好库。</p>\n<p>支持Node.js和浏览器端。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/43075e5e-026f-4acb-a51f-a998cf1a6e11.jpg\" alt=\"生成用户\"></p>\n<h2 id=\"整理\"><a href=\"#整理\" class=\"headerlink\" title=\"整理\"></a>整理</h2><h4 id=\"Nodejs的单元测试工具\"><a href=\"#Nodejs的单元测试工具\" class=\"headerlink\" title=\"Nodejs的单元测试工具\"></a>Nodejs的单元测试工具</h4><ol>\n<li>测试框架 mocha</li>\n<li>断言库：should.js、expect.js、chai</li>\n<li>覆盖率：istanbul、jscover、blanket</li>\n<li>Mock库：muk</li>\n<li>测试私有方法：rewire</li>\n<li>Web测试：supertest</li>\n<li>持续集成：Travis-cli</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/JacksonTian/unittesting\" target=\"_blank\" rel=\"external\">https://github.com/JacksonTian/unittesting</a></li>\n<li><a href=\"\"></a><a href=\"http://html5ify.com/unittesting/slides/index.html\" target=\"_blank\" rel=\"external\">http://html5ify.com/unittesting/slides/index.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/06/istanbul.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2015/06/istanbul.html</a></li>\n<li><a href=\"http://coolshell.cn/articles/8209.html\" target=\"_blank\" rel=\"external\">http://coolshell.cn/articles/8209.html</a></li>\n<li><a href=\"http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\" target=\"_blank\" rel=\"external\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming\" target=\"_blank\" rel=\"external\">http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming</a></li>\n<li><a href=\"http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D\" target=\"_blank\" rel=\"external\">http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\" target=\"_blank\" rel=\"external\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"https://github.com/visionmedia/superagent/blob/master/Makefile\" target=\"_blank\" rel=\"external\">https://github.com/visionmedia/superagent/blob/master/Makefile</a></li>\n</ul>\n","excerpt":"","more":"<p>在团队合作中，你写好了一个函数，供队友使用，跑去跟你的队友说，你传个A值进去，他就会返回B结果了。过了一会，你队友跑过来说，我传个A值却返回C结果，怎么回事？你丫的有没有测试过啊？</p>\n<p>大家一起写个项目，难免会有我要写的函数里面依赖别人的函数，但是这个函数到底值不值得信赖？单元测试是衡量代码质量的一重要标准，纵观Github的受欢迎项目，都是有test文件夹，并且buliding-pass的。如果你也为社区贡献过module，想更多人使用的话，加上单元测试吧，让你的module值得别人信赖。</p>\n<p>要在Nodejs中写单元测试的话，你需要知道用什么测试框架，怎么测试异步函数，怎么测试私有方法，怎么模拟测试环境，怎么测试依赖HTTP协议的web应用，需要了解TDD和BDD，还有需要提供测试的覆盖率。</p>\n<blockquote>\n<p>本文的示例代码会备份到 Github : <a href=\"https://github.com/JerryC8080/unittest-demo\">unittest-demo</a></p>\n</blockquote>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li>测试框架</li>\n<li>断言库</li>\n<li>需求变更</li>\n<li>异步测试</li>\n<li>异常测试</li>\n<li>测试私有方法</li>\n<li>测试Web应用</li>\n<li>覆盖率</li>\n<li>使用Makefile把测试串起来</li>\n<li>持续集成，Travis-cli</li>\n<li>一些观点</li>\n<li>彩蛋</li>\n<li>整理</li>\n</ol>\n<h2 id=\"测试框架\"><a href=\"#测试框架\" class=\"headerlink\" title=\"测试框架\"></a>测试框架</h2><p>Nodejs的测试框架还用说？大家都在用，Mocha。</p>\n<p>Mocha 是一个功能丰富的Javascript测试框架，它能运行在Node.js和浏览器中，支持<strong>BDD</strong>、<strong>TDD</strong>、<strong>QUnit</strong>、<strong>Exports</strong>式的测试，本文主要示例是使用更接近与思考方式的BDD，\b如果了解更多可以访问Mocha的<a href=\"http://mochajs.org/\">官网</a></p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\b\"></a>\b</h4><h4 id=\"测试接口\"><a href=\"#测试接口\" class=\"headerlink\" title=\"测试接口\"></a>测试接口</h4><p>Mocha的BDD接口有：</p>\n<ul>\n<li><code>describe()</code></li>\n<li><code>it()</code></li>\n<li><code>before()</code></li>\n<li><code>after()</code></li>\n<li><code>beforeEach()</code></li>\n<li><code>afterEach()</code></li>\n</ul>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p><code>npm install mocha -g</code></p>\n<h4 id=\"编写一个稳定可靠的模块\"><a href=\"#编写一个稳定可靠的模块\" class=\"headerlink\" title=\"编写一个稳定可靠的模块\"></a>编写一个稳定可靠的模块</h4><p>模块具备limit方法，输入一个数值，小于0的时候返回0，其余正常返回</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports.limit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (num &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> num;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"目录分配\"><a href=\"#目录分配\" class=\"headerlink\" title=\"目录分配\"></a>目录分配</h4><ul>\n<li><code>lib</code>，存放模块代码的地方</li>\n<li><code>test</code>，存放单元测试代码的地方</li>\n<li><code>index.js</code>，向外导出模块的地方</li>\n<li><code>package.json</code>，包描述文件</li>\n</ul>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> lib = <span class=\"built_in\">require</span>(<span class=\"string\">'index'</span>);</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'module'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  describe(<span class=\"string\">'limit'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'limit should success'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      lib.limit(<span class=\"number\">10</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h4><p>在当前目录下执行<code>mocha</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mocha</div><div class=\"line\"></div><div class=\"line\">  ․</div><div class=\"line\"></div><div class=\"line\">  ✔ 1 test complete (2ms)</div></pre></td></tr></table></figure>\n<h2 id=\"断言库\"><a href=\"#断言库\" class=\"headerlink\" title=\"断言库\"></a>断言库</h2><p>上面的代码只是运行了代码，并没有对结果进行检查，这时候就要用到断言库了，Node.js中常用的断言库有：</p>\n<ul>\n<li>should.js</li>\n<li>expect.js</li>\n<li>chai</li>\n</ul>\n<h4 id=\"加上断言\"><a href=\"#加上断言\" class=\"headerlink\" title=\"加上断言\"></a>加上断言</h4><p>使用<code>should</code>库为测试用例加上断言</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">it(<span class=\"string\">'limit should success'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  lib.limit(<span class=\"number\">10</span>).should.be.equal(<span class=\"number\">10</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"需求变更\"><a href=\"#需求变更\" class=\"headerlink\" title=\"\b需求变更\"></a>\b需求变更</h2><p>需求变更啦： <code>limit</code>这个方法还要求返回值大于100时返回100。</p>\n<p>针对需求重构代码之后，正是测试用例的价值所在了，</p>\n<p>它能确保你的改动对原有成果没有造成破坏。</p>\n<p>但是，你要多做的一些工作的是，需要为新的需求编写新的测试代码。</p>\n<h2 id=\"异步测试\"><a href=\"#异步测试\" class=\"headerlink\" title=\"异步测试\"></a>异步测试</h2><h4 id=\"测试异步回调\"><a href=\"#测试异步回调\" class=\"headerlink\" title=\"测试异步回调\"></a>测试异步回调</h4><p>lib库中新增async函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports.async = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    callback(<span class=\"number\">10</span>);</div><div class=\"line\">  &#125;, <span class=\"number\">10</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>测试异步代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  it(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">done</span>) </span>&#123;</div><div class=\"line\">    lib.async(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">      done();</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"测试Promise\"><a href=\"#测试Promise\" class=\"headerlink\" title=\"测试Promise\"></a>测试Promise</h4><p>使用should提供的Promise断言接口:</p>\n<ul>\n<li><code>finally</code> | <code>eventually</code></li>\n<li><code>fulfilled</code></li>\n<li><code>fulfilledWith</code></li>\n<li><code>rejected</code></li>\n<li><code>rejectedWith</code></li>\n<li><code>then</code></li>\n</ul>\n<p>测试代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">'should'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  describe(<span class=\"string\">'#Promise'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    it(<span class=\"string\">'should.reject'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'wrong'</span>));</div><div class=\"line\">      &#125;)).should.be.rejectedWith(<span class=\"string\">'wrong'</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    it(<span class=\"string\">'should.fulfilled'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      (<span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">        resolve(&#123;<span class=\"attr\">username</span>: <span class=\"string\">'jc'</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span>, <span class=\"attr\">gender</span>: <span class=\"string\">'male'</span>&#125;)</div><div class=\"line\">      &#125;)).should.be.fulfilled().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">it</span>) </span>&#123;</div><div class=\"line\">          it.should.have.property(<span class=\"string\">'username'</span>, <span class=\"string\">'jc'</span>);</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"异步方法的超时支持\"><a href=\"#异步方法的超时支持\" class=\"headerlink\" title=\"异步方法的超时支持\"></a>异步方法的超时支持</h4><p>Mocha的超时设定默认是2s，如果执行的测试超过2s的话，就会报timeout错误。</p>\n<p>可以主动修改超时时间，有两种方法。</p>\n<h4 id=\"命令行式\"><a href=\"#命令行式\" class=\"headerlink\" title=\"命令行式\"></a>命令行式</h4><p><code>mocha -t 10000</code></p>\n<h4 id=\"API式\"><a href=\"#API式\" class=\"headerlink\" title=\"API式\"></a>API式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.timeout(<span class=\"number\">10000</span>);</div><div class=\"line\">  it(<span class=\"string\">'async'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">done</span>) </span>&#123;</div><div class=\"line\">    lib.async(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">      done();</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这样的话<code>async</code>执行时间不超过10s，就不会报错timeout错误了。</p>\n<h2 id=\"异常测试\"><a href=\"#异常测试\" class=\"headerlink\" title=\"异常测试\"></a>异常测试</h2><p>异常应该怎么测试，现在有<code>getContent</code>方法，他会读取指定文件的内容，但是不一定会成功，会抛出异常。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">exports.getContent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">filename, callback</span>) </span>&#123;</div><div class=\"line\">  fs.readFile(filename, <span class=\"string\">'utf-8'</span>, callback);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这时候就应该模拟(mock)错误环境了</p>\n<h4 id=\"简单Mock\"><a href=\"#简单Mock\" class=\"headerlink\" title=\"简单Mock\"></a>简单Mock</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">describe(<span class=\"string\">\"getContent\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> _readFile;</div><div class=\"line\">  before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    _readFile = fs.readFile;</div><div class=\"line\">    fs.readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">filename, encoding, callback</span>) </span>&#123;</div><div class=\"line\">      process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        callback(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"mock readFile error\"</span>));</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;;\t</div><div class=\"line\">  &#125;);</div><div class=\"line\">  <span class=\"comment\">// it();</span></div><div class=\"line\">  after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 用完之后记得还原。否则影响其他case</span></div><div class=\"line\">    fs.readFile = _readFile;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"Mock库\"><a href=\"#Mock库\" class=\"headerlink\" title=\"\bMock库\"></a>\bMock库</h4><p>Mock小模块：<a href=\"https://github.com/fent/node-muk\"><code>muk</code></a> ，略微优美的写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> muk = <span class=\"built_in\">require</span>(<span class=\"string\">'muk'</span>);</div><div class=\"line\"></div><div class=\"line\">before(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  muk(fs, <span class=\"string\">'readFile'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, encoding, callback</span>) </span>&#123;</div><div class=\"line\">    process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      callback(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"mock readFile error\"</span>));</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">// it();</span></div><div class=\"line\">after(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  muk.restore();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"测试私有方法\"><a href=\"#测试私有方法\" class=\"headerlink\" title=\"测试私有方法\"></a>测试私有方法</h2><p>针对一些内部的方法，没有通过exports暴露出来，怎么测试它？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_adding</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"通过rewire导出方法\"><a href=\"#通过rewire导出方法\" class=\"headerlink\" title=\"通过rewire导出方法\"></a>通过rewire导出方法</h4><p>模块：<a href=\"http://jhnns.github.com/rewire/\"><code>rewire</code></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">it(&apos;limit should return success&apos;, function () &#123;</div><div class=\"line\">  var lib = rewire(&apos;../lib/index.js&apos;);</div><div class=\"line\">  var litmit = lib.__get__(&apos;limit&apos;);</div><div class=\"line\">  litmit(10);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"测试Web应用\"><a href=\"#测试Web应用\" class=\"headerlink\" title=\"测试Web应用\"></a>测试Web应用</h2><p>在开发Web项目的时候，要测试某一个API，如：<code>/user</code>，到底怎么编写测试用例呢？</p>\n<p>使用：<a href=\"https://github.com/visionmedia/supertest\"><code>supertest</code></a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">\"express\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">\"supertest\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> app = express();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 定义路由</span></div><div class=\"line\">app.get(<span class=\"string\">'/user'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</div><div class=\"line\">  res.send(<span class=\"number\">200</span>, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'jerryc'</span> &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">describe(<span class=\"string\">'GET /user'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  it(<span class=\"string\">'respond with json'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">done</span>)</span>&#123;</div><div class=\"line\">    request(app)</div><div class=\"line\">      .get(<span class=\"string\">'/user'</span>)</div><div class=\"line\">      .set(<span class=\"string\">'Accept'</span>, <span class=\"string\">'application/json'</span>)</div><div class=\"line\">      .expect(<span class=\"string\">'Content-Type'</span>, /json/)</div><div class=\"line\">      .expect(<span class=\"number\">200</span>)</div><div class=\"line\">      .end(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err)&#123;</div><div class=\"line\">          done(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        res.body.name.should.be.eql(<span class=\"string\">'jerryc'</span>);</div><div class=\"line\">        done();</div><div class=\"line\">      &#125;)</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h2 id=\"覆盖率\"><a href=\"#覆盖率\" class=\"headerlink\" title=\"覆盖率\"></a>覆盖率</h2><p>测试的时候，我们常常关心，是否所有代码都测试到了。</p>\n<p>这个指标就叫做<a href=\"http://en.wikipedia.org/wiki/Code_coverage\">“代码覆盖率”</a>（code coverage）。它有四个测量维度。</p>\n<blockquote>\n<ul>\n<li><strong>行覆盖率</strong>（line coverage）：是否每一行都执行了？</li>\n<li><strong>函数覆盖率</strong>（function coverage）：是否每个函数都调用了？</li>\n<li><strong>分支覆盖率</strong>（branch coverage）：是否每个if代码块都执行了？</li>\n<li><strong>语句覆盖率</strong>（statement coverage）：是否每个语句都执行了？</li>\n</ul>\n</blockquote>\n<p><a href=\"https://github.com/gotwarlost/istanbul\">Istanbul</a> 是 JavaScript 程序的代码覆盖率工具。</p>\n<h4 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p><code>$ npm install -g istanbul</code></p>\n<h4 id=\"覆盖率测试\"><a href=\"#覆盖率测试\" class=\"headerlink\" title=\"覆盖率测试\"></a>覆盖率测试</h4><p>在编写过以上的测试用例之后，执行命令：</p>\n<p><code>istanbul cover _mocha</code></p>\n<p>就能得到覆盖率:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">JerryC% istanbul cover _mocha                                                                                                                                                                </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  module</div><div class=\"line\">    limit</div><div class=\"line\">      ✓ limit should success</div><div class=\"line\">    async</div><div class=\"line\">      ✓ async</div><div class=\"line\">    getContent</div><div class=\"line\">      ✓ getContent</div><div class=\"line\">    add</div><div class=\"line\">      ✓ add</div><div class=\"line\"></div><div class=\"line\">  should</div><div class=\"line\">    #Promise</div><div class=\"line\">      ✓ should.reject</div><div class=\"line\">      ✓ should fulfilled</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">  6 passing (32ms)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">================== Coverage summary ======================</div><div class=\"line\">Statements   : 100% ( 10/10 )</div><div class=\"line\">Branches     : 100% ( 2/2 )</div><div class=\"line\">Functions    : 100% ( 5/5 )</div><div class=\"line\">Lines        : 100% ( 10/10 )</div><div class=\"line\">==========================================================</div></pre></td></tr></table></figure>\n<p>这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/eac87dbf-4e4b-426e-80ac-7c50e1b9a1cb.jpg\" alt=\"覆盖率html\"></p>\n<p>上面命令中，<code>istanbul cover</code> 命令后面跟的是 <code>_mocha</code> 命令，前面的下划线是不能省略的。</p>\n<p>因为，<a href=\"https://github.com/gotwarlost/istanbul/issues/44\">mocha 和 _mocha 是两个不同的命令</a>，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。</p>\n<p>如果要向 mocha 传入参数，可以写成下面的样子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ istanbul cover _mocha -- tests/test.sqrt.js -R spec</div></pre></td></tr></table></figure>\n<p>上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接<a href=\"http://www.clock.co.uk/blog/npm-module-code-coverage-in-2-simple-steps\">1</a>，<a href=\"http://www.vapidspace.com/coding/2014/10/29/code-coverage-metrics-with-mocha-and-istanbul/\">2</a>）。</p>\n<h2 id=\"使用Makefile串起项目\"><a href=\"#使用Makefile串起项目\" class=\"headerlink\" title=\"使用Makefile串起项目\"></a>使用Makefile串起项目</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">TESTS = test/*.test.js</div><div class=\"line\">REPORTER = spec</div><div class=\"line\">TIMEOUT = 10000</div><div class=\"line\">JSCOVERAGE = ./node_modules/jscover/bin/jscover</div><div class=\"line\"></div><div class=\"line\">test:</div><div class=\"line\">    @NODE_ENV=test ./node_modules/mocha/bin/mocha -R $(REPORTER) -t $(TIMEOUT) $(TESTS)</div><div class=\"line\"></div><div class=\"line\">test-cov: lib-cov</div><div class=\"line\">    @LIB_COV=1 $(MAKE) test REPORTER=dot</div><div class=\"line\">    @LIB_COV=1 $(MAKE) test REPORTER=html-cov &gt; coverage.html</div><div class=\"line\"></div><div class=\"line\">lib-cov:</div><div class=\"line\">    @rm -rf ./lib-cov</div><div class=\"line\">    @$(JSCOVERAGE) lib lib-cov</div><div class=\"line\"></div><div class=\"line\">.PHONY: test test-cov lib-cov</div><div class=\"line\"></div><div class=\"line\">make test</div><div class=\"line\">make test-cov</div></pre></td></tr></table></figure>\n<p>用项目自身的jscover和mocha，避免版本冲突和混乱</p>\n<h2 id=\"持续集成，Travis-cli\"><a href=\"#持续集成，Travis-cli\" class=\"headerlink\" title=\"持续集成，Travis-cli\"></a>持续集成，Travis-cli</h2><ul>\n<li><a href=\"https://travis-ci.org/\">Travis-ci</a><ul>\n<li>绑定Github帐号</li>\n<li>在Github仓库的Admin打开Services hook</li>\n<li>打开Travis</li>\n<li>每次push将会hook触发执行<code>npm test</code>命令</li>\n</ul>\n</li>\n</ul>\n<p>注意：Travis会将未描述的项目当作Ruby项目。所以需要在根目录下加入<code>.travis.yml</code>文件。内容如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">language:</span> node_js</div><div class=\"line\"><span class=\"attr\">node_js:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">\"0.12\"</span></div></pre></td></tr></table></figure>\n<p>Travis-cli还会对项目颁发标签，</p>\n<p><img src=\"https://camo.githubusercontent.com/f479d6cf4ac300093da5a90d70565cebf8c8ed40/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f4a61636b736f6e5469616e2f626167706970652e706e67\" alt=\"/\">or <img src=\"https://camo.githubusercontent.com/08478cd5a732822aec47e6e60d5f823ef0898dec/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f54424544502f64617461766a732e706e67\" alt=\"/\"></p>\n<p>如果项目通过所有测试，就会build-passing，</p>\n<p>如果项目没有通过所有测试，就会build-failing</p>\n<h2 id=\"一些观点\"><a href=\"#一些观点\" class=\"headerlink\" title=\"一些观点\"></a>一些观点</h2><p>实施单元测试的时候, 如果没有一份经过实践证明的详细规范, 很难掌握测试的 “度”, 范围太小施展不开, 太大又侵犯 “别人的” 地盘. 上帝的归上帝, 凯撒的归凯撒, 给单元测试念念紧箍咒不见得是件坏事, 反而更有利于发挥单元测试的威力, 为代码重构和提高代码质量提供动力.</p>\n<p>这份文档来自 Geotechnical, 是一份非常难得的经验准则. 你完全可以以这份准则作为模板, 结合所在团队的经验, 整理出一份内部单元测试准则.</p>\n<p><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">单元测试准则</a></p>\n<h2 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h2><p>最后，介绍一个库：<a href=\"https://github.com/Marak/Faker.js\"><code>faker</code></a></p>\n<p>他是一个能伪造用户数据的库，包括用户常包含的属性：个人信息、头像、地址等等。</p>\n<p>是一个开发初期，模拟用户数据的绝佳好库。</p>\n<p>支持Node.js和浏览器端。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/43075e5e-026f-4acb-a51f-a998cf1a6e11.jpg\" alt=\"生成用户\"></p>\n<h2 id=\"整理\"><a href=\"#整理\" class=\"headerlink\" title=\"整理\"></a>整理</h2><h4 id=\"Nodejs的单元测试工具\"><a href=\"#Nodejs的单元测试工具\" class=\"headerlink\" title=\"Nodejs的单元测试工具\"></a>Nodejs的单元测试工具</h4><ol>\n<li>测试框架 mocha</li>\n<li>断言库：should.js、expect.js、chai</li>\n<li>覆盖率：istanbul、jscover、blanket</li>\n<li>Mock库：muk</li>\n<li>测试私有方法：rewire</li>\n<li>Web测试：supertest</li>\n<li>持续集成：Travis-cli</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://github.com/JacksonTian/unittesting\">https://github.com/JacksonTian/unittesting</a></li>\n<li><a href=\"\"></a><a href=\"http://html5ify.com/unittesting/slides/index.html\">http://html5ify.com/unittesting/slides/index.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/06/istanbul.html\">http://www.ruanyifeng.com/blog/2015/06/istanbul.html</a></li>\n<li><a href=\"http://coolshell.cn/articles/8209.html\">http://coolshell.cn/articles/8209.html</a></li>\n<li><a href=\"http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests\">http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming\">http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming</a></li>\n<li><a href=\"http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D\">http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"https://github.com/visionmedia/superagent/blob/master/Makefile\">https://github.com/visionmedia/superagent/blob/master/Makefile</a></li>\n</ul>\n"},{"title":"基于jQuery的2048游戏","date":"2014-07-12T08:29:09.000Z","_content":"\n### 前言\n受网上看到的一个2048视频游戏制作的启发，做了一个网页版的，很多细节参照了一下别人的。暂时还没有分数统计功能，找时间再做好。先上一个demo版。\n\n### 截图\n![截图](/image/blog/imgFile1412172676130.jpg)\n\n### 程序架构\n![脑图](/image/blog/imgFile1412172691061.jpeg)\n\n\n**演示地址**：[http://jerryc8080.github.io/My2048/](http://jerryc8080.github.io/My2048/)\n**程序地址**：[https://github.com/JerryC8080/My2048](http://jerryc8080.github.io/My2048/)\n\n\n代码：太多了就不贴了，有兴趣的看管请到以上地址下载吧。\n","source":"_posts/基于jQuery的2048游戏.md","raw":"---\ntitle: 基于jQuery的2048游戏\ncategory: 搬砖码农\ndate: 2014-07-12 16:29:09\ntags:\n---\n\n### 前言\n受网上看到的一个2048视频游戏制作的启发，做了一个网页版的，很多细节参照了一下别人的。暂时还没有分数统计功能，找时间再做好。先上一个demo版。\n\n### 截图\n![截图](/image/blog/imgFile1412172676130.jpg)\n\n### 程序架构\n![脑图](/image/blog/imgFile1412172691061.jpeg)\n\n\n**演示地址**：[http://jerryc8080.github.io/My2048/](http://jerryc8080.github.io/My2048/)\n**程序地址**：[https://github.com/JerryC8080/My2048](http://jerryc8080.github.io/My2048/)\n\n\n代码：太多了就不贴了，有兴趣的看管请到以上地址下载吧。\n","slug":"基于jQuery的2048游戏","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqo002o15hlylkgg25s","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>受网上看到的一个2048视频游戏制作的启发，做了一个网页版的，很多细节参照了一下别人的。暂时还没有分数统计功能，找时间再做好。先上一个demo版。</p>\n<h3 id=\"截图\"><a href=\"#截图\" class=\"headerlink\" title=\"截图\"></a>截图</h3><p><img src=\"/image/blog/imgFile1412172676130.jpg\" alt=\"截图\"></p>\n<h3 id=\"程序架构\"><a href=\"#程序架构\" class=\"headerlink\" title=\"程序架构\"></a>程序架构</h3><p><img src=\"/image/blog/imgFile1412172691061.jpeg\" alt=\"脑图\"></p>\n<p><strong>演示地址</strong>：<a href=\"http://jerryc8080.github.io/My2048/\" target=\"_blank\" rel=\"external\">http://jerryc8080.github.io/My2048/</a><br><strong>程序地址</strong>：<a href=\"http://jerryc8080.github.io/My2048/\" target=\"_blank\" rel=\"external\">https://github.com/JerryC8080/My2048</a></p>\n<p>代码：太多了就不贴了，有兴趣的看管请到以上地址下载吧。</p>\n","excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>受网上看到的一个2048视频游戏制作的启发，做了一个网页版的，很多细节参照了一下别人的。暂时还没有分数统计功能，找时间再做好。先上一个demo版。</p>\n<h3 id=\"截图\"><a href=\"#截图\" class=\"headerlink\" title=\"截图\"></a>截图</h3><p><img src=\"/image/blog/imgFile1412172676130.jpg\" alt=\"截图\"></p>\n<h3 id=\"程序架构\"><a href=\"#程序架构\" class=\"headerlink\" title=\"程序架构\"></a>程序架构</h3><p><img src=\"/image/blog/imgFile1412172691061.jpeg\" alt=\"脑图\"></p>\n<p><strong>演示地址</strong>：<a href=\"http://jerryc8080.github.io/My2048/\">http://jerryc8080.github.io/My2048/</a><br><strong>程序地址</strong>：<a href=\"http://jerryc8080.github.io/My2048/\">https://github.com/JerryC8080/My2048</a></p>\n<p>代码：太多了就不贴了，有兴趣的看管请到以上地址下载吧。</p>\n"},{"title":"如果你用GitHub，可以这样提高效率","date":"2016-01-15T11:22:59.000Z","_content":"\n\n一年时间我们从几个人的开发团队发展到十几人的团队，最初的我们只有两个后端加两个前端，而且其中三个还是实习生。\n但今时不同往日，现在我们有前端、后端、测试、运维、设计、产品、交互，成功集齐了七个兵种，可以召唤神龙，赐我们一个敏捷的开发团队。\n作为一个敏捷性的开发团队，我们要保持快速的迭代速度的同时保证高质量的代码，这是一个艰巨的过程。\n\n### 版本管理 — Git~Hub\n>「开始的开始，我们还是孩子」(出自《北京路的日子》)\n\n开始的开始，我们还是用着SVN，代码存储在公司的服务器中，只有一个分支，提交代码无需审核，无需单元测试。因为我们只有几个人......\n\n作为一个有逼格的团队，后来我们用上了Git，并且把代码迁移到Coding中去，然后引入了名为「git flow」的工作流，关于这个工作流可以参考我们老大的文章：[「企业级开发：Gitflow Workflow工作流」](http://www.jianshu.com/p/104fa8b15d1e)\n\nCoding真的是一款很不错的产品，可称为业届良心。\n\n为什么当初没有直接用GitHub，因为私有仓库贵啊......\n\n但，作为一个有逼格的团队，我们是不会满足于此的。Coding自身的服务很不错了，但是相对于GitHub的一些专业的第三方服务，缺少了那么一些竞争力。我们当时想接入持续集成的服务，但是无奈找不到支持Coding的第三方服务，代码Review也没有一个更让我们舒心的体验，我承认我们要求比较高。再加上Coding的几次down机，其中一次是我们准备发布新版本的那一个下午.....\n\n终于有一天，我们老大两眼发光的跟我们说：我们要买GitHub的服务了，申请到资金了。\n\n于是乎，我们浩浩荡荡的迁移代码库。\n\n迁移到Github之后，我们开始接入各方工具，提高我们的工作效率（钱可不能白花啊）。\n\n### 武装GitHub — ZenHub\n> [ZenHub](https://www.zenhub.io/)     \n> Project management inside GitHub    \n> Transform your GitHub issues\n\n正如Zenhub所说，这是一款项目管理工具，嵌入式集成到GitHub中。作为插件，它的UI完全迎合了GitHub，以至于你难以分别出哪些功能是GitHub的，哪些功能是Zenhub的。\n\n如果你用了ZenHub，它会提供给你：\n\n1. **一套任务面板**，给不同的任务提供不同的泳道，直观的展示每个任务的进度。于是乎我抛弃了Teambition。\n2. **一套个人的Todo List**，如果有一个issue或者一个PR需要你来处理，但你现在没有空，你可以把它添加到Todo List中，于是乎我又抛弃了Wunderlist。\n3. **一套项目图标与统计**，结合着Github自带的项目图表，这个提供更多维度的数据，但是个人感觉意义不太大。\n4. **再加一些小彩蛋**，由于它是作为插件形式嵌入到Github中的，所以会在很多地方提供一些这样那样的按钮，等着你去发现了。\n\n### 持续集成 — TravisCI \n> [TravisCI](https://travis-ci.org/)    \n> Test and Deploy with Confidence    \n> Easily sync your GitHub projects with Travis CI and you’ll be testing your code in minutes!\n\n不知道你有没有好奇Github上的一些明星项目的这样的标签：\n\n[![Build Status](https://travis-ci.org/expressjs/express.svg?branch=master)](https://travis-ci.org/expressjs/express)\n\n这个是Express的构建状态的标签，格式是svg，它会根据Express的构建状态改变。如果Express的某一次提交是没有通过TravisCI构建的，他会变成 build failing。（有心人可以点击这个标签进去看看。）\n\n我们加入TravisCI主要目的是用于自动化的单元测试，每一次Commit与PR，TravisCI都会从Github仓库中拉取代码，然后执行我们写好的单元测试，通过与否会通过状态展示出来。    \n合并的人如果看到build failing，就不会合并了，这在一定程度上保证与提高了代码的质量。\n\nTravisCI除了可以用来自动化单元测试，还可以自动化部署，可以设定，通过测试之后，就自动部署上线。\n\nTravisCI对于公开仓库是免费的，但对于私有仓库是要收费的，而且价格也不便宜。    \n如果你觉得贵，这里还有一个可以代替的：**[CircleCI](https://circleci.com/)**    \nTravisCI可以做的，它都可以做得到，而且会提供一个免费的私有仓库。    \n\n### 代码Review — Reviewable\n> [Reviewable](https://reviewable.io/)\n> GitHub code reviews done right\n\n如果你觉得Github自带的Review还不够满足的话，可以尝试一下这款产品。\n当你提交一个PR之后，在你的PR中，会在你的评论框中嵌入这样的按钮\n\n![](//dn-cnode.qbox.me/FrDLVgDD6alCXnHAfk4XNHJCCnS_)\n\n点击进入Reviewable的页面对应的PR进行review。\n\n并且一个PR没有完成Review之前，是会一直被警告，让你警惕进行合并。\n\n### 代码覆盖率 — Coveralls\n> [Coveralls](http://coveralls.io/)    \n> We help you deliver code confidently by showing which parts of your code aren’t covered by your test suite. Free for open source repos. Pro accounts for private repos. Instant sign up through GitHub and Bitbucket.\n\n在明星项目Express的Github项目主页中，你可以看到这样的标签：\n\n[![Coverage Status](https://coveralls.io/repos/strongloop/express/badge.svg?branch=master&service=github)](https://coveralls.io/github/strongloop/express?branch=master)\n\n结合着TravisCI的自动化单元测试，加上这个测试覆盖率，提高你对项目的信心。\n\n\n### 快速进行沟通 — Slack\n> [Slack](https://slack.com/)    \n> A messaging app for teams who see through the Earth\n\n相信大部分团队都是使用微信进行沟通的，    \n再一次，最为一个有逼格的团队，我们使用了Slack进行团队上的沟通，在Slack上，你可以创建频道(Channel)，不同Channel不同的人进行着不同的话题沟通。我们有设计的Channel、产品的Channel、开发的Channel。我最欣赏的是，Slack可以接入很多第三方服务，Github是其中一个。\n\n接入Github之后，项目的每一个Commit、PR之类的动态信息，会被推送到聊天室中。\n\n助你时刻掌控项目动态。\n\n![](//dn-cnode.qbox.me/FjrMtthZ9pX08AWOKbIPlogDKBcK)\n\nSlack接入Githu只是其中的一个小功能而已，更强大的在于Slack本身，利器如何用，待君慢慢体会。  \n  \n**但**，Slack有一个硬伤：不会科学上网，用不了呀。\n\n\n### 最后\n\n再一次，作为一个有逼格的团队，我们依然不会满足现状。\n\n","source":"_posts/如果你用GitHub，可以这样提高效率.md","raw":"---\ntitle: 如果你用GitHub，可以这样提高效率\ncategory: 搬砖码农\ndate: 2016-01-15 19:22:59\ntags:\n- Nodejs\n- Tool Kit\n---\n\n\n一年时间我们从几个人的开发团队发展到十几人的团队，最初的我们只有两个后端加两个前端，而且其中三个还是实习生。\n但今时不同往日，现在我们有前端、后端、测试、运维、设计、产品、交互，成功集齐了七个兵种，可以召唤神龙，赐我们一个敏捷的开发团队。\n作为一个敏捷性的开发团队，我们要保持快速的迭代速度的同时保证高质量的代码，这是一个艰巨的过程。\n\n### 版本管理 — Git~Hub\n>「开始的开始，我们还是孩子」(出自《北京路的日子》)\n\n开始的开始，我们还是用着SVN，代码存储在公司的服务器中，只有一个分支，提交代码无需审核，无需单元测试。因为我们只有几个人......\n\n作为一个有逼格的团队，后来我们用上了Git，并且把代码迁移到Coding中去，然后引入了名为「git flow」的工作流，关于这个工作流可以参考我们老大的文章：[「企业级开发：Gitflow Workflow工作流」](http://www.jianshu.com/p/104fa8b15d1e)\n\nCoding真的是一款很不错的产品，可称为业届良心。\n\n为什么当初没有直接用GitHub，因为私有仓库贵啊......\n\n但，作为一个有逼格的团队，我们是不会满足于此的。Coding自身的服务很不错了，但是相对于GitHub的一些专业的第三方服务，缺少了那么一些竞争力。我们当时想接入持续集成的服务，但是无奈找不到支持Coding的第三方服务，代码Review也没有一个更让我们舒心的体验，我承认我们要求比较高。再加上Coding的几次down机，其中一次是我们准备发布新版本的那一个下午.....\n\n终于有一天，我们老大两眼发光的跟我们说：我们要买GitHub的服务了，申请到资金了。\n\n于是乎，我们浩浩荡荡的迁移代码库。\n\n迁移到Github之后，我们开始接入各方工具，提高我们的工作效率（钱可不能白花啊）。\n\n### 武装GitHub — ZenHub\n> [ZenHub](https://www.zenhub.io/)     \n> Project management inside GitHub    \n> Transform your GitHub issues\n\n正如Zenhub所说，这是一款项目管理工具，嵌入式集成到GitHub中。作为插件，它的UI完全迎合了GitHub，以至于你难以分别出哪些功能是GitHub的，哪些功能是Zenhub的。\n\n如果你用了ZenHub，它会提供给你：\n\n1. **一套任务面板**，给不同的任务提供不同的泳道，直观的展示每个任务的进度。于是乎我抛弃了Teambition。\n2. **一套个人的Todo List**，如果有一个issue或者一个PR需要你来处理，但你现在没有空，你可以把它添加到Todo List中，于是乎我又抛弃了Wunderlist。\n3. **一套项目图标与统计**，结合着Github自带的项目图表，这个提供更多维度的数据，但是个人感觉意义不太大。\n4. **再加一些小彩蛋**，由于它是作为插件形式嵌入到Github中的，所以会在很多地方提供一些这样那样的按钮，等着你去发现了。\n\n### 持续集成 — TravisCI \n> [TravisCI](https://travis-ci.org/)    \n> Test and Deploy with Confidence    \n> Easily sync your GitHub projects with Travis CI and you’ll be testing your code in minutes!\n\n不知道你有没有好奇Github上的一些明星项目的这样的标签：\n\n[![Build Status](https://travis-ci.org/expressjs/express.svg?branch=master)](https://travis-ci.org/expressjs/express)\n\n这个是Express的构建状态的标签，格式是svg，它会根据Express的构建状态改变。如果Express的某一次提交是没有通过TravisCI构建的，他会变成 build failing。（有心人可以点击这个标签进去看看。）\n\n我们加入TravisCI主要目的是用于自动化的单元测试，每一次Commit与PR，TravisCI都会从Github仓库中拉取代码，然后执行我们写好的单元测试，通过与否会通过状态展示出来。    \n合并的人如果看到build failing，就不会合并了，这在一定程度上保证与提高了代码的质量。\n\nTravisCI除了可以用来自动化单元测试，还可以自动化部署，可以设定，通过测试之后，就自动部署上线。\n\nTravisCI对于公开仓库是免费的，但对于私有仓库是要收费的，而且价格也不便宜。    \n如果你觉得贵，这里还有一个可以代替的：**[CircleCI](https://circleci.com/)**    \nTravisCI可以做的，它都可以做得到，而且会提供一个免费的私有仓库。    \n\n### 代码Review — Reviewable\n> [Reviewable](https://reviewable.io/)\n> GitHub code reviews done right\n\n如果你觉得Github自带的Review还不够满足的话，可以尝试一下这款产品。\n当你提交一个PR之后，在你的PR中，会在你的评论框中嵌入这样的按钮\n\n![](//dn-cnode.qbox.me/FrDLVgDD6alCXnHAfk4XNHJCCnS_)\n\n点击进入Reviewable的页面对应的PR进行review。\n\n并且一个PR没有完成Review之前，是会一直被警告，让你警惕进行合并。\n\n### 代码覆盖率 — Coveralls\n> [Coveralls](http://coveralls.io/)    \n> We help you deliver code confidently by showing which parts of your code aren’t covered by your test suite. Free for open source repos. Pro accounts for private repos. Instant sign up through GitHub and Bitbucket.\n\n在明星项目Express的Github项目主页中，你可以看到这样的标签：\n\n[![Coverage Status](https://coveralls.io/repos/strongloop/express/badge.svg?branch=master&service=github)](https://coveralls.io/github/strongloop/express?branch=master)\n\n结合着TravisCI的自动化单元测试，加上这个测试覆盖率，提高你对项目的信心。\n\n\n### 快速进行沟通 — Slack\n> [Slack](https://slack.com/)    \n> A messaging app for teams who see through the Earth\n\n相信大部分团队都是使用微信进行沟通的，    \n再一次，最为一个有逼格的团队，我们使用了Slack进行团队上的沟通，在Slack上，你可以创建频道(Channel)，不同Channel不同的人进行着不同的话题沟通。我们有设计的Channel、产品的Channel、开发的Channel。我最欣赏的是，Slack可以接入很多第三方服务，Github是其中一个。\n\n接入Github之后，项目的每一个Commit、PR之类的动态信息，会被推送到聊天室中。\n\n助你时刻掌控项目动态。\n\n![](//dn-cnode.qbox.me/FjrMtthZ9pX08AWOKbIPlogDKBcK)\n\nSlack接入Githu只是其中的一个小功能而已，更强大的在于Slack本身，利器如何用，待君慢慢体会。  \n  \n**但**，Slack有一个硬伤：不会科学上网，用不了呀。\n\n\n### 最后\n\n再一次，作为一个有逼格的团队，我们依然不会满足现状。\n\n","slug":"如果你用GitHub，可以这样提高效率","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqo002q15hl30c6kmfq","content":"<p>一年时间我们从几个人的开发团队发展到十几人的团队，最初的我们只有两个后端加两个前端，而且其中三个还是实习生。<br>但今时不同往日，现在我们有前端、后端、测试、运维、设计、产品、交互，成功集齐了七个兵种，可以召唤神龙，赐我们一个敏捷的开发团队。<br>作为一个敏捷性的开发团队，我们要保持快速的迭代速度的同时保证高质量的代码，这是一个艰巨的过程。</p>\n<h3 id=\"版本管理-—-Git-Hub\"><a href=\"#版本管理-—-Git-Hub\" class=\"headerlink\" title=\"版本管理 — Git~Hub\"></a>版本管理 — Git~Hub</h3><blockquote>\n<p>「开始的开始，我们还是孩子」(出自《北京路的日子》)</p>\n</blockquote>\n<p>开始的开始，我们还是用着SVN，代码存储在公司的服务器中，只有一个分支，提交代码无需审核，无需单元测试。因为我们只有几个人……</p>\n<p>作为一个有逼格的团队，后来我们用上了Git，并且把代码迁移到Coding中去，然后引入了名为「git flow」的工作流，关于这个工作流可以参考我们老大的文章：<a href=\"http://www.jianshu.com/p/104fa8b15d1e\" target=\"_blank\" rel=\"external\">「企业级开发：Gitflow Workflow工作流」</a></p>\n<p>Coding真的是一款很不错的产品，可称为业届良心。</p>\n<p>为什么当初没有直接用GitHub，因为私有仓库贵啊……</p>\n<p>但，作为一个有逼格的团队，我们是不会满足于此的。Coding自身的服务很不错了，但是相对于GitHub的一些专业的第三方服务，缺少了那么一些竞争力。我们当时想接入持续集成的服务，但是无奈找不到支持Coding的第三方服务，代码Review也没有一个更让我们舒心的体验，我承认我们要求比较高。再加上Coding的几次down机，其中一次是我们准备发布新版本的那一个下午…..</p>\n<p>终于有一天，我们老大两眼发光的跟我们说：我们要买GitHub的服务了，申请到资金了。</p>\n<p>于是乎，我们浩浩荡荡的迁移代码库。</p>\n<p>迁移到Github之后，我们开始接入各方工具，提高我们的工作效率（钱可不能白花啊）。</p>\n<h3 id=\"武装GitHub-—-ZenHub\"><a href=\"#武装GitHub-—-ZenHub\" class=\"headerlink\" title=\"武装GitHub — ZenHub\"></a>武装GitHub — ZenHub</h3><blockquote>\n<p><a href=\"https://www.zenhub.io/\" target=\"_blank\" rel=\"external\">ZenHub</a><br>Project management inside GitHub<br>Transform your GitHub issues</p>\n</blockquote>\n<p>正如Zenhub所说，这是一款项目管理工具，嵌入式集成到GitHub中。作为插件，它的UI完全迎合了GitHub，以至于你难以分别出哪些功能是GitHub的，哪些功能是Zenhub的。</p>\n<p>如果你用了ZenHub，它会提供给你：</p>\n<ol>\n<li><strong>一套任务面板</strong>，给不同的任务提供不同的泳道，直观的展示每个任务的进度。于是乎我抛弃了Teambition。</li>\n<li><strong>一套个人的Todo List</strong>，如果有一个issue或者一个PR需要你来处理，但你现在没有空，你可以把它添加到Todo List中，于是乎我又抛弃了Wunderlist。</li>\n<li><strong>一套项目图标与统计</strong>，结合着Github自带的项目图表，这个提供更多维度的数据，但是个人感觉意义不太大。</li>\n<li><strong>再加一些小彩蛋</strong>，由于它是作为插件形式嵌入到Github中的，所以会在很多地方提供一些这样那样的按钮，等着你去发现了。</li>\n</ol>\n<h3 id=\"持续集成-—-TravisCI\"><a href=\"#持续集成-—-TravisCI\" class=\"headerlink\" title=\"持续集成 — TravisCI\"></a>持续集成 — TravisCI</h3><blockquote>\n<p><a href=\"https://travis-ci.org/\" target=\"_blank\" rel=\"external\">TravisCI</a><br>Test and Deploy with Confidence<br>Easily sync your GitHub projects with Travis CI and you’ll be testing your code in minutes!</p>\n</blockquote>\n<p>不知道你有没有好奇Github上的一些明星项目的这样的标签：</p>\n<p><a href=\"https://travis-ci.org/expressjs/express\" target=\"_blank\" rel=\"external\"><img src=\"https://travis-ci.org/expressjs/express.svg?branch=master\" alt=\"Build Status\"></a></p>\n<p>这个是Express的构建状态的标签，格式是svg，它会根据Express的构建状态改变。如果Express的某一次提交是没有通过TravisCI构建的，他会变成 build failing。（有心人可以点击这个标签进去看看。）</p>\n<p>我们加入TravisCI主要目的是用于自动化的单元测试，每一次Commit与PR，TravisCI都会从Github仓库中拉取代码，然后执行我们写好的单元测试，通过与否会通过状态展示出来。<br>合并的人如果看到build failing，就不会合并了，这在一定程度上保证与提高了代码的质量。</p>\n<p>TravisCI除了可以用来自动化单元测试，还可以自动化部署，可以设定，通过测试之后，就自动部署上线。</p>\n<p>TravisCI对于公开仓库是免费的，但对于私有仓库是要收费的，而且价格也不便宜。<br>如果你觉得贵，这里还有一个可以代替的：<strong><a href=\"https://circleci.com/\" target=\"_blank\" rel=\"external\">CircleCI</a></strong><br>TravisCI可以做的，它都可以做得到，而且会提供一个免费的私有仓库。    </p>\n<h3 id=\"代码Review-—-Reviewable\"><a href=\"#代码Review-—-Reviewable\" class=\"headerlink\" title=\"代码Review — Reviewable\"></a>代码Review — Reviewable</h3><blockquote>\n<p><a href=\"https://reviewable.io/\" target=\"_blank\" rel=\"external\">Reviewable</a><br>GitHub code reviews done right</p>\n</blockquote>\n<p>如果你觉得Github自带的Review还不够满足的话，可以尝试一下这款产品。<br>当你提交一个PR之后，在你的PR中，会在你的评论框中嵌入这样的按钮</p>\n<p><img src=\"//dn-cnode.qbox.me/FrDLVgDD6alCXnHAfk4XNHJCCnS_\" alt=\"\"></p>\n<p>点击进入Reviewable的页面对应的PR进行review。</p>\n<p>并且一个PR没有完成Review之前，是会一直被警告，让你警惕进行合并。</p>\n<h3 id=\"代码覆盖率-—-Coveralls\"><a href=\"#代码覆盖率-—-Coveralls\" class=\"headerlink\" title=\"代码覆盖率 — Coveralls\"></a>代码覆盖率 — Coveralls</h3><blockquote>\n<p><a href=\"http://coveralls.io/\" target=\"_blank\" rel=\"external\">Coveralls</a><br>We help you deliver code confidently by showing which parts of your code aren’t covered by your test suite. Free for open source repos. Pro accounts for private repos. Instant sign up through GitHub and Bitbucket.</p>\n</blockquote>\n<p>在明星项目Express的Github项目主页中，你可以看到这样的标签：</p>\n<p><a href=\"https://coveralls.io/github/strongloop/express?branch=master\" target=\"_blank\" rel=\"external\"><img src=\"https://coveralls.io/repos/strongloop/express/badge.svg?branch=master&amp;service=github\" alt=\"Coverage Status\"></a></p>\n<p>结合着TravisCI的自动化单元测试，加上这个测试覆盖率，提高你对项目的信心。</p>\n<h3 id=\"快速进行沟通-—-Slack\"><a href=\"#快速进行沟通-—-Slack\" class=\"headerlink\" title=\"快速进行沟通 — Slack\"></a>快速进行沟通 — Slack</h3><blockquote>\n<p><a href=\"https://slack.com/\" target=\"_blank\" rel=\"external\">Slack</a><br>A messaging app for teams who see through the Earth</p>\n</blockquote>\n<p>相信大部分团队都是使用微信进行沟通的，<br>再一次，最为一个有逼格的团队，我们使用了Slack进行团队上的沟通，在Slack上，你可以创建频道(Channel)，不同Channel不同的人进行着不同的话题沟通。我们有设计的Channel、产品的Channel、开发的Channel。我最欣赏的是，Slack可以接入很多第三方服务，Github是其中一个。</p>\n<p>接入Github之后，项目的每一个Commit、PR之类的动态信息，会被推送到聊天室中。</p>\n<p>助你时刻掌控项目动态。</p>\n<p><img src=\"//dn-cnode.qbox.me/FjrMtthZ9pX08AWOKbIPlogDKBcK\" alt=\"\"></p>\n<p>Slack接入Githu只是其中的一个小功能而已，更强大的在于Slack本身，利器如何用，待君慢慢体会。  </p>\n<p><strong>但</strong>，Slack有一个硬伤：不会科学上网，用不了呀。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>再一次，作为一个有逼格的团队，我们依然不会满足现状。</p>\n","excerpt":"","more":"<p>一年时间我们从几个人的开发团队发展到十几人的团队，最初的我们只有两个后端加两个前端，而且其中三个还是实习生。<br>但今时不同往日，现在我们有前端、后端、测试、运维、设计、产品、交互，成功集齐了七个兵种，可以召唤神龙，赐我们一个敏捷的开发团队。<br>作为一个敏捷性的开发团队，我们要保持快速的迭代速度的同时保证高质量的代码，这是一个艰巨的过程。</p>\n<h3 id=\"版本管理-—-Git-Hub\"><a href=\"#版本管理-—-Git-Hub\" class=\"headerlink\" title=\"版本管理 — Git~Hub\"></a>版本管理 — Git~Hub</h3><blockquote>\n<p>「开始的开始，我们还是孩子」(出自《北京路的日子》)</p>\n</blockquote>\n<p>开始的开始，我们还是用着SVN，代码存储在公司的服务器中，只有一个分支，提交代码无需审核，无需单元测试。因为我们只有几个人……</p>\n<p>作为一个有逼格的团队，后来我们用上了Git，并且把代码迁移到Coding中去，然后引入了名为「git flow」的工作流，关于这个工作流可以参考我们老大的文章：<a href=\"http://www.jianshu.com/p/104fa8b15d1e\">「企业级开发：Gitflow Workflow工作流」</a></p>\n<p>Coding真的是一款很不错的产品，可称为业届良心。</p>\n<p>为什么当初没有直接用GitHub，因为私有仓库贵啊……</p>\n<p>但，作为一个有逼格的团队，我们是不会满足于此的。Coding自身的服务很不错了，但是相对于GitHub的一些专业的第三方服务，缺少了那么一些竞争力。我们当时想接入持续集成的服务，但是无奈找不到支持Coding的第三方服务，代码Review也没有一个更让我们舒心的体验，我承认我们要求比较高。再加上Coding的几次down机，其中一次是我们准备发布新版本的那一个下午…..</p>\n<p>终于有一天，我们老大两眼发光的跟我们说：我们要买GitHub的服务了，申请到资金了。</p>\n<p>于是乎，我们浩浩荡荡的迁移代码库。</p>\n<p>迁移到Github之后，我们开始接入各方工具，提高我们的工作效率（钱可不能白花啊）。</p>\n<h3 id=\"武装GitHub-—-ZenHub\"><a href=\"#武装GitHub-—-ZenHub\" class=\"headerlink\" title=\"武装GitHub — ZenHub\"></a>武装GitHub — ZenHub</h3><blockquote>\n<p><a href=\"https://www.zenhub.io/\">ZenHub</a><br>Project management inside GitHub<br>Transform your GitHub issues</p>\n</blockquote>\n<p>正如Zenhub所说，这是一款项目管理工具，嵌入式集成到GitHub中。作为插件，它的UI完全迎合了GitHub，以至于你难以分别出哪些功能是GitHub的，哪些功能是Zenhub的。</p>\n<p>如果你用了ZenHub，它会提供给你：</p>\n<ol>\n<li><strong>一套任务面板</strong>，给不同的任务提供不同的泳道，直观的展示每个任务的进度。于是乎我抛弃了Teambition。</li>\n<li><strong>一套个人的Todo List</strong>，如果有一个issue或者一个PR需要你来处理，但你现在没有空，你可以把它添加到Todo List中，于是乎我又抛弃了Wunderlist。</li>\n<li><strong>一套项目图标与统计</strong>，结合着Github自带的项目图表，这个提供更多维度的数据，但是个人感觉意义不太大。</li>\n<li><strong>再加一些小彩蛋</strong>，由于它是作为插件形式嵌入到Github中的，所以会在很多地方提供一些这样那样的按钮，等着你去发现了。</li>\n</ol>\n<h3 id=\"持续集成-—-TravisCI\"><a href=\"#持续集成-—-TravisCI\" class=\"headerlink\" title=\"持续集成 — TravisCI\"></a>持续集成 — TravisCI</h3><blockquote>\n<p><a href=\"https://travis-ci.org/\">TravisCI</a><br>Test and Deploy with Confidence<br>Easily sync your GitHub projects with Travis CI and you’ll be testing your code in minutes!</p>\n</blockquote>\n<p>不知道你有没有好奇Github上的一些明星项目的这样的标签：</p>\n<p><a href=\"https://travis-ci.org/expressjs/express\"><img src=\"https://travis-ci.org/expressjs/express.svg?branch=master\" alt=\"Build Status\"></a></p>\n<p>这个是Express的构建状态的标签，格式是svg，它会根据Express的构建状态改变。如果Express的某一次提交是没有通过TravisCI构建的，他会变成 build failing。（有心人可以点击这个标签进去看看。）</p>\n<p>我们加入TravisCI主要目的是用于自动化的单元测试，每一次Commit与PR，TravisCI都会从Github仓库中拉取代码，然后执行我们写好的单元测试，通过与否会通过状态展示出来。<br>合并的人如果看到build failing，就不会合并了，这在一定程度上保证与提高了代码的质量。</p>\n<p>TravisCI除了可以用来自动化单元测试，还可以自动化部署，可以设定，通过测试之后，就自动部署上线。</p>\n<p>TravisCI对于公开仓库是免费的，但对于私有仓库是要收费的，而且价格也不便宜。<br>如果你觉得贵，这里还有一个可以代替的：<strong><a href=\"https://circleci.com/\">CircleCI</a></strong><br>TravisCI可以做的，它都可以做得到，而且会提供一个免费的私有仓库。    </p>\n<h3 id=\"代码Review-—-Reviewable\"><a href=\"#代码Review-—-Reviewable\" class=\"headerlink\" title=\"代码Review — Reviewable\"></a>代码Review — Reviewable</h3><blockquote>\n<p><a href=\"https://reviewable.io/\">Reviewable</a><br>GitHub code reviews done right</p>\n</blockquote>\n<p>如果你觉得Github自带的Review还不够满足的话，可以尝试一下这款产品。<br>当你提交一个PR之后，在你的PR中，会在你的评论框中嵌入这样的按钮</p>\n<p><img src=\"//dn-cnode.qbox.me/FrDLVgDD6alCXnHAfk4XNHJCCnS_\" alt=\"\"></p>\n<p>点击进入Reviewable的页面对应的PR进行review。</p>\n<p>并且一个PR没有完成Review之前，是会一直被警告，让你警惕进行合并。</p>\n<h3 id=\"代码覆盖率-—-Coveralls\"><a href=\"#代码覆盖率-—-Coveralls\" class=\"headerlink\" title=\"代码覆盖率 — Coveralls\"></a>代码覆盖率 — Coveralls</h3><blockquote>\n<p><a href=\"http://coveralls.io/\">Coveralls</a><br>We help you deliver code confidently by showing which parts of your code aren’t covered by your test suite. Free for open source repos. Pro accounts for private repos. Instant sign up through GitHub and Bitbucket.</p>\n</blockquote>\n<p>在明星项目Express的Github项目主页中，你可以看到这样的标签：</p>\n<p><a href=\"https://coveralls.io/github/strongloop/express?branch=master\"><img src=\"https://coveralls.io/repos/strongloop/express/badge.svg?branch=master&amp;service=github\" alt=\"Coverage Status\"></a></p>\n<p>结合着TravisCI的自动化单元测试，加上这个测试覆盖率，提高你对项目的信心。</p>\n<h3 id=\"快速进行沟通-—-Slack\"><a href=\"#快速进行沟通-—-Slack\" class=\"headerlink\" title=\"快速进行沟通 — Slack\"></a>快速进行沟通 — Slack</h3><blockquote>\n<p><a href=\"https://slack.com/\">Slack</a><br>A messaging app for teams who see through the Earth</p>\n</blockquote>\n<p>相信大部分团队都是使用微信进行沟通的，<br>再一次，最为一个有逼格的团队，我们使用了Slack进行团队上的沟通，在Slack上，你可以创建频道(Channel)，不同Channel不同的人进行着不同的话题沟通。我们有设计的Channel、产品的Channel、开发的Channel。我最欣赏的是，Slack可以接入很多第三方服务，Github是其中一个。</p>\n<p>接入Github之后，项目的每一个Commit、PR之类的动态信息，会被推送到聊天室中。</p>\n<p>助你时刻掌控项目动态。</p>\n<p><img src=\"//dn-cnode.qbox.me/FjrMtthZ9pX08AWOKbIPlogDKBcK\" alt=\"\"></p>\n<p>Slack接入Githu只是其中的一个小功能而已，更强大的在于Slack本身，利器如何用，待君慢慢体会。  </p>\n<p><strong>但</strong>，Slack有一个硬伤：不会科学上网，用不了呀。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>再一次，作为一个有逼格的团队，我们依然不会满足现状。</p>\n"},{"title":"消息系统设计与实现「上篇」","date":"2015-10-14T09:22:33.000Z","_content":"\n> 由于文章篇幅较长，而作者精力有限，不希望这么早就精尽人亡，故分成上下篇来写消息系统的设计与实现。上篇主要讲的是一些概念，搞清楚我们要做的这个消息系统的主要内容。而下篇主要讲具体的实现，会包括架构设计，数据库设计，业务流程详细的实现等。\n\n> 整个系统的设计与实现，并非我一人之力就可以完成的。这其中是同事们大家一起讨论与商讨的结果，而我只是把它细化，呈现出来。\n\n> 我只是一个会思考的idea搬运工。\n\n\n## 产品分析\n首先我们来看一下市场上关于消息的实现是怎么样的。\n\n### 简书\n简书的消息系统主要分了两种\n* 简信\n* 提醒\n\n**简信**\n简信的性质其实跟私信是一样的，是用户发送给用户的一则消息，有具体的信息内容。\n\n![简书简信](http://xia-dev.b0.upaiyun.com/c3aad7dc-5914-4c5c-9f88-34e40077d0ff.jpg)\n\n**提醒**\n而提醒，则是系统发送的一则消息，其文案格式是固定的，并且对特殊对象一般拥有超链接。\n![简书提醒](http://xia-dev.b0.upaiyun.com/b0ee917e-0776-4aa9-bf4a-0a2cd33ca853.jpg)\n\n### 知乎\n知乎跟简书一样，主要分了两种：\n* 私信\n* 消息\n\n**私信**\n跟简书一样，使用户发送给用户的一则消息，也可以是管理员发送给用户的消息。\n<img src=\"http://xia-dev.b0.upaiyun.com/a6b102ed-d337-41d2-a5d3-b3923650de16.jpg\" width=250></img>\n\n\n**消息**\n知乎的消息比简书的提醒有过之而无不及，知乎会对多条相似的消息进行聚会，以达到减轻用户阅读压力的体验。\n<img src=\"http://xia-dev.b0.upaiyun.com/5f90952e-2fe6-447f-affb-8a7c9a04d0ab.jpg\" width=450></img>\n\n## 消息的三种分类\n通过两种产品的简单分析，得出他们的消息有两种分类，在这基础上，我们再加上一种：公告。\n公告的主要性质是系统发送一则含有具体内容的消息，站内所有用户都能读取到这条消息。\n所以，消息有三种分类：\n1. 公告 Announce\n2. 提醒 Remind\n3. 私信 Message\n\n## 提醒的语言分析\n我们从简书取一组提醒样本：\n* 3dbe1bd90774 关注了你\n* magicdawn 喜欢了你的文章 《单点登录的三种实现方式》\n* 无良程序 喜欢了你的文章 《基于RESTful API 怎么设计用户权限控制？》\n* alexcc4 喜欢了你的文章 《在Nodejs中贯彻单元测试》\n*  你在《基于RESTful API 怎么设计用户权限控制？》中收到一条 cnlinjie 的评论\n*  你的文章《Session原理》已被加入专题 《ios开发》\n\n分析句子结构，提醒的内容无非就是\n\n>「谁对一样属于谁的事物做了什么操作」\n「someone do something in someone's something」\n\nsomeone = 提醒的触发者，或者发送者，标记为sender\ndo something = 提醒的动作，评论、喜欢、关注都属于一个动作，标记为action\nsomething = 提醒的动作作用对象，这就具体到是哪一篇文章，标记为target\nsomeone's = 提醒的动作作用对象的所有者，标记为targetOwner\n\n这就清楚了，sender和targetOwner就是网站的用户，而target是具体到哪一篇文章，如果提醒的对象不仅仅局限于文章，还有其他的话，就需要增加一项targetType，来标记目标是文章还是其他的什么。而action，则是固定的，整个网站会触发提醒的动作可能就只有那几样：评论、喜欢、关注.....（或者其他业务需要提醒的动作）\n\n## 消息的两种获取方式\n* 推 Push\n* 拉 Pull\n\n**以知乎为例**\n推的比较常见，需要针对某一个问题维护着一张关注者的列表，每当触发这个问题推送的条件时（例如有人回答问题），就把这个通知发送给每个关注者。\n\n拉的相对麻烦一点，就是推的反向，例如每个用户都有一张关注问题的列表，每当用户上线的时候，对每个问题进行轮询，当问题的事件列表出现了比我原本时间戳大的信息就进行拉取。\n\n**而我们则根据消息的不同分类采用不同的获取方式**：\n通告和提醒，适合使用拉取的方式，消息产生之后，会存在消息表中，用户在某一特定的时间根据自己关注问题的表进行消息的拉取，然后添加到自己的消息队列中，\n\n信息，适合使用推的方式，在发送者建立一条信息之后，同时指定接收者，把消息添加到接收者的消息队列中。\n\n## 订阅\n根据提醒使用拉取的方式，需要维护一个关注某一事物的列表。\n这种行为，我们称之为：**「订阅」Subscribe **\n\n**一则订阅有以下三个核心属性**：\n* 订阅的目标 target\n* 订阅的目标类型 targetType\n* 订阅的动作 action\n\n比如我发布了一篇文章，那么我会订阅文章《XXX》的评论动作，所以文章《XXX》每被人评论了，就需要发送一则提醒告知我。\n\n**订阅的规则还可以扩展**\n我喜欢了一篇文章，和我发布了一篇文章，订阅的动作可能不一样。\n喜欢了一篇文章，我希望我订阅这篇文章更新、评论的动作。\n而发布了一篇文章，我希望我只是订阅这篇文章的评论动作。\n\n这时候就需要多一个参数：subscribReason\n不同的subscribReason，对应着一个动作数组，\nsubscribReason = 喜欢，对应着 actions = [更新，评论]\nsubscribReason = 发布，对应着 actions = [评论]\n\n**订阅的规则还还可以扩展**\n用户可能会有一个自己的订阅设置，比如对于所有的喜欢的动作，我都不希望接收。\n比如Knewone的提醒设置\n<img src=\"http://xia-dev.b0.upaiyun.com/80cc4aaf-0568-478c-8513-b8821e57520f.jpg\" alt=\"Knewone提醒设置\" width=\"500\">\n\n所以我们需要再维护一个表：**SubscriptionConfig**，来存放用户的提醒设置。\n并且，当用户没有提醒设置的时候，可以使用系统提供的一套默认设置：**defaultSubscriptionConfig**\n\n\n## 聚合\n如果我发布了一篇文章《XXX》，在我不在线的时候，被评论了10遍，当我一上线的时候，应该是收到十条信息类似于：「谁谁谁评论了你的文章《XXX》」?\n还是应该收到一条信息：「甲、乙、丙、丁...评论了你的文章《XXX》」?\n\n知乎在聚合上做的很优秀，要知道他们要实现这个还是挺有技术的：\n[知乎的消息机制，在技术上如何设计与规划？](http://www.zhihu.com/question/22394809)\n[网站的消息（通知）系统一般是如何实现的？](http://www.zhihu.com/question/20380990/answer/14960006)\n\n关于这部分功能，我们还没有具体的实现方法，暂时也无法讲得更加详细。⊙﹏⊙\n\n## 五个实体\n通过上面的分析，大概知道做这个消息系统，需要哪些实体类：\n1. 用户消息队列 UserNotify\n2. 用户 User\n3. 订阅 Subscription\n4. 订阅设置 SubscriptionConfig\n5. 消息 Notify\n\t- 通告 Announce\n\t- 提醒 Remind\n\t- 信息 Message\n\n## 行为分解\n说了这么多，整理一下整个消息流程的一些行为：\n\n- 系统或者管理员，创建消息 \n\t- createNotify (make announce | remind | message)\n- 用户，订阅消息，取消订阅\n\t- subscribe, cancelSubscription\n- 用户管理订阅设置\n\t- getSubscriptionConfig, updateSubscriptionConfig\n- 用户，拉取消息\n\t- pullNotify (pull announce | remind | message | all)\n- 用户，查询消息队列\n\t- getUserNotify(get announce | remind | message | all)\n- 用户阅读消息\n\t- read\n\n\n> 在本文的「下篇」我们来探讨一下：模型怎么做、数据库怎么设计、代码结构怎么来、一些逻辑上的时序图应该是怎么样的。\n\n\n","source":"_posts/消息系统设计与实现「上篇」.md","raw":"---\ntitle: 消息系统设计与实现「上篇」\ncategory: 搬砖码农\ndate: 2015-10-14 17:22:33\ntags:\n- 架构\n- 消息系统\n---\n\n> 由于文章篇幅较长，而作者精力有限，不希望这么早就精尽人亡，故分成上下篇来写消息系统的设计与实现。上篇主要讲的是一些概念，搞清楚我们要做的这个消息系统的主要内容。而下篇主要讲具体的实现，会包括架构设计，数据库设计，业务流程详细的实现等。\n\n> 整个系统的设计与实现，并非我一人之力就可以完成的。这其中是同事们大家一起讨论与商讨的结果，而我只是把它细化，呈现出来。\n\n> 我只是一个会思考的idea搬运工。\n\n\n## 产品分析\n首先我们来看一下市场上关于消息的实现是怎么样的。\n\n### 简书\n简书的消息系统主要分了两种\n* 简信\n* 提醒\n\n**简信**\n简信的性质其实跟私信是一样的，是用户发送给用户的一则消息，有具体的信息内容。\n\n![简书简信](http://xia-dev.b0.upaiyun.com/c3aad7dc-5914-4c5c-9f88-34e40077d0ff.jpg)\n\n**提醒**\n而提醒，则是系统发送的一则消息，其文案格式是固定的，并且对特殊对象一般拥有超链接。\n![简书提醒](http://xia-dev.b0.upaiyun.com/b0ee917e-0776-4aa9-bf4a-0a2cd33ca853.jpg)\n\n### 知乎\n知乎跟简书一样，主要分了两种：\n* 私信\n* 消息\n\n**私信**\n跟简书一样，使用户发送给用户的一则消息，也可以是管理员发送给用户的消息。\n<img src=\"http://xia-dev.b0.upaiyun.com/a6b102ed-d337-41d2-a5d3-b3923650de16.jpg\" width=250></img>\n\n\n**消息**\n知乎的消息比简书的提醒有过之而无不及，知乎会对多条相似的消息进行聚会，以达到减轻用户阅读压力的体验。\n<img src=\"http://xia-dev.b0.upaiyun.com/5f90952e-2fe6-447f-affb-8a7c9a04d0ab.jpg\" width=450></img>\n\n## 消息的三种分类\n通过两种产品的简单分析，得出他们的消息有两种分类，在这基础上，我们再加上一种：公告。\n公告的主要性质是系统发送一则含有具体内容的消息，站内所有用户都能读取到这条消息。\n所以，消息有三种分类：\n1. 公告 Announce\n2. 提醒 Remind\n3. 私信 Message\n\n## 提醒的语言分析\n我们从简书取一组提醒样本：\n* 3dbe1bd90774 关注了你\n* magicdawn 喜欢了你的文章 《单点登录的三种实现方式》\n* 无良程序 喜欢了你的文章 《基于RESTful API 怎么设计用户权限控制？》\n* alexcc4 喜欢了你的文章 《在Nodejs中贯彻单元测试》\n*  你在《基于RESTful API 怎么设计用户权限控制？》中收到一条 cnlinjie 的评论\n*  你的文章《Session原理》已被加入专题 《ios开发》\n\n分析句子结构，提醒的内容无非就是\n\n>「谁对一样属于谁的事物做了什么操作」\n「someone do something in someone's something」\n\nsomeone = 提醒的触发者，或者发送者，标记为sender\ndo something = 提醒的动作，评论、喜欢、关注都属于一个动作，标记为action\nsomething = 提醒的动作作用对象，这就具体到是哪一篇文章，标记为target\nsomeone's = 提醒的动作作用对象的所有者，标记为targetOwner\n\n这就清楚了，sender和targetOwner就是网站的用户，而target是具体到哪一篇文章，如果提醒的对象不仅仅局限于文章，还有其他的话，就需要增加一项targetType，来标记目标是文章还是其他的什么。而action，则是固定的，整个网站会触发提醒的动作可能就只有那几样：评论、喜欢、关注.....（或者其他业务需要提醒的动作）\n\n## 消息的两种获取方式\n* 推 Push\n* 拉 Pull\n\n**以知乎为例**\n推的比较常见，需要针对某一个问题维护着一张关注者的列表，每当触发这个问题推送的条件时（例如有人回答问题），就把这个通知发送给每个关注者。\n\n拉的相对麻烦一点，就是推的反向，例如每个用户都有一张关注问题的列表，每当用户上线的时候，对每个问题进行轮询，当问题的事件列表出现了比我原本时间戳大的信息就进行拉取。\n\n**而我们则根据消息的不同分类采用不同的获取方式**：\n通告和提醒，适合使用拉取的方式，消息产生之后，会存在消息表中，用户在某一特定的时间根据自己关注问题的表进行消息的拉取，然后添加到自己的消息队列中，\n\n信息，适合使用推的方式，在发送者建立一条信息之后，同时指定接收者，把消息添加到接收者的消息队列中。\n\n## 订阅\n根据提醒使用拉取的方式，需要维护一个关注某一事物的列表。\n这种行为，我们称之为：**「订阅」Subscribe **\n\n**一则订阅有以下三个核心属性**：\n* 订阅的目标 target\n* 订阅的目标类型 targetType\n* 订阅的动作 action\n\n比如我发布了一篇文章，那么我会订阅文章《XXX》的评论动作，所以文章《XXX》每被人评论了，就需要发送一则提醒告知我。\n\n**订阅的规则还可以扩展**\n我喜欢了一篇文章，和我发布了一篇文章，订阅的动作可能不一样。\n喜欢了一篇文章，我希望我订阅这篇文章更新、评论的动作。\n而发布了一篇文章，我希望我只是订阅这篇文章的评论动作。\n\n这时候就需要多一个参数：subscribReason\n不同的subscribReason，对应着一个动作数组，\nsubscribReason = 喜欢，对应着 actions = [更新，评论]\nsubscribReason = 发布，对应着 actions = [评论]\n\n**订阅的规则还还可以扩展**\n用户可能会有一个自己的订阅设置，比如对于所有的喜欢的动作，我都不希望接收。\n比如Knewone的提醒设置\n<img src=\"http://xia-dev.b0.upaiyun.com/80cc4aaf-0568-478c-8513-b8821e57520f.jpg\" alt=\"Knewone提醒设置\" width=\"500\">\n\n所以我们需要再维护一个表：**SubscriptionConfig**，来存放用户的提醒设置。\n并且，当用户没有提醒设置的时候，可以使用系统提供的一套默认设置：**defaultSubscriptionConfig**\n\n\n## 聚合\n如果我发布了一篇文章《XXX》，在我不在线的时候，被评论了10遍，当我一上线的时候，应该是收到十条信息类似于：「谁谁谁评论了你的文章《XXX》」?\n还是应该收到一条信息：「甲、乙、丙、丁...评论了你的文章《XXX》」?\n\n知乎在聚合上做的很优秀，要知道他们要实现这个还是挺有技术的：\n[知乎的消息机制，在技术上如何设计与规划？](http://www.zhihu.com/question/22394809)\n[网站的消息（通知）系统一般是如何实现的？](http://www.zhihu.com/question/20380990/answer/14960006)\n\n关于这部分功能，我们还没有具体的实现方法，暂时也无法讲得更加详细。⊙﹏⊙\n\n## 五个实体\n通过上面的分析，大概知道做这个消息系统，需要哪些实体类：\n1. 用户消息队列 UserNotify\n2. 用户 User\n3. 订阅 Subscription\n4. 订阅设置 SubscriptionConfig\n5. 消息 Notify\n\t- 通告 Announce\n\t- 提醒 Remind\n\t- 信息 Message\n\n## 行为分解\n说了这么多，整理一下整个消息流程的一些行为：\n\n- 系统或者管理员，创建消息 \n\t- createNotify (make announce | remind | message)\n- 用户，订阅消息，取消订阅\n\t- subscribe, cancelSubscription\n- 用户管理订阅设置\n\t- getSubscriptionConfig, updateSubscriptionConfig\n- 用户，拉取消息\n\t- pullNotify (pull announce | remind | message | all)\n- 用户，查询消息队列\n\t- getUserNotify(get announce | remind | message | all)\n- 用户阅读消息\n\t- read\n\n\n> 在本文的「下篇」我们来探讨一下：模型怎么做、数据库怎么设计、代码结构怎么来、一些逻辑上的时序图应该是怎么样的。\n\n\n","slug":"消息系统设计与实现「上篇」","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqp002s15hlf2zjqpyb","content":"<blockquote>\n<p>由于文章篇幅较长，而作者精力有限，不希望这么早就精尽人亡，故分成上下篇来写消息系统的设计与实现。上篇主要讲的是一些概念，搞清楚我们要做的这个消息系统的主要内容。而下篇主要讲具体的实现，会包括架构设计，数据库设计，业务流程详细的实现等。</p>\n<p>整个系统的设计与实现，并非我一人之力就可以完成的。这其中是同事们大家一起讨论与商讨的结果，而我只是把它细化，呈现出来。</p>\n<p>我只是一个会思考的idea搬运工。</p>\n</blockquote>\n<h2 id=\"产品分析\"><a href=\"#产品分析\" class=\"headerlink\" title=\"产品分析\"></a>产品分析</h2><p>首先我们来看一下市场上关于消息的实现是怎么样的。</p>\n<h3 id=\"简书\"><a href=\"#简书\" class=\"headerlink\" title=\"简书\"></a>简书</h3><p>简书的消息系统主要分了两种</p>\n<ul>\n<li>简信</li>\n<li>提醒</li>\n</ul>\n<p><strong>简信</strong><br>简信的性质其实跟私信是一样的，是用户发送给用户的一则消息，有具体的信息内容。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/c3aad7dc-5914-4c5c-9f88-34e40077d0ff.jpg\" alt=\"简书简信\"></p>\n<p><strong>提醒</strong><br>而提醒，则是系统发送的一则消息，其文案格式是固定的，并且对特殊对象一般拥有超链接。<br><img src=\"http://xia-dev.b0.upaiyun.com/b0ee917e-0776-4aa9-bf4a-0a2cd33ca853.jpg\" alt=\"简书提醒\"></p>\n<h3 id=\"知乎\"><a href=\"#知乎\" class=\"headerlink\" title=\"知乎\"></a>知乎</h3><p>知乎跟简书一样，主要分了两种：</p>\n<ul>\n<li>私信</li>\n<li>消息</li>\n</ul>\n<p><strong>私信</strong><br>跟简书一样，使用户发送给用户的一则消息，也可以是管理员发送给用户的消息。<br><img src=\"http://xia-dev.b0.upaiyun.com/a6b102ed-d337-41d2-a5d3-b3923650de16.jpg\" width=\"250\"></p>\n<p><strong>消息</strong><br>知乎的消息比简书的提醒有过之而无不及，知乎会对多条相似的消息进行聚会，以达到减轻用户阅读压力的体验。<br><img src=\"http://xia-dev.b0.upaiyun.com/5f90952e-2fe6-447f-affb-8a7c9a04d0ab.jpg\" width=\"450\"></p>\n<h2 id=\"消息的三种分类\"><a href=\"#消息的三种分类\" class=\"headerlink\" title=\"消息的三种分类\"></a>消息的三种分类</h2><p>通过两种产品的简单分析，得出他们的消息有两种分类，在这基础上，我们再加上一种：公告。<br>公告的主要性质是系统发送一则含有具体内容的消息，站内所有用户都能读取到这条消息。<br>所以，消息有三种分类：</p>\n<ol>\n<li>公告 Announce</li>\n<li>提醒 Remind</li>\n<li>私信 Message</li>\n</ol>\n<h2 id=\"提醒的语言分析\"><a href=\"#提醒的语言分析\" class=\"headerlink\" title=\"提醒的语言分析\"></a>提醒的语言分析</h2><p>我们从简书取一组提醒样本：</p>\n<ul>\n<li>3dbe1bd90774 关注了你</li>\n<li>magicdawn 喜欢了你的文章 《单点登录的三种实现方式》</li>\n<li>无良程序 喜欢了你的文章 《基于RESTful API 怎么设计用户权限控制？》</li>\n<li>alexcc4 喜欢了你的文章 《在Nodejs中贯彻单元测试》</li>\n<li>你在《基于RESTful API 怎么设计用户权限控制？》中收到一条 cnlinjie 的评论</li>\n<li>你的文章《Session原理》已被加入专题 《ios开发》</li>\n</ul>\n<p>分析句子结构，提醒的内容无非就是</p>\n<blockquote>\n<p>「谁对一样属于谁的事物做了什么操作」<br>「someone do something in someone’s something」</p>\n</blockquote>\n<p>someone = 提醒的触发者，或者发送者，标记为sender<br>do something = 提醒的动作，评论、喜欢、关注都属于一个动作，标记为action<br>something = 提醒的动作作用对象，这就具体到是哪一篇文章，标记为target<br>someone’s = 提醒的动作作用对象的所有者，标记为targetOwner</p>\n<p>这就清楚了，sender和targetOwner就是网站的用户，而target是具体到哪一篇文章，如果提醒的对象不仅仅局限于文章，还有其他的话，就需要增加一项targetType，来标记目标是文章还是其他的什么。而action，则是固定的，整个网站会触发提醒的动作可能就只有那几样：评论、喜欢、关注…..（或者其他业务需要提醒的动作）</p>\n<h2 id=\"消息的两种获取方式\"><a href=\"#消息的两种获取方式\" class=\"headerlink\" title=\"消息的两种获取方式\"></a>消息的两种获取方式</h2><ul>\n<li>推 Push</li>\n<li>拉 Pull</li>\n</ul>\n<p><strong>以知乎为例</strong><br>推的比较常见，需要针对某一个问题维护着一张关注者的列表，每当触发这个问题推送的条件时（例如有人回答问题），就把这个通知发送给每个关注者。</p>\n<p>拉的相对麻烦一点，就是推的反向，例如每个用户都有一张关注问题的列表，每当用户上线的时候，对每个问题进行轮询，当问题的事件列表出现了比我原本时间戳大的信息就进行拉取。</p>\n<p><strong>而我们则根据消息的不同分类采用不同的获取方式</strong>：<br>通告和提醒，适合使用拉取的方式，消息产生之后，会存在消息表中，用户在某一特定的时间根据自己关注问题的表进行消息的拉取，然后添加到自己的消息队列中，</p>\n<p>信息，适合使用推的方式，在发送者建立一条信息之后，同时指定接收者，把消息添加到接收者的消息队列中。</p>\n<h2 id=\"订阅\"><a href=\"#订阅\" class=\"headerlink\" title=\"订阅\"></a>订阅</h2><p>根据提醒使用拉取的方式，需要维护一个关注某一事物的列表。<br>这种行为，我们称之为：<strong>「订阅」Subscribe </strong></p>\n<p><strong>一则订阅有以下三个核心属性</strong>：</p>\n<ul>\n<li>订阅的目标 target</li>\n<li>订阅的目标类型 targetType</li>\n<li>订阅的动作 action</li>\n</ul>\n<p>比如我发布了一篇文章，那么我会订阅文章《XXX》的评论动作，所以文章《XXX》每被人评论了，就需要发送一则提醒告知我。</p>\n<p><strong>订阅的规则还可以扩展</strong><br>我喜欢了一篇文章，和我发布了一篇文章，订阅的动作可能不一样。<br>喜欢了一篇文章，我希望我订阅这篇文章更新、评论的动作。<br>而发布了一篇文章，我希望我只是订阅这篇文章的评论动作。</p>\n<p>这时候就需要多一个参数：subscribReason<br>不同的subscribReason，对应着一个动作数组，<br>subscribReason = 喜欢，对应着 actions = [更新，评论]<br>subscribReason = 发布，对应着 actions = [评论]</p>\n<p><strong>订阅的规则还还可以扩展</strong><br>用户可能会有一个自己的订阅设置，比如对于所有的喜欢的动作，我都不希望接收。<br>比如Knewone的提醒设置<br><img src=\"http://xia-dev.b0.upaiyun.com/80cc4aaf-0568-478c-8513-b8821e57520f.jpg\" alt=\"Knewone提醒设置\" width=\"500\"></p>\n<p>所以我们需要再维护一个表：<strong>SubscriptionConfig</strong>，来存放用户的提醒设置。<br>并且，当用户没有提醒设置的时候，可以使用系统提供的一套默认设置：<strong>defaultSubscriptionConfig</strong></p>\n<h2 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h2><p>如果我发布了一篇文章《XXX》，在我不在线的时候，被评论了10遍，当我一上线的时候，应该是收到十条信息类似于：「谁谁谁评论了你的文章《XXX》」?<br>还是应该收到一条信息：「甲、乙、丙、丁…评论了你的文章《XXX》」?</p>\n<p>知乎在聚合上做的很优秀，要知道他们要实现这个还是挺有技术的：<br><a href=\"http://www.zhihu.com/question/22394809\" target=\"_blank\" rel=\"external\">知乎的消息机制，在技术上如何设计与规划？</a><br><a href=\"http://www.zhihu.com/question/20380990/answer/14960006\" target=\"_blank\" rel=\"external\">网站的消息（通知）系统一般是如何实现的？</a></p>\n<p>关于这部分功能，我们还没有具体的实现方法，暂时也无法讲得更加详细。⊙﹏⊙</p>\n<h2 id=\"五个实体\"><a href=\"#五个实体\" class=\"headerlink\" title=\"五个实体\"></a>五个实体</h2><p>通过上面的分析，大概知道做这个消息系统，需要哪些实体类：</p>\n<ol>\n<li>用户消息队列 UserNotify</li>\n<li>用户 User</li>\n<li>订阅 Subscription</li>\n<li>订阅设置 SubscriptionConfig</li>\n<li>消息 Notify<ul>\n<li>通告 Announce</li>\n<li>提醒 Remind</li>\n<li>信息 Message</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"行为分解\"><a href=\"#行为分解\" class=\"headerlink\" title=\"行为分解\"></a>行为分解</h2><p>说了这么多，整理一下整个消息流程的一些行为：</p>\n<ul>\n<li>系统或者管理员，创建消息 <ul>\n<li>createNotify (make announce | remind | message)</li>\n</ul>\n</li>\n<li>用户，订阅消息，取消订阅<ul>\n<li>subscribe, cancelSubscription</li>\n</ul>\n</li>\n<li>用户管理订阅设置<ul>\n<li>getSubscriptionConfig, updateSubscriptionConfig</li>\n</ul>\n</li>\n<li>用户，拉取消息<ul>\n<li>pullNotify (pull announce | remind | message | all)</li>\n</ul>\n</li>\n<li>用户，查询消息队列<ul>\n<li>getUserNotify(get announce | remind | message | all)</li>\n</ul>\n</li>\n<li>用户阅读消息<ul>\n<li>read</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>在本文的「下篇」我们来探讨一下：模型怎么做、数据库怎么设计、代码结构怎么来、一些逻辑上的时序图应该是怎么样的。</p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>由于文章篇幅较长，而作者精力有限，不希望这么早就精尽人亡，故分成上下篇来写消息系统的设计与实现。上篇主要讲的是一些概念，搞清楚我们要做的这个消息系统的主要内容。而下篇主要讲具体的实现，会包括架构设计，数据库设计，业务流程详细的实现等。</p>\n<p>整个系统的设计与实现，并非我一人之力就可以完成的。这其中是同事们大家一起讨论与商讨的结果，而我只是把它细化，呈现出来。</p>\n<p>我只是一个会思考的idea搬运工。</p>\n</blockquote>\n<h2 id=\"产品分析\"><a href=\"#产品分析\" class=\"headerlink\" title=\"产品分析\"></a>产品分析</h2><p>首先我们来看一下市场上关于消息的实现是怎么样的。</p>\n<h3 id=\"简书\"><a href=\"#简书\" class=\"headerlink\" title=\"简书\"></a>简书</h3><p>简书的消息系统主要分了两种</p>\n<ul>\n<li>简信</li>\n<li>提醒</li>\n</ul>\n<p><strong>简信</strong><br>简信的性质其实跟私信是一样的，是用户发送给用户的一则消息，有具体的信息内容。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/c3aad7dc-5914-4c5c-9f88-34e40077d0ff.jpg\" alt=\"简书简信\"></p>\n<p><strong>提醒</strong><br>而提醒，则是系统发送的一则消息，其文案格式是固定的，并且对特殊对象一般拥有超链接。<br><img src=\"http://xia-dev.b0.upaiyun.com/b0ee917e-0776-4aa9-bf4a-0a2cd33ca853.jpg\" alt=\"简书提醒\"></p>\n<h3 id=\"知乎\"><a href=\"#知乎\" class=\"headerlink\" title=\"知乎\"></a>知乎</h3><p>知乎跟简书一样，主要分了两种：</p>\n<ul>\n<li>私信</li>\n<li>消息</li>\n</ul>\n<p><strong>私信</strong><br>跟简书一样，使用户发送给用户的一则消息，也可以是管理员发送给用户的消息。<br><img src=\"http://xia-dev.b0.upaiyun.com/a6b102ed-d337-41d2-a5d3-b3923650de16.jpg\" width=250></img></p>\n<p><strong>消息</strong><br>知乎的消息比简书的提醒有过之而无不及，知乎会对多条相似的消息进行聚会，以达到减轻用户阅读压力的体验。<br><img src=\"http://xia-dev.b0.upaiyun.com/5f90952e-2fe6-447f-affb-8a7c9a04d0ab.jpg\" width=450></img></p>\n<h2 id=\"消息的三种分类\"><a href=\"#消息的三种分类\" class=\"headerlink\" title=\"消息的三种分类\"></a>消息的三种分类</h2><p>通过两种产品的简单分析，得出他们的消息有两种分类，在这基础上，我们再加上一种：公告。<br>公告的主要性质是系统发送一则含有具体内容的消息，站内所有用户都能读取到这条消息。<br>所以，消息有三种分类：</p>\n<ol>\n<li>公告 Announce</li>\n<li>提醒 Remind</li>\n<li>私信 Message</li>\n</ol>\n<h2 id=\"提醒的语言分析\"><a href=\"#提醒的语言分析\" class=\"headerlink\" title=\"提醒的语言分析\"></a>提醒的语言分析</h2><p>我们从简书取一组提醒样本：</p>\n<ul>\n<li>3dbe1bd90774 关注了你</li>\n<li>magicdawn 喜欢了你的文章 《单点登录的三种实现方式》</li>\n<li>无良程序 喜欢了你的文章 《基于RESTful API 怎么设计用户权限控制？》</li>\n<li>alexcc4 喜欢了你的文章 《在Nodejs中贯彻单元测试》</li>\n<li>你在《基于RESTful API 怎么设计用户权限控制？》中收到一条 cnlinjie 的评论</li>\n<li>你的文章《Session原理》已被加入专题 《ios开发》</li>\n</ul>\n<p>分析句子结构，提醒的内容无非就是</p>\n<blockquote>\n<p>「谁对一样属于谁的事物做了什么操作」<br>「someone do something in someone’s something」</p>\n</blockquote>\n<p>someone = 提醒的触发者，或者发送者，标记为sender<br>do something = 提醒的动作，评论、喜欢、关注都属于一个动作，标记为action<br>something = 提醒的动作作用对象，这就具体到是哪一篇文章，标记为target<br>someone’s = 提醒的动作作用对象的所有者，标记为targetOwner</p>\n<p>这就清楚了，sender和targetOwner就是网站的用户，而target是具体到哪一篇文章，如果提醒的对象不仅仅局限于文章，还有其他的话，就需要增加一项targetType，来标记目标是文章还是其他的什么。而action，则是固定的，整个网站会触发提醒的动作可能就只有那几样：评论、喜欢、关注…..（或者其他业务需要提醒的动作）</p>\n<h2 id=\"消息的两种获取方式\"><a href=\"#消息的两种获取方式\" class=\"headerlink\" title=\"消息的两种获取方式\"></a>消息的两种获取方式</h2><ul>\n<li>推 Push</li>\n<li>拉 Pull</li>\n</ul>\n<p><strong>以知乎为例</strong><br>推的比较常见，需要针对某一个问题维护着一张关注者的列表，每当触发这个问题推送的条件时（例如有人回答问题），就把这个通知发送给每个关注者。</p>\n<p>拉的相对麻烦一点，就是推的反向，例如每个用户都有一张关注问题的列表，每当用户上线的时候，对每个问题进行轮询，当问题的事件列表出现了比我原本时间戳大的信息就进行拉取。</p>\n<p><strong>而我们则根据消息的不同分类采用不同的获取方式</strong>：<br>通告和提醒，适合使用拉取的方式，消息产生之后，会存在消息表中，用户在某一特定的时间根据自己关注问题的表进行消息的拉取，然后添加到自己的消息队列中，</p>\n<p>信息，适合使用推的方式，在发送者建立一条信息之后，同时指定接收者，把消息添加到接收者的消息队列中。</p>\n<h2 id=\"订阅\"><a href=\"#订阅\" class=\"headerlink\" title=\"订阅\"></a>订阅</h2><p>根据提醒使用拉取的方式，需要维护一个关注某一事物的列表。<br>这种行为，我们称之为：<strong>「订阅」Subscribe </strong></p>\n<p><strong>一则订阅有以下三个核心属性</strong>：</p>\n<ul>\n<li>订阅的目标 target</li>\n<li>订阅的目标类型 targetType</li>\n<li>订阅的动作 action</li>\n</ul>\n<p>比如我发布了一篇文章，那么我会订阅文章《XXX》的评论动作，所以文章《XXX》每被人评论了，就需要发送一则提醒告知我。</p>\n<p><strong>订阅的规则还可以扩展</strong><br>我喜欢了一篇文章，和我发布了一篇文章，订阅的动作可能不一样。<br>喜欢了一篇文章，我希望我订阅这篇文章更新、评论的动作。<br>而发布了一篇文章，我希望我只是订阅这篇文章的评论动作。</p>\n<p>这时候就需要多一个参数：subscribReason<br>不同的subscribReason，对应着一个动作数组，<br>subscribReason = 喜欢，对应着 actions = [更新，评论]<br>subscribReason = 发布，对应着 actions = [评论]</p>\n<p><strong>订阅的规则还还可以扩展</strong><br>用户可能会有一个自己的订阅设置，比如对于所有的喜欢的动作，我都不希望接收。<br>比如Knewone的提醒设置<br><img src=\"http://xia-dev.b0.upaiyun.com/80cc4aaf-0568-478c-8513-b8821e57520f.jpg\" alt=\"Knewone提醒设置\" width=\"500\"></p>\n<p>所以我们需要再维护一个表：<strong>SubscriptionConfig</strong>，来存放用户的提醒设置。<br>并且，当用户没有提醒设置的时候，可以使用系统提供的一套默认设置：<strong>defaultSubscriptionConfig</strong></p>\n<h2 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h2><p>如果我发布了一篇文章《XXX》，在我不在线的时候，被评论了10遍，当我一上线的时候，应该是收到十条信息类似于：「谁谁谁评论了你的文章《XXX》」?<br>还是应该收到一条信息：「甲、乙、丙、丁…评论了你的文章《XXX》」?</p>\n<p>知乎在聚合上做的很优秀，要知道他们要实现这个还是挺有技术的：<br><a href=\"http://www.zhihu.com/question/22394809\">知乎的消息机制，在技术上如何设计与规划？</a><br><a href=\"http://www.zhihu.com/question/20380990/answer/14960006\">网站的消息（通知）系统一般是如何实现的？</a></p>\n<p>关于这部分功能，我们还没有具体的实现方法，暂时也无法讲得更加详细。⊙﹏⊙</p>\n<h2 id=\"五个实体\"><a href=\"#五个实体\" class=\"headerlink\" title=\"五个实体\"></a>五个实体</h2><p>通过上面的分析，大概知道做这个消息系统，需要哪些实体类：</p>\n<ol>\n<li>用户消息队列 UserNotify</li>\n<li>用户 User</li>\n<li>订阅 Subscription</li>\n<li>订阅设置 SubscriptionConfig</li>\n<li>消息 Notify<ul>\n<li>通告 Announce</li>\n<li>提醒 Remind</li>\n<li>信息 Message</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"行为分解\"><a href=\"#行为分解\" class=\"headerlink\" title=\"行为分解\"></a>行为分解</h2><p>说了这么多，整理一下整个消息流程的一些行为：</p>\n<ul>\n<li>系统或者管理员，创建消息 <ul>\n<li>createNotify (make announce | remind | message)</li>\n</ul>\n</li>\n<li>用户，订阅消息，取消订阅<ul>\n<li>subscribe, cancelSubscription</li>\n</ul>\n</li>\n<li>用户管理订阅设置<ul>\n<li>getSubscriptionConfig, updateSubscriptionConfig</li>\n</ul>\n</li>\n<li>用户，拉取消息<ul>\n<li>pullNotify (pull announce | remind | message | all)</li>\n</ul>\n</li>\n<li>用户，查询消息队列<ul>\n<li>getUserNotify(get announce | remind | message | all)</li>\n</ul>\n</li>\n<li>用户阅读消息<ul>\n<li>read</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>在本文的「下篇」我们来探讨一下：模型怎么做、数据库怎么设计、代码结构怎么来、一些逻辑上的时序图应该是怎么样的。</p>\n</blockquote>\n"},{"title":"消息系统设计与实现「下篇」","date":"2015-11-15T10:16:55.000Z","_content":"\n\n## 模型设计\n\n### Notify\n```javascript\nid\t\t\t: {type: 'integer', primaryKey: true},\t\t// 主键\ncontent     : {type: 'text'},\t// 消息的内容\ntype        : {type: 'integer', required: true, enum: [1, 2, 3]},  // 消息的类型，1: 公告 Announce，2: 提醒 Remind，3：信息 Message\ntarget      : {type: 'integer'},    // 目标的ID\ntargetType  : {type: 'string'},    // 目标的类型\naction      : {type: 'string'},    // 提醒信息的动作类型\nsender      : {type: 'integer'},    // 发送者的ID\ncreatedAt\t: {type: 'datetime', required: true}\n```\n\n**Save Remind**\n消息表，我们需要`target`、`targetType`字段，来记录该条提醒所关联的对象。而`action`字段，则记录该条提醒所关联的动作。\n比如消息：「小明喜欢了文章」\n则：\n```javascript\ntarget = 123,  // 文章ID\ntargetType = 'post',  // 指明target所属类型是文章\nsender = 123456  // 小明ID\n```\n\n**Save Announce and Message**\n当然，Notify还支持存储公告和信息。它们会用到`content`字段，而不会用到`target`、`targetType`、`action`字段。\n\n### UserNotify\n```javascript\nid\t\t\t: {type: 'integer', primaryKey: true},\t\t// 主键\nisRead      : {type: 'boolean', required: true},   \nuser        : {type: 'integer', required: true},  // 用户消息所属者\nnotify      : {type: 'integer', required: true}   // 关联的Notify\ncreatedAt\t: {type: 'datetime', required: true}\n```\n\n我们用UserNotify来存储用户的消息队列，它关联一则提醒(Notify)的具体内容。\nUserNotify的创建，主要通过两个途径：\n1. 遍历订阅(Subscription)表拉取公告(Announce)和提醒(Remind)的时候创建\n2. 新建信息(Message)之后，立刻创建。\n\n### Subscription\n```javascript\ntarget      : {type: 'integer', required: true},    // 目标的ID\ntargetType  : {type: 'string', required: true},    // 目标的类型\naction      : {type: 'string'},   // 订阅动作,如: comment/like/post/update etc.\nuser        : {type: 'integer'}，\ncreatedAt\t: {type: 'datetime', required: true}\n```\n订阅，是从Notify表拉取消息到UserNotify的前提，用户首先订阅了某一个目标的某一个动作，在此之后产生这个目标的这个动作的消息，才会被通知到该用户。\n如：「小明关注了产品A的评论」，数据表现为：\n```javascript\ntarget: 123,  // 产品A的ID\ntargetType: 'product',\naction: 'comment',\nuser: 123  // 小明的ID\n```\n这样，产品A下产生的每一条评论，都会产生通知给小明了。\n\n### SubscriptionConfig\n```javascript\naction: {type: 'json', required: true},   // 用户的设置\nuser: {type: 'integer'}\n```\n不同用户可能会有不一样的订阅习惯，在这个表中，用户可以统一针对某种动作进行是否订阅的设置。而默认是使用系统提供的默认配置：\n```javascript\ndefaultSubscriptionConfig: {\n  'comment'   : true,    // 评论\n  'like'      : true,    // 喜欢\n}\n```\n\n> 在这套模型中，`targetType`、`action`是可以根据需求来扩展的，例如我们还可以增加多几个动作的提醒：`hate`被踩、`update`被更新....诸如此类。\n\n## 配置文件 NotifyConfig\n```javascript\n// 提醒关联的目标类型\ntargetType: {\n  PRODUCT : 'product',    // 产品\n  POST    : 'post'    // 文章\n},\n\n// 提醒关联的动作\naction: {\n  COMMENT   : 'comment',  // 评论\n  LIKE      : 'like',     // 喜欢\n},\n\n// 订阅原因对应订阅事件\nreasonAction: {\n  'create_product'  : ['comment', 'like']\n  'like_product'    : ['comment'],\n  'like_post'       : ['comment'],\n},\n\n// 默认订阅配置\ndefaultSubscriptionConfig: {\n  'comment'   : true,    // 评论\n  'like'      : true,    // 喜欢\n}\n```\n\n## 服务层 NotifyService\n#### NotifyService拥有以下方法:\n* createAnnounce(content, sender)\n* createRemind(target, targetType, action, sender, content)\n* createMessage(content, sender, receiver)\n* pullAnnounce(user)\n* pullRemind(user)\n* subscribe(user, target, targetType, reason)\n* cancelSubscription(user, target ,targetType)\n* getSubscriptionConfig(userID)\n* updateSubscriptionConfig(userID)\n* getUserNotify(userID)\n* read(user, notifyIDs)\n\n#### 各方法的处理逻辑如下：\n**createAnnounce(content, sender)**\n1. 往Notify表中插入一条公告记录\n\n**createRemind(target, targetType, action, sender, content)**\n1. 往Notify表中插入一条提醒记录\n\n**createMessage(content, sender, receiver)**\n1. 往Notify表中插入一条信息记录\n2. 往UserNotify表中插入一条记录，并关联新建的Notify\n\n**pullAnnounce(user)**\n1. 从UserNotify中获取最近的一条公告信息的创建时间: `lastTime`\n2. 用`lastTime`作为过滤条件，查询Notify的公告信息\n3. 新建UserNotify并关联查询出来的公告信息\n\n**pullRemind(user)**\n1. 查询用户的订阅表，得到用户的一系列订阅记录\n2. 通过每一条的订阅记录的`target`、`targetType`、`action`、`createdAt`去查询Notify表，获取订阅的Notify记录。（注意订阅时间必须早于提醒创建时间）\n3. 查询用户的配置文件SubscriptionConfig，如果没有则使用默认的配置DefaultSubscriptionConfig\n4. 使用订阅配置，过滤查询出来的Notify\n5. 使用过滤好的Notify作为关联新建UserNotify\n\n**subscribe(user, target, targetType, reason)**\n1. 通过reason，查询NotifyConfig，获取对应的动作组:`actions`\n2. 遍历动作组，每一个动作新建一则Subscription记录\n\n**cancelSubscription(user, target ,targetType)**\n1. 删除`user`、`target`、`targetType`对应的一则或多则记录\n\n**getSubscriptionConfig(userID)**\n1. 查询SubscriptionConfig表，获取用户的订阅配置\n\n**updateSubscriptionConfig(userID)**\n1. 更新用户的SubscriptionConfig记录\n\n**getUserNotify(userID)**\n1. 获取用户的消息列表\n\n**read(user, notifyIDs)**\n1. 更新指定的notify，把isRead属性设置为true\n\n## 时序图\n### 提醒的订阅、创建、拉取\n![提醒的订阅、创建、拉取](//dn-cnode.qbox.me/FrvQvJn3YzSnYjlGTaBkhZ-PdZtZ)\n\n我们可以在产品创建之后，调用`NotifyService.subscribe`方法，\n然后在产品被评论之后调用`NotifyService.createRemind`方法，\n再就是用户登录系统或者其他的某一个时刻调用`NotifyService.pullRemind`方法，\n最后在用户查询消息队列的时候调用`NotifyService.getUserNotify`方法。\n\n\n### 公告的创建、拉取\n![公告的创建、拉取](//dn-cnode.qbox.me/FiTeODLU97C8VG6V-rRQwgZYS8ff)\n\n在管理员发送了一则公告的时候，调用`NotifyService.createAnnounce`方法，\n然后在用户登录系统或者其他的某一个时刻调用`NotifyService.pullAnnounce`方法，\n最后在用户查询消息队列的时候调用`NotifyService.getUserNotify`方法。\n\n### 信息的创建\n![信息的创建](//dn-cnode.qbox.me/Fjvq4egEZcMeoynkUUURWKgGP9KF)\n信息的创建，只需要直接调用`NotifyService.createMessage`方法就可以了，\n在下一次用户查询消息队列的时候，就会查询这条信息。\n","source":"_posts/消息系统设计与实现「下篇」.md","raw":"---\ntitle: 消息系统设计与实现「下篇」\ncategory: 搬砖码农\ndate: 2015-11-15 18:16:55\ntags:\n- 架构\n- 消息系统\n---\n\n\n## 模型设计\n\n### Notify\n```javascript\nid\t\t\t: {type: 'integer', primaryKey: true},\t\t// 主键\ncontent     : {type: 'text'},\t// 消息的内容\ntype        : {type: 'integer', required: true, enum: [1, 2, 3]},  // 消息的类型，1: 公告 Announce，2: 提醒 Remind，3：信息 Message\ntarget      : {type: 'integer'},    // 目标的ID\ntargetType  : {type: 'string'},    // 目标的类型\naction      : {type: 'string'},    // 提醒信息的动作类型\nsender      : {type: 'integer'},    // 发送者的ID\ncreatedAt\t: {type: 'datetime', required: true}\n```\n\n**Save Remind**\n消息表，我们需要`target`、`targetType`字段，来记录该条提醒所关联的对象。而`action`字段，则记录该条提醒所关联的动作。\n比如消息：「小明喜欢了文章」\n则：\n```javascript\ntarget = 123,  // 文章ID\ntargetType = 'post',  // 指明target所属类型是文章\nsender = 123456  // 小明ID\n```\n\n**Save Announce and Message**\n当然，Notify还支持存储公告和信息。它们会用到`content`字段，而不会用到`target`、`targetType`、`action`字段。\n\n### UserNotify\n```javascript\nid\t\t\t: {type: 'integer', primaryKey: true},\t\t// 主键\nisRead      : {type: 'boolean', required: true},   \nuser        : {type: 'integer', required: true},  // 用户消息所属者\nnotify      : {type: 'integer', required: true}   // 关联的Notify\ncreatedAt\t: {type: 'datetime', required: true}\n```\n\n我们用UserNotify来存储用户的消息队列，它关联一则提醒(Notify)的具体内容。\nUserNotify的创建，主要通过两个途径：\n1. 遍历订阅(Subscription)表拉取公告(Announce)和提醒(Remind)的时候创建\n2. 新建信息(Message)之后，立刻创建。\n\n### Subscription\n```javascript\ntarget      : {type: 'integer', required: true},    // 目标的ID\ntargetType  : {type: 'string', required: true},    // 目标的类型\naction      : {type: 'string'},   // 订阅动作,如: comment/like/post/update etc.\nuser        : {type: 'integer'}，\ncreatedAt\t: {type: 'datetime', required: true}\n```\n订阅，是从Notify表拉取消息到UserNotify的前提，用户首先订阅了某一个目标的某一个动作，在此之后产生这个目标的这个动作的消息，才会被通知到该用户。\n如：「小明关注了产品A的评论」，数据表现为：\n```javascript\ntarget: 123,  // 产品A的ID\ntargetType: 'product',\naction: 'comment',\nuser: 123  // 小明的ID\n```\n这样，产品A下产生的每一条评论，都会产生通知给小明了。\n\n### SubscriptionConfig\n```javascript\naction: {type: 'json', required: true},   // 用户的设置\nuser: {type: 'integer'}\n```\n不同用户可能会有不一样的订阅习惯，在这个表中，用户可以统一针对某种动作进行是否订阅的设置。而默认是使用系统提供的默认配置：\n```javascript\ndefaultSubscriptionConfig: {\n  'comment'   : true,    // 评论\n  'like'      : true,    // 喜欢\n}\n```\n\n> 在这套模型中，`targetType`、`action`是可以根据需求来扩展的，例如我们还可以增加多几个动作的提醒：`hate`被踩、`update`被更新....诸如此类。\n\n## 配置文件 NotifyConfig\n```javascript\n// 提醒关联的目标类型\ntargetType: {\n  PRODUCT : 'product',    // 产品\n  POST    : 'post'    // 文章\n},\n\n// 提醒关联的动作\naction: {\n  COMMENT   : 'comment',  // 评论\n  LIKE      : 'like',     // 喜欢\n},\n\n// 订阅原因对应订阅事件\nreasonAction: {\n  'create_product'  : ['comment', 'like']\n  'like_product'    : ['comment'],\n  'like_post'       : ['comment'],\n},\n\n// 默认订阅配置\ndefaultSubscriptionConfig: {\n  'comment'   : true,    // 评论\n  'like'      : true,    // 喜欢\n}\n```\n\n## 服务层 NotifyService\n#### NotifyService拥有以下方法:\n* createAnnounce(content, sender)\n* createRemind(target, targetType, action, sender, content)\n* createMessage(content, sender, receiver)\n* pullAnnounce(user)\n* pullRemind(user)\n* subscribe(user, target, targetType, reason)\n* cancelSubscription(user, target ,targetType)\n* getSubscriptionConfig(userID)\n* updateSubscriptionConfig(userID)\n* getUserNotify(userID)\n* read(user, notifyIDs)\n\n#### 各方法的处理逻辑如下：\n**createAnnounce(content, sender)**\n1. 往Notify表中插入一条公告记录\n\n**createRemind(target, targetType, action, sender, content)**\n1. 往Notify表中插入一条提醒记录\n\n**createMessage(content, sender, receiver)**\n1. 往Notify表中插入一条信息记录\n2. 往UserNotify表中插入一条记录，并关联新建的Notify\n\n**pullAnnounce(user)**\n1. 从UserNotify中获取最近的一条公告信息的创建时间: `lastTime`\n2. 用`lastTime`作为过滤条件，查询Notify的公告信息\n3. 新建UserNotify并关联查询出来的公告信息\n\n**pullRemind(user)**\n1. 查询用户的订阅表，得到用户的一系列订阅记录\n2. 通过每一条的订阅记录的`target`、`targetType`、`action`、`createdAt`去查询Notify表，获取订阅的Notify记录。（注意订阅时间必须早于提醒创建时间）\n3. 查询用户的配置文件SubscriptionConfig，如果没有则使用默认的配置DefaultSubscriptionConfig\n4. 使用订阅配置，过滤查询出来的Notify\n5. 使用过滤好的Notify作为关联新建UserNotify\n\n**subscribe(user, target, targetType, reason)**\n1. 通过reason，查询NotifyConfig，获取对应的动作组:`actions`\n2. 遍历动作组，每一个动作新建一则Subscription记录\n\n**cancelSubscription(user, target ,targetType)**\n1. 删除`user`、`target`、`targetType`对应的一则或多则记录\n\n**getSubscriptionConfig(userID)**\n1. 查询SubscriptionConfig表，获取用户的订阅配置\n\n**updateSubscriptionConfig(userID)**\n1. 更新用户的SubscriptionConfig记录\n\n**getUserNotify(userID)**\n1. 获取用户的消息列表\n\n**read(user, notifyIDs)**\n1. 更新指定的notify，把isRead属性设置为true\n\n## 时序图\n### 提醒的订阅、创建、拉取\n![提醒的订阅、创建、拉取](//dn-cnode.qbox.me/FrvQvJn3YzSnYjlGTaBkhZ-PdZtZ)\n\n我们可以在产品创建之后，调用`NotifyService.subscribe`方法，\n然后在产品被评论之后调用`NotifyService.createRemind`方法，\n再就是用户登录系统或者其他的某一个时刻调用`NotifyService.pullRemind`方法，\n最后在用户查询消息队列的时候调用`NotifyService.getUserNotify`方法。\n\n\n### 公告的创建、拉取\n![公告的创建、拉取](//dn-cnode.qbox.me/FiTeODLU97C8VG6V-rRQwgZYS8ff)\n\n在管理员发送了一则公告的时候，调用`NotifyService.createAnnounce`方法，\n然后在用户登录系统或者其他的某一个时刻调用`NotifyService.pullAnnounce`方法，\n最后在用户查询消息队列的时候调用`NotifyService.getUserNotify`方法。\n\n### 信息的创建\n![信息的创建](//dn-cnode.qbox.me/Fjvq4egEZcMeoynkUUURWKgGP9KF)\n信息的创建，只需要直接调用`NotifyService.createMessage`方法就可以了，\n在下一次用户查询消息队列的时候，就会查询这条信息。\n","slug":"消息系统设计与实现「下篇」","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqq002w15hldmzugqsv","content":"<h2 id=\"模型设计\"><a href=\"#模型设计\" class=\"headerlink\" title=\"模型设计\"></a>模型设计</h2><h3 id=\"Notify\"><a href=\"#Notify\" class=\"headerlink\" title=\"Notify\"></a>Notify</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">id\t\t\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">primaryKey</span>: <span class=\"literal\">true</span>&#125;,\t\t<span class=\"comment\">// 主键</span></div><div class=\"line\">content     : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'text'</span>&#125;,\t<span class=\"comment\">// 消息的内容</span></div><div class=\"line\">type        : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>, <span class=\"attr\">enum</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]&#125;,  <span class=\"comment\">// 消息的类型，1: 公告 Announce，2: 提醒 Remind，3：信息 Message</span></div><div class=\"line\">target      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;,    <span class=\"comment\">// 目标的ID</span></div><div class=\"line\">targetType  : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>&#125;,    <span class=\"comment\">// 目标的类型</span></div><div class=\"line\">action      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>&#125;,    <span class=\"comment\">// 提醒信息的动作类型</span></div><div class=\"line\">sender      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;,    <span class=\"comment\">// 发送者的ID</span></div><div class=\"line\">createdAt\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'datetime'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;</div></pre></td></tr></table></figure>\n<p><strong>Save Remind</strong><br>消息表，我们需要<code>target</code>、<code>targetType</code>字段，来记录该条提醒所关联的对象。而<code>action</code>字段，则记录该条提醒所关联的动作。<br>比如消息：「小明喜欢了文章」<br>则：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">target = <span class=\"number\">123</span>,  <span class=\"comment\">// 文章ID</span></div><div class=\"line\">targetType = <span class=\"string\">'post'</span>,  <span class=\"comment\">// 指明target所属类型是文章</span></div><div class=\"line\">sender = <span class=\"number\">123456</span>  <span class=\"comment\">// 小明ID</span></div></pre></td></tr></table></figure></p>\n<p><strong>Save Announce and Message</strong><br>当然，Notify还支持存储公告和信息。它们会用到<code>content</code>字段，而不会用到<code>target</code>、<code>targetType</code>、<code>action</code>字段。</p>\n<h3 id=\"UserNotify\"><a href=\"#UserNotify\" class=\"headerlink\" title=\"UserNotify\"></a>UserNotify</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">id\t\t\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">primaryKey</span>: <span class=\"literal\">true</span>&#125;,\t\t<span class=\"comment\">// 主键</span></div><div class=\"line\">isRead      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'boolean'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,   </div><div class=\"line\"><span class=\"attr\">user</span>        : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,  <span class=\"comment\">// 用户消息所属者</span></div><div class=\"line\">notify      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;   <span class=\"comment\">// 关联的Notify</span></div><div class=\"line\">createdAt\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'datetime'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;</div></pre></td></tr></table></figure>\n<p>我们用UserNotify来存储用户的消息队列，它关联一则提醒(Notify)的具体内容。<br>UserNotify的创建，主要通过两个途径：</p>\n<ol>\n<li>遍历订阅(Subscription)表拉取公告(Announce)和提醒(Remind)的时候创建</li>\n<li>新建信息(Message)之后，立刻创建。</li>\n</ol>\n<h3 id=\"Subscription\"><a href=\"#Subscription\" class=\"headerlink\" title=\"Subscription\"></a>Subscription</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">target      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,    <span class=\"comment\">// 目标的ID</span></div><div class=\"line\">targetType  : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,    <span class=\"comment\">// 目标的类型</span></div><div class=\"line\">action      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>&#125;,   <span class=\"comment\">// 订阅动作,如: comment/like/post/update etc.</span></div><div class=\"line\">user        : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;，</div><div class=\"line\">createdAt\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'datetime'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;</div></pre></td></tr></table></figure>\n<p>订阅，是从Notify表拉取消息到UserNotify的前提，用户首先订阅了某一个目标的某一个动作，在此之后产生这个目标的这个动作的消息，才会被通知到该用户。<br>如：「小明关注了产品A的评论」，数据表现为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">target: <span class=\"number\">123</span>,  <span class=\"comment\">// 产品A的ID</span></div><div class=\"line\">targetType: <span class=\"string\">'product'</span>,</div><div class=\"line\"><span class=\"attr\">action</span>: <span class=\"string\">'comment'</span>,</div><div class=\"line\"><span class=\"attr\">user</span>: <span class=\"number\">123</span>  <span class=\"comment\">// 小明的ID</span></div></pre></td></tr></table></figure></p>\n<p>这样，产品A下产生的每一条评论，都会产生通知给小明了。</p>\n<h3 id=\"SubscriptionConfig\"><a href=\"#SubscriptionConfig\" class=\"headerlink\" title=\"SubscriptionConfig\"></a>SubscriptionConfig</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">action: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'json'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,   <span class=\"comment\">// 用户的设置</span></div><div class=\"line\">user: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;</div></pre></td></tr></table></figure>\n<p>不同用户可能会有不一样的订阅习惯，在这个表中，用户可以统一针对某种动作进行是否订阅的设置。而默认是使用系统提供的默认配置：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">defaultSubscriptionConfig: &#123;</div><div class=\"line\">  <span class=\"string\">'comment'</span>   : <span class=\"literal\">true</span>,    <span class=\"comment\">// 评论</span></div><div class=\"line\">  <span class=\"string\">'like'</span>      : <span class=\"literal\">true</span>,    <span class=\"comment\">// 喜欢</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在这套模型中，<code>targetType</code>、<code>action</code>是可以根据需求来扩展的，例如我们还可以增加多几个动作的提醒：<code>hate</code>被踩、<code>update</code>被更新….诸如此类。</p>\n</blockquote>\n<h2 id=\"配置文件-NotifyConfig\"><a href=\"#配置文件-NotifyConfig\" class=\"headerlink\" title=\"配置文件 NotifyConfig\"></a>配置文件 NotifyConfig</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 提醒关联的目标类型</span></div><div class=\"line\">targetType: &#123;</div><div class=\"line\">  <span class=\"attr\">PRODUCT</span> : <span class=\"string\">'product'</span>,    <span class=\"comment\">// 产品</span></div><div class=\"line\">  POST    : <span class=\"string\">'post'</span>    <span class=\"comment\">// 文章</span></div><div class=\"line\">&#125;,</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 提醒关联的动作</span></div><div class=\"line\">action: &#123;</div><div class=\"line\">  <span class=\"attr\">COMMENT</span>   : <span class=\"string\">'comment'</span>,  <span class=\"comment\">// 评论</span></div><div class=\"line\">  LIKE      : <span class=\"string\">'like'</span>,     <span class=\"comment\">// 喜欢</span></div><div class=\"line\">&#125;,</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 订阅原因对应订阅事件</span></div><div class=\"line\">reasonAction: &#123;</div><div class=\"line\">  <span class=\"string\">'create_product'</span>  : [<span class=\"string\">'comment'</span>, <span class=\"string\">'like'</span>]</div><div class=\"line\">  <span class=\"string\">'like_product'</span>    : [<span class=\"string\">'comment'</span>],</div><div class=\"line\">  <span class=\"string\">'like_post'</span>       : [<span class=\"string\">'comment'</span>],</div><div class=\"line\">&#125;,</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 默认订阅配置</span></div><div class=\"line\">defaultSubscriptionConfig: &#123;</div><div class=\"line\">  <span class=\"string\">'comment'</span>   : <span class=\"literal\">true</span>,    <span class=\"comment\">// 评论</span></div><div class=\"line\">  <span class=\"string\">'like'</span>      : <span class=\"literal\">true</span>,    <span class=\"comment\">// 喜欢</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"服务层-NotifyService\"><a href=\"#服务层-NotifyService\" class=\"headerlink\" title=\"服务层 NotifyService\"></a>服务层 NotifyService</h2><h4 id=\"NotifyService拥有以下方法\"><a href=\"#NotifyService拥有以下方法\" class=\"headerlink\" title=\"NotifyService拥有以下方法:\"></a>NotifyService拥有以下方法:</h4><ul>\n<li>createAnnounce(content, sender)</li>\n<li>createRemind(target, targetType, action, sender, content)</li>\n<li>createMessage(content, sender, receiver)</li>\n<li>pullAnnounce(user)</li>\n<li>pullRemind(user)</li>\n<li>subscribe(user, target, targetType, reason)</li>\n<li>cancelSubscription(user, target ,targetType)</li>\n<li>getSubscriptionConfig(userID)</li>\n<li>updateSubscriptionConfig(userID)</li>\n<li>getUserNotify(userID)</li>\n<li>read(user, notifyIDs)</li>\n</ul>\n<h4 id=\"各方法的处理逻辑如下：\"><a href=\"#各方法的处理逻辑如下：\" class=\"headerlink\" title=\"各方法的处理逻辑如下：\"></a>各方法的处理逻辑如下：</h4><p><strong>createAnnounce(content, sender)</strong></p>\n<ol>\n<li>往Notify表中插入一条公告记录</li>\n</ol>\n<p><strong>createRemind(target, targetType, action, sender, content)</strong></p>\n<ol>\n<li>往Notify表中插入一条提醒记录</li>\n</ol>\n<p><strong>createMessage(content, sender, receiver)</strong></p>\n<ol>\n<li>往Notify表中插入一条信息记录</li>\n<li>往UserNotify表中插入一条记录，并关联新建的Notify</li>\n</ol>\n<p><strong>pullAnnounce(user)</strong></p>\n<ol>\n<li>从UserNotify中获取最近的一条公告信息的创建时间: <code>lastTime</code></li>\n<li>用<code>lastTime</code>作为过滤条件，查询Notify的公告信息</li>\n<li>新建UserNotify并关联查询出来的公告信息</li>\n</ol>\n<p><strong>pullRemind(user)</strong></p>\n<ol>\n<li>查询用户的订阅表，得到用户的一系列订阅记录</li>\n<li>通过每一条的订阅记录的<code>target</code>、<code>targetType</code>、<code>action</code>、<code>createdAt</code>去查询Notify表，获取订阅的Notify记录。（注意订阅时间必须早于提醒创建时间）</li>\n<li>查询用户的配置文件SubscriptionConfig，如果没有则使用默认的配置DefaultSubscriptionConfig</li>\n<li>使用订阅配置，过滤查询出来的Notify</li>\n<li>使用过滤好的Notify作为关联新建UserNotify</li>\n</ol>\n<p><strong>subscribe(user, target, targetType, reason)</strong></p>\n<ol>\n<li>通过reason，查询NotifyConfig，获取对应的动作组:<code>actions</code></li>\n<li>遍历动作组，每一个动作新建一则Subscription记录</li>\n</ol>\n<p><strong>cancelSubscription(user, target ,targetType)</strong></p>\n<ol>\n<li>删除<code>user</code>、<code>target</code>、<code>targetType</code>对应的一则或多则记录</li>\n</ol>\n<p><strong>getSubscriptionConfig(userID)</strong></p>\n<ol>\n<li>查询SubscriptionConfig表，获取用户的订阅配置</li>\n</ol>\n<p><strong>updateSubscriptionConfig(userID)</strong></p>\n<ol>\n<li>更新用户的SubscriptionConfig记录</li>\n</ol>\n<p><strong>getUserNotify(userID)</strong></p>\n<ol>\n<li>获取用户的消息列表</li>\n</ol>\n<p><strong>read(user, notifyIDs)</strong></p>\n<ol>\n<li>更新指定的notify，把isRead属性设置为true</li>\n</ol>\n<h2 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h2><h3 id=\"提醒的订阅、创建、拉取\"><a href=\"#提醒的订阅、创建、拉取\" class=\"headerlink\" title=\"提醒的订阅、创建、拉取\"></a>提醒的订阅、创建、拉取</h3><p><img src=\"//dn-cnode.qbox.me/FrvQvJn3YzSnYjlGTaBkhZ-PdZtZ\" alt=\"提醒的订阅、创建、拉取\"></p>\n<p>我们可以在产品创建之后，调用<code>NotifyService.subscribe</code>方法，<br>然后在产品被评论之后调用<code>NotifyService.createRemind</code>方法，<br>再就是用户登录系统或者其他的某一个时刻调用<code>NotifyService.pullRemind</code>方法，<br>最后在用户查询消息队列的时候调用<code>NotifyService.getUserNotify</code>方法。</p>\n<h3 id=\"公告的创建、拉取\"><a href=\"#公告的创建、拉取\" class=\"headerlink\" title=\"公告的创建、拉取\"></a>公告的创建、拉取</h3><p><img src=\"//dn-cnode.qbox.me/FiTeODLU97C8VG6V-rRQwgZYS8ff\" alt=\"公告的创建、拉取\"></p>\n<p>在管理员发送了一则公告的时候，调用<code>NotifyService.createAnnounce</code>方法，<br>然后在用户登录系统或者其他的某一个时刻调用<code>NotifyService.pullAnnounce</code>方法，<br>最后在用户查询消息队列的时候调用<code>NotifyService.getUserNotify</code>方法。</p>\n<h3 id=\"信息的创建\"><a href=\"#信息的创建\" class=\"headerlink\" title=\"信息的创建\"></a>信息的创建</h3><p><img src=\"//dn-cnode.qbox.me/Fjvq4egEZcMeoynkUUURWKgGP9KF\" alt=\"信息的创建\"><br>信息的创建，只需要直接调用<code>NotifyService.createMessage</code>方法就可以了，<br>在下一次用户查询消息队列的时候，就会查询这条信息。</p>\n","excerpt":"","more":"<h2 id=\"模型设计\"><a href=\"#模型设计\" class=\"headerlink\" title=\"模型设计\"></a>模型设计</h2><h3 id=\"Notify\"><a href=\"#Notify\" class=\"headerlink\" title=\"Notify\"></a>Notify</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">id\t\t\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">primaryKey</span>: <span class=\"literal\">true</span>&#125;,\t\t<span class=\"comment\">// 主键</span></div><div class=\"line\">content     : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'text'</span>&#125;,\t<span class=\"comment\">// 消息的内容</span></div><div class=\"line\">type        : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>, <span class=\"attr\">enum</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]&#125;,  <span class=\"comment\">// 消息的类型，1: 公告 Announce，2: 提醒 Remind，3：信息 Message</span></div><div class=\"line\">target      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;,    <span class=\"comment\">// 目标的ID</span></div><div class=\"line\">targetType  : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>&#125;,    <span class=\"comment\">// 目标的类型</span></div><div class=\"line\">action      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>&#125;,    <span class=\"comment\">// 提醒信息的动作类型</span></div><div class=\"line\">sender      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;,    <span class=\"comment\">// 发送者的ID</span></div><div class=\"line\">createdAt\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'datetime'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;</div></pre></td></tr></table></figure>\n<p><strong>Save Remind</strong><br>消息表，我们需要<code>target</code>、<code>targetType</code>字段，来记录该条提醒所关联的对象。而<code>action</code>字段，则记录该条提醒所关联的动作。<br>比如消息：「小明喜欢了文章」<br>则：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">target = <span class=\"number\">123</span>,  <span class=\"comment\">// 文章ID</span></div><div class=\"line\">targetType = <span class=\"string\">'post'</span>,  <span class=\"comment\">// 指明target所属类型是文章</span></div><div class=\"line\">sender = <span class=\"number\">123456</span>  <span class=\"comment\">// 小明ID</span></div></pre></td></tr></table></figure></p>\n<p><strong>Save Announce and Message</strong><br>当然，Notify还支持存储公告和信息。它们会用到<code>content</code>字段，而不会用到<code>target</code>、<code>targetType</code>、<code>action</code>字段。</p>\n<h3 id=\"UserNotify\"><a href=\"#UserNotify\" class=\"headerlink\" title=\"UserNotify\"></a>UserNotify</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">id\t\t\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">primaryKey</span>: <span class=\"literal\">true</span>&#125;,\t\t<span class=\"comment\">// 主键</span></div><div class=\"line\">isRead      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'boolean'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,   </div><div class=\"line\"><span class=\"attr\">user</span>        : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,  <span class=\"comment\">// 用户消息所属者</span></div><div class=\"line\">notify      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;   <span class=\"comment\">// 关联的Notify</span></div><div class=\"line\">createdAt\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'datetime'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;</div></pre></td></tr></table></figure>\n<p>我们用UserNotify来存储用户的消息队列，它关联一则提醒(Notify)的具体内容。<br>UserNotify的创建，主要通过两个途径：</p>\n<ol>\n<li>遍历订阅(Subscription)表拉取公告(Announce)和提醒(Remind)的时候创建</li>\n<li>新建信息(Message)之后，立刻创建。</li>\n</ol>\n<h3 id=\"Subscription\"><a href=\"#Subscription\" class=\"headerlink\" title=\"Subscription\"></a>Subscription</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">target      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,    <span class=\"comment\">// 目标的ID</span></div><div class=\"line\">targetType  : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,    <span class=\"comment\">// 目标的类型</span></div><div class=\"line\">action      : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'string'</span>&#125;,   <span class=\"comment\">// 订阅动作,如: comment/like/post/update etc.</span></div><div class=\"line\">user        : &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;，</div><div class=\"line\">createdAt\t: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'datetime'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;</div></pre></td></tr></table></figure>\n<p>订阅，是从Notify表拉取消息到UserNotify的前提，用户首先订阅了某一个目标的某一个动作，在此之后产生这个目标的这个动作的消息，才会被通知到该用户。<br>如：「小明关注了产品A的评论」，数据表现为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">target: <span class=\"number\">123</span>,  <span class=\"comment\">// 产品A的ID</span></div><div class=\"line\">targetType: <span class=\"string\">'product'</span>,</div><div class=\"line\"><span class=\"attr\">action</span>: <span class=\"string\">'comment'</span>,</div><div class=\"line\"><span class=\"attr\">user</span>: <span class=\"number\">123</span>  <span class=\"comment\">// 小明的ID</span></div></pre></td></tr></table></figure></p>\n<p>这样，产品A下产生的每一条评论，都会产生通知给小明了。</p>\n<h3 id=\"SubscriptionConfig\"><a href=\"#SubscriptionConfig\" class=\"headerlink\" title=\"SubscriptionConfig\"></a>SubscriptionConfig</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">action: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'json'</span>, <span class=\"attr\">required</span>: <span class=\"literal\">true</span>&#125;,   <span class=\"comment\">// 用户的设置</span></div><div class=\"line\">user: &#123;<span class=\"attr\">type</span>: <span class=\"string\">'integer'</span>&#125;</div></pre></td></tr></table></figure>\n<p>不同用户可能会有不一样的订阅习惯，在这个表中，用户可以统一针对某种动作进行是否订阅的设置。而默认是使用系统提供的默认配置：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">defaultSubscriptionConfig: &#123;</div><div class=\"line\">  <span class=\"string\">'comment'</span>   : <span class=\"literal\">true</span>,    <span class=\"comment\">// 评论</span></div><div class=\"line\">  <span class=\"string\">'like'</span>      : <span class=\"literal\">true</span>,    <span class=\"comment\">// 喜欢</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在这套模型中，<code>targetType</code>、<code>action</code>是可以根据需求来扩展的，例如我们还可以增加多几个动作的提醒：<code>hate</code>被踩、<code>update</code>被更新….诸如此类。</p>\n</blockquote>\n<h2 id=\"配置文件-NotifyConfig\"><a href=\"#配置文件-NotifyConfig\" class=\"headerlink\" title=\"配置文件 NotifyConfig\"></a>配置文件 NotifyConfig</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 提醒关联的目标类型</span></div><div class=\"line\">targetType: &#123;</div><div class=\"line\">  <span class=\"attr\">PRODUCT</span> : <span class=\"string\">'product'</span>,    <span class=\"comment\">// 产品</span></div><div class=\"line\">  POST    : <span class=\"string\">'post'</span>    <span class=\"comment\">// 文章</span></div><div class=\"line\">&#125;,</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 提醒关联的动作</span></div><div class=\"line\">action: &#123;</div><div class=\"line\">  <span class=\"attr\">COMMENT</span>   : <span class=\"string\">'comment'</span>,  <span class=\"comment\">// 评论</span></div><div class=\"line\">  LIKE      : <span class=\"string\">'like'</span>,     <span class=\"comment\">// 喜欢</span></div><div class=\"line\">&#125;,</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 订阅原因对应订阅事件</span></div><div class=\"line\">reasonAction: &#123;</div><div class=\"line\">  <span class=\"string\">'create_product'</span>  : [<span class=\"string\">'comment'</span>, <span class=\"string\">'like'</span>]</div><div class=\"line\">  <span class=\"string\">'like_product'</span>    : [<span class=\"string\">'comment'</span>],</div><div class=\"line\">  <span class=\"string\">'like_post'</span>       : [<span class=\"string\">'comment'</span>],</div><div class=\"line\">&#125;,</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 默认订阅配置</span></div><div class=\"line\">defaultSubscriptionConfig: &#123;</div><div class=\"line\">  <span class=\"string\">'comment'</span>   : <span class=\"literal\">true</span>,    <span class=\"comment\">// 评论</span></div><div class=\"line\">  <span class=\"string\">'like'</span>      : <span class=\"literal\">true</span>,    <span class=\"comment\">// 喜欢</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"服务层-NotifyService\"><a href=\"#服务层-NotifyService\" class=\"headerlink\" title=\"服务层 NotifyService\"></a>服务层 NotifyService</h2><h4 id=\"NotifyService拥有以下方法\"><a href=\"#NotifyService拥有以下方法\" class=\"headerlink\" title=\"NotifyService拥有以下方法:\"></a>NotifyService拥有以下方法:</h4><ul>\n<li>createAnnounce(content, sender)</li>\n<li>createRemind(target, targetType, action, sender, content)</li>\n<li>createMessage(content, sender, receiver)</li>\n<li>pullAnnounce(user)</li>\n<li>pullRemind(user)</li>\n<li>subscribe(user, target, targetType, reason)</li>\n<li>cancelSubscription(user, target ,targetType)</li>\n<li>getSubscriptionConfig(userID)</li>\n<li>updateSubscriptionConfig(userID)</li>\n<li>getUserNotify(userID)</li>\n<li>read(user, notifyIDs)</li>\n</ul>\n<h4 id=\"各方法的处理逻辑如下：\"><a href=\"#各方法的处理逻辑如下：\" class=\"headerlink\" title=\"各方法的处理逻辑如下：\"></a>各方法的处理逻辑如下：</h4><p><strong>createAnnounce(content, sender)</strong></p>\n<ol>\n<li>往Notify表中插入一条公告记录</li>\n</ol>\n<p><strong>createRemind(target, targetType, action, sender, content)</strong></p>\n<ol>\n<li>往Notify表中插入一条提醒记录</li>\n</ol>\n<p><strong>createMessage(content, sender, receiver)</strong></p>\n<ol>\n<li>往Notify表中插入一条信息记录</li>\n<li>往UserNotify表中插入一条记录，并关联新建的Notify</li>\n</ol>\n<p><strong>pullAnnounce(user)</strong></p>\n<ol>\n<li>从UserNotify中获取最近的一条公告信息的创建时间: <code>lastTime</code></li>\n<li>用<code>lastTime</code>作为过滤条件，查询Notify的公告信息</li>\n<li>新建UserNotify并关联查询出来的公告信息</li>\n</ol>\n<p><strong>pullRemind(user)</strong></p>\n<ol>\n<li>查询用户的订阅表，得到用户的一系列订阅记录</li>\n<li>通过每一条的订阅记录的<code>target</code>、<code>targetType</code>、<code>action</code>、<code>createdAt</code>去查询Notify表，获取订阅的Notify记录。（注意订阅时间必须早于提醒创建时间）</li>\n<li>查询用户的配置文件SubscriptionConfig，如果没有则使用默认的配置DefaultSubscriptionConfig</li>\n<li>使用订阅配置，过滤查询出来的Notify</li>\n<li>使用过滤好的Notify作为关联新建UserNotify</li>\n</ol>\n<p><strong>subscribe(user, target, targetType, reason)</strong></p>\n<ol>\n<li>通过reason，查询NotifyConfig，获取对应的动作组:<code>actions</code></li>\n<li>遍历动作组，每一个动作新建一则Subscription记录</li>\n</ol>\n<p><strong>cancelSubscription(user, target ,targetType)</strong></p>\n<ol>\n<li>删除<code>user</code>、<code>target</code>、<code>targetType</code>对应的一则或多则记录</li>\n</ol>\n<p><strong>getSubscriptionConfig(userID)</strong></p>\n<ol>\n<li>查询SubscriptionConfig表，获取用户的订阅配置</li>\n</ol>\n<p><strong>updateSubscriptionConfig(userID)</strong></p>\n<ol>\n<li>更新用户的SubscriptionConfig记录</li>\n</ol>\n<p><strong>getUserNotify(userID)</strong></p>\n<ol>\n<li>获取用户的消息列表</li>\n</ol>\n<p><strong>read(user, notifyIDs)</strong></p>\n<ol>\n<li>更新指定的notify，把isRead属性设置为true</li>\n</ol>\n<h2 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h2><h3 id=\"提醒的订阅、创建、拉取\"><a href=\"#提醒的订阅、创建、拉取\" class=\"headerlink\" title=\"提醒的订阅、创建、拉取\"></a>提醒的订阅、创建、拉取</h3><p><img src=\"//dn-cnode.qbox.me/FrvQvJn3YzSnYjlGTaBkhZ-PdZtZ\" alt=\"提醒的订阅、创建、拉取\"></p>\n<p>我们可以在产品创建之后，调用<code>NotifyService.subscribe</code>方法，<br>然后在产品被评论之后调用<code>NotifyService.createRemind</code>方法，<br>再就是用户登录系统或者其他的某一个时刻调用<code>NotifyService.pullRemind</code>方法，<br>最后在用户查询消息队列的时候调用<code>NotifyService.getUserNotify</code>方法。</p>\n<h3 id=\"公告的创建、拉取\"><a href=\"#公告的创建、拉取\" class=\"headerlink\" title=\"公告的创建、拉取\"></a>公告的创建、拉取</h3><p><img src=\"//dn-cnode.qbox.me/FiTeODLU97C8VG6V-rRQwgZYS8ff\" alt=\"公告的创建、拉取\"></p>\n<p>在管理员发送了一则公告的时候，调用<code>NotifyService.createAnnounce</code>方法，<br>然后在用户登录系统或者其他的某一个时刻调用<code>NotifyService.pullAnnounce</code>方法，<br>最后在用户查询消息队列的时候调用<code>NotifyService.getUserNotify</code>方法。</p>\n<h3 id=\"信息的创建\"><a href=\"#信息的创建\" class=\"headerlink\" title=\"信息的创建\"></a>信息的创建</h3><p><img src=\"//dn-cnode.qbox.me/Fjvq4egEZcMeoynkUUURWKgGP9KF\" alt=\"信息的创建\"><br>信息的创建，只需要直接调用<code>NotifyService.createMessage</code>方法就可以了，<br>在下一次用户查询消息队列的时候，就会查询这条信息。</p>\n"},{"title":"盘点国内的那些ROM","date":"2015-03-03T11:21:12.000Z","_content":"\n## 前言\n\n最近新闻比较多，阿里入股魅族的消息除了轰动之余，不免会让人回想起去年的Flyme Powered by YunOS。腾讯推出的TOS，也会使人想起那年昙花一现的tita。一加公布其自主ROM正式改名OxygenOS的消息，也让人好奇刘作虎的下一步棋。\n百度的\"百度云OS\"、阿里的\"YunOS\"、腾讯的\"TOS\"、魅族的“FLymeOS”、小米的“MIUI”、锤子的“SmartisanOS”还有一加的“OxygenOS”等等，让人有一种在Android市场下欣欣向荣、百花齐放、百家争鸣的感觉。拥有一个自家的ROM，貌似成为了争夺移动互联网之战的入场券。我们不妨来看一下国内Android市场的那些你听过的没听过，用过没用过的那些ROM。\n\n## BAT巨头\n\n### 百度：百度云OS\n\n![](http://xia-dev.b0.upaiyun.com/463ff1a5-b814-485a-96f0-cf98439250f3.jpg)\n\n百度在2012年6月推出了基于Android进行开发的百度云OS。2013年战略投资过100+爱奇艺手机，在手机上内置百度云OS，并将旗下收购的爱奇艺视频业务整合到手机系统。近日，又传出消息称百度入股联想神奇工场。百度云OS适配机型众多，目前在“刷机党”中已有一定认知度和口碑。\n\n### 阿里：YunOS\n\n![](http://xia-dev.b0.upaiyun.com/8d2b6d92-5ef4-4662-85c5-f32d2bed93c7.jpg)\n\n2011年7月28日，阿里巴巴集团旗下阿里云计算有限公司在北京召开新闻发布会，正式推出了阿里云OS。根据阿里云公司官方的说法，阿里云OS是一个独立于Android之外，自助研发的独立操作系统，底层核心一样是用的Linux内核。但虚拟机却不是用Android的Dalvik虚拟机，而是阿里云自家的虚拟机。但是阿里没有把原始代码公布的做法，受到了开源信奉者的Linux以及Android的排挤，以至于发展道路坎坷。\n\n### 腾讯：TOS\n\n2015年2月10日，TencentOS官方微博发布内侧招募通知。TOS究竟是一种什么样性质的系统呢？腾讯没说。是真正的自主研发，还是安卓阵营中的一名新兵，还是改头换面式的“伪原创”，在它没有正式发售之前，我们还不得而知，所以我们只能猜测。曾经，腾讯有过一款名为Tita的产品，但最后“无疾而终”。有趣的是，TOS内侧招募和阿里入股魅族的日子只差了一天。\n\n## 手机厂商的软硬件结合之路\n\n### 魅族：FlymeOS\n\n![](http://xia-dev.b0.upaiyun.com/91b3008a-9be4-406c-aa31-f32a31551d54.png)\n\nFlyme OS是魅族公司基于Android系统深度定制的手机操作系统。在2012年6月，魅族旗下的手机操作系统正式改名为\"Flyme OS\"，而在此之前魅族有分别有基于WindowsCE内核以及Android自主研发的手机操作系统，但没有对外公布正式的名字，当然，那时也只是适配自家手机。不过，到目前为止，FlymeOS已经能适配HTC、三星、索尼、LG等品牌的手机了。其优秀的设计，也使魅族拥有了相当可观的粉丝群。\n\n### 中兴：MiFavor\n\n![](http://xia-dev.b0.upaiyun.com/c0e4bc32-0bf5-4c64-ba4a-2885d0ff9082.jpg)\n\n自2011年8月MiFavor v1.0发布以来，经过多次迭代，到目前为止已经是v3.0了，但是适配机型只是旗下的星星1号和天机。从这方面来看，中兴旗下有不少型号的手机，却没有配备自家的ROM，确实不太能够捕获人心。\n\n### OPPO：ColorOS\n\n![](http://xia-dev.b0.upaiyun.com/19fff263-7919-47f2-b219-c71d929c82f1.jpg)\n\n2013年9月，OPPO发布ColorOS 1.0版本，随后再2014年3月更新到2.0之后，一直到现在差不多有一年没更新了。如此迭代速度要在如此激烈的ROM市场中角逐，还是不容易的。不过有一点是，ColorOS适配的机器比Mifavor多一点，除了OPPO的手机以外，还适配三星、小米、HTC等品牌。\n\n### 小米：MIUI\n\n![](http://xia-dev.b0.upaiyun.com/e65a952b-cc06-45ed-b59d-eaf476db7b31.jpg)\n\nMIUI是小米科技基于CM及AOSP改进而来，作为ROM市场的一款明星产品，其受欢迎程度自不用多说。MIUI的稳定性，交互，设计，迭代速度是值得肯定。但是它抄袭IOS的嫌疑，以及捆绑腾讯安全管家引擎，还有不允许删除部分小米服务软件也一直受米黑所诟病。若抛开开源精神来说的话，MIUI确实是一款实用性不错的产品。\n\n### 锤子：SmartisanOS\n\n![](http://xia-dev.b0.upaiyun.com/a60af4f7-0c16-4dbf-85ac-8d0efead84d4.jpg)\n\n2014年5月20日，罗永浩在北京举办的产品发布会上，从曝光开始历时一年载的SmartisanOS以一种高调的方式出现在大家的眼前，和它的宿主SmartisanT1一样，SmartisanOS也被灌进满满的情怀。耳目一新的设计，贴心的交互方式，细腻的动画等等，都可以说SmartisanOS是一款优秀的OS，但是受Smartisan T1的出货量和ROM的适配机型少限制，装机量不太理想。\n\n### 一加：OxygenOS 和 H2OS\n\n傍CyanogenMod的大腿大半年，一加手机终于也开始捣弄属于自己的ROM了。刘作虎在2月6日微博给OxygenOS预热了一下，在2月12日放出了OxygenOS的开发团队的信息，但是并没有表明发布日期。值得注意的是，一加自主研发的ROM不仅仅只有OxygenOS，还有H2OS。中文翻译分别是“氧OS”和“氢OS”，据一加官方说法，前者是针对海外市场，界面非常接近原生。而后者则针对国内市场，采用全新的设计风格。\n\n### 酷派：CoolUI\n\nCoolUI是酷派旗下基于Android深度定制的ROOM，目前最新稳定版本是CoolUI 6.0，首次搭配在大神X7机型上。\n\n### VIVO：Funtouch OS\n\nFuntouch OS是VIVO手机2013年10月15日发布的深度定制的ROM，在2014年10月20日发布更新版本Funtouch OS 2.0。适配旗下的X1s/st、X3、Y17、Xplay、Xplay3s、Xshot等几款机型。目前没发现有适配其他手机品牌的ROM。\n\n### 华为：EMUI\n\n2012年7月推出以来，EMUI现在已经更新到3.0版本了，EMUI还有一个别称，Emotion UI。EMUI现在能适配的机型也只有自家的手机。\n\n## 民间中的明星团队\n\n### 乐蛙OS\n\n![](http://xia-dev.b0.upaiyun.com/67db2cfc-e52c-4cd1-bce1-27b59efa11ed.jpg)\n\n乐蛙OS是由上海的乐蛙科技在2011年12月30日发布的的基于Android深度定制的ROM，经过多次迭代，于2014年10月22日推出最新版本6.0。适配机型覆盖了酷派、华为、TCL、中兴、小米等著名国产品牌。\n\n### 新蜂ROM\n\n![](http://xia-dev.b0.upaiyun.com/e5a0cbea-e5fb-4551-ad46-70f0685200e5.jpg)\n\n新蜂ROM是新蜂工作室基于各Android深度定制的ROM，据说新蜂工作室只有十余人。适配机型70余款，覆盖中兴、联想、华为、三星、HTC、索尼、OPPO等品牌。\n\n### MokeeOS\n\n![](http://xia-dev.b0.upaiyun.com/17055a94-717c-4119-816c-d1402218d3fa.jpg)\n\nMokeeOS（Mokee OpenSource）是真正具有开源血统的开源项目，由魔趣论坛发起，民间自发组织开发的产物。适配机型达150余款，而且都在Github上公开源码，可以说能开源的ROM在现在的ROM市场上实属罕见。\n\n## 壮士一去兮不复还\n\n在ROM大潮中，后浪盖前浪，前浪死在沙滩上，在欣赏活跃的明星ROM在舞台上光彩夺目的舞姿以外，我们是否应缅怀一下那些曾经一度夺人眼球，但由于种种原因停止更新，最后化作成泥更护花的ROM？\n\n*   点心 (2010.8)\n*   LiGux (2011.6)\n*   魔趣 (2011.9)\n*   Joyos (2011.12)\n*   QissME (2012.2)\n*   乐众 (2012.2)\n*   腾讯tita (2012.4)\n*   深度OS (2012.4)\n*   X-UI (2012.9)\n*   ViBE UI (2013.9)\n\n## 后话\n\n自09年CM成立后，众多基于官方或CM进行深层定制的第三方Android ROM团队也相继成立并推出各自的OS或者UI，通过适配不同的机型来让更多的用户获得另类的ROM体验。部分手机厂商也开始发现自身不足，逐渐转为软硬结合的模式，跻身ROM定制行列。除提升手机硬件配置以外，还通过优化出厂系统来提升手机性能。此外，也有ROM团队与厂商合作，将品牌OS深度定制为手机出厂系统，发挥双方在线上线下的优势。","source":"_posts/盘点国内的那些ROM.md","raw":"---\ntitle: 盘点国内的那些ROM\ncategory: 搬砖码农\ndate: 2015-03-03 19:21:12\ntags: \n- ROM\n---\n\n## 前言\n\n最近新闻比较多，阿里入股魅族的消息除了轰动之余，不免会让人回想起去年的Flyme Powered by YunOS。腾讯推出的TOS，也会使人想起那年昙花一现的tita。一加公布其自主ROM正式改名OxygenOS的消息，也让人好奇刘作虎的下一步棋。\n百度的\"百度云OS\"、阿里的\"YunOS\"、腾讯的\"TOS\"、魅族的“FLymeOS”、小米的“MIUI”、锤子的“SmartisanOS”还有一加的“OxygenOS”等等，让人有一种在Android市场下欣欣向荣、百花齐放、百家争鸣的感觉。拥有一个自家的ROM，貌似成为了争夺移动互联网之战的入场券。我们不妨来看一下国内Android市场的那些你听过的没听过，用过没用过的那些ROM。\n\n## BAT巨头\n\n### 百度：百度云OS\n\n![](http://xia-dev.b0.upaiyun.com/463ff1a5-b814-485a-96f0-cf98439250f3.jpg)\n\n百度在2012年6月推出了基于Android进行开发的百度云OS。2013年战略投资过100+爱奇艺手机，在手机上内置百度云OS，并将旗下收购的爱奇艺视频业务整合到手机系统。近日，又传出消息称百度入股联想神奇工场。百度云OS适配机型众多，目前在“刷机党”中已有一定认知度和口碑。\n\n### 阿里：YunOS\n\n![](http://xia-dev.b0.upaiyun.com/8d2b6d92-5ef4-4662-85c5-f32d2bed93c7.jpg)\n\n2011年7月28日，阿里巴巴集团旗下阿里云计算有限公司在北京召开新闻发布会，正式推出了阿里云OS。根据阿里云公司官方的说法，阿里云OS是一个独立于Android之外，自助研发的独立操作系统，底层核心一样是用的Linux内核。但虚拟机却不是用Android的Dalvik虚拟机，而是阿里云自家的虚拟机。但是阿里没有把原始代码公布的做法，受到了开源信奉者的Linux以及Android的排挤，以至于发展道路坎坷。\n\n### 腾讯：TOS\n\n2015年2月10日，TencentOS官方微博发布内侧招募通知。TOS究竟是一种什么样性质的系统呢？腾讯没说。是真正的自主研发，还是安卓阵营中的一名新兵，还是改头换面式的“伪原创”，在它没有正式发售之前，我们还不得而知，所以我们只能猜测。曾经，腾讯有过一款名为Tita的产品，但最后“无疾而终”。有趣的是，TOS内侧招募和阿里入股魅族的日子只差了一天。\n\n## 手机厂商的软硬件结合之路\n\n### 魅族：FlymeOS\n\n![](http://xia-dev.b0.upaiyun.com/91b3008a-9be4-406c-aa31-f32a31551d54.png)\n\nFlyme OS是魅族公司基于Android系统深度定制的手机操作系统。在2012年6月，魅族旗下的手机操作系统正式改名为\"Flyme OS\"，而在此之前魅族有分别有基于WindowsCE内核以及Android自主研发的手机操作系统，但没有对外公布正式的名字，当然，那时也只是适配自家手机。不过，到目前为止，FlymeOS已经能适配HTC、三星、索尼、LG等品牌的手机了。其优秀的设计，也使魅族拥有了相当可观的粉丝群。\n\n### 中兴：MiFavor\n\n![](http://xia-dev.b0.upaiyun.com/c0e4bc32-0bf5-4c64-ba4a-2885d0ff9082.jpg)\n\n自2011年8月MiFavor v1.0发布以来，经过多次迭代，到目前为止已经是v3.0了，但是适配机型只是旗下的星星1号和天机。从这方面来看，中兴旗下有不少型号的手机，却没有配备自家的ROM，确实不太能够捕获人心。\n\n### OPPO：ColorOS\n\n![](http://xia-dev.b0.upaiyun.com/19fff263-7919-47f2-b219-c71d929c82f1.jpg)\n\n2013年9月，OPPO发布ColorOS 1.0版本，随后再2014年3月更新到2.0之后，一直到现在差不多有一年没更新了。如此迭代速度要在如此激烈的ROM市场中角逐，还是不容易的。不过有一点是，ColorOS适配的机器比Mifavor多一点，除了OPPO的手机以外，还适配三星、小米、HTC等品牌。\n\n### 小米：MIUI\n\n![](http://xia-dev.b0.upaiyun.com/e65a952b-cc06-45ed-b59d-eaf476db7b31.jpg)\n\nMIUI是小米科技基于CM及AOSP改进而来，作为ROM市场的一款明星产品，其受欢迎程度自不用多说。MIUI的稳定性，交互，设计，迭代速度是值得肯定。但是它抄袭IOS的嫌疑，以及捆绑腾讯安全管家引擎，还有不允许删除部分小米服务软件也一直受米黑所诟病。若抛开开源精神来说的话，MIUI确实是一款实用性不错的产品。\n\n### 锤子：SmartisanOS\n\n![](http://xia-dev.b0.upaiyun.com/a60af4f7-0c16-4dbf-85ac-8d0efead84d4.jpg)\n\n2014年5月20日，罗永浩在北京举办的产品发布会上，从曝光开始历时一年载的SmartisanOS以一种高调的方式出现在大家的眼前，和它的宿主SmartisanT1一样，SmartisanOS也被灌进满满的情怀。耳目一新的设计，贴心的交互方式，细腻的动画等等，都可以说SmartisanOS是一款优秀的OS，但是受Smartisan T1的出货量和ROM的适配机型少限制，装机量不太理想。\n\n### 一加：OxygenOS 和 H2OS\n\n傍CyanogenMod的大腿大半年，一加手机终于也开始捣弄属于自己的ROM了。刘作虎在2月6日微博给OxygenOS预热了一下，在2月12日放出了OxygenOS的开发团队的信息，但是并没有表明发布日期。值得注意的是，一加自主研发的ROM不仅仅只有OxygenOS，还有H2OS。中文翻译分别是“氧OS”和“氢OS”，据一加官方说法，前者是针对海外市场，界面非常接近原生。而后者则针对国内市场，采用全新的设计风格。\n\n### 酷派：CoolUI\n\nCoolUI是酷派旗下基于Android深度定制的ROOM，目前最新稳定版本是CoolUI 6.0，首次搭配在大神X7机型上。\n\n### VIVO：Funtouch OS\n\nFuntouch OS是VIVO手机2013年10月15日发布的深度定制的ROM，在2014年10月20日发布更新版本Funtouch OS 2.0。适配旗下的X1s/st、X3、Y17、Xplay、Xplay3s、Xshot等几款机型。目前没发现有适配其他手机品牌的ROM。\n\n### 华为：EMUI\n\n2012年7月推出以来，EMUI现在已经更新到3.0版本了，EMUI还有一个别称，Emotion UI。EMUI现在能适配的机型也只有自家的手机。\n\n## 民间中的明星团队\n\n### 乐蛙OS\n\n![](http://xia-dev.b0.upaiyun.com/67db2cfc-e52c-4cd1-bce1-27b59efa11ed.jpg)\n\n乐蛙OS是由上海的乐蛙科技在2011年12月30日发布的的基于Android深度定制的ROM，经过多次迭代，于2014年10月22日推出最新版本6.0。适配机型覆盖了酷派、华为、TCL、中兴、小米等著名国产品牌。\n\n### 新蜂ROM\n\n![](http://xia-dev.b0.upaiyun.com/e5a0cbea-e5fb-4551-ad46-70f0685200e5.jpg)\n\n新蜂ROM是新蜂工作室基于各Android深度定制的ROM，据说新蜂工作室只有十余人。适配机型70余款，覆盖中兴、联想、华为、三星、HTC、索尼、OPPO等品牌。\n\n### MokeeOS\n\n![](http://xia-dev.b0.upaiyun.com/17055a94-717c-4119-816c-d1402218d3fa.jpg)\n\nMokeeOS（Mokee OpenSource）是真正具有开源血统的开源项目，由魔趣论坛发起，民间自发组织开发的产物。适配机型达150余款，而且都在Github上公开源码，可以说能开源的ROM在现在的ROM市场上实属罕见。\n\n## 壮士一去兮不复还\n\n在ROM大潮中，后浪盖前浪，前浪死在沙滩上，在欣赏活跃的明星ROM在舞台上光彩夺目的舞姿以外，我们是否应缅怀一下那些曾经一度夺人眼球，但由于种种原因停止更新，最后化作成泥更护花的ROM？\n\n*   点心 (2010.8)\n*   LiGux (2011.6)\n*   魔趣 (2011.9)\n*   Joyos (2011.12)\n*   QissME (2012.2)\n*   乐众 (2012.2)\n*   腾讯tita (2012.4)\n*   深度OS (2012.4)\n*   X-UI (2012.9)\n*   ViBE UI (2013.9)\n\n## 后话\n\n自09年CM成立后，众多基于官方或CM进行深层定制的第三方Android ROM团队也相继成立并推出各自的OS或者UI，通过适配不同的机型来让更多的用户获得另类的ROM体验。部分手机厂商也开始发现自身不足，逐渐转为软硬结合的模式，跻身ROM定制行列。除提升手机硬件配置以外，还通过优化出厂系统来提升手机性能。此外，也有ROM团队与厂商合作，将品牌OS深度定制为手机出厂系统，发挥双方在线上线下的优势。","slug":"盘点国内的那些ROM","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqr002z15hlpkbhjhvg","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近新闻比较多，阿里入股魅族的消息除了轰动之余，不免会让人回想起去年的Flyme Powered by YunOS。腾讯推出的TOS，也会使人想起那年昙花一现的tita。一加公布其自主ROM正式改名OxygenOS的消息，也让人好奇刘作虎的下一步棋。<br>百度的”百度云OS”、阿里的”YunOS”、腾讯的”TOS”、魅族的“FLymeOS”、小米的“MIUI”、锤子的“SmartisanOS”还有一加的“OxygenOS”等等，让人有一种在Android市场下欣欣向荣、百花齐放、百家争鸣的感觉。拥有一个自家的ROM，貌似成为了争夺移动互联网之战的入场券。我们不妨来看一下国内Android市场的那些你听过的没听过，用过没用过的那些ROM。</p>\n<h2 id=\"BAT巨头\"><a href=\"#BAT巨头\" class=\"headerlink\" title=\"BAT巨头\"></a>BAT巨头</h2><h3 id=\"百度：百度云OS\"><a href=\"#百度：百度云OS\" class=\"headerlink\" title=\"百度：百度云OS\"></a>百度：百度云OS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/463ff1a5-b814-485a-96f0-cf98439250f3.jpg\" alt=\"\"></p>\n<p>百度在2012年6月推出了基于Android进行开发的百度云OS。2013年战略投资过100+爱奇艺手机，在手机上内置百度云OS，并将旗下收购的爱奇艺视频业务整合到手机系统。近日，又传出消息称百度入股联想神奇工场。百度云OS适配机型众多，目前在“刷机党”中已有一定认知度和口碑。</p>\n<h3 id=\"阿里：YunOS\"><a href=\"#阿里：YunOS\" class=\"headerlink\" title=\"阿里：YunOS\"></a>阿里：YunOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/8d2b6d92-5ef4-4662-85c5-f32d2bed93c7.jpg\" alt=\"\"></p>\n<p>2011年7月28日，阿里巴巴集团旗下阿里云计算有限公司在北京召开新闻发布会，正式推出了阿里云OS。根据阿里云公司官方的说法，阿里云OS是一个独立于Android之外，自助研发的独立操作系统，底层核心一样是用的Linux内核。但虚拟机却不是用Android的Dalvik虚拟机，而是阿里云自家的虚拟机。但是阿里没有把原始代码公布的做法，受到了开源信奉者的Linux以及Android的排挤，以至于发展道路坎坷。</p>\n<h3 id=\"腾讯：TOS\"><a href=\"#腾讯：TOS\" class=\"headerlink\" title=\"腾讯：TOS\"></a>腾讯：TOS</h3><p>2015年2月10日，TencentOS官方微博发布内侧招募通知。TOS究竟是一种什么样性质的系统呢？腾讯没说。是真正的自主研发，还是安卓阵营中的一名新兵，还是改头换面式的“伪原创”，在它没有正式发售之前，我们还不得而知，所以我们只能猜测。曾经，腾讯有过一款名为Tita的产品，但最后“无疾而终”。有趣的是，TOS内侧招募和阿里入股魅族的日子只差了一天。</p>\n<h2 id=\"手机厂商的软硬件结合之路\"><a href=\"#手机厂商的软硬件结合之路\" class=\"headerlink\" title=\"手机厂商的软硬件结合之路\"></a>手机厂商的软硬件结合之路</h2><h3 id=\"魅族：FlymeOS\"><a href=\"#魅族：FlymeOS\" class=\"headerlink\" title=\"魅族：FlymeOS\"></a>魅族：FlymeOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/91b3008a-9be4-406c-aa31-f32a31551d54.png\" alt=\"\"></p>\n<p>Flyme OS是魅族公司基于Android系统深度定制的手机操作系统。在2012年6月，魅族旗下的手机操作系统正式改名为”Flyme OS”，而在此之前魅族有分别有基于WindowsCE内核以及Android自主研发的手机操作系统，但没有对外公布正式的名字，当然，那时也只是适配自家手机。不过，到目前为止，FlymeOS已经能适配HTC、三星、索尼、LG等品牌的手机了。其优秀的设计，也使魅族拥有了相当可观的粉丝群。</p>\n<h3 id=\"中兴：MiFavor\"><a href=\"#中兴：MiFavor\" class=\"headerlink\" title=\"中兴：MiFavor\"></a>中兴：MiFavor</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/c0e4bc32-0bf5-4c64-ba4a-2885d0ff9082.jpg\" alt=\"\"></p>\n<p>自2011年8月MiFavor v1.0发布以来，经过多次迭代，到目前为止已经是v3.0了，但是适配机型只是旗下的星星1号和天机。从这方面来看，中兴旗下有不少型号的手机，却没有配备自家的ROM，确实不太能够捕获人心。</p>\n<h3 id=\"OPPO：ColorOS\"><a href=\"#OPPO：ColorOS\" class=\"headerlink\" title=\"OPPO：ColorOS\"></a>OPPO：ColorOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/19fff263-7919-47f2-b219-c71d929c82f1.jpg\" alt=\"\"></p>\n<p>2013年9月，OPPO发布ColorOS 1.0版本，随后再2014年3月更新到2.0之后，一直到现在差不多有一年没更新了。如此迭代速度要在如此激烈的ROM市场中角逐，还是不容易的。不过有一点是，ColorOS适配的机器比Mifavor多一点，除了OPPO的手机以外，还适配三星、小米、HTC等品牌。</p>\n<h3 id=\"小米：MIUI\"><a href=\"#小米：MIUI\" class=\"headerlink\" title=\"小米：MIUI\"></a>小米：MIUI</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/e65a952b-cc06-45ed-b59d-eaf476db7b31.jpg\" alt=\"\"></p>\n<p>MIUI是小米科技基于CM及AOSP改进而来，作为ROM市场的一款明星产品，其受欢迎程度自不用多说。MIUI的稳定性，交互，设计，迭代速度是值得肯定。但是它抄袭IOS的嫌疑，以及捆绑腾讯安全管家引擎，还有不允许删除部分小米服务软件也一直受米黑所诟病。若抛开开源精神来说的话，MIUI确实是一款实用性不错的产品。</p>\n<h3 id=\"锤子：SmartisanOS\"><a href=\"#锤子：SmartisanOS\" class=\"headerlink\" title=\"锤子：SmartisanOS\"></a>锤子：SmartisanOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/a60af4f7-0c16-4dbf-85ac-8d0efead84d4.jpg\" alt=\"\"></p>\n<p>2014年5月20日，罗永浩在北京举办的产品发布会上，从曝光开始历时一年载的SmartisanOS以一种高调的方式出现在大家的眼前，和它的宿主SmartisanT1一样，SmartisanOS也被灌进满满的情怀。耳目一新的设计，贴心的交互方式，细腻的动画等等，都可以说SmartisanOS是一款优秀的OS，但是受Smartisan T1的出货量和ROM的适配机型少限制，装机量不太理想。</p>\n<h3 id=\"一加：OxygenOS-和-H2OS\"><a href=\"#一加：OxygenOS-和-H2OS\" class=\"headerlink\" title=\"一加：OxygenOS 和 H2OS\"></a>一加：OxygenOS 和 H2OS</h3><p>傍CyanogenMod的大腿大半年，一加手机终于也开始捣弄属于自己的ROM了。刘作虎在2月6日微博给OxygenOS预热了一下，在2月12日放出了OxygenOS的开发团队的信息，但是并没有表明发布日期。值得注意的是，一加自主研发的ROM不仅仅只有OxygenOS，还有H2OS。中文翻译分别是“氧OS”和“氢OS”，据一加官方说法，前者是针对海外市场，界面非常接近原生。而后者则针对国内市场，采用全新的设计风格。</p>\n<h3 id=\"酷派：CoolUI\"><a href=\"#酷派：CoolUI\" class=\"headerlink\" title=\"酷派：CoolUI\"></a>酷派：CoolUI</h3><p>CoolUI是酷派旗下基于Android深度定制的ROOM，目前最新稳定版本是CoolUI 6.0，首次搭配在大神X7机型上。</p>\n<h3 id=\"VIVO：Funtouch-OS\"><a href=\"#VIVO：Funtouch-OS\" class=\"headerlink\" title=\"VIVO：Funtouch OS\"></a>VIVO：Funtouch OS</h3><p>Funtouch OS是VIVO手机2013年10月15日发布的深度定制的ROM，在2014年10月20日发布更新版本Funtouch OS 2.0。适配旗下的X1s/st、X3、Y17、Xplay、Xplay3s、Xshot等几款机型。目前没发现有适配其他手机品牌的ROM。</p>\n<h3 id=\"华为：EMUI\"><a href=\"#华为：EMUI\" class=\"headerlink\" title=\"华为：EMUI\"></a>华为：EMUI</h3><p>2012年7月推出以来，EMUI现在已经更新到3.0版本了，EMUI还有一个别称，Emotion UI。EMUI现在能适配的机型也只有自家的手机。</p>\n<h2 id=\"民间中的明星团队\"><a href=\"#民间中的明星团队\" class=\"headerlink\" title=\"民间中的明星团队\"></a>民间中的明星团队</h2><h3 id=\"乐蛙OS\"><a href=\"#乐蛙OS\" class=\"headerlink\" title=\"乐蛙OS\"></a>乐蛙OS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/67db2cfc-e52c-4cd1-bce1-27b59efa11ed.jpg\" alt=\"\"></p>\n<p>乐蛙OS是由上海的乐蛙科技在2011年12月30日发布的的基于Android深度定制的ROM，经过多次迭代，于2014年10月22日推出最新版本6.0。适配机型覆盖了酷派、华为、TCL、中兴、小米等著名国产品牌。</p>\n<h3 id=\"新蜂ROM\"><a href=\"#新蜂ROM\" class=\"headerlink\" title=\"新蜂ROM\"></a>新蜂ROM</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/e5a0cbea-e5fb-4551-ad46-70f0685200e5.jpg\" alt=\"\"></p>\n<p>新蜂ROM是新蜂工作室基于各Android深度定制的ROM，据说新蜂工作室只有十余人。适配机型70余款，覆盖中兴、联想、华为、三星、HTC、索尼、OPPO等品牌。</p>\n<h3 id=\"MokeeOS\"><a href=\"#MokeeOS\" class=\"headerlink\" title=\"MokeeOS\"></a>MokeeOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/17055a94-717c-4119-816c-d1402218d3fa.jpg\" alt=\"\"></p>\n<p>MokeeOS（Mokee OpenSource）是真正具有开源血统的开源项目，由魔趣论坛发起，民间自发组织开发的产物。适配机型达150余款，而且都在Github上公开源码，可以说能开源的ROM在现在的ROM市场上实属罕见。</p>\n<h2 id=\"壮士一去兮不复还\"><a href=\"#壮士一去兮不复还\" class=\"headerlink\" title=\"壮士一去兮不复还\"></a>壮士一去兮不复还</h2><p>在ROM大潮中，后浪盖前浪，前浪死在沙滩上，在欣赏活跃的明星ROM在舞台上光彩夺目的舞姿以外，我们是否应缅怀一下那些曾经一度夺人眼球，但由于种种原因停止更新，最后化作成泥更护花的ROM？</p>\n<ul>\n<li>点心 (2010.8)</li>\n<li>LiGux (2011.6)</li>\n<li>魔趣 (2011.9)</li>\n<li>Joyos (2011.12)</li>\n<li>QissME (2012.2)</li>\n<li>乐众 (2012.2)</li>\n<li>腾讯tita (2012.4)</li>\n<li>深度OS (2012.4)</li>\n<li>X-UI (2012.9)</li>\n<li>ViBE UI (2013.9)</li>\n</ul>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>自09年CM成立后，众多基于官方或CM进行深层定制的第三方Android ROM团队也相继成立并推出各自的OS或者UI，通过适配不同的机型来让更多的用户获得另类的ROM体验。部分手机厂商也开始发现自身不足，逐渐转为软硬结合的模式，跻身ROM定制行列。除提升手机硬件配置以外，还通过优化出厂系统来提升手机性能。此外，也有ROM团队与厂商合作，将品牌OS深度定制为手机出厂系统，发挥双方在线上线下的优势。</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近新闻比较多，阿里入股魅族的消息除了轰动之余，不免会让人回想起去年的Flyme Powered by YunOS。腾讯推出的TOS，也会使人想起那年昙花一现的tita。一加公布其自主ROM正式改名OxygenOS的消息，也让人好奇刘作虎的下一步棋。<br>百度的”百度云OS”、阿里的”YunOS”、腾讯的”TOS”、魅族的“FLymeOS”、小米的“MIUI”、锤子的“SmartisanOS”还有一加的“OxygenOS”等等，让人有一种在Android市场下欣欣向荣、百花齐放、百家争鸣的感觉。拥有一个自家的ROM，貌似成为了争夺移动互联网之战的入场券。我们不妨来看一下国内Android市场的那些你听过的没听过，用过没用过的那些ROM。</p>\n<h2 id=\"BAT巨头\"><a href=\"#BAT巨头\" class=\"headerlink\" title=\"BAT巨头\"></a>BAT巨头</h2><h3 id=\"百度：百度云OS\"><a href=\"#百度：百度云OS\" class=\"headerlink\" title=\"百度：百度云OS\"></a>百度：百度云OS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/463ff1a5-b814-485a-96f0-cf98439250f3.jpg\" alt=\"\"></p>\n<p>百度在2012年6月推出了基于Android进行开发的百度云OS。2013年战略投资过100+爱奇艺手机，在手机上内置百度云OS，并将旗下收购的爱奇艺视频业务整合到手机系统。近日，又传出消息称百度入股联想神奇工场。百度云OS适配机型众多，目前在“刷机党”中已有一定认知度和口碑。</p>\n<h3 id=\"阿里：YunOS\"><a href=\"#阿里：YunOS\" class=\"headerlink\" title=\"阿里：YunOS\"></a>阿里：YunOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/8d2b6d92-5ef4-4662-85c5-f32d2bed93c7.jpg\" alt=\"\"></p>\n<p>2011年7月28日，阿里巴巴集团旗下阿里云计算有限公司在北京召开新闻发布会，正式推出了阿里云OS。根据阿里云公司官方的说法，阿里云OS是一个独立于Android之外，自助研发的独立操作系统，底层核心一样是用的Linux内核。但虚拟机却不是用Android的Dalvik虚拟机，而是阿里云自家的虚拟机。但是阿里没有把原始代码公布的做法，受到了开源信奉者的Linux以及Android的排挤，以至于发展道路坎坷。</p>\n<h3 id=\"腾讯：TOS\"><a href=\"#腾讯：TOS\" class=\"headerlink\" title=\"腾讯：TOS\"></a>腾讯：TOS</h3><p>2015年2月10日，TencentOS官方微博发布内侧招募通知。TOS究竟是一种什么样性质的系统呢？腾讯没说。是真正的自主研发，还是安卓阵营中的一名新兵，还是改头换面式的“伪原创”，在它没有正式发售之前，我们还不得而知，所以我们只能猜测。曾经，腾讯有过一款名为Tita的产品，但最后“无疾而终”。有趣的是，TOS内侧招募和阿里入股魅族的日子只差了一天。</p>\n<h2 id=\"手机厂商的软硬件结合之路\"><a href=\"#手机厂商的软硬件结合之路\" class=\"headerlink\" title=\"手机厂商的软硬件结合之路\"></a>手机厂商的软硬件结合之路</h2><h3 id=\"魅族：FlymeOS\"><a href=\"#魅族：FlymeOS\" class=\"headerlink\" title=\"魅族：FlymeOS\"></a>魅族：FlymeOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/91b3008a-9be4-406c-aa31-f32a31551d54.png\" alt=\"\"></p>\n<p>Flyme OS是魅族公司基于Android系统深度定制的手机操作系统。在2012年6月，魅族旗下的手机操作系统正式改名为”Flyme OS”，而在此之前魅族有分别有基于WindowsCE内核以及Android自主研发的手机操作系统，但没有对外公布正式的名字，当然，那时也只是适配自家手机。不过，到目前为止，FlymeOS已经能适配HTC、三星、索尼、LG等品牌的手机了。其优秀的设计，也使魅族拥有了相当可观的粉丝群。</p>\n<h3 id=\"中兴：MiFavor\"><a href=\"#中兴：MiFavor\" class=\"headerlink\" title=\"中兴：MiFavor\"></a>中兴：MiFavor</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/c0e4bc32-0bf5-4c64-ba4a-2885d0ff9082.jpg\" alt=\"\"></p>\n<p>自2011年8月MiFavor v1.0发布以来，经过多次迭代，到目前为止已经是v3.0了，但是适配机型只是旗下的星星1号和天机。从这方面来看，中兴旗下有不少型号的手机，却没有配备自家的ROM，确实不太能够捕获人心。</p>\n<h3 id=\"OPPO：ColorOS\"><a href=\"#OPPO：ColorOS\" class=\"headerlink\" title=\"OPPO：ColorOS\"></a>OPPO：ColorOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/19fff263-7919-47f2-b219-c71d929c82f1.jpg\" alt=\"\"></p>\n<p>2013年9月，OPPO发布ColorOS 1.0版本，随后再2014年3月更新到2.0之后，一直到现在差不多有一年没更新了。如此迭代速度要在如此激烈的ROM市场中角逐，还是不容易的。不过有一点是，ColorOS适配的机器比Mifavor多一点，除了OPPO的手机以外，还适配三星、小米、HTC等品牌。</p>\n<h3 id=\"小米：MIUI\"><a href=\"#小米：MIUI\" class=\"headerlink\" title=\"小米：MIUI\"></a>小米：MIUI</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/e65a952b-cc06-45ed-b59d-eaf476db7b31.jpg\" alt=\"\"></p>\n<p>MIUI是小米科技基于CM及AOSP改进而来，作为ROM市场的一款明星产品，其受欢迎程度自不用多说。MIUI的稳定性，交互，设计，迭代速度是值得肯定。但是它抄袭IOS的嫌疑，以及捆绑腾讯安全管家引擎，还有不允许删除部分小米服务软件也一直受米黑所诟病。若抛开开源精神来说的话，MIUI确实是一款实用性不错的产品。</p>\n<h3 id=\"锤子：SmartisanOS\"><a href=\"#锤子：SmartisanOS\" class=\"headerlink\" title=\"锤子：SmartisanOS\"></a>锤子：SmartisanOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/a60af4f7-0c16-4dbf-85ac-8d0efead84d4.jpg\" alt=\"\"></p>\n<p>2014年5月20日，罗永浩在北京举办的产品发布会上，从曝光开始历时一年载的SmartisanOS以一种高调的方式出现在大家的眼前，和它的宿主SmartisanT1一样，SmartisanOS也被灌进满满的情怀。耳目一新的设计，贴心的交互方式，细腻的动画等等，都可以说SmartisanOS是一款优秀的OS，但是受Smartisan T1的出货量和ROM的适配机型少限制，装机量不太理想。</p>\n<h3 id=\"一加：OxygenOS-和-H2OS\"><a href=\"#一加：OxygenOS-和-H2OS\" class=\"headerlink\" title=\"一加：OxygenOS 和 H2OS\"></a>一加：OxygenOS 和 H2OS</h3><p>傍CyanogenMod的大腿大半年，一加手机终于也开始捣弄属于自己的ROM了。刘作虎在2月6日微博给OxygenOS预热了一下，在2月12日放出了OxygenOS的开发团队的信息，但是并没有表明发布日期。值得注意的是，一加自主研发的ROM不仅仅只有OxygenOS，还有H2OS。中文翻译分别是“氧OS”和“氢OS”，据一加官方说法，前者是针对海外市场，界面非常接近原生。而后者则针对国内市场，采用全新的设计风格。</p>\n<h3 id=\"酷派：CoolUI\"><a href=\"#酷派：CoolUI\" class=\"headerlink\" title=\"酷派：CoolUI\"></a>酷派：CoolUI</h3><p>CoolUI是酷派旗下基于Android深度定制的ROOM，目前最新稳定版本是CoolUI 6.0，首次搭配在大神X7机型上。</p>\n<h3 id=\"VIVO：Funtouch-OS\"><a href=\"#VIVO：Funtouch-OS\" class=\"headerlink\" title=\"VIVO：Funtouch OS\"></a>VIVO：Funtouch OS</h3><p>Funtouch OS是VIVO手机2013年10月15日发布的深度定制的ROM，在2014年10月20日发布更新版本Funtouch OS 2.0。适配旗下的X1s/st、X3、Y17、Xplay、Xplay3s、Xshot等几款机型。目前没发现有适配其他手机品牌的ROM。</p>\n<h3 id=\"华为：EMUI\"><a href=\"#华为：EMUI\" class=\"headerlink\" title=\"华为：EMUI\"></a>华为：EMUI</h3><p>2012年7月推出以来，EMUI现在已经更新到3.0版本了，EMUI还有一个别称，Emotion UI。EMUI现在能适配的机型也只有自家的手机。</p>\n<h2 id=\"民间中的明星团队\"><a href=\"#民间中的明星团队\" class=\"headerlink\" title=\"民间中的明星团队\"></a>民间中的明星团队</h2><h3 id=\"乐蛙OS\"><a href=\"#乐蛙OS\" class=\"headerlink\" title=\"乐蛙OS\"></a>乐蛙OS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/67db2cfc-e52c-4cd1-bce1-27b59efa11ed.jpg\" alt=\"\"></p>\n<p>乐蛙OS是由上海的乐蛙科技在2011年12月30日发布的的基于Android深度定制的ROM，经过多次迭代，于2014年10月22日推出最新版本6.0。适配机型覆盖了酷派、华为、TCL、中兴、小米等著名国产品牌。</p>\n<h3 id=\"新蜂ROM\"><a href=\"#新蜂ROM\" class=\"headerlink\" title=\"新蜂ROM\"></a>新蜂ROM</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/e5a0cbea-e5fb-4551-ad46-70f0685200e5.jpg\" alt=\"\"></p>\n<p>新蜂ROM是新蜂工作室基于各Android深度定制的ROM，据说新蜂工作室只有十余人。适配机型70余款，覆盖中兴、联想、华为、三星、HTC、索尼、OPPO等品牌。</p>\n<h3 id=\"MokeeOS\"><a href=\"#MokeeOS\" class=\"headerlink\" title=\"MokeeOS\"></a>MokeeOS</h3><p><img src=\"http://xia-dev.b0.upaiyun.com/17055a94-717c-4119-816c-d1402218d3fa.jpg\" alt=\"\"></p>\n<p>MokeeOS（Mokee OpenSource）是真正具有开源血统的开源项目，由魔趣论坛发起，民间自发组织开发的产物。适配机型达150余款，而且都在Github上公开源码，可以说能开源的ROM在现在的ROM市场上实属罕见。</p>\n<h2 id=\"壮士一去兮不复还\"><a href=\"#壮士一去兮不复还\" class=\"headerlink\" title=\"壮士一去兮不复还\"></a>壮士一去兮不复还</h2><p>在ROM大潮中，后浪盖前浪，前浪死在沙滩上，在欣赏活跃的明星ROM在舞台上光彩夺目的舞姿以外，我们是否应缅怀一下那些曾经一度夺人眼球，但由于种种原因停止更新，最后化作成泥更护花的ROM？</p>\n<ul>\n<li>点心 (2010.8)</li>\n<li>LiGux (2011.6)</li>\n<li>魔趣 (2011.9)</li>\n<li>Joyos (2011.12)</li>\n<li>QissME (2012.2)</li>\n<li>乐众 (2012.2)</li>\n<li>腾讯tita (2012.4)</li>\n<li>深度OS (2012.4)</li>\n<li>X-UI (2012.9)</li>\n<li>ViBE UI (2013.9)</li>\n</ul>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>自09年CM成立后，众多基于官方或CM进行深层定制的第三方Android ROM团队也相继成立并推出各自的OS或者UI，通过适配不同的机型来让更多的用户获得另类的ROM体验。部分手机厂商也开始发现自身不足，逐渐转为软硬结合的模式，跻身ROM定制行列。除提升手机硬件配置以外，还通过优化出厂系统来提升手机性能。此外，也有ROM团队与厂商合作，将品牌OS深度定制为手机出厂系统，发挥双方在线上线下的优势。</p>\n"},{"title":"登录那些事儿","date":"2015-12-14T15:16:33.000Z","_content":"\n也不知道是什么原因，刚开始不久的职业生涯，在技术这条路走着走着，和「登录」总是有着一个不解之缘。还记得当初学习Web编程的时候么？不管是Java、.Net、PHP，继经典「Hello World」之后，要写的很有可能就是「登录」功能。至今「登录」的问题还是让我心中一万只草泥马奔过。\n下面，给分享一下各种「登录」相关的需求\n\n## 普通的登录\n这个是极其普通的登录需求，要的就是一个登录页面，输入账号密码，提交Form表单，后端查询数据库对应用户名的密码，匹配正确则把用户记录到Session，不正确则返回错误。\n这种登录，在上学的时候，也许敬爱的老师就已经教过你了。\n但可能他没有教你的是，密码需要hash加密，session为什么可以记录登录用户的原理。\n\n**密码Hash**\n密码hash，就是存进数据库的密码是一串密文，密文是明文密码通过不可逆算法得出的。在Nodejs中，你可以使用[bcryptjs](https://www.npmjs.com/package/bcryptjs)，它提供了`hash`以及对应的`compare`方法，非常适合用于密码的加密和对比。\n\n**Session原理**\nSession的原理其实还是依赖了Cookie，所以Cookie才是记录用户凭证的真理。它的原理大概是酱紫的：服务器端维护一个session的表，这个表的每一条记录存的就是与某一个客户端的会话，会话会有过期时间，过期的会话会被清理。然后这个会话，会有一个对应的id，一般是一串长长的看不懂的字符串，然后这个字符串会被存储在客户端的cookie中，每一次请求服务器端都会带上这个cookie，服务器端就知道访问的就是哪个客户端了。\n欲知更多有关「Session原理」请点击传送门：[Session原理](http://www.jianshu.com/p/2b7c10291aad)\n\n## 使用独立登录系统\n应项目需要，登录逻辑需要独立出来做成一个系统，就是另外一个项目。与原来的主站不是在同一个项目中了。一个域名是 `www.site.com`，一个则是`passport.site.com`了。要在不同的域名下进行登录，一般的方法是`www.site.com/login` 跳转到 `passport.site.com/login`，passport这边是一个登录页面，用户输入账号密码登录成功之后，passport会通过带着一个可逆加密的包含用户信息的token，重定向到`www.site.com`提供的回调处理地址，然后进行解密，匹配正确，则登录用户。\n要注意的是，这里的加密的信息需要包含一个时间戳，接收方需要认证这个时间戳，过期登录失败。避免token被窃取，被无限登录site系统。\n\n## 单点登录\n单点登录需要实现的需求，说白了就是在站点A的登录了，那么用户就自动在站点B、站点C、站点E、F、G登录。\n这又分两种情况，A站点和B站点是否在同一个二级域名下。\n假如是在同一个域名下，例如`siteA.site.com`与`siteB.site.com`，因为cookie允许设置到二级域名下`.site.com`，所以siteA和siteB是可以共享cookie的，用户的信息可以通过可逆加密放在二级域名下的cookie，并且设置`http only`，就可以一站登录，站站登录。\n而如果A站点和B站点不在同一二级域名下，例如`www.siteA.com`与`www.siteB.com`，他们就无法通过共享cookie的方式共享用户信息，所以需要用到jsonp的方式，用户在siteA登录之后，提供一个jsonp接口获取加密的用户信息，siteB访问这个jsonp获取加密信息。达到共享用户状态的效果。\n欲知更多有关「单点登录」请点击传送门：[单点登录的三种实现方式](http://www.jianshu.com/p/613e44d4a464)\n\n## OAuth2.0登录\n这就比较普遍了，现在随随便便做个网站，都接入「微信登录」、「微博登录」、「豆瓣登录」、「QQ登录」、「Github登录」、*@^*&@%#^%^@%&%@&#........\n这些统一叫做：「第三方登录」。\n第三方登录都是实现了OAuth2.0协议的，流程大概是酱紫的：\n第三方提供一个登录入口，也就是第三方域名下的登录页面。主站需要登录的时候，引导用户重定向到第三方的登录页面，用户输入账号密码之后，登录第三方系统，第三方系统匹配帐号成功之后，带上一个code到主站的回调地址，主站接收到code，短时间内拿着code请求第三方提供获取长期凭证的接口(因为code有一个比较短的过期时间)，这个长期凭证叫`access_token`，获取之后就把这个`access_token`存到数据库中，请求一些第三方提供的API，需要用到这个`access_token`，因为这个token就是记录用户在第三方系统的一个身份凭证。\n一些系统，在获取`access_token`的时候，还会返回一个副参数`refresh_token`，因为`access_token`是有过期时间的，一旦过期了，主站可以使用`refresh_token`请求第三方提供的接口获取新的`access_token`以及新的`refresh_token`。\n在Nodejs中，你可以使用`passport`来给第三方登录提供一个统一解决方案，而如果你是开发「微信公众号」授权，除了[passport](https://www.npmjs.com/package/passport)，也可以使用[wechat-oauth](https://www.npmjs.com/package/wechat-oauth)\n\n## 在最后\n其实登录问题，理解了Session原理是很重要的，这个也不难理解。然后站点之间的用户信息交流，就是通过各种跨域限制，各种加密解密而已。在做这个的时候，需要充分考虑到加密的token是否会被窃取的可能性，还要考虑让这个token加上时间的验证，在一些可能会被窃取，安全需求比较高的情况，就需要把token的时间设置的更短。还有就是加密的方式需要依照需求不同而选择可逆或者不可逆，hash sha1还是JWT(Json Web Token)。\nsha1加密，可以使用Nodejs自带的`crypto`，JWT可以使用[jsonwebtoken]()\n","source":"_posts/登录那些事儿.md","raw":"---\ntitle: 登录那些事儿\ncategory: 搬砖码农\ndate: 2015-12-14 23:16:33\ntags:\n- 单点登录\n- cookie\n- session\n- Nodejs\n---\n\n也不知道是什么原因，刚开始不久的职业生涯，在技术这条路走着走着，和「登录」总是有着一个不解之缘。还记得当初学习Web编程的时候么？不管是Java、.Net、PHP，继经典「Hello World」之后，要写的很有可能就是「登录」功能。至今「登录」的问题还是让我心中一万只草泥马奔过。\n下面，给分享一下各种「登录」相关的需求\n\n## 普通的登录\n这个是极其普通的登录需求，要的就是一个登录页面，输入账号密码，提交Form表单，后端查询数据库对应用户名的密码，匹配正确则把用户记录到Session，不正确则返回错误。\n这种登录，在上学的时候，也许敬爱的老师就已经教过你了。\n但可能他没有教你的是，密码需要hash加密，session为什么可以记录登录用户的原理。\n\n**密码Hash**\n密码hash，就是存进数据库的密码是一串密文，密文是明文密码通过不可逆算法得出的。在Nodejs中，你可以使用[bcryptjs](https://www.npmjs.com/package/bcryptjs)，它提供了`hash`以及对应的`compare`方法，非常适合用于密码的加密和对比。\n\n**Session原理**\nSession的原理其实还是依赖了Cookie，所以Cookie才是记录用户凭证的真理。它的原理大概是酱紫的：服务器端维护一个session的表，这个表的每一条记录存的就是与某一个客户端的会话，会话会有过期时间，过期的会话会被清理。然后这个会话，会有一个对应的id，一般是一串长长的看不懂的字符串，然后这个字符串会被存储在客户端的cookie中，每一次请求服务器端都会带上这个cookie，服务器端就知道访问的就是哪个客户端了。\n欲知更多有关「Session原理」请点击传送门：[Session原理](http://www.jianshu.com/p/2b7c10291aad)\n\n## 使用独立登录系统\n应项目需要，登录逻辑需要独立出来做成一个系统，就是另外一个项目。与原来的主站不是在同一个项目中了。一个域名是 `www.site.com`，一个则是`passport.site.com`了。要在不同的域名下进行登录，一般的方法是`www.site.com/login` 跳转到 `passport.site.com/login`，passport这边是一个登录页面，用户输入账号密码登录成功之后，passport会通过带着一个可逆加密的包含用户信息的token，重定向到`www.site.com`提供的回调处理地址，然后进行解密，匹配正确，则登录用户。\n要注意的是，这里的加密的信息需要包含一个时间戳，接收方需要认证这个时间戳，过期登录失败。避免token被窃取，被无限登录site系统。\n\n## 单点登录\n单点登录需要实现的需求，说白了就是在站点A的登录了，那么用户就自动在站点B、站点C、站点E、F、G登录。\n这又分两种情况，A站点和B站点是否在同一个二级域名下。\n假如是在同一个域名下，例如`siteA.site.com`与`siteB.site.com`，因为cookie允许设置到二级域名下`.site.com`，所以siteA和siteB是可以共享cookie的，用户的信息可以通过可逆加密放在二级域名下的cookie，并且设置`http only`，就可以一站登录，站站登录。\n而如果A站点和B站点不在同一二级域名下，例如`www.siteA.com`与`www.siteB.com`，他们就无法通过共享cookie的方式共享用户信息，所以需要用到jsonp的方式，用户在siteA登录之后，提供一个jsonp接口获取加密的用户信息，siteB访问这个jsonp获取加密信息。达到共享用户状态的效果。\n欲知更多有关「单点登录」请点击传送门：[单点登录的三种实现方式](http://www.jianshu.com/p/613e44d4a464)\n\n## OAuth2.0登录\n这就比较普遍了，现在随随便便做个网站，都接入「微信登录」、「微博登录」、「豆瓣登录」、「QQ登录」、「Github登录」、*@^*&@%#^%^@%&%@&#........\n这些统一叫做：「第三方登录」。\n第三方登录都是实现了OAuth2.0协议的，流程大概是酱紫的：\n第三方提供一个登录入口，也就是第三方域名下的登录页面。主站需要登录的时候，引导用户重定向到第三方的登录页面，用户输入账号密码之后，登录第三方系统，第三方系统匹配帐号成功之后，带上一个code到主站的回调地址，主站接收到code，短时间内拿着code请求第三方提供获取长期凭证的接口(因为code有一个比较短的过期时间)，这个长期凭证叫`access_token`，获取之后就把这个`access_token`存到数据库中，请求一些第三方提供的API，需要用到这个`access_token`，因为这个token就是记录用户在第三方系统的一个身份凭证。\n一些系统，在获取`access_token`的时候，还会返回一个副参数`refresh_token`，因为`access_token`是有过期时间的，一旦过期了，主站可以使用`refresh_token`请求第三方提供的接口获取新的`access_token`以及新的`refresh_token`。\n在Nodejs中，你可以使用`passport`来给第三方登录提供一个统一解决方案，而如果你是开发「微信公众号」授权，除了[passport](https://www.npmjs.com/package/passport)，也可以使用[wechat-oauth](https://www.npmjs.com/package/wechat-oauth)\n\n## 在最后\n其实登录问题，理解了Session原理是很重要的，这个也不难理解。然后站点之间的用户信息交流，就是通过各种跨域限制，各种加密解密而已。在做这个的时候，需要充分考虑到加密的token是否会被窃取的可能性，还要考虑让这个token加上时间的验证，在一些可能会被窃取，安全需求比较高的情况，就需要把token的时间设置的更短。还有就是加密的方式需要依照需求不同而选择可逆或者不可逆，hash sha1还是JWT(Json Web Token)。\nsha1加密，可以使用Nodejs自带的`crypto`，JWT可以使用[jsonwebtoken]()\n","slug":"登录那些事儿","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqt003315hl5pypmien","content":"<p>也不知道是什么原因，刚开始不久的职业生涯，在技术这条路走着走着，和「登录」总是有着一个不解之缘。还记得当初学习Web编程的时候么？不管是Java、.Net、PHP，继经典「Hello World」之后，要写的很有可能就是「登录」功能。至今「登录」的问题还是让我心中一万只草泥马奔过。<br>下面，给分享一下各种「登录」相关的需求</p>\n<h2 id=\"普通的登录\"><a href=\"#普通的登录\" class=\"headerlink\" title=\"普通的登录\"></a>普通的登录</h2><p>这个是极其普通的登录需求，要的就是一个登录页面，输入账号密码，提交Form表单，后端查询数据库对应用户名的密码，匹配正确则把用户记录到Session，不正确则返回错误。<br>这种登录，在上学的时候，也许敬爱的老师就已经教过你了。<br>但可能他没有教你的是，密码需要hash加密，session为什么可以记录登录用户的原理。</p>\n<p><strong>密码Hash</strong><br>密码hash，就是存进数据库的密码是一串密文，密文是明文密码通过不可逆算法得出的。在Nodejs中，你可以使用<a href=\"https://www.npmjs.com/package/bcryptjs\" target=\"_blank\" rel=\"external\">bcryptjs</a>，它提供了<code>hash</code>以及对应的<code>compare</code>方法，非常适合用于密码的加密和对比。</p>\n<p><strong>Session原理</strong><br>Session的原理其实还是依赖了Cookie，所以Cookie才是记录用户凭证的真理。它的原理大概是酱紫的：服务器端维护一个session的表，这个表的每一条记录存的就是与某一个客户端的会话，会话会有过期时间，过期的会话会被清理。然后这个会话，会有一个对应的id，一般是一串长长的看不懂的字符串，然后这个字符串会被存储在客户端的cookie中，每一次请求服务器端都会带上这个cookie，服务器端就知道访问的就是哪个客户端了。<br>欲知更多有关「Session原理」请点击传送门：<a href=\"http://www.jianshu.com/p/2b7c10291aad\" target=\"_blank\" rel=\"external\">Session原理</a></p>\n<h2 id=\"使用独立登录系统\"><a href=\"#使用独立登录系统\" class=\"headerlink\" title=\"使用独立登录系统\"></a>使用独立登录系统</h2><p>应项目需要，登录逻辑需要独立出来做成一个系统，就是另外一个项目。与原来的主站不是在同一个项目中了。一个域名是 <code>www.site.com</code>，一个则是<code>passport.site.com</code>了。要在不同的域名下进行登录，一般的方法是<code>www.site.com/login</code> 跳转到 <code>passport.site.com/login</code>，passport这边是一个登录页面，用户输入账号密码登录成功之后，passport会通过带着一个可逆加密的包含用户信息的token，重定向到<code>www.site.com</code>提供的回调处理地址，然后进行解密，匹配正确，则登录用户。<br>要注意的是，这里的加密的信息需要包含一个时间戳，接收方需要认证这个时间戳，过期登录失败。避免token被窃取，被无限登录site系统。</p>\n<h2 id=\"单点登录\"><a href=\"#单点登录\" class=\"headerlink\" title=\"单点登录\"></a>单点登录</h2><p>单点登录需要实现的需求，说白了就是在站点A的登录了，那么用户就自动在站点B、站点C、站点E、F、G登录。<br>这又分两种情况，A站点和B站点是否在同一个二级域名下。<br>假如是在同一个域名下，例如<code>siteA.site.com</code>与<code>siteB.site.com</code>，因为cookie允许设置到二级域名下<code>.site.com</code>，所以siteA和siteB是可以共享cookie的，用户的信息可以通过可逆加密放在二级域名下的cookie，并且设置<code>http only</code>，就可以一站登录，站站登录。<br>而如果A站点和B站点不在同一二级域名下，例如<code>www.siteA.com</code>与<code>www.siteB.com</code>，他们就无法通过共享cookie的方式共享用户信息，所以需要用到jsonp的方式，用户在siteA登录之后，提供一个jsonp接口获取加密的用户信息，siteB访问这个jsonp获取加密信息。达到共享用户状态的效果。<br>欲知更多有关「单点登录」请点击传送门：<a href=\"http://www.jianshu.com/p/613e44d4a464\" target=\"_blank\" rel=\"external\">单点登录的三种实现方式</a></p>\n<h2 id=\"OAuth2-0登录\"><a href=\"#OAuth2-0登录\" class=\"headerlink\" title=\"OAuth2.0登录\"></a>OAuth2.0登录</h2><p>这就比较普遍了，现在随随便便做个网站，都接入「微信登录」、「微博登录」、「豆瓣登录」、「QQ登录」、「Github登录」、<em>@^</em>&amp;@%#^%^@%&amp;%@&amp;#……..<br>这些统一叫做：「第三方登录」。<br>第三方登录都是实现了OAuth2.0协议的，流程大概是酱紫的：<br>第三方提供一个登录入口，也就是第三方域名下的登录页面。主站需要登录的时候，引导用户重定向到第三方的登录页面，用户输入账号密码之后，登录第三方系统，第三方系统匹配帐号成功之后，带上一个code到主站的回调地址，主站接收到code，短时间内拿着code请求第三方提供获取长期凭证的接口(因为code有一个比较短的过期时间)，这个长期凭证叫<code>access_token</code>，获取之后就把这个<code>access_token</code>存到数据库中，请求一些第三方提供的API，需要用到这个<code>access_token</code>，因为这个token就是记录用户在第三方系统的一个身份凭证。<br>一些系统，在获取<code>access_token</code>的时候，还会返回一个副参数<code>refresh_token</code>，因为<code>access_token</code>是有过期时间的，一旦过期了，主站可以使用<code>refresh_token</code>请求第三方提供的接口获取新的<code>access_token</code>以及新的<code>refresh_token</code>。<br>在Nodejs中，你可以使用<code>passport</code>来给第三方登录提供一个统一解决方案，而如果你是开发「微信公众号」授权，除了<a href=\"https://www.npmjs.com/package/passport\" target=\"_blank\" rel=\"external\">passport</a>，也可以使用<a href=\"https://www.npmjs.com/package/wechat-oauth\" target=\"_blank\" rel=\"external\">wechat-oauth</a></p>\n<h2 id=\"在最后\"><a href=\"#在最后\" class=\"headerlink\" title=\"在最后\"></a>在最后</h2><p>其实登录问题，理解了Session原理是很重要的，这个也不难理解。然后站点之间的用户信息交流，就是通过各种跨域限制，各种加密解密而已。在做这个的时候，需要充分考虑到加密的token是否会被窃取的可能性，还要考虑让这个token加上时间的验证，在一些可能会被窃取，安全需求比较高的情况，就需要把token的时间设置的更短。还有就是加密的方式需要依照需求不同而选择可逆或者不可逆，hash sha1还是JWT(Json Web Token)。<br>sha1加密，可以使用Nodejs自带的<code>crypto</code>，JWT可以使用<a href=\"\">jsonwebtoken</a></p>\n","excerpt":"","more":"<p>也不知道是什么原因，刚开始不久的职业生涯，在技术这条路走着走着，和「登录」总是有着一个不解之缘。还记得当初学习Web编程的时候么？不管是Java、.Net、PHP，继经典「Hello World」之后，要写的很有可能就是「登录」功能。至今「登录」的问题还是让我心中一万只草泥马奔过。<br>下面，给分享一下各种「登录」相关的需求</p>\n<h2 id=\"普通的登录\"><a href=\"#普通的登录\" class=\"headerlink\" title=\"普通的登录\"></a>普通的登录</h2><p>这个是极其普通的登录需求，要的就是一个登录页面，输入账号密码，提交Form表单，后端查询数据库对应用户名的密码，匹配正确则把用户记录到Session，不正确则返回错误。<br>这种登录，在上学的时候，也许敬爱的老师就已经教过你了。<br>但可能他没有教你的是，密码需要hash加密，session为什么可以记录登录用户的原理。</p>\n<p><strong>密码Hash</strong><br>密码hash，就是存进数据库的密码是一串密文，密文是明文密码通过不可逆算法得出的。在Nodejs中，你可以使用<a href=\"https://www.npmjs.com/package/bcryptjs\">bcryptjs</a>，它提供了<code>hash</code>以及对应的<code>compare</code>方法，非常适合用于密码的加密和对比。</p>\n<p><strong>Session原理</strong><br>Session的原理其实还是依赖了Cookie，所以Cookie才是记录用户凭证的真理。它的原理大概是酱紫的：服务器端维护一个session的表，这个表的每一条记录存的就是与某一个客户端的会话，会话会有过期时间，过期的会话会被清理。然后这个会话，会有一个对应的id，一般是一串长长的看不懂的字符串，然后这个字符串会被存储在客户端的cookie中，每一次请求服务器端都会带上这个cookie，服务器端就知道访问的就是哪个客户端了。<br>欲知更多有关「Session原理」请点击传送门：<a href=\"http://www.jianshu.com/p/2b7c10291aad\">Session原理</a></p>\n<h2 id=\"使用独立登录系统\"><a href=\"#使用独立登录系统\" class=\"headerlink\" title=\"使用独立登录系统\"></a>使用独立登录系统</h2><p>应项目需要，登录逻辑需要独立出来做成一个系统，就是另外一个项目。与原来的主站不是在同一个项目中了。一个域名是 <code>www.site.com</code>，一个则是<code>passport.site.com</code>了。要在不同的域名下进行登录，一般的方法是<code>www.site.com/login</code> 跳转到 <code>passport.site.com/login</code>，passport这边是一个登录页面，用户输入账号密码登录成功之后，passport会通过带着一个可逆加密的包含用户信息的token，重定向到<code>www.site.com</code>提供的回调处理地址，然后进行解密，匹配正确，则登录用户。<br>要注意的是，这里的加密的信息需要包含一个时间戳，接收方需要认证这个时间戳，过期登录失败。避免token被窃取，被无限登录site系统。</p>\n<h2 id=\"单点登录\"><a href=\"#单点登录\" class=\"headerlink\" title=\"单点登录\"></a>单点登录</h2><p>单点登录需要实现的需求，说白了就是在站点A的登录了，那么用户就自动在站点B、站点C、站点E、F、G登录。<br>这又分两种情况，A站点和B站点是否在同一个二级域名下。<br>假如是在同一个域名下，例如<code>siteA.site.com</code>与<code>siteB.site.com</code>，因为cookie允许设置到二级域名下<code>.site.com</code>，所以siteA和siteB是可以共享cookie的，用户的信息可以通过可逆加密放在二级域名下的cookie，并且设置<code>http only</code>，就可以一站登录，站站登录。<br>而如果A站点和B站点不在同一二级域名下，例如<code>www.siteA.com</code>与<code>www.siteB.com</code>，他们就无法通过共享cookie的方式共享用户信息，所以需要用到jsonp的方式，用户在siteA登录之后，提供一个jsonp接口获取加密的用户信息，siteB访问这个jsonp获取加密信息。达到共享用户状态的效果。<br>欲知更多有关「单点登录」请点击传送门：<a href=\"http://www.jianshu.com/p/613e44d4a464\">单点登录的三种实现方式</a></p>\n<h2 id=\"OAuth2-0登录\"><a href=\"#OAuth2-0登录\" class=\"headerlink\" title=\"OAuth2.0登录\"></a>OAuth2.0登录</h2><p>这就比较普遍了，现在随随便便做个网站，都接入「微信登录」、「微博登录」、「豆瓣登录」、「QQ登录」、「Github登录」、<em>@^</em>&amp;@%#^%^@%&amp;%@&amp;#……..<br>这些统一叫做：「第三方登录」。<br>第三方登录都是实现了OAuth2.0协议的，流程大概是酱紫的：<br>第三方提供一个登录入口，也就是第三方域名下的登录页面。主站需要登录的时候，引导用户重定向到第三方的登录页面，用户输入账号密码之后，登录第三方系统，第三方系统匹配帐号成功之后，带上一个code到主站的回调地址，主站接收到code，短时间内拿着code请求第三方提供获取长期凭证的接口(因为code有一个比较短的过期时间)，这个长期凭证叫<code>access_token</code>，获取之后就把这个<code>access_token</code>存到数据库中，请求一些第三方提供的API，需要用到这个<code>access_token</code>，因为这个token就是记录用户在第三方系统的一个身份凭证。<br>一些系统，在获取<code>access_token</code>的时候，还会返回一个副参数<code>refresh_token</code>，因为<code>access_token</code>是有过期时间的，一旦过期了，主站可以使用<code>refresh_token</code>请求第三方提供的接口获取新的<code>access_token</code>以及新的<code>refresh_token</code>。<br>在Nodejs中，你可以使用<code>passport</code>来给第三方登录提供一个统一解决方案，而如果你是开发「微信公众号」授权，除了<a href=\"https://www.npmjs.com/package/passport\">passport</a>，也可以使用<a href=\"https://www.npmjs.com/package/wechat-oauth\">wechat-oauth</a></p>\n<h2 id=\"在最后\"><a href=\"#在最后\" class=\"headerlink\" title=\"在最后\"></a>在最后</h2><p>其实登录问题，理解了Session原理是很重要的，这个也不难理解。然后站点之间的用户信息交流，就是通过各种跨域限制，各种加密解密而已。在做这个的时候，需要充分考虑到加密的token是否会被窃取的可能性，还要考虑让这个token加上时间的验证，在一些可能会被窃取，安全需求比较高的情况，就需要把token的时间设置的更短。还有就是加密的方式需要依照需求不同而选择可逆或者不可逆，hash sha1还是JWT(Json Web Token)。<br>sha1加密，可以使用Nodejs自带的<code>crypto</code>，JWT可以使用<a href=\"\">jsonwebtoken</a></p>\n"},{"title":"理解 CORS (Cross-Origin Resource Sharing)","date":"2016-05-15T15:22:25.000Z","_content":"\n## 存在即是合理\n> 首先理解一下「跨站HTTP请求」\n\n跨站HTTP(Cross-Site HTTP Reuqest)请求，是指发起请求的资源所在域不同于该请求所指向资源所在域的HTTP请求。\n比如说，域名A(`http://domaina.example`)的某 Web 应用程序中通过`<img>`标签引入了域名B(`http://domainb.foo`)站点的某图片资源(`http://domainb.foo/image.jpg`)，域名A的那 Web 应用就会导致浏览器发起一个跨站 HTTP 请求。\n在现在的Web开发中，使用跨站HTTP请求加载各类资源(包括CSS、图片、JavaScript脚本以及其他类资源)，已经成为了一种普遍且流行的方式。\n\n> 出于安全考虑，浏览器会限制脚本中发起的跨站请求\n\n比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。\n要注意的是，跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是CSRF跨站攻击原理，请求是发送到了后端服务器无论是否跨域。\n\n\n## 理解同源策略\n\n[Cross-Site Sharing Standard](https://www.w3.org/TR/cors) 是W3C推荐的一种机制，让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。下面截取其中「[Syntax](https://www.w3.org/TR/cors/#syntax)」章节，来说明一下请求与响应的规范。\n\n\n> For Response\n\n### Access-Control-Allow-Origin Response Header\n该请求头表示所请求的资源是否接受来自指定origin(根据 Origin Request Header)的请求.\n```\nAccess-Control-Allow-Origin: <origin> | *\n```\n举个栗子,允许来自 http://baidu.com 的请求,你可以这样指定:\n```\nAccess-Control-Allow-Origin: http://baidu.com\n```\n\n### Access-Control-Allow-Credentials Response Heade\n告知客户端,当请求的credientials属性是true的时候,响应是否可以被得到.当它作为预请求的响应的一部分时,它用来告知实际的请求是否使用了credentials.注意,简单的GET请求不会预检,所以如果一个请求是为了得到一个带有credentials的资源,而响应里又没有Access-Control-Allow-Credentials头信息,那么说明这个响应被忽略了.\n```\nAccess-Control-Allow-Credentials: true | false\n```\n\n### Access-Control-Expose-Headers Response Header\n设置浏览器允许访问的服务器响应请求的头信息的白名单:\n```\nAccess-Control-Expose-Headers: X-A-Custom-Header, X-B-Custom-Header\n```\n这样，浏览器就可以得到服务器响应请求的头信息中的` X-A-Custom-Header`、` X-B-Custom-Header`\n\n### Access-Control-Max-Age Response Header\n这个头告诉我们这次预请求的结果的有效期是多久：\n```\nAccess-Control-Max-Age: <delta-seconds>\n```\n`delta-seconds` 参数表示,允许这个预请求的参数缓存的秒数,在此期间,不用发出另一条预检请求. \n\n### Access-Control-Allow-Methods Response Header\n指明资源可以被请求的方式有哪些(一个或者多个). 这个响应头信息在客户端发出预检请求的时候会被返回.\n```\nAccess-Control-Allow-Methods: <method>[, <method>]*\n```\n\n### Access-Control-Allow-Headers Response Header\n也是在响应预检请求的时候使用.用来指明在实际的请求中,可以使用哪些自定义HTTP请求头.比如\n```\nAccess-Control-Allow-Headers: X-Custom-Header\n```\n这样在实际的请求里,请求头信息里就可以有这么一条:\n```\nX-Custom-Header: hello world\n```\n\n> For Request\n\n### Origin Request Header\n表明发送请求或者预请求的域\n```\nOrigin: <origin>\n```\n参数`origin`是一个URI,告诉服务器端,请求来自哪里.它不包含任何路径信息,只是服务器名.\n\n### Access-Control-Request-Method Request Header\n在发出预检请求时带有这个头信息,告诉服务器在实际请求时会使用的请求方式\n```\nAccess-Control-Request-Method: <method>\n```\n\n### Access-Control-Request-Headers\n在发出预检请求时带有这个头信息,告诉服务器在实际请求时会携带的自定义头信息.如有多个,可以用逗号分开.\n```\nAccess-Control-Request-Headers: <field-name>[, <field-name>]*\n```\n\n\n## 举三个栗子\n### 一个简单的请求\n比如说，假如站点 `http://foo.example` 的网页应用想要访问 `http://bar.other` 的资源。以下的 JavaScript 代码应该会在 foo.example 上执行：\n```\nvar invocation = new XMLHttpRequest();\nvar url = 'http://bar.other/resources/public-data/';\n   \nfunction callOtherDomain() {\n  if(invocation) {    \n    invocation.open('GET', url, true);\n    invocation.onreadystatechange = handler;\n    invocation.send(); \n  }\n}\n```\n让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：\n```\nGET /resources/public-data/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nReferer: http://foo.example/examples/access-control/simpleXSInvocation.html\nOrigin: http://foo.example\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 00:23:53 GMT\nServer: Apache/2.0.61 \nAccess-Control-Allow-Origin: *\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nTransfer-Encoding: chunked\nContent-Type: application/xml\n\n[XML Data]\n```\n第 1~10 行是 浏览器 发出的请求头。注意看第10行的请求头 Origin，它表明了该请求来自于 `http://foo.exmaple`。\n\n第 13~22 行则是 `http://bar.other` 服务器的响应。如第16行所示，服务器返回了响应头 Access-Control-Allow-Origin: *，这表明服务器接受来自任何站点的跨站请求。如果服务器端仅允许来自 `http://foo.example` 的跨站请求，它可以返回：\n```\nAccess-Control-Allow-Origin: http://foo.example\n```\n现在，除了 `http://foo.example`，其它站点就不能跨站访问 `http://bar.other` 的资源了。\n\n如上，通过使用 Origin 和 Access-Control-Allow-Origin 就可以完成最简单的跨站请求。不过 Access-Control-Allow-Origin 需要为 * 或者包含由 Origin 指明的站点。\n\n### 预请求 Prefilght\n不同于上面讨论的简单请求，“预请求”要求必须先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。 当请求具备以下条件，就会被当成预请求处理：\n\n* 请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。\n* 使用自定义请求头（比如添加诸如 X-PINGOTHER\n\n如示例：\n```\nvar invocation = new XMLHttpRequest();\nvar url = 'http://bar.other/resources/post-here/';\nvar body = '{C}{C}{C}{C}{C}{C}{C}{C}{C}{C}Arun';\n    \nfunction callOtherDomain(){\n  if(invocation)\n    {\n      invocation.open('POST', url, true);\n      invocation.setRequestHeader('X-PINGOTHER', 'pingpong');\n      invocation.setRequestHeader('Content-Type', 'application/xml');\n      invocation.onreadystatechange = handler;\n      invocation.send(body); \n    }\n\n......\n```\n如上，以 XMLHttpRequest 创建了一个 POST 请求，为该请求添加了一个自定义请求头(X-PINGOTHER: pingpong)，并指定数据类型为 application/xml。所以，该请求是一个“预请求”形式的跨站请求。\n\n让我们看看服务器与浏览器之间具体的交互过程：\n```\nOPTIONS /resources/post-here/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nOrigin: http://foo.example\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER\nAccess-Control-Max-Age: 1728000\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n\nPOST /resources/post-here/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nX-PINGOTHER: pingpong\nContent-Type: text/xml; charset=UTF-8\nReferer: http://foo.example/examples/preflightInvocation.html\nContent-Length: 55\nOrigin: http://foo.example\nPragma: no-cache\nCache-Control: no-cache\n\nArun\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:40 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://foo.example\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 235\nKeep-Alive: timeout=2, max=99\nConnection: Keep-Alive\nContent-Type: text/plain\n\n[Some GZIP'd payload]\n```\n第1至12行，使用一个 OPTIONS 发送了一个“预请求”。浏览器 根据请求参数，决定需要发送一个“预请求”，来探明服务器端是否接受后续真正的请求。 OPTIONS 是 HTTP/1.1 里的方法，用来获取更多服务器端的信息，是一个不应该对服务器数据造成影响的方法。 随同 OPTIONS 请求，以下两个请求头一起被发送：\n```\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER\n```\n请求头Access-Control-Request-Method可以提醒服务器跨站请求将使用POST方法，而请求头Access-Control-Request-Headers则告知服务器该跨站请求将携带一个自定义请求头X-PINGOTHER。这样，服务器就可以决定，在当前情况下，是否接受该跨站请求访问。\n\n第15至27行是服务器的响应。该响应表明，服务器接受了客服端的跨站请求。具体可以看看第18至21行：\n```\nAccess-Control-Allow-Origin: http://foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER\nAccess-Control-Max-Age: 1728000\n```\n响应头Access-Control-Allow-Methods表明服务器可以接受POST, GET和 OPTIONS的请求方法。请注意，这个响应头类似于HTTP/1.1 Allow: response header，但仅限于访问控制的场景下。而响应头Access-Control-Allow-Headers则表示服务器接受自定义请求头X-PINGOTHER。就像Access-Control-Allow-Methods一样，Access-Control-Allow-Headers允许以逗号分隔，传递一个可接受的自定义请求头列表。最后，响应头Access-Control-Max-Age告诉浏览器，本次“预请求”的响应结果有效时间是多久。在上面的例子里，1728000秒代表着20天内，浏览器在处理针对该服务器的跨站请求，都可以无需再发送“预请求”，只需根据本次结果进行判断处理。\n\n\n### 附带凭证信息的请求\nXMLHttpRequest和访问控制功能，最有趣的特性就是，发送凭证请求（HTTP Cookies和验证信息）的功能。一般而言，对于跨站请求，浏览器是不会发送凭证信息的。但如果将XMLHttpRequest的一个特殊标志位设置为true，浏览器就将允许该请求的发送。\n\n`http://foo.example`站点的脚本向`http://bar.other`站点发送一个GET请求，并设置了一个Cookies值。脚本代码如下：\n```\nvar invocation = new XMLHttpRequest();\nvar url = 'http://bar.other/resources/credentialed-content/';\n    \nfunction callOtherDomain(){\n  if(invocation) {\n    invocation.open('GET', url, true);\n    invocation.withCredentials = true;\n    invocation.onreadystatechange = handler;\n    invocation.send(); \n  }\n```\n如你所见，第七行代码将XMLHttpRequest的withCredentials标志设置为true，从而使得Cookies可以随着请求发送。因为这是一个简单的GET请求，所以浏览器不会发送一个“预请求”。但是，如果服务器端的响应中，如果没有返回Access-Control-Allow-Credentials: true的响应头，那么浏览器将不会把响应结果传递给发出请求的脚本程序，以保证信息的安全。\n\n客服端与服务器端交互示例如下：\n```\nGET /resources/access-control-with-credentials/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nReferer: http://foo.example/examples/credential.html\nOrigin: http://foo.example\nCookie: pageAccess=2\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:34:52 GMT\nServer: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2\nX-Powered-By: PHP/5.2.6\nAccess-Control-Allow-Origin: http://foo.example\nAccess-Control-Allow-Credentials: true\nCache-Control: no-cache\nPragma: no-cache\nSet-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 106\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n\n\n[text/plain payload]\n```\n虽然第11行指定了要提交到`http://bar.other`的内容的Cookie信息,但是如果bar.other的响应头里没有Access-Control-Allow-Credentials:true(第19行),则响应会被忽略. 特别注意: 给一个带有withCredentials的请求发送响应的时候,服务器端必须指定允许请求的域名,不能使用'*'.上面这个例子中,如果响应头是这样的:Access-Control-Allow-Origin: * ,则响应会失败. 在这个例子里,因为Access-Control-Allow-Origin的值是`http://foo.example`这个指定的请求域名,所以客户端把带有凭证信息的内容被返回给了客户端. 另外注意第22行,更多的cookie信息也被创建了\n\n## 参考\n[Access_control_CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)\n[Cross-Origin Resource Sharing Standard](https://www.w3.org/TR/cors/)\n[Same-origin_policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)","source":"_posts/理解 CORS (Cross-Origin Resource Sharing).md","raw":"---\ntitle: 理解 CORS (Cross-Origin Resource Sharing)\ncategory: 搬砖码农\ndate: 2016-05-15 23:22:25\ntags: \n- http\n- cors\n---\n\n## 存在即是合理\n> 首先理解一下「跨站HTTP请求」\n\n跨站HTTP(Cross-Site HTTP Reuqest)请求，是指发起请求的资源所在域不同于该请求所指向资源所在域的HTTP请求。\n比如说，域名A(`http://domaina.example`)的某 Web 应用程序中通过`<img>`标签引入了域名B(`http://domainb.foo`)站点的某图片资源(`http://domainb.foo/image.jpg`)，域名A的那 Web 应用就会导致浏览器发起一个跨站 HTTP 请求。\n在现在的Web开发中，使用跨站HTTP请求加载各类资源(包括CSS、图片、JavaScript脚本以及其他类资源)，已经成为了一种普遍且流行的方式。\n\n> 出于安全考虑，浏览器会限制脚本中发起的跨站请求\n\n比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。\n要注意的是，跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是CSRF跨站攻击原理，请求是发送到了后端服务器无论是否跨域。\n\n\n## 理解同源策略\n\n[Cross-Site Sharing Standard](https://www.w3.org/TR/cors) 是W3C推荐的一种机制，让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。下面截取其中「[Syntax](https://www.w3.org/TR/cors/#syntax)」章节，来说明一下请求与响应的规范。\n\n\n> For Response\n\n### Access-Control-Allow-Origin Response Header\n该请求头表示所请求的资源是否接受来自指定origin(根据 Origin Request Header)的请求.\n```\nAccess-Control-Allow-Origin: <origin> | *\n```\n举个栗子,允许来自 http://baidu.com 的请求,你可以这样指定:\n```\nAccess-Control-Allow-Origin: http://baidu.com\n```\n\n### Access-Control-Allow-Credentials Response Heade\n告知客户端,当请求的credientials属性是true的时候,响应是否可以被得到.当它作为预请求的响应的一部分时,它用来告知实际的请求是否使用了credentials.注意,简单的GET请求不会预检,所以如果一个请求是为了得到一个带有credentials的资源,而响应里又没有Access-Control-Allow-Credentials头信息,那么说明这个响应被忽略了.\n```\nAccess-Control-Allow-Credentials: true | false\n```\n\n### Access-Control-Expose-Headers Response Header\n设置浏览器允许访问的服务器响应请求的头信息的白名单:\n```\nAccess-Control-Expose-Headers: X-A-Custom-Header, X-B-Custom-Header\n```\n这样，浏览器就可以得到服务器响应请求的头信息中的` X-A-Custom-Header`、` X-B-Custom-Header`\n\n### Access-Control-Max-Age Response Header\n这个头告诉我们这次预请求的结果的有效期是多久：\n```\nAccess-Control-Max-Age: <delta-seconds>\n```\n`delta-seconds` 参数表示,允许这个预请求的参数缓存的秒数,在此期间,不用发出另一条预检请求. \n\n### Access-Control-Allow-Methods Response Header\n指明资源可以被请求的方式有哪些(一个或者多个). 这个响应头信息在客户端发出预检请求的时候会被返回.\n```\nAccess-Control-Allow-Methods: <method>[, <method>]*\n```\n\n### Access-Control-Allow-Headers Response Header\n也是在响应预检请求的时候使用.用来指明在实际的请求中,可以使用哪些自定义HTTP请求头.比如\n```\nAccess-Control-Allow-Headers: X-Custom-Header\n```\n这样在实际的请求里,请求头信息里就可以有这么一条:\n```\nX-Custom-Header: hello world\n```\n\n> For Request\n\n### Origin Request Header\n表明发送请求或者预请求的域\n```\nOrigin: <origin>\n```\n参数`origin`是一个URI,告诉服务器端,请求来自哪里.它不包含任何路径信息,只是服务器名.\n\n### Access-Control-Request-Method Request Header\n在发出预检请求时带有这个头信息,告诉服务器在实际请求时会使用的请求方式\n```\nAccess-Control-Request-Method: <method>\n```\n\n### Access-Control-Request-Headers\n在发出预检请求时带有这个头信息,告诉服务器在实际请求时会携带的自定义头信息.如有多个,可以用逗号分开.\n```\nAccess-Control-Request-Headers: <field-name>[, <field-name>]*\n```\n\n\n## 举三个栗子\n### 一个简单的请求\n比如说，假如站点 `http://foo.example` 的网页应用想要访问 `http://bar.other` 的资源。以下的 JavaScript 代码应该会在 foo.example 上执行：\n```\nvar invocation = new XMLHttpRequest();\nvar url = 'http://bar.other/resources/public-data/';\n   \nfunction callOtherDomain() {\n  if(invocation) {    \n    invocation.open('GET', url, true);\n    invocation.onreadystatechange = handler;\n    invocation.send(); \n  }\n}\n```\n让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：\n```\nGET /resources/public-data/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nReferer: http://foo.example/examples/access-control/simpleXSInvocation.html\nOrigin: http://foo.example\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 00:23:53 GMT\nServer: Apache/2.0.61 \nAccess-Control-Allow-Origin: *\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nTransfer-Encoding: chunked\nContent-Type: application/xml\n\n[XML Data]\n```\n第 1~10 行是 浏览器 发出的请求头。注意看第10行的请求头 Origin，它表明了该请求来自于 `http://foo.exmaple`。\n\n第 13~22 行则是 `http://bar.other` 服务器的响应。如第16行所示，服务器返回了响应头 Access-Control-Allow-Origin: *，这表明服务器接受来自任何站点的跨站请求。如果服务器端仅允许来自 `http://foo.example` 的跨站请求，它可以返回：\n```\nAccess-Control-Allow-Origin: http://foo.example\n```\n现在，除了 `http://foo.example`，其它站点就不能跨站访问 `http://bar.other` 的资源了。\n\n如上，通过使用 Origin 和 Access-Control-Allow-Origin 就可以完成最简单的跨站请求。不过 Access-Control-Allow-Origin 需要为 * 或者包含由 Origin 指明的站点。\n\n### 预请求 Prefilght\n不同于上面讨论的简单请求，“预请求”要求必须先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。 当请求具备以下条件，就会被当成预请求处理：\n\n* 请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。\n* 使用自定义请求头（比如添加诸如 X-PINGOTHER\n\n如示例：\n```\nvar invocation = new XMLHttpRequest();\nvar url = 'http://bar.other/resources/post-here/';\nvar body = '{C}{C}{C}{C}{C}{C}{C}{C}{C}{C}Arun';\n    \nfunction callOtherDomain(){\n  if(invocation)\n    {\n      invocation.open('POST', url, true);\n      invocation.setRequestHeader('X-PINGOTHER', 'pingpong');\n      invocation.setRequestHeader('Content-Type', 'application/xml');\n      invocation.onreadystatechange = handler;\n      invocation.send(body); \n    }\n\n......\n```\n如上，以 XMLHttpRequest 创建了一个 POST 请求，为该请求添加了一个自定义请求头(X-PINGOTHER: pingpong)，并指定数据类型为 application/xml。所以，该请求是一个“预请求”形式的跨站请求。\n\n让我们看看服务器与浏览器之间具体的交互过程：\n```\nOPTIONS /resources/post-here/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nOrigin: http://foo.example\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER\nAccess-Control-Max-Age: 1728000\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n\nPOST /resources/post-here/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nX-PINGOTHER: pingpong\nContent-Type: text/xml; charset=UTF-8\nReferer: http://foo.example/examples/preflightInvocation.html\nContent-Length: 55\nOrigin: http://foo.example\nPragma: no-cache\nCache-Control: no-cache\n\nArun\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:40 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://foo.example\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 235\nKeep-Alive: timeout=2, max=99\nConnection: Keep-Alive\nContent-Type: text/plain\n\n[Some GZIP'd payload]\n```\n第1至12行，使用一个 OPTIONS 发送了一个“预请求”。浏览器 根据请求参数，决定需要发送一个“预请求”，来探明服务器端是否接受后续真正的请求。 OPTIONS 是 HTTP/1.1 里的方法，用来获取更多服务器端的信息，是一个不应该对服务器数据造成影响的方法。 随同 OPTIONS 请求，以下两个请求头一起被发送：\n```\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: X-PINGOTHER\n```\n请求头Access-Control-Request-Method可以提醒服务器跨站请求将使用POST方法，而请求头Access-Control-Request-Headers则告知服务器该跨站请求将携带一个自定义请求头X-PINGOTHER。这样，服务器就可以决定，在当前情况下，是否接受该跨站请求访问。\n\n第15至27行是服务器的响应。该响应表明，服务器接受了客服端的跨站请求。具体可以看看第18至21行：\n```\nAccess-Control-Allow-Origin: http://foo.example\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER\nAccess-Control-Max-Age: 1728000\n```\n响应头Access-Control-Allow-Methods表明服务器可以接受POST, GET和 OPTIONS的请求方法。请注意，这个响应头类似于HTTP/1.1 Allow: response header，但仅限于访问控制的场景下。而响应头Access-Control-Allow-Headers则表示服务器接受自定义请求头X-PINGOTHER。就像Access-Control-Allow-Methods一样，Access-Control-Allow-Headers允许以逗号分隔，传递一个可接受的自定义请求头列表。最后，响应头Access-Control-Max-Age告诉浏览器，本次“预请求”的响应结果有效时间是多久。在上面的例子里，1728000秒代表着20天内，浏览器在处理针对该服务器的跨站请求，都可以无需再发送“预请求”，只需根据本次结果进行判断处理。\n\n\n### 附带凭证信息的请求\nXMLHttpRequest和访问控制功能，最有趣的特性就是，发送凭证请求（HTTP Cookies和验证信息）的功能。一般而言，对于跨站请求，浏览器是不会发送凭证信息的。但如果将XMLHttpRequest的一个特殊标志位设置为true，浏览器就将允许该请求的发送。\n\n`http://foo.example`站点的脚本向`http://bar.other`站点发送一个GET请求，并设置了一个Cookies值。脚本代码如下：\n```\nvar invocation = new XMLHttpRequest();\nvar url = 'http://bar.other/resources/credentialed-content/';\n    \nfunction callOtherDomain(){\n  if(invocation) {\n    invocation.open('GET', url, true);\n    invocation.withCredentials = true;\n    invocation.onreadystatechange = handler;\n    invocation.send(); \n  }\n```\n如你所见，第七行代码将XMLHttpRequest的withCredentials标志设置为true，从而使得Cookies可以随着请求发送。因为这是一个简单的GET请求，所以浏览器不会发送一个“预请求”。但是，如果服务器端的响应中，如果没有返回Access-Control-Allow-Credentials: true的响应头，那么浏览器将不会把响应结果传递给发出请求的脚本程序，以保证信息的安全。\n\n客服端与服务器端交互示例如下：\n```\nGET /resources/access-control-with-credentials/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nReferer: http://foo.example/examples/credential.html\nOrigin: http://foo.example\nCookie: pageAccess=2\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:34:52 GMT\nServer: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2\nX-Powered-By: PHP/5.2.6\nAccess-Control-Allow-Origin: http://foo.example\nAccess-Control-Allow-Credentials: true\nCache-Control: no-cache\nPragma: no-cache\nSet-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 106\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n\n\n[text/plain payload]\n```\n虽然第11行指定了要提交到`http://bar.other`的内容的Cookie信息,但是如果bar.other的响应头里没有Access-Control-Allow-Credentials:true(第19行),则响应会被忽略. 特别注意: 给一个带有withCredentials的请求发送响应的时候,服务器端必须指定允许请求的域名,不能使用'*'.上面这个例子中,如果响应头是这样的:Access-Control-Allow-Origin: * ,则响应会失败. 在这个例子里,因为Access-Control-Allow-Origin的值是`http://foo.example`这个指定的请求域名,所以客户端把带有凭证信息的内容被返回给了客户端. 另外注意第22行,更多的cookie信息也被创建了\n\n## 参考\n[Access_control_CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)\n[Cross-Origin Resource Sharing Standard](https://www.w3.org/TR/cors/)\n[Same-origin_policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)","slug":"理解 CORS (Cross-Origin Resource Sharing)","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqu003515hla6ptz6o7","content":"<h2 id=\"存在即是合理\"><a href=\"#存在即是合理\" class=\"headerlink\" title=\"存在即是合理\"></a>存在即是合理</h2><blockquote>\n<p>首先理解一下「跨站HTTP请求」</p>\n</blockquote>\n<p>跨站HTTP(Cross-Site HTTP Reuqest)请求，是指发起请求的资源所在域不同于该请求所指向资源所在域的HTTP请求。<br>比如说，域名A(<code>http://domaina.example</code>)的某 Web 应用程序中通过<code>&lt;img&gt;</code>标签引入了域名B(<code>http://domainb.foo</code>)站点的某图片资源(<code>http://domainb.foo/image.jpg</code>)，域名A的那 Web 应用就会导致浏览器发起一个跨站 HTTP 请求。<br>在现在的Web开发中，使用跨站HTTP请求加载各类资源(包括CSS、图片、JavaScript脚本以及其他类资源)，已经成为了一种普遍且流行的方式。</p>\n<blockquote>\n<p>出于安全考虑，浏览器会限制脚本中发起的跨站请求</p>\n</blockquote>\n<p>比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。<br>要注意的是，跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是CSRF跨站攻击原理，请求是发送到了后端服务器无论是否跨域。</p>\n<h2 id=\"理解同源策略\"><a href=\"#理解同源策略\" class=\"headerlink\" title=\"理解同源策略\"></a>理解同源策略</h2><p><a href=\"https://www.w3.org/TR/cors\" target=\"_blank\" rel=\"external\">Cross-Site Sharing Standard</a> 是W3C推荐的一种机制，让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。下面截取其中「<a href=\"https://www.w3.org/TR/cors/#syntax\" target=\"_blank\" rel=\"external\">Syntax</a>」章节，来说明一下请求与响应的规范。</p>\n<blockquote>\n<p>For Response</p>\n</blockquote>\n<h3 id=\"Access-Control-Allow-Origin-Response-Header\"><a href=\"#Access-Control-Allow-Origin-Response-Header\" class=\"headerlink\" title=\"Access-Control-Allow-Origin Response Header\"></a>Access-Control-Allow-Origin Response Header</h3><p>该请求头表示所请求的资源是否接受来自指定origin(根据 Origin Request Header)的请求.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Origin: &lt;origin&gt; | *</div></pre></td></tr></table></figure></p>\n<p>举个栗子,允许来自 <a href=\"http://baidu.com\" target=\"_blank\" rel=\"external\">http://baidu.com</a> 的请求,你可以这样指定:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Origin: http://baidu.com</div></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Allow-Credentials-Response-Heade\"><a href=\"#Access-Control-Allow-Credentials-Response-Heade\" class=\"headerlink\" title=\"Access-Control-Allow-Credentials Response Heade\"></a>Access-Control-Allow-Credentials Response Heade</h3><p>告知客户端,当请求的credientials属性是true的时候,响应是否可以被得到.当它作为预请求的响应的一部分时,它用来告知实际的请求是否使用了credentials.注意,简单的GET请求不会预检,所以如果一个请求是为了得到一个带有credentials的资源,而响应里又没有Access-Control-Allow-Credentials头信息,那么说明这个响应被忽略了.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Credentials: true | false</div></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Expose-Headers-Response-Header\"><a href=\"#Access-Control-Expose-Headers-Response-Header\" class=\"headerlink\" title=\"Access-Control-Expose-Headers Response Header\"></a>Access-Control-Expose-Headers Response Header</h3><p>设置浏览器允许访问的服务器响应请求的头信息的白名单:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Expose-Headers: X-A-Custom-Header, X-B-Custom-Header</div></pre></td></tr></table></figure></p>\n<p>这样，浏览器就可以得到服务器响应请求的头信息中的<code>X-A-Custom-Header</code>、<code>X-B-Custom-Header</code></p>\n<h3 id=\"Access-Control-Max-Age-Response-Header\"><a href=\"#Access-Control-Max-Age-Response-Header\" class=\"headerlink\" title=\"Access-Control-Max-Age Response Header\"></a>Access-Control-Max-Age Response Header</h3><p>这个头告诉我们这次预请求的结果的有效期是多久：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Max-Age: &lt;delta-seconds&gt;</div></pre></td></tr></table></figure></p>\n<p><code>delta-seconds</code> 参数表示,允许这个预请求的参数缓存的秒数,在此期间,不用发出另一条预检请求. </p>\n<h3 id=\"Access-Control-Allow-Methods-Response-Header\"><a href=\"#Access-Control-Allow-Methods-Response-Header\" class=\"headerlink\" title=\"Access-Control-Allow-Methods Response Header\"></a>Access-Control-Allow-Methods Response Header</h3><p>指明资源可以被请求的方式有哪些(一个或者多个). 这个响应头信息在客户端发出预检请求的时候会被返回.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</div></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Allow-Headers-Response-Header\"><a href=\"#Access-Control-Allow-Headers-Response-Header\" class=\"headerlink\" title=\"Access-Control-Allow-Headers Response Header\"></a>Access-Control-Allow-Headers Response Header</h3><p>也是在响应预检请求的时候使用.用来指明在实际的请求中,可以使用哪些自定义HTTP请求头.比如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Headers: X-Custom-Header</div></pre></td></tr></table></figure></p>\n<p>这样在实际的请求里,请求头信息里就可以有这么一条:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">X-Custom-Header: hello world</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>For Request</p>\n</blockquote>\n<h3 id=\"Origin-Request-Header\"><a href=\"#Origin-Request-Header\" class=\"headerlink\" title=\"Origin Request Header\"></a>Origin Request Header</h3><p>表明发送请求或者预请求的域<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Origin: &lt;origin&gt;</div></pre></td></tr></table></figure></p>\n<p>参数<code>origin</code>是一个URI,告诉服务器端,请求来自哪里.它不包含任何路径信息,只是服务器名.</p>\n<h3 id=\"Access-Control-Request-Method-Request-Header\"><a href=\"#Access-Control-Request-Method-Request-Header\" class=\"headerlink\" title=\"Access-Control-Request-Method Request Header\"></a>Access-Control-Request-Method Request Header</h3><p>在发出预检请求时带有这个头信息,告诉服务器在实际请求时会使用的请求方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Request-Method: &lt;method&gt;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Request-Headers\"><a href=\"#Access-Control-Request-Headers\" class=\"headerlink\" title=\"Access-Control-Request-Headers\"></a>Access-Control-Request-Headers</h3><p>在发出预检请求时带有这个头信息,告诉服务器在实际请求时会携带的自定义头信息.如有多个,可以用逗号分开.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</div></pre></td></tr></table></figure></p>\n<h2 id=\"举三个栗子\"><a href=\"#举三个栗子\" class=\"headerlink\" title=\"举三个栗子\"></a>举三个栗子</h2><h3 id=\"一个简单的请求\"><a href=\"#一个简单的请求\" class=\"headerlink\" title=\"一个简单的请求\"></a>一个简单的请求</h3><p>比如说，假如站点 <code>http://foo.example</code> 的网页应用想要访问 <code>http://bar.other</code> 的资源。以下的 JavaScript 代码应该会在 foo.example 上执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var invocation = new XMLHttpRequest();</div><div class=\"line\">var url = &apos;http://bar.other/resources/public-data/&apos;;</div><div class=\"line\">   </div><div class=\"line\">function callOtherDomain() &#123;</div><div class=\"line\">  if(invocation) &#123;    </div><div class=\"line\">    invocation.open(&apos;GET&apos;, url, true);</div><div class=\"line\">    invocation.onreadystatechange = handler;</div><div class=\"line\">    invocation.send(); </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /resources/public-data/ HTTP/1.1</div><div class=\"line\">Host: bar.other</div><div class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</div><div class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class=\"line\">Accept-Language: en-us,en;q=0.5</div><div class=\"line\">Accept-Encoding: gzip,deflate</div><div class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">Referer: http://foo.example/examples/access-control/simpleXSInvocation.html</div><div class=\"line\">Origin: http://foo.example</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date: Mon, 01 Dec 2008 00:23:53 GMT</div><div class=\"line\">Server: Apache/2.0.61 </div><div class=\"line\">Access-Control-Allow-Origin: *</div><div class=\"line\">Keep-Alive: timeout=2, max=100</div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Transfer-Encoding: chunked</div><div class=\"line\">Content-Type: application/xml</div><div class=\"line\"></div><div class=\"line\">[XML Data]</div></pre></td></tr></table></figure></p>\n<p>第 1~10 行是 浏览器 发出的请求头。注意看第10行的请求头 Origin，它表明了该请求来自于 <code>http://foo.exmaple</code>。</p>\n<p>第 13~22 行则是 <code>http://bar.other</code> 服务器的响应。如第16行所示，服务器返回了响应头 Access-Control-Allow-Origin: *，这表明服务器接受来自任何站点的跨站请求。如果服务器端仅允许来自 <code>http://foo.example</code> 的跨站请求，它可以返回：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Origin: http://foo.example</div></pre></td></tr></table></figure></p>\n<p>现在，除了 <code>http://foo.example</code>，其它站点就不能跨站访问 <code>http://bar.other</code> 的资源了。</p>\n<p>如上，通过使用 Origin 和 Access-Control-Allow-Origin 就可以完成最简单的跨站请求。不过 Access-Control-Allow-Origin 需要为 * 或者包含由 Origin 指明的站点。</p>\n<h3 id=\"预请求-Prefilght\"><a href=\"#预请求-Prefilght\" class=\"headerlink\" title=\"预请求 Prefilght\"></a>预请求 Prefilght</h3><p>不同于上面讨论的简单请求，“预请求”要求必须先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。 当请求具备以下条件，就会被当成预请求处理：</p>\n<ul>\n<li>请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。</li>\n<li>使用自定义请求头（比如添加诸如 X-PINGOTHER</li>\n</ul>\n<p>如示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var invocation = new XMLHttpRequest();</div><div class=\"line\">var url = &apos;http://bar.other/resources/post-here/&apos;;</div><div class=\"line\">var body = &apos;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;Arun&apos;;</div><div class=\"line\">    </div><div class=\"line\">function callOtherDomain()&#123;</div><div class=\"line\">  if(invocation)</div><div class=\"line\">    &#123;</div><div class=\"line\">      invocation.open(&apos;POST&apos;, url, true);</div><div class=\"line\">      invocation.setRequestHeader(&apos;X-PINGOTHER&apos;, &apos;pingpong&apos;);</div><div class=\"line\">      invocation.setRequestHeader(&apos;Content-Type&apos;, &apos;application/xml&apos;);</div><div class=\"line\">      invocation.onreadystatechange = handler;</div><div class=\"line\">      invocation.send(body); </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">......</div></pre></td></tr></table></figure></p>\n<p>如上，以 XMLHttpRequest 创建了一个 POST 请求，为该请求添加了一个自定义请求头(X-PINGOTHER: pingpong)，并指定数据类型为 application/xml。所以，该请求是一个“预请求”形式的跨站请求。</p>\n<p>让我们看看服务器与浏览器之间具体的交互过程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">OPTIONS /resources/post-here/ HTTP/1.1</div><div class=\"line\">Host: bar.other</div><div class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</div><div class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class=\"line\">Accept-Language: en-us,en;q=0.5</div><div class=\"line\">Accept-Encoding: gzip,deflate</div><div class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">Origin: http://foo.example</div><div class=\"line\">Access-Control-Request-Method: POST</div><div class=\"line\">Access-Control-Request-Headers: X-PINGOTHER</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date: Mon, 01 Dec 2008 01:15:39 GMT</div><div class=\"line\">Server: Apache/2.0.61 (Unix)</div><div class=\"line\">Access-Control-Allow-Origin: http://foo.example</div><div class=\"line\">Access-Control-Allow-Methods: POST, GET, OPTIONS</div><div class=\"line\">Access-Control-Allow-Headers: X-PINGOTHER</div><div class=\"line\">Access-Control-Max-Age: 1728000</div><div class=\"line\">Vary: Accept-Encoding, Origin</div><div class=\"line\">Content-Encoding: gzip</div><div class=\"line\">Content-Length: 0</div><div class=\"line\">Keep-Alive: timeout=2, max=100</div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Content-Type: text/plain</div><div class=\"line\"></div><div class=\"line\">POST /resources/post-here/ HTTP/1.1</div><div class=\"line\">Host: bar.other</div><div class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</div><div class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class=\"line\">Accept-Language: en-us,en;q=0.5</div><div class=\"line\">Accept-Encoding: gzip,deflate</div><div class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">X-PINGOTHER: pingpong</div><div class=\"line\">Content-Type: text/xml; charset=UTF-8</div><div class=\"line\">Referer: http://foo.example/examples/preflightInvocation.html</div><div class=\"line\">Content-Length: 55</div><div class=\"line\">Origin: http://foo.example</div><div class=\"line\">Pragma: no-cache</div><div class=\"line\">Cache-Control: no-cache</div><div class=\"line\"></div><div class=\"line\">Arun</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date: Mon, 01 Dec 2008 01:15:40 GMT</div><div class=\"line\">Server: Apache/2.0.61 (Unix)</div><div class=\"line\">Access-Control-Allow-Origin: http://foo.example</div><div class=\"line\">Vary: Accept-Encoding, Origin</div><div class=\"line\">Content-Encoding: gzip</div><div class=\"line\">Content-Length: 235</div><div class=\"line\">Keep-Alive: timeout=2, max=99</div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Content-Type: text/plain</div><div class=\"line\"></div><div class=\"line\">[Some GZIP&apos;d payload]</div></pre></td></tr></table></figure></p>\n<p>第1至12行，使用一个 OPTIONS 发送了一个“预请求”。浏览器 根据请求参数，决定需要发送一个“预请求”，来探明服务器端是否接受后续真正的请求。 OPTIONS 是 HTTP/1.1 里的方法，用来获取更多服务器端的信息，是一个不应该对服务器数据造成影响的方法。 随同 OPTIONS 请求，以下两个请求头一起被发送：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Request-Method: POST</div><div class=\"line\">Access-Control-Request-Headers: X-PINGOTHER</div></pre></td></tr></table></figure></p>\n<p>请求头Access-Control-Request-Method可以提醒服务器跨站请求将使用POST方法，而请求头Access-Control-Request-Headers则告知服务器该跨站请求将携带一个自定义请求头X-PINGOTHER。这样，服务器就可以决定，在当前情况下，是否接受该跨站请求访问。</p>\n<p>第15至27行是服务器的响应。该响应表明，服务器接受了客服端的跨站请求。具体可以看看第18至21行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Origin: http://foo.example</div><div class=\"line\">Access-Control-Allow-Methods: POST, GET, OPTIONS</div><div class=\"line\">Access-Control-Allow-Headers: X-PINGOTHER</div><div class=\"line\">Access-Control-Max-Age: 1728000</div></pre></td></tr></table></figure></p>\n<p>响应头Access-Control-Allow-Methods表明服务器可以接受POST, GET和 OPTIONS的请求方法。请注意，这个响应头类似于HTTP/1.1 Allow: response header，但仅限于访问控制的场景下。而响应头Access-Control-Allow-Headers则表示服务器接受自定义请求头X-PINGOTHER。就像Access-Control-Allow-Methods一样，Access-Control-Allow-Headers允许以逗号分隔，传递一个可接受的自定义请求头列表。最后，响应头Access-Control-Max-Age告诉浏览器，本次“预请求”的响应结果有效时间是多久。在上面的例子里，1728000秒代表着20天内，浏览器在处理针对该服务器的跨站请求，都可以无需再发送“预请求”，只需根据本次结果进行判断处理。</p>\n<h3 id=\"附带凭证信息的请求\"><a href=\"#附带凭证信息的请求\" class=\"headerlink\" title=\"附带凭证信息的请求\"></a>附带凭证信息的请求</h3><p>XMLHttpRequest和访问控制功能，最有趣的特性就是，发送凭证请求（HTTP Cookies和验证信息）的功能。一般而言，对于跨站请求，浏览器是不会发送凭证信息的。但如果将XMLHttpRequest的一个特殊标志位设置为true，浏览器就将允许该请求的发送。</p>\n<p><code>http://foo.example</code>站点的脚本向<code>http://bar.other</code>站点发送一个GET请求，并设置了一个Cookies值。脚本代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var invocation = new XMLHttpRequest();</div><div class=\"line\">var url = &apos;http://bar.other/resources/credentialed-content/&apos;;</div><div class=\"line\">    </div><div class=\"line\">function callOtherDomain()&#123;</div><div class=\"line\">  if(invocation) &#123;</div><div class=\"line\">    invocation.open(&apos;GET&apos;, url, true);</div><div class=\"line\">    invocation.withCredentials = true;</div><div class=\"line\">    invocation.onreadystatechange = handler;</div><div class=\"line\">    invocation.send(); </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>如你所见，第七行代码将XMLHttpRequest的withCredentials标志设置为true，从而使得Cookies可以随着请求发送。因为这是一个简单的GET请求，所以浏览器不会发送一个“预请求”。但是，如果服务器端的响应中，如果没有返回Access-Control-Allow-Credentials: true的响应头，那么浏览器将不会把响应结果传递给发出请求的脚本程序，以保证信息的安全。</p>\n<p>客服端与服务器端交互示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /resources/access-control-with-credentials/ HTTP/1.1</div><div class=\"line\">Host: bar.other</div><div class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</div><div class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class=\"line\">Accept-Language: en-us,en;q=0.5</div><div class=\"line\">Accept-Encoding: gzip,deflate</div><div class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">Referer: http://foo.example/examples/credential.html</div><div class=\"line\">Origin: http://foo.example</div><div class=\"line\">Cookie: pageAccess=2</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date: Mon, 01 Dec 2008 01:34:52 GMT</div><div class=\"line\">Server: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2</div><div class=\"line\">X-Powered-By: PHP/5.2.6</div><div class=\"line\">Access-Control-Allow-Origin: http://foo.example</div><div class=\"line\">Access-Control-Allow-Credentials: true</div><div class=\"line\">Cache-Control: no-cache</div><div class=\"line\">Pragma: no-cache</div><div class=\"line\">Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT</div><div class=\"line\">Vary: Accept-Encoding, Origin</div><div class=\"line\">Content-Encoding: gzip</div><div class=\"line\">Content-Length: 106</div><div class=\"line\">Keep-Alive: timeout=2, max=100</div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Content-Type: text/plain</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[text/plain payload]</div></pre></td></tr></table></figure></p>\n<p>虽然第11行指定了要提交到<code>http://bar.other</code>的内容的Cookie信息,但是如果bar.other的响应头里没有Access-Control-Allow-Credentials:true(第19行),则响应会被忽略. 特别注意: 给一个带有withCredentials的请求发送响应的时候,服务器端必须指定允许请求的域名,不能使用’<em>‘.上面这个例子中,如果响应头是这样的:Access-Control-Allow-Origin: </em> ,则响应会失败. 在这个例子里,因为Access-Control-Allow-Origin的值是<code>http://foo.example</code>这个指定的请求域名,所以客户端把带有凭证信息的内容被返回给了客户端. 另外注意第22行,更多的cookie信息也被创建了</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\" target=\"_blank\" rel=\"external\">Access_control_CORS</a><br><a href=\"https://www.w3.org/TR/cors/\" target=\"_blank\" rel=\"external\">Cross-Origin Resource Sharing Standard</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"external\">Same-origin_policy</a></p>\n","excerpt":"","more":"<h2 id=\"存在即是合理\"><a href=\"#存在即是合理\" class=\"headerlink\" title=\"存在即是合理\"></a>存在即是合理</h2><blockquote>\n<p>首先理解一下「跨站HTTP请求」</p>\n</blockquote>\n<p>跨站HTTP(Cross-Site HTTP Reuqest)请求，是指发起请求的资源所在域不同于该请求所指向资源所在域的HTTP请求。<br>比如说，域名A(<code>http://domaina.example</code>)的某 Web 应用程序中通过<code>&lt;img&gt;</code>标签引入了域名B(<code>http://domainb.foo</code>)站点的某图片资源(<code>http://domainb.foo/image.jpg</code>)，域名A的那 Web 应用就会导致浏览器发起一个跨站 HTTP 请求。<br>在现在的Web开发中，使用跨站HTTP请求加载各类资源(包括CSS、图片、JavaScript脚本以及其他类资源)，已经成为了一种普遍且流行的方式。</p>\n<blockquote>\n<p>出于安全考虑，浏览器会限制脚本中发起的跨站请求</p>\n</blockquote>\n<p>比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略。 具体而言，Web 应用程序能且只能使用 XMLHttpRequest 对象向其加载的源域名发起 HTTP 请求，而不能向任何其它域名发起请求。<br>要注意的是，跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是CSRF跨站攻击原理，请求是发送到了后端服务器无论是否跨域。</p>\n<h2 id=\"理解同源策略\"><a href=\"#理解同源策略\" class=\"headerlink\" title=\"理解同源策略\"></a>理解同源策略</h2><p><a href=\"https://www.w3.org/TR/cors\">Cross-Site Sharing Standard</a> 是W3C推荐的一种机制，让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。下面截取其中「<a href=\"https://www.w3.org/TR/cors/#syntax\">Syntax</a>」章节，来说明一下请求与响应的规范。</p>\n<blockquote>\n<p>For Response</p>\n</blockquote>\n<h3 id=\"Access-Control-Allow-Origin-Response-Header\"><a href=\"#Access-Control-Allow-Origin-Response-Header\" class=\"headerlink\" title=\"Access-Control-Allow-Origin Response Header\"></a>Access-Control-Allow-Origin Response Header</h3><p>该请求头表示所请求的资源是否接受来自指定origin(根据 Origin Request Header)的请求.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Origin: &lt;origin&gt; | *</div></pre></td></tr></table></figure></p>\n<p>举个栗子,允许来自 <a href=\"http://baidu.com\">http://baidu.com</a> 的请求,你可以这样指定:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Origin: http://baidu.com</div></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Allow-Credentials-Response-Heade\"><a href=\"#Access-Control-Allow-Credentials-Response-Heade\" class=\"headerlink\" title=\"Access-Control-Allow-Credentials Response Heade\"></a>Access-Control-Allow-Credentials Response Heade</h3><p>告知客户端,当请求的credientials属性是true的时候,响应是否可以被得到.当它作为预请求的响应的一部分时,它用来告知实际的请求是否使用了credentials.注意,简单的GET请求不会预检,所以如果一个请求是为了得到一个带有credentials的资源,而响应里又没有Access-Control-Allow-Credentials头信息,那么说明这个响应被忽略了.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Credentials: true | false</div></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Expose-Headers-Response-Header\"><a href=\"#Access-Control-Expose-Headers-Response-Header\" class=\"headerlink\" title=\"Access-Control-Expose-Headers Response Header\"></a>Access-Control-Expose-Headers Response Header</h3><p>设置浏览器允许访问的服务器响应请求的头信息的白名单:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Expose-Headers: X-A-Custom-Header, X-B-Custom-Header</div></pre></td></tr></table></figure></p>\n<p>这样，浏览器就可以得到服务器响应请求的头信息中的<code>X-A-Custom-Header</code>、<code>X-B-Custom-Header</code></p>\n<h3 id=\"Access-Control-Max-Age-Response-Header\"><a href=\"#Access-Control-Max-Age-Response-Header\" class=\"headerlink\" title=\"Access-Control-Max-Age Response Header\"></a>Access-Control-Max-Age Response Header</h3><p>这个头告诉我们这次预请求的结果的有效期是多久：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Max-Age: &lt;delta-seconds&gt;</div></pre></td></tr></table></figure></p>\n<p><code>delta-seconds</code> 参数表示,允许这个预请求的参数缓存的秒数,在此期间,不用发出另一条预检请求. </p>\n<h3 id=\"Access-Control-Allow-Methods-Response-Header\"><a href=\"#Access-Control-Allow-Methods-Response-Header\" class=\"headerlink\" title=\"Access-Control-Allow-Methods Response Header\"></a>Access-Control-Allow-Methods Response Header</h3><p>指明资源可以被请求的方式有哪些(一个或者多个). 这个响应头信息在客户端发出预检请求的时候会被返回.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</div></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Allow-Headers-Response-Header\"><a href=\"#Access-Control-Allow-Headers-Response-Header\" class=\"headerlink\" title=\"Access-Control-Allow-Headers Response Header\"></a>Access-Control-Allow-Headers Response Header</h3><p>也是在响应预检请求的时候使用.用来指明在实际的请求中,可以使用哪些自定义HTTP请求头.比如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Headers: X-Custom-Header</div></pre></td></tr></table></figure></p>\n<p>这样在实际的请求里,请求头信息里就可以有这么一条:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">X-Custom-Header: hello world</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>For Request</p>\n</blockquote>\n<h3 id=\"Origin-Request-Header\"><a href=\"#Origin-Request-Header\" class=\"headerlink\" title=\"Origin Request Header\"></a>Origin Request Header</h3><p>表明发送请求或者预请求的域<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Origin: &lt;origin&gt;</div></pre></td></tr></table></figure></p>\n<p>参数<code>origin</code>是一个URI,告诉服务器端,请求来自哪里.它不包含任何路径信息,只是服务器名.</p>\n<h3 id=\"Access-Control-Request-Method-Request-Header\"><a href=\"#Access-Control-Request-Method-Request-Header\" class=\"headerlink\" title=\"Access-Control-Request-Method Request Header\"></a>Access-Control-Request-Method Request Header</h3><p>在发出预检请求时带有这个头信息,告诉服务器在实际请求时会使用的请求方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Request-Method: &lt;method&gt;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Access-Control-Request-Headers\"><a href=\"#Access-Control-Request-Headers\" class=\"headerlink\" title=\"Access-Control-Request-Headers\"></a>Access-Control-Request-Headers</h3><p>在发出预检请求时带有这个头信息,告诉服务器在实际请求时会携带的自定义头信息.如有多个,可以用逗号分开.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</div></pre></td></tr></table></figure></p>\n<h2 id=\"举三个栗子\"><a href=\"#举三个栗子\" class=\"headerlink\" title=\"举三个栗子\"></a>举三个栗子</h2><h3 id=\"一个简单的请求\"><a href=\"#一个简单的请求\" class=\"headerlink\" title=\"一个简单的请求\"></a>一个简单的请求</h3><p>比如说，假如站点 <code>http://foo.example</code> 的网页应用想要访问 <code>http://bar.other</code> 的资源。以下的 JavaScript 代码应该会在 foo.example 上执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var invocation = new XMLHttpRequest();</div><div class=\"line\">var url = &apos;http://bar.other/resources/public-data/&apos;;</div><div class=\"line\">   </div><div class=\"line\">function callOtherDomain() &#123;</div><div class=\"line\">  if(invocation) &#123;    </div><div class=\"line\">    invocation.open(&apos;GET&apos;, url, true);</div><div class=\"line\">    invocation.onreadystatechange = handler;</div><div class=\"line\">    invocation.send(); </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /resources/public-data/ HTTP/1.1</div><div class=\"line\">Host: bar.other</div><div class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</div><div class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class=\"line\">Accept-Language: en-us,en;q=0.5</div><div class=\"line\">Accept-Encoding: gzip,deflate</div><div class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">Referer: http://foo.example/examples/access-control/simpleXSInvocation.html</div><div class=\"line\">Origin: http://foo.example</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date: Mon, 01 Dec 2008 00:23:53 GMT</div><div class=\"line\">Server: Apache/2.0.61 </div><div class=\"line\">Access-Control-Allow-Origin: *</div><div class=\"line\">Keep-Alive: timeout=2, max=100</div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Transfer-Encoding: chunked</div><div class=\"line\">Content-Type: application/xml</div><div class=\"line\"></div><div class=\"line\">[XML Data]</div></pre></td></tr></table></figure></p>\n<p>第 1~10 行是 浏览器 发出的请求头。注意看第10行的请求头 Origin，它表明了该请求来自于 <code>http://foo.exmaple</code>。</p>\n<p>第 13~22 行则是 <code>http://bar.other</code> 服务器的响应。如第16行所示，服务器返回了响应头 Access-Control-Allow-Origin: *，这表明服务器接受来自任何站点的跨站请求。如果服务器端仅允许来自 <code>http://foo.example</code> 的跨站请求，它可以返回：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Origin: http://foo.example</div></pre></td></tr></table></figure></p>\n<p>现在，除了 <code>http://foo.example</code>，其它站点就不能跨站访问 <code>http://bar.other</code> 的资源了。</p>\n<p>如上，通过使用 Origin 和 Access-Control-Allow-Origin 就可以完成最简单的跨站请求。不过 Access-Control-Allow-Origin 需要为 * 或者包含由 Origin 指明的站点。</p>\n<h3 id=\"预请求-Prefilght\"><a href=\"#预请求-Prefilght\" class=\"headerlink\" title=\"预请求 Prefilght\"></a>预请求 Prefilght</h3><p>不同于上面讨论的简单请求，“预请求”要求必须先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。 当请求具备以下条件，就会被当成预请求处理：</p>\n<ul>\n<li>请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。</li>\n<li>使用自定义请求头（比如添加诸如 X-PINGOTHER</li>\n</ul>\n<p>如示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var invocation = new XMLHttpRequest();</div><div class=\"line\">var url = &apos;http://bar.other/resources/post-here/&apos;;</div><div class=\"line\">var body = &apos;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;&#123;C&#125;Arun&apos;;</div><div class=\"line\">    </div><div class=\"line\">function callOtherDomain()&#123;</div><div class=\"line\">  if(invocation)</div><div class=\"line\">    &#123;</div><div class=\"line\">      invocation.open(&apos;POST&apos;, url, true);</div><div class=\"line\">      invocation.setRequestHeader(&apos;X-PINGOTHER&apos;, &apos;pingpong&apos;);</div><div class=\"line\">      invocation.setRequestHeader(&apos;Content-Type&apos;, &apos;application/xml&apos;);</div><div class=\"line\">      invocation.onreadystatechange = handler;</div><div class=\"line\">      invocation.send(body); </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">......</div></pre></td></tr></table></figure></p>\n<p>如上，以 XMLHttpRequest 创建了一个 POST 请求，为该请求添加了一个自定义请求头(X-PINGOTHER: pingpong)，并指定数据类型为 application/xml。所以，该请求是一个“预请求”形式的跨站请求。</p>\n<p>让我们看看服务器与浏览器之间具体的交互过程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">OPTIONS /resources/post-here/ HTTP/1.1</div><div class=\"line\">Host: bar.other</div><div class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</div><div class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class=\"line\">Accept-Language: en-us,en;q=0.5</div><div class=\"line\">Accept-Encoding: gzip,deflate</div><div class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">Origin: http://foo.example</div><div class=\"line\">Access-Control-Request-Method: POST</div><div class=\"line\">Access-Control-Request-Headers: X-PINGOTHER</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date: Mon, 01 Dec 2008 01:15:39 GMT</div><div class=\"line\">Server: Apache/2.0.61 (Unix)</div><div class=\"line\">Access-Control-Allow-Origin: http://foo.example</div><div class=\"line\">Access-Control-Allow-Methods: POST, GET, OPTIONS</div><div class=\"line\">Access-Control-Allow-Headers: X-PINGOTHER</div><div class=\"line\">Access-Control-Max-Age: 1728000</div><div class=\"line\">Vary: Accept-Encoding, Origin</div><div class=\"line\">Content-Encoding: gzip</div><div class=\"line\">Content-Length: 0</div><div class=\"line\">Keep-Alive: timeout=2, max=100</div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Content-Type: text/plain</div><div class=\"line\"></div><div class=\"line\">POST /resources/post-here/ HTTP/1.1</div><div class=\"line\">Host: bar.other</div><div class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</div><div class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class=\"line\">Accept-Language: en-us,en;q=0.5</div><div class=\"line\">Accept-Encoding: gzip,deflate</div><div class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">X-PINGOTHER: pingpong</div><div class=\"line\">Content-Type: text/xml; charset=UTF-8</div><div class=\"line\">Referer: http://foo.example/examples/preflightInvocation.html</div><div class=\"line\">Content-Length: 55</div><div class=\"line\">Origin: http://foo.example</div><div class=\"line\">Pragma: no-cache</div><div class=\"line\">Cache-Control: no-cache</div><div class=\"line\"></div><div class=\"line\">Arun</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date: Mon, 01 Dec 2008 01:15:40 GMT</div><div class=\"line\">Server: Apache/2.0.61 (Unix)</div><div class=\"line\">Access-Control-Allow-Origin: http://foo.example</div><div class=\"line\">Vary: Accept-Encoding, Origin</div><div class=\"line\">Content-Encoding: gzip</div><div class=\"line\">Content-Length: 235</div><div class=\"line\">Keep-Alive: timeout=2, max=99</div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Content-Type: text/plain</div><div class=\"line\"></div><div class=\"line\">[Some GZIP&apos;d payload]</div></pre></td></tr></table></figure></p>\n<p>第1至12行，使用一个 OPTIONS 发送了一个“预请求”。浏览器 根据请求参数，决定需要发送一个“预请求”，来探明服务器端是否接受后续真正的请求。 OPTIONS 是 HTTP/1.1 里的方法，用来获取更多服务器端的信息，是一个不应该对服务器数据造成影响的方法。 随同 OPTIONS 请求，以下两个请求头一起被发送：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Request-Method: POST</div><div class=\"line\">Access-Control-Request-Headers: X-PINGOTHER</div></pre></td></tr></table></figure></p>\n<p>请求头Access-Control-Request-Method可以提醒服务器跨站请求将使用POST方法，而请求头Access-Control-Request-Headers则告知服务器该跨站请求将携带一个自定义请求头X-PINGOTHER。这样，服务器就可以决定，在当前情况下，是否接受该跨站请求访问。</p>\n<p>第15至27行是服务器的响应。该响应表明，服务器接受了客服端的跨站请求。具体可以看看第18至21行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Access-Control-Allow-Origin: http://foo.example</div><div class=\"line\">Access-Control-Allow-Methods: POST, GET, OPTIONS</div><div class=\"line\">Access-Control-Allow-Headers: X-PINGOTHER</div><div class=\"line\">Access-Control-Max-Age: 1728000</div></pre></td></tr></table></figure></p>\n<p>响应头Access-Control-Allow-Methods表明服务器可以接受POST, GET和 OPTIONS的请求方法。请注意，这个响应头类似于HTTP/1.1 Allow: response header，但仅限于访问控制的场景下。而响应头Access-Control-Allow-Headers则表示服务器接受自定义请求头X-PINGOTHER。就像Access-Control-Allow-Methods一样，Access-Control-Allow-Headers允许以逗号分隔，传递一个可接受的自定义请求头列表。最后，响应头Access-Control-Max-Age告诉浏览器，本次“预请求”的响应结果有效时间是多久。在上面的例子里，1728000秒代表着20天内，浏览器在处理针对该服务器的跨站请求，都可以无需再发送“预请求”，只需根据本次结果进行判断处理。</p>\n<h3 id=\"附带凭证信息的请求\"><a href=\"#附带凭证信息的请求\" class=\"headerlink\" title=\"附带凭证信息的请求\"></a>附带凭证信息的请求</h3><p>XMLHttpRequest和访问控制功能，最有趣的特性就是，发送凭证请求（HTTP Cookies和验证信息）的功能。一般而言，对于跨站请求，浏览器是不会发送凭证信息的。但如果将XMLHttpRequest的一个特殊标志位设置为true，浏览器就将允许该请求的发送。</p>\n<p><code>http://foo.example</code>站点的脚本向<code>http://bar.other</code>站点发送一个GET请求，并设置了一个Cookies值。脚本代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var invocation = new XMLHttpRequest();</div><div class=\"line\">var url = &apos;http://bar.other/resources/credentialed-content/&apos;;</div><div class=\"line\">    </div><div class=\"line\">function callOtherDomain()&#123;</div><div class=\"line\">  if(invocation) &#123;</div><div class=\"line\">    invocation.open(&apos;GET&apos;, url, true);</div><div class=\"line\">    invocation.withCredentials = true;</div><div class=\"line\">    invocation.onreadystatechange = handler;</div><div class=\"line\">    invocation.send(); </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>如你所见，第七行代码将XMLHttpRequest的withCredentials标志设置为true，从而使得Cookies可以随着请求发送。因为这是一个简单的GET请求，所以浏览器不会发送一个“预请求”。但是，如果服务器端的响应中，如果没有返回Access-Control-Allow-Credentials: true的响应头，那么浏览器将不会把响应结果传递给发出请求的脚本程序，以保证信息的安全。</p>\n<p>客服端与服务器端交互示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET /resources/access-control-with-credentials/ HTTP/1.1</div><div class=\"line\">Host: bar.other</div><div class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre</div><div class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class=\"line\">Accept-Language: en-us,en;q=0.5</div><div class=\"line\">Accept-Encoding: gzip,deflate</div><div class=\"line\">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</div><div class=\"line\">Connection: keep-alive</div><div class=\"line\">Referer: http://foo.example/examples/credential.html</div><div class=\"line\">Origin: http://foo.example</div><div class=\"line\">Cookie: pageAccess=2</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date: Mon, 01 Dec 2008 01:34:52 GMT</div><div class=\"line\">Server: Apache/2.0.61 (Unix) PHP/4.4.7 mod_ssl/2.0.61 OpenSSL/0.9.7e mod_fastcgi/2.4.2 DAV/2 SVN/1.4.2</div><div class=\"line\">X-Powered-By: PHP/5.2.6</div><div class=\"line\">Access-Control-Allow-Origin: http://foo.example</div><div class=\"line\">Access-Control-Allow-Credentials: true</div><div class=\"line\">Cache-Control: no-cache</div><div class=\"line\">Pragma: no-cache</div><div class=\"line\">Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT</div><div class=\"line\">Vary: Accept-Encoding, Origin</div><div class=\"line\">Content-Encoding: gzip</div><div class=\"line\">Content-Length: 106</div><div class=\"line\">Keep-Alive: timeout=2, max=100</div><div class=\"line\">Connection: Keep-Alive</div><div class=\"line\">Content-Type: text/plain</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[text/plain payload]</div></pre></td></tr></table></figure></p>\n<p>虽然第11行指定了要提交到<code>http://bar.other</code>的内容的Cookie信息,但是如果bar.other的响应头里没有Access-Control-Allow-Credentials:true(第19行),则响应会被忽略. 特别注意: 给一个带有withCredentials的请求发送响应的时候,服务器端必须指定允许请求的域名,不能使用’<em>‘.上面这个例子中,如果响应头是这样的:Access-Control-Allow-Origin: </em> ,则响应会失败. 在这个例子里,因为Access-Control-Allow-Origin的值是<code>http://foo.example</code>这个指定的请求域名,所以客户端把带有凭证信息的内容被返回给了客户端. 另外注意第22行,更多的cookie信息也被创建了</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\">Access_control_CORS</a><br><a href=\"https://www.w3.org/TR/cors/\">Cross-Origin Resource Sharing Standard</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\">Same-origin_policy</a></p>\n"},{"title":"读《重来》","date":"2016-07-06T16:14:25.000Z","_content":"\n之前我们团队一直在用Coding来作为代码仓库，以及团队协作的工具。大半年下来，攒了不少「码币」，正好碰上Coding的码市搞活动，用码币换取一些Coding的周边，我翻到码市页面的最底下，正好有《重来》这本书可以兑换。对于码农来说，书是一个廉价却特别有价值的东西，于是毫不犹豫就兑换了这本书。\n\n《重来》，也叫《Rework》，作者是37signals的两位创始人：Json Fried, David Heinemeier Hansson。\n这本书的主题是「创业」，书中蕴含了90条作者在创业过程中的商业思维，把它们分篇到12个章节中。\n读这本书的过程中，我会在每一条有所体会，有所思的「思维」中，用铅笔在空白处写下自己的思考。\n读这本书的感觉很像以前读的一本《人性的弱点》，都是教条式的写作。\n其中的每一条，描述的篇幅都很小，但是每一条都需要思思品味，好好感悟。\n很多「思维」中，虽然描述中明显的指向到「创业」思维中，但是我认为很多跟平时我们做人做事的原则很相符。\n读书的过程虽慢，但是我却很认真，对一本好的书，多认真都不显得过分。\n故以此文记录这些笔记。\n\n## 卸负篇\n\n### 哪来的从错误中学习 <small>Learning from mistakes is overrated</small>\n> \n在广义上，成功时并不需要知道失败所遇到的事情\n若放在小事上，例如编程，有一些不折腾过，并不知道以后出错时如何解决\n但也可以延伸另外一个观点：寻找前往成功的直径，绕开不必要的弯路。\n\n### 计划既瞎猜 <small>Planning is guessing</small>\n> \n这篇的说法很符合「说走就走的旅行」的观念。\n计划有用，是对未来的憧憬，但行动更重要，做自己想做的。\n\n### 何必壮大 <small>Why grow?</small>\n> \n在这一篇中，我想起了海贼王中「草帽路飞」海贼团。\n团队中每个人都能独当一面，且有一个统一的向心点。\n\n### 工作狂 <small>Workaholism</small>\n> \n这篇虽说加班，但更深层是效率的问题。\n追求在对的方向，以对的方式快速完成事情。\n\n## 行动篇\n\n### 挠自己的痒处 <small>Scratch your own itch</small> \n> \n为自己服务，解决自己的痛点，顺便造福一下人类。\n让我想起了我那几个搁浅的开源项目-_-!\n\n### 着手做点什么 <small>Start making something</small>\n> \n价值并不在创意，而在于执行力。\n\n### 画沙为界，立场明确 <small>Draw a line in the sand</small>\n> \n让自己更加主见，并且为你的主见提供足够让人信服的论证，如果没有，就去创造这样的论证。\n这一篇有点「乔布斯」的味道，特立独行，打造自身的个性品牌，并无刻意迎合大众。\n这又让我想起了魅族改变路线，迎合消费者，冲销量的做法。\n但是，毕竟它身处一个苛刻的战场。\n\n### 万不得已不筹资 <small>Outside money is Plan 2</small>\n> \n这篇文章是站在创始人视角看待问题。\n从另外一个角度来说，要看待投资方是谁。\n如果是一些基金会，它们需要的是急切的盈利，想到的是如何套现。\n而如果是看中你所做的事情，想一起合作的，或者合并你的公司的投资方就不一样了。他会把你所做的事情当做自己的事情来做。\n\n## 进阶篇\n\n### 条件受限是好事 <small>Embrace constaints</small>\n> \n本篇强调「灵活」与「限制」。\n提出了一个让我所有共鸣，以往能感觉到却没能形容的观点：\n以艰苦的条件来激发人的创造力。\n\n### 与其做个半成品，不如做好半个产品 <small>Build half a product. Not a half-assed product</small>\n> \n不要大而全，只要简而美。\n兴趣与学习也是一个道理，选一件最需要做好的事情投入。\n\n### 从核心出发 <small>Start at the epicenter</small>\n> \n选择能做的，想做的，必须做的。\n\n### 不要过早关注细节 <small>Ignore the details early on</small>\n> \n从整体到局部的思想，做设计、做架构，都是先有个轮廓，然后一点点细化。\n\n### 作出决定就是取得进展 <small>Making the call is making progress</small>\n> \n规划总是要有个度，太近的不够全面，太远的变数太多，不切实际。\n当有了想法，尽早做个决定，先尝试走几步吧。\n\n### 当好博物馆长 <small>Be a curator</small>\n> \n精简，小而美。\n不必追求大而全，东西要发挥它的作用。\n\n### 关注不变因素 <small>Focus on what won't change</small>\n> \n英语、经济学、写作、音乐，\n这一些都是性价比颇高的素质，都十分有助于一个人的内在修养。\n\n### 音乐就在你的指尖流淌 <small>Tone is in your fingers</small>\n> \n抛开工具，关注事物的内在。\n工具，是在你了解了其内部原理之后用来提升效率的。\n\n### 卖掉副产品 <small>Sell your by-products</small>\n> \n对于我的工作来说，把学习的过程，工作上遇到的问题给写下来，发表到博客，这就是我的副产品。\n\n### 立马就上线 <small>Launch now</small>\n> \n第一个版本：一个能用的版本\n\n## 效率篇\n\n### 赞同的错觉 <small>Illusions of agreement</small>\n> \n很多时候多希望有一个idea出现的时候，立马可以动手来做，而不用太在意后来的事情。\n但我认为，需要谨慎的事情需要适度的设计和考虑。\n\n### 打岔是效率的敌人 <small>Interruption is the enemy of productivity</small>\n> \n这一点让我深有体会，并且一直在挣扎的事情。\n尝试过番茄工作法，并且尝试让同事理解我这样的做法。\n并不接受直接过来打扰的沟通方式。\n\n### 刚刚好就是真的好 <small>Good enough is fine</small>\n> \n以小博大，遵循简单，首要目的是把事情做好，做出来。\n后面可以随时改善以及改进。\n\n### 速战速决 <small>Quick Wins</small>\n> \n在这一章中，作者多次提出一个概念，或者是思维：不要等，马上行动!\n在我眼中，这里还有一个思维：积跬步以至千里。\n这跟我的座右铭很相似：厚积薄发。\n\n### 不要逞英雄 <small>Don't be a hero</small>\n> \n把你的时间花在最值得花的地方，并且要量力而行，学会放弃\n\n### 该睡觉时就睡觉 <small>Go to sleep</small>\n> \n学会休息，并且是高效的休息。\n因为疲倦会带来懒惰思考、缺乏创意、士气低落、情绪失控。\n\n### 预估的都是垃圾 <small>Your estimates suck</small>\n> \n对于自己的学习计划也是如此，很多东西想学，却不知从哪个开始，怎么开始。\n那么就把它们排个序，然后逐个评估时间，然后马上执行。\n\n### 罗列问题，不得解决 <small>Long lists don't get done</small>\n> \n把大任务分成小任务，并从小任务中获得成就感。\n\n## 对手篇\n\n### 拒绝照搬 <small>Don't copy</small>\n> \n在学习的方向上，需要模仿，这是一种有效的学习方式。\nCopy-Paste的过程中，尽量知其所以然。\n不需要盲从，掌握主动。\n\n### 向对手挑战 <small>Pick a fight</small>\n> \n调侃对手这种做法，更偏向于一种营销手段，需要玩出自己的特色。\n在国内，这种案例也很多，被网友戏称「碰瓷营销」。\n\n### 给竞争力做减法 <small>Underdo your competition</small>\n> \n一款简约的产品，只需要集中解决用户的一个主要的痛点，而且如果以低成本随手可得的话，更加容易成为流行品。\n\n## 进化篇\n\n### 头脑发热不等于当务之急 <small>Don't confuse enthusiasm with priority</small>\n> \n避免头脑发热，有些事情或决定，可以先放着，过几天再回来看看。\n在《人性的弱点》中，也有类似的观点，那是这样的一个说法：一封愤怒的信，先放几天再决定是否要寄出。\n\n### 家用便利就是好 <small>Be at home good</small>\n> \n弄清哪个是本，哪个是辅\n\n### 甘于低微 <small>Welcome obscurity</small>\n> \n之所以说籍籍无名值得庆幸。\n是因为在这个阶段犯的错误，并没有放大效应，试错成本低。\n对于「甘于低微」，我还有另外一种理解。\n每个人都有他的优点，有胜于你的地方。甘于低微，可以让你保持低调，以及一颗愿意接纳新想法的心。\n\n### 培养自己的拥趸 <small>Build an audience</small>\n> \n通过提供有价值的内容，来培养自己的粉丝。\n\n### 普及知识，赢得竞争 <small>Out-teach your competition</small>\n> \n国内的很多技术团队，都有各自的技术博客，都会有分享的习惯。\n如果他们的内容强劲，他们所做的产品和项目也会备受关注。\n\n### 效仿大厨 <small>Emulate chefs</small>\n> \n分享知识，是我一直所推崇的。\n能帮助别人，记录进步，好处是不少的。\n\n### 没人喜欢塑料花 <small>Nobody likes plostic flowers</small>\n> \n不完美才真实，这一篇有很多优美的句子，尽管是翻译的句子。这让我好奇原版是怎么样的句子了。\n这些句子，都谈论了一个道理：直面弱点，做真实的自己，把真实的自己展示给别人。\n摘抄：\n1. 不完美才真实，真实才能激起人们的共鸣。\n2. 繁华落尽见真淳。\n3. \"保留原有的韵致\"是一种美丽的行事方法。\n4. 过度的雕琢会使事物失去灵魂，变得机械乏味。\n\n### 一夜成名只是传说 <small>The myth of the overnight sensation</small>\n> \n文章中谈论到的几点，也是对个人来说很有启发性。\n你要拥有足够牢固的基础来支撑你以后的名声。\n现在就需要开始一点一滴的培养基础，和你的观众。\n\n## 招聘篇\n\n### 受不了时再招人 <small>Hire when it hurts</small>\n> \n这也是对于创业团队，或者小团队而言。\n在大公司的团队中，往往所分配的名额是固定的。\n申请名额不容易，所以会导致很多一些部门都是招人进来先占个坑。\n\n### 放弃牛人 <small>Pass on greate people</small>\n> \n这个也是大公司毛病，很多都是储备员工，也是没事找事干。\n站在牛人的角度来想问题的话，在一个方向牛起来，总会有需要你的地方。\n\n### 鸡尾酒会上的陌生人 <small>Strangers at a cocktail party</small>\n> \n招人，要给予足够的时间来交谈，得到充分的相互了解。\n应聘，同样对你所应聘的公司给予足够的关注和充分的沟通。\n\n### 可笑的求职简历 <small>Resumes are ridiculous</small>\n> \n要充分的了解你所应聘的公司，这是未来很长一段时间共同奋斗的团队。\n这考验了你的信息收集能力，和社交能力。\n\n### 多年的无关经验 <small>Years of irrelevance</small>\n> \n熟悉、掌握一门技术活，只需要半年到一年的时间。\n而在这之后，真正要看的是个人的努力程度、性格差异、智力水平以及工作态度。\n当然，还有基础知识的积累。\n例如你说有两年的NodeJS工作经验，但是基础的JavaScript都吃不通的话，让别人怎么相信你过去的努力程度。\n\n## 救灾篇\n\n### 主动掌控负面新闻 <small>Own your bad news</small>\n> \n自己的糗事由自己来说比别人来说，结果会好得多。\n本篇说的，我总结三个字：责任心。\n愿意承担起责任的人，总是受人尊重。\n\n## 文化篇\n\n### 文化不是由谁创造的 <small>You don't create a culture</small>\n> \n但是对于小团队来说，企业文化往往取决于创始人的个人魅力。\n\n### 决策都是临时性的 <small>Decisions are temporary</small>\n> \n在平时工作中，考虑功能实现的时候也是如此。\n考虑得多是好事，但要参考特定环境的符合程度。\n渐渐地感觉到了，担心的事情大多不会真的发生，当它真的发生了，再考虑对策吧。\n\n### 跳过摇滚明星 <small>Skip the rock starts</small>\n> \n巨星环境的生成源于信任、自律以及责任感，是给予员工充分的隐私权、空间以及必备工具的结果。\n所以BAT的技术团队才那么多人趋之若鹜。\n\n### 员工不知13岁 <small>They're not children</small>\n> \n当你像小孩一样行事，别人也会把你当小孩子。\n如何获得信任？\n让你的工作在领导不用操心的情况下完成，在遇到问题和不懂的地方，先尝试自己解决。\n\n### 发出你的心声 <small>Sound like you</small>\n> \n悲惨的是国内的应试语文教育，只会扼杀大部分人的写作能力。\n真正的写作是一种自由、个性、观点的表述过程。\n而不是那些为作文题目，为分数而写的非自愿的文章。\n\n### 需要避开的词汇 <small>Four-letters words</small>\n> \n避开那种「非黑即白」的词语，真相往往不是非黑即白。\n\n## 总结篇\n\n### 灵感稍纵即逝\n> \n有些灵感也会因为当前能力的局限而难以实现。\n但如果仅因为这样而放弃或者耽误你的灵感，是十分浪费的。\n所以，在灵感还没来的时候就要「厚积」，而当灵感来敲门了，不管是否有足够的执行力，先开始了再说。\n\n","source":"_posts/读《重来》.md","raw":"---\ntitle: 读《重来》\ncategory: 人丑就要多读书\ndate: 2016-07-07 00:14:25\ntags: \n- 读书笔记\n---\n\n之前我们团队一直在用Coding来作为代码仓库，以及团队协作的工具。大半年下来，攒了不少「码币」，正好碰上Coding的码市搞活动，用码币换取一些Coding的周边，我翻到码市页面的最底下，正好有《重来》这本书可以兑换。对于码农来说，书是一个廉价却特别有价值的东西，于是毫不犹豫就兑换了这本书。\n\n《重来》，也叫《Rework》，作者是37signals的两位创始人：Json Fried, David Heinemeier Hansson。\n这本书的主题是「创业」，书中蕴含了90条作者在创业过程中的商业思维，把它们分篇到12个章节中。\n读这本书的过程中，我会在每一条有所体会，有所思的「思维」中，用铅笔在空白处写下自己的思考。\n读这本书的感觉很像以前读的一本《人性的弱点》，都是教条式的写作。\n其中的每一条，描述的篇幅都很小，但是每一条都需要思思品味，好好感悟。\n很多「思维」中，虽然描述中明显的指向到「创业」思维中，但是我认为很多跟平时我们做人做事的原则很相符。\n读书的过程虽慢，但是我却很认真，对一本好的书，多认真都不显得过分。\n故以此文记录这些笔记。\n\n## 卸负篇\n\n### 哪来的从错误中学习 <small>Learning from mistakes is overrated</small>\n> \n在广义上，成功时并不需要知道失败所遇到的事情\n若放在小事上，例如编程，有一些不折腾过，并不知道以后出错时如何解决\n但也可以延伸另外一个观点：寻找前往成功的直径，绕开不必要的弯路。\n\n### 计划既瞎猜 <small>Planning is guessing</small>\n> \n这篇的说法很符合「说走就走的旅行」的观念。\n计划有用，是对未来的憧憬，但行动更重要，做自己想做的。\n\n### 何必壮大 <small>Why grow?</small>\n> \n在这一篇中，我想起了海贼王中「草帽路飞」海贼团。\n团队中每个人都能独当一面，且有一个统一的向心点。\n\n### 工作狂 <small>Workaholism</small>\n> \n这篇虽说加班，但更深层是效率的问题。\n追求在对的方向，以对的方式快速完成事情。\n\n## 行动篇\n\n### 挠自己的痒处 <small>Scratch your own itch</small> \n> \n为自己服务，解决自己的痛点，顺便造福一下人类。\n让我想起了我那几个搁浅的开源项目-_-!\n\n### 着手做点什么 <small>Start making something</small>\n> \n价值并不在创意，而在于执行力。\n\n### 画沙为界，立场明确 <small>Draw a line in the sand</small>\n> \n让自己更加主见，并且为你的主见提供足够让人信服的论证，如果没有，就去创造这样的论证。\n这一篇有点「乔布斯」的味道，特立独行，打造自身的个性品牌，并无刻意迎合大众。\n这又让我想起了魅族改变路线，迎合消费者，冲销量的做法。\n但是，毕竟它身处一个苛刻的战场。\n\n### 万不得已不筹资 <small>Outside money is Plan 2</small>\n> \n这篇文章是站在创始人视角看待问题。\n从另外一个角度来说，要看待投资方是谁。\n如果是一些基金会，它们需要的是急切的盈利，想到的是如何套现。\n而如果是看中你所做的事情，想一起合作的，或者合并你的公司的投资方就不一样了。他会把你所做的事情当做自己的事情来做。\n\n## 进阶篇\n\n### 条件受限是好事 <small>Embrace constaints</small>\n> \n本篇强调「灵活」与「限制」。\n提出了一个让我所有共鸣，以往能感觉到却没能形容的观点：\n以艰苦的条件来激发人的创造力。\n\n### 与其做个半成品，不如做好半个产品 <small>Build half a product. Not a half-assed product</small>\n> \n不要大而全，只要简而美。\n兴趣与学习也是一个道理，选一件最需要做好的事情投入。\n\n### 从核心出发 <small>Start at the epicenter</small>\n> \n选择能做的，想做的，必须做的。\n\n### 不要过早关注细节 <small>Ignore the details early on</small>\n> \n从整体到局部的思想，做设计、做架构，都是先有个轮廓，然后一点点细化。\n\n### 作出决定就是取得进展 <small>Making the call is making progress</small>\n> \n规划总是要有个度，太近的不够全面，太远的变数太多，不切实际。\n当有了想法，尽早做个决定，先尝试走几步吧。\n\n### 当好博物馆长 <small>Be a curator</small>\n> \n精简，小而美。\n不必追求大而全，东西要发挥它的作用。\n\n### 关注不变因素 <small>Focus on what won't change</small>\n> \n英语、经济学、写作、音乐，\n这一些都是性价比颇高的素质，都十分有助于一个人的内在修养。\n\n### 音乐就在你的指尖流淌 <small>Tone is in your fingers</small>\n> \n抛开工具，关注事物的内在。\n工具，是在你了解了其内部原理之后用来提升效率的。\n\n### 卖掉副产品 <small>Sell your by-products</small>\n> \n对于我的工作来说，把学习的过程，工作上遇到的问题给写下来，发表到博客，这就是我的副产品。\n\n### 立马就上线 <small>Launch now</small>\n> \n第一个版本：一个能用的版本\n\n## 效率篇\n\n### 赞同的错觉 <small>Illusions of agreement</small>\n> \n很多时候多希望有一个idea出现的时候，立马可以动手来做，而不用太在意后来的事情。\n但我认为，需要谨慎的事情需要适度的设计和考虑。\n\n### 打岔是效率的敌人 <small>Interruption is the enemy of productivity</small>\n> \n这一点让我深有体会，并且一直在挣扎的事情。\n尝试过番茄工作法，并且尝试让同事理解我这样的做法。\n并不接受直接过来打扰的沟通方式。\n\n### 刚刚好就是真的好 <small>Good enough is fine</small>\n> \n以小博大，遵循简单，首要目的是把事情做好，做出来。\n后面可以随时改善以及改进。\n\n### 速战速决 <small>Quick Wins</small>\n> \n在这一章中，作者多次提出一个概念，或者是思维：不要等，马上行动!\n在我眼中，这里还有一个思维：积跬步以至千里。\n这跟我的座右铭很相似：厚积薄发。\n\n### 不要逞英雄 <small>Don't be a hero</small>\n> \n把你的时间花在最值得花的地方，并且要量力而行，学会放弃\n\n### 该睡觉时就睡觉 <small>Go to sleep</small>\n> \n学会休息，并且是高效的休息。\n因为疲倦会带来懒惰思考、缺乏创意、士气低落、情绪失控。\n\n### 预估的都是垃圾 <small>Your estimates suck</small>\n> \n对于自己的学习计划也是如此，很多东西想学，却不知从哪个开始，怎么开始。\n那么就把它们排个序，然后逐个评估时间，然后马上执行。\n\n### 罗列问题，不得解决 <small>Long lists don't get done</small>\n> \n把大任务分成小任务，并从小任务中获得成就感。\n\n## 对手篇\n\n### 拒绝照搬 <small>Don't copy</small>\n> \n在学习的方向上，需要模仿，这是一种有效的学习方式。\nCopy-Paste的过程中，尽量知其所以然。\n不需要盲从，掌握主动。\n\n### 向对手挑战 <small>Pick a fight</small>\n> \n调侃对手这种做法，更偏向于一种营销手段，需要玩出自己的特色。\n在国内，这种案例也很多，被网友戏称「碰瓷营销」。\n\n### 给竞争力做减法 <small>Underdo your competition</small>\n> \n一款简约的产品，只需要集中解决用户的一个主要的痛点，而且如果以低成本随手可得的话，更加容易成为流行品。\n\n## 进化篇\n\n### 头脑发热不等于当务之急 <small>Don't confuse enthusiasm with priority</small>\n> \n避免头脑发热，有些事情或决定，可以先放着，过几天再回来看看。\n在《人性的弱点》中，也有类似的观点，那是这样的一个说法：一封愤怒的信，先放几天再决定是否要寄出。\n\n### 家用便利就是好 <small>Be at home good</small>\n> \n弄清哪个是本，哪个是辅\n\n### 甘于低微 <small>Welcome obscurity</small>\n> \n之所以说籍籍无名值得庆幸。\n是因为在这个阶段犯的错误，并没有放大效应，试错成本低。\n对于「甘于低微」，我还有另外一种理解。\n每个人都有他的优点，有胜于你的地方。甘于低微，可以让你保持低调，以及一颗愿意接纳新想法的心。\n\n### 培养自己的拥趸 <small>Build an audience</small>\n> \n通过提供有价值的内容，来培养自己的粉丝。\n\n### 普及知识，赢得竞争 <small>Out-teach your competition</small>\n> \n国内的很多技术团队，都有各自的技术博客，都会有分享的习惯。\n如果他们的内容强劲，他们所做的产品和项目也会备受关注。\n\n### 效仿大厨 <small>Emulate chefs</small>\n> \n分享知识，是我一直所推崇的。\n能帮助别人，记录进步，好处是不少的。\n\n### 没人喜欢塑料花 <small>Nobody likes plostic flowers</small>\n> \n不完美才真实，这一篇有很多优美的句子，尽管是翻译的句子。这让我好奇原版是怎么样的句子了。\n这些句子，都谈论了一个道理：直面弱点，做真实的自己，把真实的自己展示给别人。\n摘抄：\n1. 不完美才真实，真实才能激起人们的共鸣。\n2. 繁华落尽见真淳。\n3. \"保留原有的韵致\"是一种美丽的行事方法。\n4. 过度的雕琢会使事物失去灵魂，变得机械乏味。\n\n### 一夜成名只是传说 <small>The myth of the overnight sensation</small>\n> \n文章中谈论到的几点，也是对个人来说很有启发性。\n你要拥有足够牢固的基础来支撑你以后的名声。\n现在就需要开始一点一滴的培养基础，和你的观众。\n\n## 招聘篇\n\n### 受不了时再招人 <small>Hire when it hurts</small>\n> \n这也是对于创业团队，或者小团队而言。\n在大公司的团队中，往往所分配的名额是固定的。\n申请名额不容易，所以会导致很多一些部门都是招人进来先占个坑。\n\n### 放弃牛人 <small>Pass on greate people</small>\n> \n这个也是大公司毛病，很多都是储备员工，也是没事找事干。\n站在牛人的角度来想问题的话，在一个方向牛起来，总会有需要你的地方。\n\n### 鸡尾酒会上的陌生人 <small>Strangers at a cocktail party</small>\n> \n招人，要给予足够的时间来交谈，得到充分的相互了解。\n应聘，同样对你所应聘的公司给予足够的关注和充分的沟通。\n\n### 可笑的求职简历 <small>Resumes are ridiculous</small>\n> \n要充分的了解你所应聘的公司，这是未来很长一段时间共同奋斗的团队。\n这考验了你的信息收集能力，和社交能力。\n\n### 多年的无关经验 <small>Years of irrelevance</small>\n> \n熟悉、掌握一门技术活，只需要半年到一年的时间。\n而在这之后，真正要看的是个人的努力程度、性格差异、智力水平以及工作态度。\n当然，还有基础知识的积累。\n例如你说有两年的NodeJS工作经验，但是基础的JavaScript都吃不通的话，让别人怎么相信你过去的努力程度。\n\n## 救灾篇\n\n### 主动掌控负面新闻 <small>Own your bad news</small>\n> \n自己的糗事由自己来说比别人来说，结果会好得多。\n本篇说的，我总结三个字：责任心。\n愿意承担起责任的人，总是受人尊重。\n\n## 文化篇\n\n### 文化不是由谁创造的 <small>You don't create a culture</small>\n> \n但是对于小团队来说，企业文化往往取决于创始人的个人魅力。\n\n### 决策都是临时性的 <small>Decisions are temporary</small>\n> \n在平时工作中，考虑功能实现的时候也是如此。\n考虑得多是好事，但要参考特定环境的符合程度。\n渐渐地感觉到了，担心的事情大多不会真的发生，当它真的发生了，再考虑对策吧。\n\n### 跳过摇滚明星 <small>Skip the rock starts</small>\n> \n巨星环境的生成源于信任、自律以及责任感，是给予员工充分的隐私权、空间以及必备工具的结果。\n所以BAT的技术团队才那么多人趋之若鹜。\n\n### 员工不知13岁 <small>They're not children</small>\n> \n当你像小孩一样行事，别人也会把你当小孩子。\n如何获得信任？\n让你的工作在领导不用操心的情况下完成，在遇到问题和不懂的地方，先尝试自己解决。\n\n### 发出你的心声 <small>Sound like you</small>\n> \n悲惨的是国内的应试语文教育，只会扼杀大部分人的写作能力。\n真正的写作是一种自由、个性、观点的表述过程。\n而不是那些为作文题目，为分数而写的非自愿的文章。\n\n### 需要避开的词汇 <small>Four-letters words</small>\n> \n避开那种「非黑即白」的词语，真相往往不是非黑即白。\n\n## 总结篇\n\n### 灵感稍纵即逝\n> \n有些灵感也会因为当前能力的局限而难以实现。\n但如果仅因为这样而放弃或者耽误你的灵感，是十分浪费的。\n所以，在灵感还没来的时候就要「厚积」，而当灵感来敲门了，不管是否有足够的执行力，先开始了再说。\n\n","slug":"读《重来》","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqu003815hl1fp35sgk","content":"<p>之前我们团队一直在用Coding来作为代码仓库，以及团队协作的工具。大半年下来，攒了不少「码币」，正好碰上Coding的码市搞活动，用码币换取一些Coding的周边，我翻到码市页面的最底下，正好有《重来》这本书可以兑换。对于码农来说，书是一个廉价却特别有价值的东西，于是毫不犹豫就兑换了这本书。</p>\n<p>《重来》，也叫《Rework》，作者是37signals的两位创始人：Json Fried, David Heinemeier Hansson。<br>这本书的主题是「创业」，书中蕴含了90条作者在创业过程中的商业思维，把它们分篇到12个章节中。<br>读这本书的过程中，我会在每一条有所体会，有所思的「思维」中，用铅笔在空白处写下自己的思考。<br>读这本书的感觉很像以前读的一本《人性的弱点》，都是教条式的写作。<br>其中的每一条，描述的篇幅都很小，但是每一条都需要思思品味，好好感悟。<br>很多「思维」中，虽然描述中明显的指向到「创业」思维中，但是我认为很多跟平时我们做人做事的原则很相符。<br>读书的过程虽慢，但是我却很认真，对一本好的书，多认真都不显得过分。<br>故以此文记录这些笔记。</p>\n<h2 id=\"卸负篇\"><a href=\"#卸负篇\" class=\"headerlink\" title=\"卸负篇\"></a>卸负篇</h2><h3 id=\"哪来的从错误中学习-Learning-from-mistakes-is-overrated\"><a href=\"#哪来的从错误中学习-Learning-from-mistakes-is-overrated\" class=\"headerlink\" title=\"哪来的从错误中学习 Learning from mistakes is overrated\"></a>哪来的从错误中学习 <small>Learning from mistakes is overrated</small></h3><blockquote>\n<p>在广义上，成功时并不需要知道失败所遇到的事情<br>若放在小事上，例如编程，有一些不折腾过，并不知道以后出错时如何解决<br>但也可以延伸另外一个观点：寻找前往成功的直径，绕开不必要的弯路。</p>\n</blockquote>\n<h3 id=\"计划既瞎猜-Planning-is-guessing\"><a href=\"#计划既瞎猜-Planning-is-guessing\" class=\"headerlink\" title=\"计划既瞎猜 Planning is guessing\"></a>计划既瞎猜 <small>Planning is guessing</small></h3><blockquote>\n<p>这篇的说法很符合「说走就走的旅行」的观念。<br>计划有用，是对未来的憧憬，但行动更重要，做自己想做的。</p>\n</blockquote>\n<h3 id=\"何必壮大-Why-grow\"><a href=\"#何必壮大-Why-grow\" class=\"headerlink\" title=\"何必壮大 Why grow?\"></a>何必壮大 <small>Why grow?</small></h3><blockquote>\n<p>在这一篇中，我想起了海贼王中「草帽路飞」海贼团。<br>团队中每个人都能独当一面，且有一个统一的向心点。</p>\n</blockquote>\n<h3 id=\"工作狂-Workaholism\"><a href=\"#工作狂-Workaholism\" class=\"headerlink\" title=\"工作狂 Workaholism\"></a>工作狂 <small>Workaholism</small></h3><blockquote>\n<p>这篇虽说加班，但更深层是效率的问题。<br>追求在对的方向，以对的方式快速完成事情。</p>\n</blockquote>\n<h2 id=\"行动篇\"><a href=\"#行动篇\" class=\"headerlink\" title=\"行动篇\"></a>行动篇</h2><h3 id=\"挠自己的痒处-Scratch-your-own-itch\"><a href=\"#挠自己的痒处-Scratch-your-own-itch\" class=\"headerlink\" title=\"挠自己的痒处 Scratch your own itch\"></a>挠自己的痒处 <small>Scratch your own itch</small></h3><blockquote>\n<p>为自己服务，解决自己的痛点，顺便造福一下人类。<br>让我想起了我那几个搁浅的开源项目-_-!</p>\n</blockquote>\n<h3 id=\"着手做点什么-Start-making-something\"><a href=\"#着手做点什么-Start-making-something\" class=\"headerlink\" title=\"着手做点什么 Start making something\"></a>着手做点什么 <small>Start making something</small></h3><blockquote>\n<p>价值并不在创意，而在于执行力。</p>\n</blockquote>\n<h3 id=\"画沙为界，立场明确-Draw-a-line-in-the-sand\"><a href=\"#画沙为界，立场明确-Draw-a-line-in-the-sand\" class=\"headerlink\" title=\"画沙为界，立场明确 Draw a line in the sand\"></a>画沙为界，立场明确 <small>Draw a line in the sand</small></h3><blockquote>\n<p>让自己更加主见，并且为你的主见提供足够让人信服的论证，如果没有，就去创造这样的论证。<br>这一篇有点「乔布斯」的味道，特立独行，打造自身的个性品牌，并无刻意迎合大众。<br>这又让我想起了魅族改变路线，迎合消费者，冲销量的做法。<br>但是，毕竟它身处一个苛刻的战场。</p>\n</blockquote>\n<h3 id=\"万不得已不筹资-Outside-money-is-Plan-2\"><a href=\"#万不得已不筹资-Outside-money-is-Plan-2\" class=\"headerlink\" title=\"万不得已不筹资 Outside money is Plan 2\"></a>万不得已不筹资 <small>Outside money is Plan 2</small></h3><blockquote>\n<p>这篇文章是站在创始人视角看待问题。<br>从另外一个角度来说，要看待投资方是谁。<br>如果是一些基金会，它们需要的是急切的盈利，想到的是如何套现。<br>而如果是看中你所做的事情，想一起合作的，或者合并你的公司的投资方就不一样了。他会把你所做的事情当做自己的事情来做。</p>\n</blockquote>\n<h2 id=\"进阶篇\"><a href=\"#进阶篇\" class=\"headerlink\" title=\"进阶篇\"></a>进阶篇</h2><h3 id=\"条件受限是好事-Embrace-constaints\"><a href=\"#条件受限是好事-Embrace-constaints\" class=\"headerlink\" title=\"条件受限是好事 Embrace constaints\"></a>条件受限是好事 <small>Embrace constaints</small></h3><blockquote>\n<p>本篇强调「灵活」与「限制」。<br>提出了一个让我所有共鸣，以往能感觉到却没能形容的观点：<br>以艰苦的条件来激发人的创造力。</p>\n</blockquote>\n<h3 id=\"与其做个半成品，不如做好半个产品-Build-half-a-product-Not-a-half-assed-product\"><a href=\"#与其做个半成品，不如做好半个产品-Build-half-a-product-Not-a-half-assed-product\" class=\"headerlink\" title=\"与其做个半成品，不如做好半个产品 Build half a product. Not a half-assed product\"></a>与其做个半成品，不如做好半个产品 <small>Build half a product. Not a half-assed product</small></h3><blockquote>\n<p>不要大而全，只要简而美。<br>兴趣与学习也是一个道理，选一件最需要做好的事情投入。</p>\n</blockquote>\n<h3 id=\"从核心出发-Start-at-the-epicenter\"><a href=\"#从核心出发-Start-at-the-epicenter\" class=\"headerlink\" title=\"从核心出发 Start at the epicenter\"></a>从核心出发 <small>Start at the epicenter</small></h3><blockquote>\n<p>选择能做的，想做的，必须做的。</p>\n</blockquote>\n<h3 id=\"不要过早关注细节-Ignore-the-details-early-on\"><a href=\"#不要过早关注细节-Ignore-the-details-early-on\" class=\"headerlink\" title=\"不要过早关注细节 Ignore the details early on\"></a>不要过早关注细节 <small>Ignore the details early on</small></h3><blockquote>\n<p>从整体到局部的思想，做设计、做架构，都是先有个轮廓，然后一点点细化。</p>\n</blockquote>\n<h3 id=\"作出决定就是取得进展-Making-the-call-is-making-progress\"><a href=\"#作出决定就是取得进展-Making-the-call-is-making-progress\" class=\"headerlink\" title=\"作出决定就是取得进展 Making the call is making progress\"></a>作出决定就是取得进展 <small>Making the call is making progress</small></h3><blockquote>\n<p>规划总是要有个度，太近的不够全面，太远的变数太多，不切实际。<br>当有了想法，尽早做个决定，先尝试走几步吧。</p>\n</blockquote>\n<h3 id=\"当好博物馆长-Be-a-curator\"><a href=\"#当好博物馆长-Be-a-curator\" class=\"headerlink\" title=\"当好博物馆长 Be a curator\"></a>当好博物馆长 <small>Be a curator</small></h3><blockquote>\n<p>精简，小而美。<br>不必追求大而全，东西要发挥它的作用。</p>\n</blockquote>\n<h3 id=\"关注不变因素-Focus-on-what-won’t-change\"><a href=\"#关注不变因素-Focus-on-what-won’t-change\" class=\"headerlink\" title=\"关注不变因素 Focus on what won’t change\"></a>关注不变因素 <small>Focus on what won’t change</small></h3><blockquote>\n<p>英语、经济学、写作、音乐，<br>这一些都是性价比颇高的素质，都十分有助于一个人的内在修养。</p>\n</blockquote>\n<h3 id=\"音乐就在你的指尖流淌-Tone-is-in-your-fingers\"><a href=\"#音乐就在你的指尖流淌-Tone-is-in-your-fingers\" class=\"headerlink\" title=\"音乐就在你的指尖流淌 Tone is in your fingers\"></a>音乐就在你的指尖流淌 <small>Tone is in your fingers</small></h3><blockquote>\n<p>抛开工具，关注事物的内在。<br>工具，是在你了解了其内部原理之后用来提升效率的。</p>\n</blockquote>\n<h3 id=\"卖掉副产品-Sell-your-by-products\"><a href=\"#卖掉副产品-Sell-your-by-products\" class=\"headerlink\" title=\"卖掉副产品 Sell your by-products\"></a>卖掉副产品 <small>Sell your by-products</small></h3><blockquote>\n<p>对于我的工作来说，把学习的过程，工作上遇到的问题给写下来，发表到博客，这就是我的副产品。</p>\n</blockquote>\n<h3 id=\"立马就上线-Launch-now\"><a href=\"#立马就上线-Launch-now\" class=\"headerlink\" title=\"立马就上线 Launch now\"></a>立马就上线 <small>Launch now</small></h3><blockquote>\n<p>第一个版本：一个能用的版本</p>\n</blockquote>\n<h2 id=\"效率篇\"><a href=\"#效率篇\" class=\"headerlink\" title=\"效率篇\"></a>效率篇</h2><h3 id=\"赞同的错觉-Illusions-of-agreement\"><a href=\"#赞同的错觉-Illusions-of-agreement\" class=\"headerlink\" title=\"赞同的错觉 Illusions of agreement\"></a>赞同的错觉 <small>Illusions of agreement</small></h3><blockquote>\n<p>很多时候多希望有一个idea出现的时候，立马可以动手来做，而不用太在意后来的事情。<br>但我认为，需要谨慎的事情需要适度的设计和考虑。</p>\n</blockquote>\n<h3 id=\"打岔是效率的敌人-Interruption-is-the-enemy-of-productivity\"><a href=\"#打岔是效率的敌人-Interruption-is-the-enemy-of-productivity\" class=\"headerlink\" title=\"打岔是效率的敌人 Interruption is the enemy of productivity\"></a>打岔是效率的敌人 <small>Interruption is the enemy of productivity</small></h3><blockquote>\n<p>这一点让我深有体会，并且一直在挣扎的事情。<br>尝试过番茄工作法，并且尝试让同事理解我这样的做法。<br>并不接受直接过来打扰的沟通方式。</p>\n</blockquote>\n<h3 id=\"刚刚好就是真的好-Good-enough-is-fine\"><a href=\"#刚刚好就是真的好-Good-enough-is-fine\" class=\"headerlink\" title=\"刚刚好就是真的好 Good enough is fine\"></a>刚刚好就是真的好 <small>Good enough is fine</small></h3><blockquote>\n<p>以小博大，遵循简单，首要目的是把事情做好，做出来。<br>后面可以随时改善以及改进。</p>\n</blockquote>\n<h3 id=\"速战速决-Quick-Wins\"><a href=\"#速战速决-Quick-Wins\" class=\"headerlink\" title=\"速战速决 Quick Wins\"></a>速战速决 <small>Quick Wins</small></h3><blockquote>\n<p>在这一章中，作者多次提出一个概念，或者是思维：不要等，马上行动!<br>在我眼中，这里还有一个思维：积跬步以至千里。<br>这跟我的座右铭很相似：厚积薄发。</p>\n</blockquote>\n<h3 id=\"不要逞英雄-Don’t-be-a-hero\"><a href=\"#不要逞英雄-Don’t-be-a-hero\" class=\"headerlink\" title=\"不要逞英雄 Don’t be a hero\"></a>不要逞英雄 <small>Don’t be a hero</small></h3><blockquote>\n<p>把你的时间花在最值得花的地方，并且要量力而行，学会放弃</p>\n</blockquote>\n<h3 id=\"该睡觉时就睡觉-Go-to-sleep\"><a href=\"#该睡觉时就睡觉-Go-to-sleep\" class=\"headerlink\" title=\"该睡觉时就睡觉 Go to sleep\"></a>该睡觉时就睡觉 <small>Go to sleep</small></h3><blockquote>\n<p>学会休息，并且是高效的休息。<br>因为疲倦会带来懒惰思考、缺乏创意、士气低落、情绪失控。</p>\n</blockquote>\n<h3 id=\"预估的都是垃圾-Your-estimates-suck\"><a href=\"#预估的都是垃圾-Your-estimates-suck\" class=\"headerlink\" title=\"预估的都是垃圾 Your estimates suck\"></a>预估的都是垃圾 <small>Your estimates suck</small></h3><blockquote>\n<p>对于自己的学习计划也是如此，很多东西想学，却不知从哪个开始，怎么开始。<br>那么就把它们排个序，然后逐个评估时间，然后马上执行。</p>\n</blockquote>\n<h3 id=\"罗列问题，不得解决-Long-lists-don’t-get-done\"><a href=\"#罗列问题，不得解决-Long-lists-don’t-get-done\" class=\"headerlink\" title=\"罗列问题，不得解决 Long lists don’t get done\"></a>罗列问题，不得解决 <small>Long lists don’t get done</small></h3><blockquote>\n<p>把大任务分成小任务，并从小任务中获得成就感。</p>\n</blockquote>\n<h2 id=\"对手篇\"><a href=\"#对手篇\" class=\"headerlink\" title=\"对手篇\"></a>对手篇</h2><h3 id=\"拒绝照搬-Don’t-copy\"><a href=\"#拒绝照搬-Don’t-copy\" class=\"headerlink\" title=\"拒绝照搬 Don’t copy\"></a>拒绝照搬 <small>Don’t copy</small></h3><blockquote>\n<p>在学习的方向上，需要模仿，这是一种有效的学习方式。<br>Copy-Paste的过程中，尽量知其所以然。<br>不需要盲从，掌握主动。</p>\n</blockquote>\n<h3 id=\"向对手挑战-Pick-a-fight\"><a href=\"#向对手挑战-Pick-a-fight\" class=\"headerlink\" title=\"向对手挑战 Pick a fight\"></a>向对手挑战 <small>Pick a fight</small></h3><blockquote>\n<p>调侃对手这种做法，更偏向于一种营销手段，需要玩出自己的特色。<br>在国内，这种案例也很多，被网友戏称「碰瓷营销」。</p>\n</blockquote>\n<h3 id=\"给竞争力做减法-Underdo-your-competition\"><a href=\"#给竞争力做减法-Underdo-your-competition\" class=\"headerlink\" title=\"给竞争力做减法 Underdo your competition\"></a>给竞争力做减法 <small>Underdo your competition</small></h3><blockquote>\n<p>一款简约的产品，只需要集中解决用户的一个主要的痛点，而且如果以低成本随手可得的话，更加容易成为流行品。</p>\n</blockquote>\n<h2 id=\"进化篇\"><a href=\"#进化篇\" class=\"headerlink\" title=\"进化篇\"></a>进化篇</h2><h3 id=\"头脑发热不等于当务之急-Don’t-confuse-enthusiasm-with-priority\"><a href=\"#头脑发热不等于当务之急-Don’t-confuse-enthusiasm-with-priority\" class=\"headerlink\" title=\"头脑发热不等于当务之急 Don’t confuse enthusiasm with priority\"></a>头脑发热不等于当务之急 <small>Don’t confuse enthusiasm with priority</small></h3><blockquote>\n<p>避免头脑发热，有些事情或决定，可以先放着，过几天再回来看看。<br>在《人性的弱点》中，也有类似的观点，那是这样的一个说法：一封愤怒的信，先放几天再决定是否要寄出。</p>\n</blockquote>\n<h3 id=\"家用便利就是好-Be-at-home-good\"><a href=\"#家用便利就是好-Be-at-home-good\" class=\"headerlink\" title=\"家用便利就是好 Be at home good\"></a>家用便利就是好 <small>Be at home good</small></h3><blockquote>\n<p>弄清哪个是本，哪个是辅</p>\n</blockquote>\n<h3 id=\"甘于低微-Welcome-obscurity\"><a href=\"#甘于低微-Welcome-obscurity\" class=\"headerlink\" title=\"甘于低微 Welcome obscurity\"></a>甘于低微 <small>Welcome obscurity</small></h3><blockquote>\n<p>之所以说籍籍无名值得庆幸。<br>是因为在这个阶段犯的错误，并没有放大效应，试错成本低。<br>对于「甘于低微」，我还有另外一种理解。<br>每个人都有他的优点，有胜于你的地方。甘于低微，可以让你保持低调，以及一颗愿意接纳新想法的心。</p>\n</blockquote>\n<h3 id=\"培养自己的拥趸-Build-an-audience\"><a href=\"#培养自己的拥趸-Build-an-audience\" class=\"headerlink\" title=\"培养自己的拥趸 Build an audience\"></a>培养自己的拥趸 <small>Build an audience</small></h3><blockquote>\n<p>通过提供有价值的内容，来培养自己的粉丝。</p>\n</blockquote>\n<h3 id=\"普及知识，赢得竞争-Out-teach-your-competition\"><a href=\"#普及知识，赢得竞争-Out-teach-your-competition\" class=\"headerlink\" title=\"普及知识，赢得竞争 Out-teach your competition\"></a>普及知识，赢得竞争 <small>Out-teach your competition</small></h3><blockquote>\n<p>国内的很多技术团队，都有各自的技术博客，都会有分享的习惯。<br>如果他们的内容强劲，他们所做的产品和项目也会备受关注。</p>\n</blockquote>\n<h3 id=\"效仿大厨-Emulate-chefs\"><a href=\"#效仿大厨-Emulate-chefs\" class=\"headerlink\" title=\"效仿大厨 Emulate chefs\"></a>效仿大厨 <small>Emulate chefs</small></h3><blockquote>\n<p>分享知识，是我一直所推崇的。<br>能帮助别人，记录进步，好处是不少的。</p>\n</blockquote>\n<h3 id=\"没人喜欢塑料花-Nobody-likes-plostic-flowers\"><a href=\"#没人喜欢塑料花-Nobody-likes-plostic-flowers\" class=\"headerlink\" title=\"没人喜欢塑料花 Nobody likes plostic flowers\"></a>没人喜欢塑料花 <small>Nobody likes plostic flowers</small></h3><blockquote>\n<p>不完美才真实，这一篇有很多优美的句子，尽管是翻译的句子。这让我好奇原版是怎么样的句子了。<br>这些句子，都谈论了一个道理：直面弱点，做真实的自己，把真实的自己展示给别人。<br>摘抄：</p>\n<ol>\n<li>不完美才真实，真实才能激起人们的共鸣。</li>\n<li>繁华落尽见真淳。</li>\n<li>“保留原有的韵致”是一种美丽的行事方法。</li>\n<li>过度的雕琢会使事物失去灵魂，变得机械乏味。</li>\n</ol>\n</blockquote>\n<h3 id=\"一夜成名只是传说-The-myth-of-the-overnight-sensation\"><a href=\"#一夜成名只是传说-The-myth-of-the-overnight-sensation\" class=\"headerlink\" title=\"一夜成名只是传说 The myth of the overnight sensation\"></a>一夜成名只是传说 <small>The myth of the overnight sensation</small></h3><blockquote>\n<p>文章中谈论到的几点，也是对个人来说很有启发性。<br>你要拥有足够牢固的基础来支撑你以后的名声。<br>现在就需要开始一点一滴的培养基础，和你的观众。</p>\n</blockquote>\n<h2 id=\"招聘篇\"><a href=\"#招聘篇\" class=\"headerlink\" title=\"招聘篇\"></a>招聘篇</h2><h3 id=\"受不了时再招人-Hire-when-it-hurts\"><a href=\"#受不了时再招人-Hire-when-it-hurts\" class=\"headerlink\" title=\"受不了时再招人 Hire when it hurts\"></a>受不了时再招人 <small>Hire when it hurts</small></h3><blockquote>\n<p>这也是对于创业团队，或者小团队而言。<br>在大公司的团队中，往往所分配的名额是固定的。<br>申请名额不容易，所以会导致很多一些部门都是招人进来先占个坑。</p>\n</blockquote>\n<h3 id=\"放弃牛人-Pass-on-greate-people\"><a href=\"#放弃牛人-Pass-on-greate-people\" class=\"headerlink\" title=\"放弃牛人 Pass on greate people\"></a>放弃牛人 <small>Pass on greate people</small></h3><blockquote>\n<p>这个也是大公司毛病，很多都是储备员工，也是没事找事干。<br>站在牛人的角度来想问题的话，在一个方向牛起来，总会有需要你的地方。</p>\n</blockquote>\n<h3 id=\"鸡尾酒会上的陌生人-Strangers-at-a-cocktail-party\"><a href=\"#鸡尾酒会上的陌生人-Strangers-at-a-cocktail-party\" class=\"headerlink\" title=\"鸡尾酒会上的陌生人 Strangers at a cocktail party\"></a>鸡尾酒会上的陌生人 <small>Strangers at a cocktail party</small></h3><blockquote>\n<p>招人，要给予足够的时间来交谈，得到充分的相互了解。<br>应聘，同样对你所应聘的公司给予足够的关注和充分的沟通。</p>\n</blockquote>\n<h3 id=\"可笑的求职简历-Resumes-are-ridiculous\"><a href=\"#可笑的求职简历-Resumes-are-ridiculous\" class=\"headerlink\" title=\"可笑的求职简历 Resumes are ridiculous\"></a>可笑的求职简历 <small>Resumes are ridiculous</small></h3><blockquote>\n<p>要充分的了解你所应聘的公司，这是未来很长一段时间共同奋斗的团队。<br>这考验了你的信息收集能力，和社交能力。</p>\n</blockquote>\n<h3 id=\"多年的无关经验-Years-of-irrelevance\"><a href=\"#多年的无关经验-Years-of-irrelevance\" class=\"headerlink\" title=\"多年的无关经验 Years of irrelevance\"></a>多年的无关经验 <small>Years of irrelevance</small></h3><blockquote>\n<p>熟悉、掌握一门技术活，只需要半年到一年的时间。<br>而在这之后，真正要看的是个人的努力程度、性格差异、智力水平以及工作态度。<br>当然，还有基础知识的积累。<br>例如你说有两年的NodeJS工作经验，但是基础的JavaScript都吃不通的话，让别人怎么相信你过去的努力程度。</p>\n</blockquote>\n<h2 id=\"救灾篇\"><a href=\"#救灾篇\" class=\"headerlink\" title=\"救灾篇\"></a>救灾篇</h2><h3 id=\"主动掌控负面新闻-Own-your-bad-news\"><a href=\"#主动掌控负面新闻-Own-your-bad-news\" class=\"headerlink\" title=\"主动掌控负面新闻 Own your bad news\"></a>主动掌控负面新闻 <small>Own your bad news</small></h3><blockquote>\n<p>自己的糗事由自己来说比别人来说，结果会好得多。<br>本篇说的，我总结三个字：责任心。<br>愿意承担起责任的人，总是受人尊重。</p>\n</blockquote>\n<h2 id=\"文化篇\"><a href=\"#文化篇\" class=\"headerlink\" title=\"文化篇\"></a>文化篇</h2><h3 id=\"文化不是由谁创造的-You-don’t-create-a-culture\"><a href=\"#文化不是由谁创造的-You-don’t-create-a-culture\" class=\"headerlink\" title=\"文化不是由谁创造的 You don’t create a culture\"></a>文化不是由谁创造的 <small>You don’t create a culture</small></h3><blockquote>\n<p>但是对于小团队来说，企业文化往往取决于创始人的个人魅力。</p>\n</blockquote>\n<h3 id=\"决策都是临时性的-Decisions-are-temporary\"><a href=\"#决策都是临时性的-Decisions-are-temporary\" class=\"headerlink\" title=\"决策都是临时性的 Decisions are temporary\"></a>决策都是临时性的 <small>Decisions are temporary</small></h3><blockquote>\n<p>在平时工作中，考虑功能实现的时候也是如此。<br>考虑得多是好事，但要参考特定环境的符合程度。<br>渐渐地感觉到了，担心的事情大多不会真的发生，当它真的发生了，再考虑对策吧。</p>\n</blockquote>\n<h3 id=\"跳过摇滚明星-Skip-the-rock-starts\"><a href=\"#跳过摇滚明星-Skip-the-rock-starts\" class=\"headerlink\" title=\"跳过摇滚明星 Skip the rock starts\"></a>跳过摇滚明星 <small>Skip the rock starts</small></h3><blockquote>\n<p>巨星环境的生成源于信任、自律以及责任感，是给予员工充分的隐私权、空间以及必备工具的结果。<br>所以BAT的技术团队才那么多人趋之若鹜。</p>\n</blockquote>\n<h3 id=\"员工不知13岁-They’re-not-children\"><a href=\"#员工不知13岁-They’re-not-children\" class=\"headerlink\" title=\"员工不知13岁 They’re not children\"></a>员工不知13岁 <small>They’re not children</small></h3><blockquote>\n<p>当你像小孩一样行事，别人也会把你当小孩子。<br>如何获得信任？<br>让你的工作在领导不用操心的情况下完成，在遇到问题和不懂的地方，先尝试自己解决。</p>\n</blockquote>\n<h3 id=\"发出你的心声-Sound-like-you\"><a href=\"#发出你的心声-Sound-like-you\" class=\"headerlink\" title=\"发出你的心声 Sound like you\"></a>发出你的心声 <small>Sound like you</small></h3><blockquote>\n<p>悲惨的是国内的应试语文教育，只会扼杀大部分人的写作能力。<br>真正的写作是一种自由、个性、观点的表述过程。<br>而不是那些为作文题目，为分数而写的非自愿的文章。</p>\n</blockquote>\n<h3 id=\"需要避开的词汇-Four-letters-words\"><a href=\"#需要避开的词汇-Four-letters-words\" class=\"headerlink\" title=\"需要避开的词汇 Four-letters words\"></a>需要避开的词汇 <small>Four-letters words</small></h3><blockquote>\n<p>避开那种「非黑即白」的词语，真相往往不是非黑即白。</p>\n</blockquote>\n<h2 id=\"总结篇\"><a href=\"#总结篇\" class=\"headerlink\" title=\"总结篇\"></a>总结篇</h2><h3 id=\"灵感稍纵即逝\"><a href=\"#灵感稍纵即逝\" class=\"headerlink\" title=\"灵感稍纵即逝\"></a>灵感稍纵即逝</h3><blockquote>\n<p>有些灵感也会因为当前能力的局限而难以实现。<br>但如果仅因为这样而放弃或者耽误你的灵感，是十分浪费的。<br>所以，在灵感还没来的时候就要「厚积」，而当灵感来敲门了，不管是否有足够的执行力，先开始了再说。</p>\n</blockquote>\n","excerpt":"","more":"<p>之前我们团队一直在用Coding来作为代码仓库，以及团队协作的工具。大半年下来，攒了不少「码币」，正好碰上Coding的码市搞活动，用码币换取一些Coding的周边，我翻到码市页面的最底下，正好有《重来》这本书可以兑换。对于码农来说，书是一个廉价却特别有价值的东西，于是毫不犹豫就兑换了这本书。</p>\n<p>《重来》，也叫《Rework》，作者是37signals的两位创始人：Json Fried, David Heinemeier Hansson。<br>这本书的主题是「创业」，书中蕴含了90条作者在创业过程中的商业思维，把它们分篇到12个章节中。<br>读这本书的过程中，我会在每一条有所体会，有所思的「思维」中，用铅笔在空白处写下自己的思考。<br>读这本书的感觉很像以前读的一本《人性的弱点》，都是教条式的写作。<br>其中的每一条，描述的篇幅都很小，但是每一条都需要思思品味，好好感悟。<br>很多「思维」中，虽然描述中明显的指向到「创业」思维中，但是我认为很多跟平时我们做人做事的原则很相符。<br>读书的过程虽慢，但是我却很认真，对一本好的书，多认真都不显得过分。<br>故以此文记录这些笔记。</p>\n<h2 id=\"卸负篇\"><a href=\"#卸负篇\" class=\"headerlink\" title=\"卸负篇\"></a>卸负篇</h2><h3 id=\"哪来的从错误中学习-Learning-from-mistakes-is-overrated\"><a href=\"#哪来的从错误中学习-Learning-from-mistakes-is-overrated\" class=\"headerlink\" title=\"哪来的从错误中学习 Learning from mistakes is overrated\"></a>哪来的从错误中学习 <small>Learning from mistakes is overrated</small></h3><blockquote>\n<p>在广义上，成功时并不需要知道失败所遇到的事情<br>若放在小事上，例如编程，有一些不折腾过，并不知道以后出错时如何解决<br>但也可以延伸另外一个观点：寻找前往成功的直径，绕开不必要的弯路。</p>\n</blockquote>\n<h3 id=\"计划既瞎猜-Planning-is-guessing\"><a href=\"#计划既瞎猜-Planning-is-guessing\" class=\"headerlink\" title=\"计划既瞎猜 Planning is guessing\"></a>计划既瞎猜 <small>Planning is guessing</small></h3><blockquote>\n<p>这篇的说法很符合「说走就走的旅行」的观念。<br>计划有用，是对未来的憧憬，但行动更重要，做自己想做的。</p>\n</blockquote>\n<h3 id=\"何必壮大-Why-grow\"><a href=\"#何必壮大-Why-grow\" class=\"headerlink\" title=\"何必壮大 Why grow?\"></a>何必壮大 <small>Why grow?</small></h3><blockquote>\n<p>在这一篇中，我想起了海贼王中「草帽路飞」海贼团。<br>团队中每个人都能独当一面，且有一个统一的向心点。</p>\n</blockquote>\n<h3 id=\"工作狂-Workaholism\"><a href=\"#工作狂-Workaholism\" class=\"headerlink\" title=\"工作狂 Workaholism\"></a>工作狂 <small>Workaholism</small></h3><blockquote>\n<p>这篇虽说加班，但更深层是效率的问题。<br>追求在对的方向，以对的方式快速完成事情。</p>\n</blockquote>\n<h2 id=\"行动篇\"><a href=\"#行动篇\" class=\"headerlink\" title=\"行动篇\"></a>行动篇</h2><h3 id=\"挠自己的痒处-Scratch-your-own-itch\"><a href=\"#挠自己的痒处-Scratch-your-own-itch\" class=\"headerlink\" title=\"挠自己的痒处 Scratch your own itch\"></a>挠自己的痒处 <small>Scratch your own itch</small></h3><blockquote>\n<p>为自己服务，解决自己的痛点，顺便造福一下人类。<br>让我想起了我那几个搁浅的开源项目-_-!</p>\n</blockquote>\n<h3 id=\"着手做点什么-Start-making-something\"><a href=\"#着手做点什么-Start-making-something\" class=\"headerlink\" title=\"着手做点什么 Start making something\"></a>着手做点什么 <small>Start making something</small></h3><blockquote>\n<p>价值并不在创意，而在于执行力。</p>\n</blockquote>\n<h3 id=\"画沙为界，立场明确-Draw-a-line-in-the-sand\"><a href=\"#画沙为界，立场明确-Draw-a-line-in-the-sand\" class=\"headerlink\" title=\"画沙为界，立场明确 Draw a line in the sand\"></a>画沙为界，立场明确 <small>Draw a line in the sand</small></h3><blockquote>\n<p>让自己更加主见，并且为你的主见提供足够让人信服的论证，如果没有，就去创造这样的论证。<br>这一篇有点「乔布斯」的味道，特立独行，打造自身的个性品牌，并无刻意迎合大众。<br>这又让我想起了魅族改变路线，迎合消费者，冲销量的做法。<br>但是，毕竟它身处一个苛刻的战场。</p>\n</blockquote>\n<h3 id=\"万不得已不筹资-Outside-money-is-Plan-2\"><a href=\"#万不得已不筹资-Outside-money-is-Plan-2\" class=\"headerlink\" title=\"万不得已不筹资 Outside money is Plan 2\"></a>万不得已不筹资 <small>Outside money is Plan 2</small></h3><blockquote>\n<p>这篇文章是站在创始人视角看待问题。<br>从另外一个角度来说，要看待投资方是谁。<br>如果是一些基金会，它们需要的是急切的盈利，想到的是如何套现。<br>而如果是看中你所做的事情，想一起合作的，或者合并你的公司的投资方就不一样了。他会把你所做的事情当做自己的事情来做。</p>\n</blockquote>\n<h2 id=\"进阶篇\"><a href=\"#进阶篇\" class=\"headerlink\" title=\"进阶篇\"></a>进阶篇</h2><h3 id=\"条件受限是好事-Embrace-constaints\"><a href=\"#条件受限是好事-Embrace-constaints\" class=\"headerlink\" title=\"条件受限是好事 Embrace constaints\"></a>条件受限是好事 <small>Embrace constaints</small></h3><blockquote>\n<p>本篇强调「灵活」与「限制」。<br>提出了一个让我所有共鸣，以往能感觉到却没能形容的观点：<br>以艰苦的条件来激发人的创造力。</p>\n</blockquote>\n<h3 id=\"与其做个半成品，不如做好半个产品-Build-half-a-product-Not-a-half-assed-product\"><a href=\"#与其做个半成品，不如做好半个产品-Build-half-a-product-Not-a-half-assed-product\" class=\"headerlink\" title=\"与其做个半成品，不如做好半个产品 Build half a product. Not a half-assed product\"></a>与其做个半成品，不如做好半个产品 <small>Build half a product. Not a half-assed product</small></h3><blockquote>\n<p>不要大而全，只要简而美。<br>兴趣与学习也是一个道理，选一件最需要做好的事情投入。</p>\n</blockquote>\n<h3 id=\"从核心出发-Start-at-the-epicenter\"><a href=\"#从核心出发-Start-at-the-epicenter\" class=\"headerlink\" title=\"从核心出发 Start at the epicenter\"></a>从核心出发 <small>Start at the epicenter</small></h3><blockquote>\n<p>选择能做的，想做的，必须做的。</p>\n</blockquote>\n<h3 id=\"不要过早关注细节-Ignore-the-details-early-on\"><a href=\"#不要过早关注细节-Ignore-the-details-early-on\" class=\"headerlink\" title=\"不要过早关注细节 Ignore the details early on\"></a>不要过早关注细节 <small>Ignore the details early on</small></h3><blockquote>\n<p>从整体到局部的思想，做设计、做架构，都是先有个轮廓，然后一点点细化。</p>\n</blockquote>\n<h3 id=\"作出决定就是取得进展-Making-the-call-is-making-progress\"><a href=\"#作出决定就是取得进展-Making-the-call-is-making-progress\" class=\"headerlink\" title=\"作出决定就是取得进展 Making the call is making progress\"></a>作出决定就是取得进展 <small>Making the call is making progress</small></h3><blockquote>\n<p>规划总是要有个度，太近的不够全面，太远的变数太多，不切实际。<br>当有了想法，尽早做个决定，先尝试走几步吧。</p>\n</blockquote>\n<h3 id=\"当好博物馆长-Be-a-curator\"><a href=\"#当好博物馆长-Be-a-curator\" class=\"headerlink\" title=\"当好博物馆长 Be a curator\"></a>当好博物馆长 <small>Be a curator</small></h3><blockquote>\n<p>精简，小而美。<br>不必追求大而全，东西要发挥它的作用。</p>\n</blockquote>\n<h3 id=\"关注不变因素-Focus-on-what-won’t-change\"><a href=\"#关注不变因素-Focus-on-what-won’t-change\" class=\"headerlink\" title=\"关注不变因素 Focus on what won’t change\"></a>关注不变因素 <small>Focus on what won’t change</small></h3><blockquote>\n<p>英语、经济学、写作、音乐，<br>这一些都是性价比颇高的素质，都十分有助于一个人的内在修养。</p>\n</blockquote>\n<h3 id=\"音乐就在你的指尖流淌-Tone-is-in-your-fingers\"><a href=\"#音乐就在你的指尖流淌-Tone-is-in-your-fingers\" class=\"headerlink\" title=\"音乐就在你的指尖流淌 Tone is in your fingers\"></a>音乐就在你的指尖流淌 <small>Tone is in your fingers</small></h3><blockquote>\n<p>抛开工具，关注事物的内在。<br>工具，是在你了解了其内部原理之后用来提升效率的。</p>\n</blockquote>\n<h3 id=\"卖掉副产品-Sell-your-by-products\"><a href=\"#卖掉副产品-Sell-your-by-products\" class=\"headerlink\" title=\"卖掉副产品 Sell your by-products\"></a>卖掉副产品 <small>Sell your by-products</small></h3><blockquote>\n<p>对于我的工作来说，把学习的过程，工作上遇到的问题给写下来，发表到博客，这就是我的副产品。</p>\n</blockquote>\n<h3 id=\"立马就上线-Launch-now\"><a href=\"#立马就上线-Launch-now\" class=\"headerlink\" title=\"立马就上线 Launch now\"></a>立马就上线 <small>Launch now</small></h3><blockquote>\n<p>第一个版本：一个能用的版本</p>\n</blockquote>\n<h2 id=\"效率篇\"><a href=\"#效率篇\" class=\"headerlink\" title=\"效率篇\"></a>效率篇</h2><h3 id=\"赞同的错觉-Illusions-of-agreement\"><a href=\"#赞同的错觉-Illusions-of-agreement\" class=\"headerlink\" title=\"赞同的错觉 Illusions of agreement\"></a>赞同的错觉 <small>Illusions of agreement</small></h3><blockquote>\n<p>很多时候多希望有一个idea出现的时候，立马可以动手来做，而不用太在意后来的事情。<br>但我认为，需要谨慎的事情需要适度的设计和考虑。</p>\n</blockquote>\n<h3 id=\"打岔是效率的敌人-Interruption-is-the-enemy-of-productivity\"><a href=\"#打岔是效率的敌人-Interruption-is-the-enemy-of-productivity\" class=\"headerlink\" title=\"打岔是效率的敌人 Interruption is the enemy of productivity\"></a>打岔是效率的敌人 <small>Interruption is the enemy of productivity</small></h3><blockquote>\n<p>这一点让我深有体会，并且一直在挣扎的事情。<br>尝试过番茄工作法，并且尝试让同事理解我这样的做法。<br>并不接受直接过来打扰的沟通方式。</p>\n</blockquote>\n<h3 id=\"刚刚好就是真的好-Good-enough-is-fine\"><a href=\"#刚刚好就是真的好-Good-enough-is-fine\" class=\"headerlink\" title=\"刚刚好就是真的好 Good enough is fine\"></a>刚刚好就是真的好 <small>Good enough is fine</small></h3><blockquote>\n<p>以小博大，遵循简单，首要目的是把事情做好，做出来。<br>后面可以随时改善以及改进。</p>\n</blockquote>\n<h3 id=\"速战速决-Quick-Wins\"><a href=\"#速战速决-Quick-Wins\" class=\"headerlink\" title=\"速战速决 Quick Wins\"></a>速战速决 <small>Quick Wins</small></h3><blockquote>\n<p>在这一章中，作者多次提出一个概念，或者是思维：不要等，马上行动!<br>在我眼中，这里还有一个思维：积跬步以至千里。<br>这跟我的座右铭很相似：厚积薄发。</p>\n</blockquote>\n<h3 id=\"不要逞英雄-Don’t-be-a-hero\"><a href=\"#不要逞英雄-Don’t-be-a-hero\" class=\"headerlink\" title=\"不要逞英雄 Don’t be a hero\"></a>不要逞英雄 <small>Don’t be a hero</small></h3><blockquote>\n<p>把你的时间花在最值得花的地方，并且要量力而行，学会放弃</p>\n</blockquote>\n<h3 id=\"该睡觉时就睡觉-Go-to-sleep\"><a href=\"#该睡觉时就睡觉-Go-to-sleep\" class=\"headerlink\" title=\"该睡觉时就睡觉 Go to sleep\"></a>该睡觉时就睡觉 <small>Go to sleep</small></h3><blockquote>\n<p>学会休息，并且是高效的休息。<br>因为疲倦会带来懒惰思考、缺乏创意、士气低落、情绪失控。</p>\n</blockquote>\n<h3 id=\"预估的都是垃圾-Your-estimates-suck\"><a href=\"#预估的都是垃圾-Your-estimates-suck\" class=\"headerlink\" title=\"预估的都是垃圾 Your estimates suck\"></a>预估的都是垃圾 <small>Your estimates suck</small></h3><blockquote>\n<p>对于自己的学习计划也是如此，很多东西想学，却不知从哪个开始，怎么开始。<br>那么就把它们排个序，然后逐个评估时间，然后马上执行。</p>\n</blockquote>\n<h3 id=\"罗列问题，不得解决-Long-lists-don’t-get-done\"><a href=\"#罗列问题，不得解决-Long-lists-don’t-get-done\" class=\"headerlink\" title=\"罗列问题，不得解决 Long lists don’t get done\"></a>罗列问题，不得解决 <small>Long lists don’t get done</small></h3><blockquote>\n<p>把大任务分成小任务，并从小任务中获得成就感。</p>\n</blockquote>\n<h2 id=\"对手篇\"><a href=\"#对手篇\" class=\"headerlink\" title=\"对手篇\"></a>对手篇</h2><h3 id=\"拒绝照搬-Don’t-copy\"><a href=\"#拒绝照搬-Don’t-copy\" class=\"headerlink\" title=\"拒绝照搬 Don’t copy\"></a>拒绝照搬 <small>Don’t copy</small></h3><blockquote>\n<p>在学习的方向上，需要模仿，这是一种有效的学习方式。<br>Copy-Paste的过程中，尽量知其所以然。<br>不需要盲从，掌握主动。</p>\n</blockquote>\n<h3 id=\"向对手挑战-Pick-a-fight\"><a href=\"#向对手挑战-Pick-a-fight\" class=\"headerlink\" title=\"向对手挑战 Pick a fight\"></a>向对手挑战 <small>Pick a fight</small></h3><blockquote>\n<p>调侃对手这种做法，更偏向于一种营销手段，需要玩出自己的特色。<br>在国内，这种案例也很多，被网友戏称「碰瓷营销」。</p>\n</blockquote>\n<h3 id=\"给竞争力做减法-Underdo-your-competition\"><a href=\"#给竞争力做减法-Underdo-your-competition\" class=\"headerlink\" title=\"给竞争力做减法 Underdo your competition\"></a>给竞争力做减法 <small>Underdo your competition</small></h3><blockquote>\n<p>一款简约的产品，只需要集中解决用户的一个主要的痛点，而且如果以低成本随手可得的话，更加容易成为流行品。</p>\n</blockquote>\n<h2 id=\"进化篇\"><a href=\"#进化篇\" class=\"headerlink\" title=\"进化篇\"></a>进化篇</h2><h3 id=\"头脑发热不等于当务之急-Don’t-confuse-enthusiasm-with-priority\"><a href=\"#头脑发热不等于当务之急-Don’t-confuse-enthusiasm-with-priority\" class=\"headerlink\" title=\"头脑发热不等于当务之急 Don’t confuse enthusiasm with priority\"></a>头脑发热不等于当务之急 <small>Don’t confuse enthusiasm with priority</small></h3><blockquote>\n<p>避免头脑发热，有些事情或决定，可以先放着，过几天再回来看看。<br>在《人性的弱点》中，也有类似的观点，那是这样的一个说法：一封愤怒的信，先放几天再决定是否要寄出。</p>\n</blockquote>\n<h3 id=\"家用便利就是好-Be-at-home-good\"><a href=\"#家用便利就是好-Be-at-home-good\" class=\"headerlink\" title=\"家用便利就是好 Be at home good\"></a>家用便利就是好 <small>Be at home good</small></h3><blockquote>\n<p>弄清哪个是本，哪个是辅</p>\n</blockquote>\n<h3 id=\"甘于低微-Welcome-obscurity\"><a href=\"#甘于低微-Welcome-obscurity\" class=\"headerlink\" title=\"甘于低微 Welcome obscurity\"></a>甘于低微 <small>Welcome obscurity</small></h3><blockquote>\n<p>之所以说籍籍无名值得庆幸。<br>是因为在这个阶段犯的错误，并没有放大效应，试错成本低。<br>对于「甘于低微」，我还有另外一种理解。<br>每个人都有他的优点，有胜于你的地方。甘于低微，可以让你保持低调，以及一颗愿意接纳新想法的心。</p>\n</blockquote>\n<h3 id=\"培养自己的拥趸-Build-an-audience\"><a href=\"#培养自己的拥趸-Build-an-audience\" class=\"headerlink\" title=\"培养自己的拥趸 Build an audience\"></a>培养自己的拥趸 <small>Build an audience</small></h3><blockquote>\n<p>通过提供有价值的内容，来培养自己的粉丝。</p>\n</blockquote>\n<h3 id=\"普及知识，赢得竞争-Out-teach-your-competition\"><a href=\"#普及知识，赢得竞争-Out-teach-your-competition\" class=\"headerlink\" title=\"普及知识，赢得竞争 Out-teach your competition\"></a>普及知识，赢得竞争 <small>Out-teach your competition</small></h3><blockquote>\n<p>国内的很多技术团队，都有各自的技术博客，都会有分享的习惯。<br>如果他们的内容强劲，他们所做的产品和项目也会备受关注。</p>\n</blockquote>\n<h3 id=\"效仿大厨-Emulate-chefs\"><a href=\"#效仿大厨-Emulate-chefs\" class=\"headerlink\" title=\"效仿大厨 Emulate chefs\"></a>效仿大厨 <small>Emulate chefs</small></h3><blockquote>\n<p>分享知识，是我一直所推崇的。<br>能帮助别人，记录进步，好处是不少的。</p>\n</blockquote>\n<h3 id=\"没人喜欢塑料花-Nobody-likes-plostic-flowers\"><a href=\"#没人喜欢塑料花-Nobody-likes-plostic-flowers\" class=\"headerlink\" title=\"没人喜欢塑料花 Nobody likes plostic flowers\"></a>没人喜欢塑料花 <small>Nobody likes plostic flowers</small></h3><blockquote>\n<p>不完美才真实，这一篇有很多优美的句子，尽管是翻译的句子。这让我好奇原版是怎么样的句子了。<br>这些句子，都谈论了一个道理：直面弱点，做真实的自己，把真实的自己展示给别人。<br>摘抄：</p>\n<ol>\n<li>不完美才真实，真实才能激起人们的共鸣。</li>\n<li>繁华落尽见真淳。</li>\n<li>“保留原有的韵致”是一种美丽的行事方法。</li>\n<li>过度的雕琢会使事物失去灵魂，变得机械乏味。</li>\n</ol>\n</blockquote>\n<h3 id=\"一夜成名只是传说-The-myth-of-the-overnight-sensation\"><a href=\"#一夜成名只是传说-The-myth-of-the-overnight-sensation\" class=\"headerlink\" title=\"一夜成名只是传说 The myth of the overnight sensation\"></a>一夜成名只是传说 <small>The myth of the overnight sensation</small></h3><blockquote>\n<p>文章中谈论到的几点，也是对个人来说很有启发性。<br>你要拥有足够牢固的基础来支撑你以后的名声。<br>现在就需要开始一点一滴的培养基础，和你的观众。</p>\n</blockquote>\n<h2 id=\"招聘篇\"><a href=\"#招聘篇\" class=\"headerlink\" title=\"招聘篇\"></a>招聘篇</h2><h3 id=\"受不了时再招人-Hire-when-it-hurts\"><a href=\"#受不了时再招人-Hire-when-it-hurts\" class=\"headerlink\" title=\"受不了时再招人 Hire when it hurts\"></a>受不了时再招人 <small>Hire when it hurts</small></h3><blockquote>\n<p>这也是对于创业团队，或者小团队而言。<br>在大公司的团队中，往往所分配的名额是固定的。<br>申请名额不容易，所以会导致很多一些部门都是招人进来先占个坑。</p>\n</blockquote>\n<h3 id=\"放弃牛人-Pass-on-greate-people\"><a href=\"#放弃牛人-Pass-on-greate-people\" class=\"headerlink\" title=\"放弃牛人 Pass on greate people\"></a>放弃牛人 <small>Pass on greate people</small></h3><blockquote>\n<p>这个也是大公司毛病，很多都是储备员工，也是没事找事干。<br>站在牛人的角度来想问题的话，在一个方向牛起来，总会有需要你的地方。</p>\n</blockquote>\n<h3 id=\"鸡尾酒会上的陌生人-Strangers-at-a-cocktail-party\"><a href=\"#鸡尾酒会上的陌生人-Strangers-at-a-cocktail-party\" class=\"headerlink\" title=\"鸡尾酒会上的陌生人 Strangers at a cocktail party\"></a>鸡尾酒会上的陌生人 <small>Strangers at a cocktail party</small></h3><blockquote>\n<p>招人，要给予足够的时间来交谈，得到充分的相互了解。<br>应聘，同样对你所应聘的公司给予足够的关注和充分的沟通。</p>\n</blockquote>\n<h3 id=\"可笑的求职简历-Resumes-are-ridiculous\"><a href=\"#可笑的求职简历-Resumes-are-ridiculous\" class=\"headerlink\" title=\"可笑的求职简历 Resumes are ridiculous\"></a>可笑的求职简历 <small>Resumes are ridiculous</small></h3><blockquote>\n<p>要充分的了解你所应聘的公司，这是未来很长一段时间共同奋斗的团队。<br>这考验了你的信息收集能力，和社交能力。</p>\n</blockquote>\n<h3 id=\"多年的无关经验-Years-of-irrelevance\"><a href=\"#多年的无关经验-Years-of-irrelevance\" class=\"headerlink\" title=\"多年的无关经验 Years of irrelevance\"></a>多年的无关经验 <small>Years of irrelevance</small></h3><blockquote>\n<p>熟悉、掌握一门技术活，只需要半年到一年的时间。<br>而在这之后，真正要看的是个人的努力程度、性格差异、智力水平以及工作态度。<br>当然，还有基础知识的积累。<br>例如你说有两年的NodeJS工作经验，但是基础的JavaScript都吃不通的话，让别人怎么相信你过去的努力程度。</p>\n</blockquote>\n<h2 id=\"救灾篇\"><a href=\"#救灾篇\" class=\"headerlink\" title=\"救灾篇\"></a>救灾篇</h2><h3 id=\"主动掌控负面新闻-Own-your-bad-news\"><a href=\"#主动掌控负面新闻-Own-your-bad-news\" class=\"headerlink\" title=\"主动掌控负面新闻 Own your bad news\"></a>主动掌控负面新闻 <small>Own your bad news</small></h3><blockquote>\n<p>自己的糗事由自己来说比别人来说，结果会好得多。<br>本篇说的，我总结三个字：责任心。<br>愿意承担起责任的人，总是受人尊重。</p>\n</blockquote>\n<h2 id=\"文化篇\"><a href=\"#文化篇\" class=\"headerlink\" title=\"文化篇\"></a>文化篇</h2><h3 id=\"文化不是由谁创造的-You-don’t-create-a-culture\"><a href=\"#文化不是由谁创造的-You-don’t-create-a-culture\" class=\"headerlink\" title=\"文化不是由谁创造的 You don’t create a culture\"></a>文化不是由谁创造的 <small>You don’t create a culture</small></h3><blockquote>\n<p>但是对于小团队来说，企业文化往往取决于创始人的个人魅力。</p>\n</blockquote>\n<h3 id=\"决策都是临时性的-Decisions-are-temporary\"><a href=\"#决策都是临时性的-Decisions-are-temporary\" class=\"headerlink\" title=\"决策都是临时性的 Decisions are temporary\"></a>决策都是临时性的 <small>Decisions are temporary</small></h3><blockquote>\n<p>在平时工作中，考虑功能实现的时候也是如此。<br>考虑得多是好事，但要参考特定环境的符合程度。<br>渐渐地感觉到了，担心的事情大多不会真的发生，当它真的发生了，再考虑对策吧。</p>\n</blockquote>\n<h3 id=\"跳过摇滚明星-Skip-the-rock-starts\"><a href=\"#跳过摇滚明星-Skip-the-rock-starts\" class=\"headerlink\" title=\"跳过摇滚明星 Skip the rock starts\"></a>跳过摇滚明星 <small>Skip the rock starts</small></h3><blockquote>\n<p>巨星环境的生成源于信任、自律以及责任感，是给予员工充分的隐私权、空间以及必备工具的结果。<br>所以BAT的技术团队才那么多人趋之若鹜。</p>\n</blockquote>\n<h3 id=\"员工不知13岁-They’re-not-children\"><a href=\"#员工不知13岁-They’re-not-children\" class=\"headerlink\" title=\"员工不知13岁 They’re not children\"></a>员工不知13岁 <small>They’re not children</small></h3><blockquote>\n<p>当你像小孩一样行事，别人也会把你当小孩子。<br>如何获得信任？<br>让你的工作在领导不用操心的情况下完成，在遇到问题和不懂的地方，先尝试自己解决。</p>\n</blockquote>\n<h3 id=\"发出你的心声-Sound-like-you\"><a href=\"#发出你的心声-Sound-like-you\" class=\"headerlink\" title=\"发出你的心声 Sound like you\"></a>发出你的心声 <small>Sound like you</small></h3><blockquote>\n<p>悲惨的是国内的应试语文教育，只会扼杀大部分人的写作能力。<br>真正的写作是一种自由、个性、观点的表述过程。<br>而不是那些为作文题目，为分数而写的非自愿的文章。</p>\n</blockquote>\n<h3 id=\"需要避开的词汇-Four-letters-words\"><a href=\"#需要避开的词汇-Four-letters-words\" class=\"headerlink\" title=\"需要避开的词汇 Four-letters words\"></a>需要避开的词汇 <small>Four-letters words</small></h3><blockquote>\n<p>避开那种「非黑即白」的词语，真相往往不是非黑即白。</p>\n</blockquote>\n<h2 id=\"总结篇\"><a href=\"#总结篇\" class=\"headerlink\" title=\"总结篇\"></a>总结篇</h2><h3 id=\"灵感稍纵即逝\"><a href=\"#灵感稍纵即逝\" class=\"headerlink\" title=\"灵感稍纵即逝\"></a>灵感稍纵即逝</h3><blockquote>\n<p>有些灵感也会因为当前能力的局限而难以实现。<br>但如果仅因为这样而放弃或者耽误你的灵感，是十分浪费的。<br>所以，在灵感还没来的时候就要「厚积」，而当灵感来敲门了，不管是否有足够的执行力，先开始了再说。</p>\n</blockquote>\n"},{"title":"那一夜独处","date":"2015-12-30T15:49:07.000Z","_content":"\n![](/image/blog/79702-d66ee9d1fd912b33.jpg)\n\n异地恋的开始，让我渐渐的开始再次......\n学会一个人的生活，\n学会享受独处的时间，\n学会享受一个人的红茶，\n学会享受周末午后那属于一个人的阳光，\n学会享受一个人安静的在暖黄色的灯光下细细品味书架上久久未动过的书。\n\n独处的时间让我重新有了思考的时间，这段时间，会想到以前没有想过的问题，会想到已经忘了的曾经的决心。\n\n黑夜中，独自一人在充满柔和暖光的房间中，闭上眼睛，发动身上的每一个细胞，去感受着周围。\n\n那是多么的安静，安静的让我忘却了我依然身处这个世界，完全沉浸在自我世界中，\n\n很久，很久，很久.....\n\n忽然，那一刻，恍然大悟，心旷神怡。\n\n清楚了自己想要的是什么，\n想走的是什么样的路，\n\n但是，\n\n我还不知道怎么去走，怎么去达到目标，\n\n这是接下来要做的。","source":"_posts/那一夜独处.md","raw":"---\ntitle: 那一夜独处\ncategory: 三省吾身\ndate: 2015-12-30 23:49:07\ntags:\n---\n\n![](/image/blog/79702-d66ee9d1fd912b33.jpg)\n\n异地恋的开始，让我渐渐的开始再次......\n学会一个人的生活，\n学会享受独处的时间，\n学会享受一个人的红茶，\n学会享受周末午后那属于一个人的阳光，\n学会享受一个人安静的在暖黄色的灯光下细细品味书架上久久未动过的书。\n\n独处的时间让我重新有了思考的时间，这段时间，会想到以前没有想过的问题，会想到已经忘了的曾经的决心。\n\n黑夜中，独自一人在充满柔和暖光的房间中，闭上眼睛，发动身上的每一个细胞，去感受着周围。\n\n那是多么的安静，安静的让我忘却了我依然身处这个世界，完全沉浸在自我世界中，\n\n很久，很久，很久.....\n\n忽然，那一刻，恍然大悟，心旷神怡。\n\n清楚了自己想要的是什么，\n想走的是什么样的路，\n\n但是，\n\n我还不知道怎么去走，怎么去达到目标，\n\n这是接下来要做的。","slug":"那一夜独处","published":1,"updated":"2017-02-02T14:53:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2otnwqv003b15hlhxrcihyk","content":"<p><img src=\"/image/blog/79702-d66ee9d1fd912b33.jpg\" alt=\"\"></p>\n<p>异地恋的开始，让我渐渐的开始再次……<br>学会一个人的生活，<br>学会享受独处的时间，<br>学会享受一个人的红茶，<br>学会享受周末午后那属于一个人的阳光，<br>学会享受一个人安静的在暖黄色的灯光下细细品味书架上久久未动过的书。</p>\n<p>独处的时间让我重新有了思考的时间，这段时间，会想到以前没有想过的问题，会想到已经忘了的曾经的决心。</p>\n<p>黑夜中，独自一人在充满柔和暖光的房间中，闭上眼睛，发动身上的每一个细胞，去感受着周围。</p>\n<p>那是多么的安静，安静的让我忘却了我依然身处这个世界，完全沉浸在自我世界中，</p>\n<p>很久，很久，很久…..</p>\n<p>忽然，那一刻，恍然大悟，心旷神怡。</p>\n<p>清楚了自己想要的是什么，<br>想走的是什么样的路，</p>\n<p>但是，</p>\n<p>我还不知道怎么去走，怎么去达到目标，</p>\n<p>这是接下来要做的。</p>\n","excerpt":"","more":"<p><img src=\"/image/blog/79702-d66ee9d1fd912b33.jpg\" alt=\"\"></p>\n<p>异地恋的开始，让我渐渐的开始再次……<br>学会一个人的生活，<br>学会享受独处的时间，<br>学会享受一个人的红茶，<br>学会享受周末午后那属于一个人的阳光，<br>学会享受一个人安静的在暖黄色的灯光下细细品味书架上久久未动过的书。</p>\n<p>独处的时间让我重新有了思考的时间，这段时间，会想到以前没有想过的问题，会想到已经忘了的曾经的决心。</p>\n<p>黑夜中，独自一人在充满柔和暖光的房间中，闭上眼睛，发动身上的每一个细胞，去感受着周围。</p>\n<p>那是多么的安静，安静的让我忘却了我依然身处这个世界，完全沉浸在自我世界中，</p>\n<p>很久，很久，很久…..</p>\n<p>忽然，那一刻，恍然大悟，心旷神怡。</p>\n<p>清楚了自己想要的是什么，<br>想走的是什么样的路，</p>\n<p>但是，</p>\n<p>我还不知道怎么去走，怎么去达到目标，</p>\n<p>这是接下来要做的。</p>\n"},{"title":"谈谈像素以及微信小程序的 rpx","date":"2017-05-21T06:21:25.000Z","_content":"\n# 前言\n最近在负责有赞的某个业务的微信小程序开发，这是我第一次着手微信小程序的开发，这个过程中发现微信小程序所定义的一套 WXSS (WeiXin Style Sheets) 中有一个有趣的长度单位 `rpx`，即 responsive pixel。\n根据官方的描述：\n> rpx（responsive pixel）， 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。\n\n平时我们一般会用 `em` 或者 `rem` 来做屏幕适配，而在微信小程序中，可以方便的借助 `rpx` 来完成这项工作。\n\n那么怎么理解 `rpx`，还有它与 `px` 之间什么关系？什么是物理像素？\n为了更好理解 `rpx`，我打算聊聊下面的一些概念：\n1. 像素 (Pixel)\n2. PPI (Pixels per inch 每英尺像素)\n3. DPR (Device pixel ratio)\n\n# 像素\n像素，英文单词：pixel，是英语单词 「picture」 的简写 「pix」，加上 「element」 的简写 「el」，合成的词汇，表示「图像元素」的意思。 \n一个像素只能表达一个色块，是显示的最小的一个单元。\n\n而在我们写代码的时候，可以把像素分为两种：\n\n1. 物理像素 Physical pixels\n2. 逻辑像素 Logical pixels\n\n## 物理像素\n也被称为设备像素 (Device independent pixels)，即设备在出厂的时候就已经固定了像素。\n\n我们来看一下 iPhone6 (左图) 与 iPhone6 plus (右图) 的官方显示屏的规格说明：\n\n![iPhone6 & iPhone6 plus 规格](http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/518488434BEC1074B675EB42A5A57AEF.png)\n\niPhone6 是 `1334px x 750px` 的像素分辨率，意思是当手机竖放的时候，横向有 750 个物理像素，纵向有 1334 个物理像素。\n\n## 逻辑像素\n在 CSS 中也被称为 CSS 像素 (CSS pixels)，是为 Web 开发者创造的，在 CSS 和 JavaScript 中使用的一个抽象的层，每一个 CSS 声明和几乎所有的 Javascript 属性都使用 CSS 像素。\n\n例如我们平时使用 Chrome 的设备调试工具的时候，iPhone6 是高 `667px`，宽是 `375px`，与苹果官方的 `1334px x 750px`，长宽分别少了 2 倍，那么面积就少了 4 倍。这就是经常说的 Retina 屏幕用四个(物理)像素表示一个(逻辑)像素。\n\n![Chrome 下 iPhone6 逻辑像素](http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/9C4CD0061C94690AF81DB8DED8F71252.png)\n\n# PPI\n\nPixels per inch，每英寸像素，也被称为像素密度，意思是一英寸中有多少个物理像素。\n其中 1英寸 (inch) = 2.54厘米 (cm)。\n\n回顾一下上面的 iPhone6 和 iPhone6 plus 的官方规格说明图，其中有 `ppi` 这一项，iPhone6 是 `326ppi`，iphone6 plus 是 `401ppi`。\n\n## PPI 怎么算出来的？\n\n要计算显示器的每英寸像素值，首先要确定屏幕的尺寸和分辨率。\nPPI 计算公式：\n\n![PPI 计算公式](http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/855BB6047CE2CA7F9DBBF1791D52C6CC.gif)\n\n其中，\n\n* dp (device pixel) 为屏幕对角线的分辨率\n* wp (width pixel) 为屏幕横向分辨率\n* hp (height piexl) 为屏幕纵向分辨率\n* di (device inch) 为屏幕对角线的长度(单位为英寸)。\n\n以 iPhone6 为例：\n\n![iPhone6 PPI 计算](http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/2A67EB1D8C0873E419C676DB430570C2.gif)\n\n四舍五入那便是 `326ppi` 了。\n\n## 物理像素有多大？\n\n「物理像素」是有特定长度的，这取决于 ppi 值。\n\n那么如何求出一个设备的物理像素的长度？\n因为绝大多数设备的物理像素都是方形的，我们可以假设当前设备的像素是方形的。\n那么，\n\n* iPhone6 中每个像素长度：1inch / 326ppi ≈ 0.003 inch = 0.0762mm\n* iPhone6 plus 中每个像素长度：1inch / 401ppi ≈ 0.002 inch = 0.0508mm\n\n可以看出 iPhone6 plus 的屏幕制作工艺更加精细。\n因为像素越小，那么单位面积内像素点就越多，显示的效果人眼就越难看出毛刺。\n用来显示一份图像的像素越多，效果就越接近现实。\n\n和物理像素不同，「逻辑像素」没有特定的物理长度的，只是表示显示设备中最小的显示单元，优秀的显示设备完全可以把显示单元做的更加小，以达到更好的显示效果。\n\n# DPR\nDevice Pixel Ratio，设备像素比。\n\n在早先的移动设备中，并没有 DPR 的概念。随着技术的发展，移动设备的屏幕像素密度越来越高。\n从 iPhone4 开始，苹果公司推出了所谓的 Retina 视网膜屏幕。之所以叫做视网膜屏幕，是因为屏幕的 PPI 太高，人的视网膜无法分辨出屏幕上的像素点。\niPhone4 的分辨率提高了一倍，但屏幕尺寸却没有变化，这意味着同样大小的屏幕上，像素多了一倍，于是 `dpr = 2`。\n\n在 Chrome 浏览器可以通过以下代码获取设备的 DPR：\n\n```\nlet dpr = window.devicePixelRatio;\n```\n\n而通过下面的代码可以获取设备的逻辑像素：\n\n```\nlet logicalHeight = screen.height;\nlet logicalWidth = screen.width;\n```\n\n那么很多人看到这里，就会认为：`物理像素 = 逻辑像素 * dpr`\n但实际情况并不是这样，\n留意一下 iPhone6 plus 的物理像素和逻辑像素：\n\n * 物理像素：`1080px x 1920px`\n * 逻辑像素：`414px x 736px`\n \n而官方声称 iPhone6 plus 的 `dpr = 3`，按理应该是：\n\n * `414px x 736px` → 乘以 3 倍 dpr → `1242px x 2208px`\n \n那么 iPhone6 plus 只有 `1080px x 1920px`，怎么去展示 `1241px x 2208px` 的分辨率呢？\n\n原来 iPhone6 plus 对逻辑像素做了缩小处理，以适应物理像素，也就是\n`1241px x 2208px` 除以 `115%` ，得到 `1080px x 1920px`。\n\n换句话来说，本来 iPhone6 plus 的 `dpr = 2.6`，但是通过虚拟技术把物理像素放大 115% ，以达到 `dpr = 3` 的效果。\n\n所以说是假 3 倍 dpr，其实我们开发和设计的时候也不用管这个，当作它就是 3 倍 dpr 就好了。\n\n\n# 回到 rpx\n\n根据官方给出的 rpx 换算 px 的实例：\n![rpx 换算 px](http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/ACED349F80C8D926AB74922C360B2F5A.png)\n\n三款机器的逻辑像素：\n\n* iPhone5 : `320px x 568px`\n* iPhone6 : `375px x 667px`\n* iPhone6 plus : `414px x 736px`\n\nrpx 转换成 px 是需要乘以一个系数的：\n\n* `px = rpx * n`\n\n其中系数 n，是跟着设备改变的：\n\n* iPhone5: `n = 2.34`\n* iPhone6: `n = 2`\n* iPhone6 plus: `n = 1.81`\n\n所以 rpx 只是定义一个绝对值 750 宽度，然后简单的根据不同设备的逻辑像素来进行 rpx 到 px 的换算。\n\n精明的观众可能发现了， rpx 压根就不需要关心 DPR 和 PPI 的概念。\n呃，其实我就是在理解 rpx 的过程中，拦不住思维的发散，了解了一大堆概念，然后顺道给你们分享一下罢了。\n\n# 参考\n[Wiki - 像素](https://www.wikiwand.com/zh-sg/%E5%83%8F%E7%B4%A0)\n[Wiki - 每英寸像素](https://www.wikiwand.com/zh-sg/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0)\n[iPhone 6 Screens Demystified](https://www.paintcodeapp.com/news/iphone-6-screens-demystified)\n\n","source":"_posts/talk-about-pixel-and-rpx.md","raw":"---\ntitle: 谈谈像素以及微信小程序的 rpx\ncategory: 搬砖码农\ndate: 2017-05-21 14:21:25\ntags: \n- 前端\n---\n\n# 前言\n最近在负责有赞的某个业务的微信小程序开发，这是我第一次着手微信小程序的开发，这个过程中发现微信小程序所定义的一套 WXSS (WeiXin Style Sheets) 中有一个有趣的长度单位 `rpx`，即 responsive pixel。\n根据官方的描述：\n> rpx（responsive pixel）， 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。\n\n平时我们一般会用 `em` 或者 `rem` 来做屏幕适配，而在微信小程序中，可以方便的借助 `rpx` 来完成这项工作。\n\n那么怎么理解 `rpx`，还有它与 `px` 之间什么关系？什么是物理像素？\n为了更好理解 `rpx`，我打算聊聊下面的一些概念：\n1. 像素 (Pixel)\n2. PPI (Pixels per inch 每英尺像素)\n3. DPR (Device pixel ratio)\n\n# 像素\n像素，英文单词：pixel，是英语单词 「picture」 的简写 「pix」，加上 「element」 的简写 「el」，合成的词汇，表示「图像元素」的意思。 \n一个像素只能表达一个色块，是显示的最小的一个单元。\n\n而在我们写代码的时候，可以把像素分为两种：\n\n1. 物理像素 Physical pixels\n2. 逻辑像素 Logical pixels\n\n## 物理像素\n也被称为设备像素 (Device independent pixels)，即设备在出厂的时候就已经固定了像素。\n\n我们来看一下 iPhone6 (左图) 与 iPhone6 plus (右图) 的官方显示屏的规格说明：\n\n![iPhone6 & iPhone6 plus 规格](http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/518488434BEC1074B675EB42A5A57AEF.png)\n\niPhone6 是 `1334px x 750px` 的像素分辨率，意思是当手机竖放的时候，横向有 750 个物理像素，纵向有 1334 个物理像素。\n\n## 逻辑像素\n在 CSS 中也被称为 CSS 像素 (CSS pixels)，是为 Web 开发者创造的，在 CSS 和 JavaScript 中使用的一个抽象的层，每一个 CSS 声明和几乎所有的 Javascript 属性都使用 CSS 像素。\n\n例如我们平时使用 Chrome 的设备调试工具的时候，iPhone6 是高 `667px`，宽是 `375px`，与苹果官方的 `1334px x 750px`，长宽分别少了 2 倍，那么面积就少了 4 倍。这就是经常说的 Retina 屏幕用四个(物理)像素表示一个(逻辑)像素。\n\n![Chrome 下 iPhone6 逻辑像素](http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/9C4CD0061C94690AF81DB8DED8F71252.png)\n\n# PPI\n\nPixels per inch，每英寸像素，也被称为像素密度，意思是一英寸中有多少个物理像素。\n其中 1英寸 (inch) = 2.54厘米 (cm)。\n\n回顾一下上面的 iPhone6 和 iPhone6 plus 的官方规格说明图，其中有 `ppi` 这一项，iPhone6 是 `326ppi`，iphone6 plus 是 `401ppi`。\n\n## PPI 怎么算出来的？\n\n要计算显示器的每英寸像素值，首先要确定屏幕的尺寸和分辨率。\nPPI 计算公式：\n\n![PPI 计算公式](http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/855BB6047CE2CA7F9DBBF1791D52C6CC.gif)\n\n其中，\n\n* dp (device pixel) 为屏幕对角线的分辨率\n* wp (width pixel) 为屏幕横向分辨率\n* hp (height piexl) 为屏幕纵向分辨率\n* di (device inch) 为屏幕对角线的长度(单位为英寸)。\n\n以 iPhone6 为例：\n\n![iPhone6 PPI 计算](http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/2A67EB1D8C0873E419C676DB430570C2.gif)\n\n四舍五入那便是 `326ppi` 了。\n\n## 物理像素有多大？\n\n「物理像素」是有特定长度的，这取决于 ppi 值。\n\n那么如何求出一个设备的物理像素的长度？\n因为绝大多数设备的物理像素都是方形的，我们可以假设当前设备的像素是方形的。\n那么，\n\n* iPhone6 中每个像素长度：1inch / 326ppi ≈ 0.003 inch = 0.0762mm\n* iPhone6 plus 中每个像素长度：1inch / 401ppi ≈ 0.002 inch = 0.0508mm\n\n可以看出 iPhone6 plus 的屏幕制作工艺更加精细。\n因为像素越小，那么单位面积内像素点就越多，显示的效果人眼就越难看出毛刺。\n用来显示一份图像的像素越多，效果就越接近现实。\n\n和物理像素不同，「逻辑像素」没有特定的物理长度的，只是表示显示设备中最小的显示单元，优秀的显示设备完全可以把显示单元做的更加小，以达到更好的显示效果。\n\n# DPR\nDevice Pixel Ratio，设备像素比。\n\n在早先的移动设备中，并没有 DPR 的概念。随着技术的发展，移动设备的屏幕像素密度越来越高。\n从 iPhone4 开始，苹果公司推出了所谓的 Retina 视网膜屏幕。之所以叫做视网膜屏幕，是因为屏幕的 PPI 太高，人的视网膜无法分辨出屏幕上的像素点。\niPhone4 的分辨率提高了一倍，但屏幕尺寸却没有变化，这意味着同样大小的屏幕上，像素多了一倍，于是 `dpr = 2`。\n\n在 Chrome 浏览器可以通过以下代码获取设备的 DPR：\n\n```\nlet dpr = window.devicePixelRatio;\n```\n\n而通过下面的代码可以获取设备的逻辑像素：\n\n```\nlet logicalHeight = screen.height;\nlet logicalWidth = screen.width;\n```\n\n那么很多人看到这里，就会认为：`物理像素 = 逻辑像素 * dpr`\n但实际情况并不是这样，\n留意一下 iPhone6 plus 的物理像素和逻辑像素：\n\n * 物理像素：`1080px x 1920px`\n * 逻辑像素：`414px x 736px`\n \n而官方声称 iPhone6 plus 的 `dpr = 3`，按理应该是：\n\n * `414px x 736px` → 乘以 3 倍 dpr → `1242px x 2208px`\n \n那么 iPhone6 plus 只有 `1080px x 1920px`，怎么去展示 `1241px x 2208px` 的分辨率呢？\n\n原来 iPhone6 plus 对逻辑像素做了缩小处理，以适应物理像素，也就是\n`1241px x 2208px` 除以 `115%` ，得到 `1080px x 1920px`。\n\n换句话来说，本来 iPhone6 plus 的 `dpr = 2.6`，但是通过虚拟技术把物理像素放大 115% ，以达到 `dpr = 3` 的效果。\n\n所以说是假 3 倍 dpr，其实我们开发和设计的时候也不用管这个，当作它就是 3 倍 dpr 就好了。\n\n\n# 回到 rpx\n\n根据官方给出的 rpx 换算 px 的实例：\n![rpx 换算 px](http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/ACED349F80C8D926AB74922C360B2F5A.png)\n\n三款机器的逻辑像素：\n\n* iPhone5 : `320px x 568px`\n* iPhone6 : `375px x 667px`\n* iPhone6 plus : `414px x 736px`\n\nrpx 转换成 px 是需要乘以一个系数的：\n\n* `px = rpx * n`\n\n其中系数 n，是跟着设备改变的：\n\n* iPhone5: `n = 2.34`\n* iPhone6: `n = 2`\n* iPhone6 plus: `n = 1.81`\n\n所以 rpx 只是定义一个绝对值 750 宽度，然后简单的根据不同设备的逻辑像素来进行 rpx 到 px 的换算。\n\n精明的观众可能发现了， rpx 压根就不需要关心 DPR 和 PPI 的概念。\n呃，其实我就是在理解 rpx 的过程中，拦不住思维的发散，了解了一大堆概念，然后顺道给你们分享一下罢了。\n\n# 参考\n[Wiki - 像素](https://www.wikiwand.com/zh-sg/%E5%83%8F%E7%B4%A0)\n[Wiki - 每英寸像素](https://www.wikiwand.com/zh-sg/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0)\n[iPhone 6 Screens Demystified](https://www.paintcodeapp.com/news/iphone-6-screens-demystified)\n\n","slug":"talk-about-pixel-and-rpx","published":1,"updated":"2017-05-21T12:29:26.000Z","_id":"cj2ybed9700004rhlnrypz9bc","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近在负责有赞的某个业务的微信小程序开发，这是我第一次着手微信小程序的开发，这个过程中发现微信小程序所定义的一套 WXSS (WeiXin Style Sheets) 中有一个有趣的长度单位 <code>rpx</code>，即 responsive pixel。<br>根据官方的描述：</p>\n<blockquote>\n<p>rpx（responsive pixel）， 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p>\n</blockquote>\n<p>平时我们一般会用 <code>em</code> 或者 <code>rem</code> 来做屏幕适配，而在微信小程序中，可以方便的借助 <code>rpx</code> 来完成这项工作。</p>\n<p>那么怎么理解 <code>rpx</code>，还有它与 <code>px</code> 之间什么关系？什么是物理像素？<br>为了更好理解 <code>rpx</code>，我打算聊聊下面的一些概念：</p>\n<ol>\n<li>像素 (Pixel)</li>\n<li>PPI (Pixels per inch 每英尺像素)</li>\n<li>DPR (Device pixel ratio)</li>\n</ol>\n<h1 id=\"像素\"><a href=\"#像素\" class=\"headerlink\" title=\"像素\"></a>像素</h1><p>像素，英文单词：pixel，是英语单词 「picture」 的简写 「pix」，加上 「element」 的简写 「el」，合成的词汇，表示「图像元素」的意思。<br>一个像素只能表达一个色块，是显示的最小的一个单元。</p>\n<p>而在我们写代码的时候，可以把像素分为两种：</p>\n<ol>\n<li>物理像素 Physical pixels</li>\n<li>逻辑像素 Logical pixels</li>\n</ol>\n<h2 id=\"物理像素\"><a href=\"#物理像素\" class=\"headerlink\" title=\"物理像素\"></a>物理像素</h2><p>也被称为设备像素 (Device independent pixels)，即设备在出厂的时候就已经固定了像素。</p>\n<p>我们来看一下 iPhone6 (左图) 与 iPhone6 plus (右图) 的官方显示屏的规格说明：</p>\n<p><img src=\"http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/518488434BEC1074B675EB42A5A57AEF.png\" alt=\"iPhone6 &amp; iPhone6 plus 规格\"></p>\n<p>iPhone6 是 <code>1334px x 750px</code> 的像素分辨率，意思是当手机竖放的时候，横向有 750 个物理像素，纵向有 1334 个物理像素。</p>\n<h2 id=\"逻辑像素\"><a href=\"#逻辑像素\" class=\"headerlink\" title=\"逻辑像素\"></a>逻辑像素</h2><p>在 CSS 中也被称为 CSS 像素 (CSS pixels)，是为 Web 开发者创造的，在 CSS 和 JavaScript 中使用的一个抽象的层，每一个 CSS 声明和几乎所有的 Javascript 属性都使用 CSS 像素。</p>\n<p>例如我们平时使用 Chrome 的设备调试工具的时候，iPhone6 是高 <code>667px</code>，宽是 <code>375px</code>，与苹果官方的 <code>1334px x 750px</code>，长宽分别少了 2 倍，那么面积就少了 4 倍。这就是经常说的 Retina 屏幕用四个(物理)像素表示一个(逻辑)像素。</p>\n<p><img src=\"http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/9C4CD0061C94690AF81DB8DED8F71252.png\" alt=\"Chrome 下 iPhone6 逻辑像素\"></p>\n<h1 id=\"PPI\"><a href=\"#PPI\" class=\"headerlink\" title=\"PPI\"></a>PPI</h1><p>Pixels per inch，每英寸像素，也被称为像素密度，意思是一英寸中有多少个物理像素。<br>其中 1英寸 (inch) = 2.54厘米 (cm)。</p>\n<p>回顾一下上面的 iPhone6 和 iPhone6 plus 的官方规格说明图，其中有 <code>ppi</code> 这一项，iPhone6 是 <code>326ppi</code>，iphone6 plus 是 <code>401ppi</code>。</p>\n<h2 id=\"PPI-怎么算出来的？\"><a href=\"#PPI-怎么算出来的？\" class=\"headerlink\" title=\"PPI 怎么算出来的？\"></a>PPI 怎么算出来的？</h2><p>要计算显示器的每英寸像素值，首先要确定屏幕的尺寸和分辨率。<br>PPI 计算公式：</p>\n<p><img src=\"http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/855BB6047CE2CA7F9DBBF1791D52C6CC.gif\" alt=\"PPI 计算公式\"></p>\n<p>其中，</p>\n<ul>\n<li>dp (device pixel) 为屏幕对角线的分辨率</li>\n<li>wp (width pixel) 为屏幕横向分辨率</li>\n<li>hp (height piexl) 为屏幕纵向分辨率</li>\n<li>di (device inch) 为屏幕对角线的长度(单位为英寸)。</li>\n</ul>\n<p>以 iPhone6 为例：</p>\n<p><img src=\"http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/2A67EB1D8C0873E419C676DB430570C2.gif\" alt=\"iPhone6 PPI 计算\"></p>\n<p>四舍五入那便是 <code>326ppi</code> 了。</p>\n<h2 id=\"物理像素有多大？\"><a href=\"#物理像素有多大？\" class=\"headerlink\" title=\"物理像素有多大？\"></a>物理像素有多大？</h2><p>「物理像素」是有特定长度的，这取决于 ppi 值。</p>\n<p>那么如何求出一个设备的物理像素的长度？<br>因为绝大多数设备的物理像素都是方形的，我们可以假设当前设备的像素是方形的。<br>那么，</p>\n<ul>\n<li>iPhone6 中每个像素长度：1inch / 326ppi ≈ 0.003 inch = 0.0762mm</li>\n<li>iPhone6 plus 中每个像素长度：1inch / 401ppi ≈ 0.002 inch = 0.0508mm</li>\n</ul>\n<p>可以看出 iPhone6 plus 的屏幕制作工艺更加精细。<br>因为像素越小，那么单位面积内像素点就越多，显示的效果人眼就越难看出毛刺。<br>用来显示一份图像的像素越多，效果就越接近现实。</p>\n<p>和物理像素不同，「逻辑像素」没有特定的物理长度的，只是表示显示设备中最小的显示单元，优秀的显示设备完全可以把显示单元做的更加小，以达到更好的显示效果。</p>\n<h1 id=\"DPR\"><a href=\"#DPR\" class=\"headerlink\" title=\"DPR\"></a>DPR</h1><p>Device Pixel Ratio，设备像素比。</p>\n<p>在早先的移动设备中，并没有 DPR 的概念。随着技术的发展，移动设备的屏幕像素密度越来越高。<br>从 iPhone4 开始，苹果公司推出了所谓的 Retina 视网膜屏幕。之所以叫做视网膜屏幕，是因为屏幕的 PPI 太高，人的视网膜无法分辨出屏幕上的像素点。<br>iPhone4 的分辨率提高了一倍，但屏幕尺寸却没有变化，这意味着同样大小的屏幕上，像素多了一倍，于是 <code>dpr = 2</code>。</p>\n<p>在 Chrome 浏览器可以通过以下代码获取设备的 DPR：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let dpr = window.devicePixelRatio;</div></pre></td></tr></table></figure>\n<p>而通过下面的代码可以获取设备的逻辑像素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let logicalHeight = screen.height;</div><div class=\"line\">let logicalWidth = screen.width;</div></pre></td></tr></table></figure>\n<p>那么很多人看到这里，就会认为：<code>物理像素 = 逻辑像素 * dpr</code><br>但实际情况并不是这样，<br>留意一下 iPhone6 plus 的物理像素和逻辑像素：</p>\n<ul>\n<li>物理像素：<code>1080px x 1920px</code></li>\n<li>逻辑像素：<code>414px x 736px</code></li>\n</ul>\n<p>而官方声称 iPhone6 plus 的 <code>dpr = 3</code>，按理应该是：</p>\n<ul>\n<li><code>414px x 736px</code> → 乘以 3 倍 dpr → <code>1242px x 2208px</code></li>\n</ul>\n<p>那么 iPhone6 plus 只有 <code>1080px x 1920px</code>，怎么去展示 <code>1241px x 2208px</code> 的分辨率呢？</p>\n<p>原来 iPhone6 plus 对逻辑像素做了缩小处理，以适应物理像素，也就是<br><code>1241px x 2208px</code> 除以 <code>115%</code> ，得到 <code>1080px x 1920px</code>。</p>\n<p>换句话来说，本来 iPhone6 plus 的 <code>dpr = 2.6</code>，但是通过虚拟技术把物理像素放大 115% ，以达到 <code>dpr = 3</code> 的效果。</p>\n<p>所以说是假 3 倍 dpr，其实我们开发和设计的时候也不用管这个，当作它就是 3 倍 dpr 就好了。</p>\n<h1 id=\"回到-rpx\"><a href=\"#回到-rpx\" class=\"headerlink\" title=\"回到 rpx\"></a>回到 rpx</h1><p>根据官方给出的 rpx 换算 px 的实例：<br><img src=\"http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/ACED349F80C8D926AB74922C360B2F5A.png\" alt=\"rpx 换算 px\"></p>\n<p>三款机器的逻辑像素：</p>\n<ul>\n<li>iPhone5 : <code>320px x 568px</code></li>\n<li>iPhone6 : <code>375px x 667px</code></li>\n<li>iPhone6 plus : <code>414px x 736px</code></li>\n</ul>\n<p>rpx 转换成 px 是需要乘以一个系数的：</p>\n<ul>\n<li><code>px = rpx * n</code></li>\n</ul>\n<p>其中系数 n，是跟着设备改变的：</p>\n<ul>\n<li>iPhone5: <code>n = 2.34</code></li>\n<li>iPhone6: <code>n = 2</code></li>\n<li>iPhone6 plus: <code>n = 1.81</code></li>\n</ul>\n<p>所以 rpx 只是定义一个绝对值 750 宽度，然后简单的根据不同设备的逻辑像素来进行 rpx 到 px 的换算。</p>\n<p>精明的观众可能发现了， rpx 压根就不需要关心 DPR 和 PPI 的概念。<br>呃，其实我就是在理解 rpx 的过程中，拦不住思维的发散，了解了一大堆概念，然后顺道给你们分享一下罢了。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.wikiwand.com/zh-sg/%E5%83%8F%E7%B4%A0\" target=\"_blank\" rel=\"external\">Wiki - 像素</a><br><a href=\"https://www.wikiwand.com/zh-sg/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0\" target=\"_blank\" rel=\"external\">Wiki - 每英寸像素</a><br><a href=\"https://www.paintcodeapp.com/news/iphone-6-screens-demystified\" target=\"_blank\" rel=\"external\">iPhone 6 Screens Demystified</a></p>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近在负责有赞的某个业务的微信小程序开发，这是我第一次着手微信小程序的开发，这个过程中发现微信小程序所定义的一套 WXSS (WeiXin Style Sheets) 中有一个有趣的长度单位 <code>rpx</code>，即 responsive pixel。<br>根据官方的描述：</p>\n<blockquote>\n<p>rpx（responsive pixel）， 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p>\n</blockquote>\n<p>平时我们一般会用 <code>em</code> 或者 <code>rem</code> 来做屏幕适配，而在微信小程序中，可以方便的借助 <code>rpx</code> 来完成这项工作。</p>\n<p>那么怎么理解 <code>rpx</code>，还有它与 <code>px</code> 之间什么关系？什么是物理像素？<br>为了更好理解 <code>rpx</code>，我打算聊聊下面的一些概念：</p>\n<ol>\n<li>像素 (Pixel)</li>\n<li>PPI (Pixels per inch 每英尺像素)</li>\n<li>DPR (Device pixel ratio)</li>\n</ol>\n<h1 id=\"像素\"><a href=\"#像素\" class=\"headerlink\" title=\"像素\"></a>像素</h1><p>像素，英文单词：pixel，是英语单词 「picture」 的简写 「pix」，加上 「element」 的简写 「el」，合成的词汇，表示「图像元素」的意思。<br>一个像素只能表达一个色块，是显示的最小的一个单元。</p>\n<p>而在我们写代码的时候，可以把像素分为两种：</p>\n<ol>\n<li>物理像素 Physical pixels</li>\n<li>逻辑像素 Logical pixels</li>\n</ol>\n<h2 id=\"物理像素\"><a href=\"#物理像素\" class=\"headerlink\" title=\"物理像素\"></a>物理像素</h2><p>也被称为设备像素 (Device independent pixels)，即设备在出厂的时候就已经固定了像素。</p>\n<p>我们来看一下 iPhone6 (左图) 与 iPhone6 plus (右图) 的官方显示屏的规格说明：</p>\n<p><img src=\"http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/518488434BEC1074B675EB42A5A57AEF.png\" alt=\"iPhone6 &amp; iPhone6 plus 规格\"></p>\n<p>iPhone6 是 <code>1334px x 750px</code> 的像素分辨率，意思是当手机竖放的时候，横向有 750 个物理像素，纵向有 1334 个物理像素。</p>\n<h2 id=\"逻辑像素\"><a href=\"#逻辑像素\" class=\"headerlink\" title=\"逻辑像素\"></a>逻辑像素</h2><p>在 CSS 中也被称为 CSS 像素 (CSS pixels)，是为 Web 开发者创造的，在 CSS 和 JavaScript 中使用的一个抽象的层，每一个 CSS 声明和几乎所有的 Javascript 属性都使用 CSS 像素。</p>\n<p>例如我们平时使用 Chrome 的设备调试工具的时候，iPhone6 是高 <code>667px</code>，宽是 <code>375px</code>，与苹果官方的 <code>1334px x 750px</code>，长宽分别少了 2 倍，那么面积就少了 4 倍。这就是经常说的 Retina 屏幕用四个(物理)像素表示一个(逻辑)像素。</p>\n<p><img src=\"http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/9C4CD0061C94690AF81DB8DED8F71252.png\" alt=\"Chrome 下 iPhone6 逻辑像素\"></p>\n<h1 id=\"PPI\"><a href=\"#PPI\" class=\"headerlink\" title=\"PPI\"></a>PPI</h1><p>Pixels per inch，每英寸像素，也被称为像素密度，意思是一英寸中有多少个物理像素。<br>其中 1英寸 (inch) = 2.54厘米 (cm)。</p>\n<p>回顾一下上面的 iPhone6 和 iPhone6 plus 的官方规格说明图，其中有 <code>ppi</code> 这一项，iPhone6 是 <code>326ppi</code>，iphone6 plus 是 <code>401ppi</code>。</p>\n<h2 id=\"PPI-怎么算出来的？\"><a href=\"#PPI-怎么算出来的？\" class=\"headerlink\" title=\"PPI 怎么算出来的？\"></a>PPI 怎么算出来的？</h2><p>要计算显示器的每英寸像素值，首先要确定屏幕的尺寸和分辨率。<br>PPI 计算公式：</p>\n<p><img src=\"http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/855BB6047CE2CA7F9DBBF1791D52C6CC.gif\" alt=\"PPI 计算公式\"></p>\n<p>其中，</p>\n<ul>\n<li>dp (device pixel) 为屏幕对角线的分辨率</li>\n<li>wp (width pixel) 为屏幕横向分辨率</li>\n<li>hp (height piexl) 为屏幕纵向分辨率</li>\n<li>di (device inch) 为屏幕对角线的长度(单位为英寸)。</li>\n</ul>\n<p>以 iPhone6 为例：</p>\n<p><img src=\"http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/2A67EB1D8C0873E419C676DB430570C2.gif\" alt=\"iPhone6 PPI 计算\"></p>\n<p>四舍五入那便是 <code>326ppi</code> 了。</p>\n<h2 id=\"物理像素有多大？\"><a href=\"#物理像素有多大？\" class=\"headerlink\" title=\"物理像素有多大？\"></a>物理像素有多大？</h2><p>「物理像素」是有特定长度的，这取决于 ppi 值。</p>\n<p>那么如何求出一个设备的物理像素的长度？<br>因为绝大多数设备的物理像素都是方形的，我们可以假设当前设备的像素是方形的。<br>那么，</p>\n<ul>\n<li>iPhone6 中每个像素长度：1inch / 326ppi ≈ 0.003 inch = 0.0762mm</li>\n<li>iPhone6 plus 中每个像素长度：1inch / 401ppi ≈ 0.002 inch = 0.0508mm</li>\n</ul>\n<p>可以看出 iPhone6 plus 的屏幕制作工艺更加精细。<br>因为像素越小，那么单位面积内像素点就越多，显示的效果人眼就越难看出毛刺。<br>用来显示一份图像的像素越多，效果就越接近现实。</p>\n<p>和物理像素不同，「逻辑像素」没有特定的物理长度的，只是表示显示设备中最小的显示单元，优秀的显示设备完全可以把显示单元做的更加小，以达到更好的显示效果。</p>\n<h1 id=\"DPR\"><a href=\"#DPR\" class=\"headerlink\" title=\"DPR\"></a>DPR</h1><p>Device Pixel Ratio，设备像素比。</p>\n<p>在早先的移动设备中，并没有 DPR 的概念。随着技术的发展，移动设备的屏幕像素密度越来越高。<br>从 iPhone4 开始，苹果公司推出了所谓的 Retina 视网膜屏幕。之所以叫做视网膜屏幕，是因为屏幕的 PPI 太高，人的视网膜无法分辨出屏幕上的像素点。<br>iPhone4 的分辨率提高了一倍，但屏幕尺寸却没有变化，这意味着同样大小的屏幕上，像素多了一倍，于是 <code>dpr = 2</code>。</p>\n<p>在 Chrome 浏览器可以通过以下代码获取设备的 DPR：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">let dpr = window.devicePixelRatio;</div></pre></td></tr></table></figure>\n<p>而通过下面的代码可以获取设备的逻辑像素：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let logicalHeight = screen.height;</div><div class=\"line\">let logicalWidth = screen.width;</div></pre></td></tr></table></figure>\n<p>那么很多人看到这里，就会认为：<code>物理像素 = 逻辑像素 * dpr</code><br>但实际情况并不是这样，<br>留意一下 iPhone6 plus 的物理像素和逻辑像素：</p>\n<ul>\n<li>物理像素：<code>1080px x 1920px</code></li>\n<li>逻辑像素：<code>414px x 736px</code></li>\n</ul>\n<p>而官方声称 iPhone6 plus 的 <code>dpr = 3</code>，按理应该是：</p>\n<ul>\n<li><code>414px x 736px</code> → 乘以 3 倍 dpr → <code>1242px x 2208px</code></li>\n</ul>\n<p>那么 iPhone6 plus 只有 <code>1080px x 1920px</code>，怎么去展示 <code>1241px x 2208px</code> 的分辨率呢？</p>\n<p>原来 iPhone6 plus 对逻辑像素做了缩小处理，以适应物理像素，也就是<br><code>1241px x 2208px</code> 除以 <code>115%</code> ，得到 <code>1080px x 1920px</code>。</p>\n<p>换句话来说，本来 iPhone6 plus 的 <code>dpr = 2.6</code>，但是通过虚拟技术把物理像素放大 115% ，以达到 <code>dpr = 3</code> 的效果。</p>\n<p>所以说是假 3 倍 dpr，其实我们开发和设计的时候也不用管这个，当作它就是 3 倍 dpr 就好了。</p>\n<h1 id=\"回到-rpx\"><a href=\"#回到-rpx\" class=\"headerlink\" title=\"回到 rpx\"></a>回到 rpx</h1><p>根据官方给出的 rpx 换算 px 的实例：<br><img src=\"http://om6ayrafu.bkt.clouddn.com/post/talk-about-pixel-and-rpx/ACED349F80C8D926AB74922C360B2F5A.png\" alt=\"rpx 换算 px\"></p>\n<p>三款机器的逻辑像素：</p>\n<ul>\n<li>iPhone5 : <code>320px x 568px</code></li>\n<li>iPhone6 : <code>375px x 667px</code></li>\n<li>iPhone6 plus : <code>414px x 736px</code></li>\n</ul>\n<p>rpx 转换成 px 是需要乘以一个系数的：</p>\n<ul>\n<li><code>px = rpx * n</code></li>\n</ul>\n<p>其中系数 n，是跟着设备改变的：</p>\n<ul>\n<li>iPhone5: <code>n = 2.34</code></li>\n<li>iPhone6: <code>n = 2</code></li>\n<li>iPhone6 plus: <code>n = 1.81</code></li>\n</ul>\n<p>所以 rpx 只是定义一个绝对值 750 宽度，然后简单的根据不同设备的逻辑像素来进行 rpx 到 px 的换算。</p>\n<p>精明的观众可能发现了， rpx 压根就不需要关心 DPR 和 PPI 的概念。<br>呃，其实我就是在理解 rpx 的过程中，拦不住思维的发散，了解了一大堆概念，然后顺道给你们分享一下罢了。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.wikiwand.com/zh-sg/%E5%83%8F%E7%B4%A0\">Wiki - 像素</a><br><a href=\"https://www.wikiwand.com/zh-sg/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0\">Wiki - 每英寸像素</a><br><a href=\"https://www.paintcodeapp.com/news/iphone-6-screens-demystified\">iPhone 6 Screens Demystified</a></p>\n"},{"title":"加深对 JavaScript This 的理解","date":"2017-07-15T02:40:00.000Z","_content":"\n我相信你已经看过很多关于 JavaScript 的 `this`  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 `this` 的理解。\n\n最近在看 [《You Dont Know JS》](https://github.com/getify/You-Dont-Know-JS) 这本书，不得感叹，就算用了 JS 很多年的老前端来看这本书，我觉得还是会有不少的收获。\n\n其中关于 `this` 的讲解，更是加深了我对 `this` 的理解，故整理知识点，再加上自身的理解，以自己的语言来描述。\n对读者来说，算是二手知识，这本书是开源的，可以到本书的 Github 项目地址学习一手的知识。\n\n首先有一句大家都明白的话，我还是要强调一遍：\n**「`this` 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。」**\n\n这句话很重要，这是理解 `this` 原理的基础。\n而在讲解 `this` 之前，先要理解一下作用域的相关概念。\n\n# 「词法作用域」与「动态作用域」\n通常来说，作用域一共有两种主要的工作模型。\n\n* 词法作用域\n* 动态作用域\n\n词法作用域是大多数编程语言所采用的模式，而动态作用域仍有一些编程语言在用，例如 Bash 脚本。\n而 JavaScript 就是采用的词法作用域，也就是在编程阶段，作用域就已经明确下来了。\n\n思考下面代码：\n\n```JavaScript\nfunction foo(){\n  console.log(a);   // 输出 2\n}\n\nfunction bar(){\n  let a = 3;\n  foo();\n}\n\nlet a = 2;\n\nbar()\n```\n\n因为 JavaScript 所用的是词法作用域，自然 `foo()` 声明的阶段，就已经确定了变量 `a` 的作用域了。\n\n倘若，JavaScript 是采用的动态作用域，`foo()` 中打印的将是 `3`\n\n```JavaScript\nfunction foo(){\n  console.log(a);   // 输出 3 （不是 2）\n}\n\nfunction bar(){\n  let a = 3;\n  foo();\n}\n\nlet a = 2;\n\nbar()\n```\n\n而 JavaScript 的 `this` 机制跟动态作用域很相似，是在运行时在被调用的地方动态绑定的。\n\n# this 的四种绑定规则\n\n在 JavaScript 中，影响 this 指向的绑定规则有四种：\n\n* 默认绑定\n* 隐式绑定\n* 显式绑定\n* new 绑定\n\n## 默认绑定\n这是最直接的一种方式，就是不加任何的修饰符直接调用函数，如：\n\n```javascript\nfunction foo() {\n  console.log(this.a)   // 输出 a\n}\n\nvar a = 2;  //  变量声明到全局对象中\n\nfoo();\n```\n\n使用 `var` 声明的变量 `a`，被绑定到全局对象中，如果是浏览器，则是在 `window` 对象。\n`foo()` 调用时，引用了默认绑定，`this` 指向了全局对象。\n\n## 隐式绑定\n这种情况会发生在调用位置存在「上下文对象」的情况，如：\n\n```javascript\nfunction foo() {\n  console.log(this.a);\n}\n\nlet obj1 = {\n  a: 1,\n  foo,\n};\n\nlet obj2 = {\n  a: 2,\n  foo,\n}\n\nobj1.foo();   // 输出 1\nobj2.foo();   // 输出 2\n```\n\n当函数调用的时候，拥有上下文对象的时候，`this` 会被绑定到该上下文对象。\n正如上面的代码，\n`obj1.foo()` 被调用时，`this` 绑定到了 `obj1`, \n而 `obj2.foo()` 被调用时，`this` 绑定到了 `obj2`。\n\n## 显式绑定\n这种就是使用 `Function.prototype` 中的三个方法 `call()`, `apply()`, `bind()` 了。\n这三个函数，都可以改变函数的 `this` 指向到指定的对象，\n不同之处在于，`call()` 和 `apply()` 是立即执行函数，并且接受的参数的形式不同：\n\n* `call(this, arg1, arg2, ...)`\n* `apply(this, [arg1, arg2, ...])`\n\n而 `bind()` 则是创建一个新的包装函数，并且返回，而不是立刻执行。\n\n* `bind(this, [arg1, arg2, ...])`\n\n`bind()` 和 `apply()` 接收参数的形式，有助于函数嵌套函数的时候，把 `arguments` 变量传递到下一层函数中。\n\n思考下面代码：\n\n```javascript\nfunction foo() {\n  console.log(this.a);  // 输出 1\n  bar.apply({a: 2}, arguments);\n}\n\nfunction bar(b) {\n  console.log(this.a + b);  // 输出 5\n}\n\nvar a = 1;\nfoo(3);\n```\n\n上面代码中， `foo()` 内部的 `this` 遵循默认绑定规则，绑定到全局变量中。\n而 `bar()` 在调用的时候，调用了 `apply()` 函数，把 `this` 绑定到了一个新的对象中 `{a: 2}`，而且原封不动的接收 `foo()` 接收的函数。\n\n## new 绑定\n最后一种，则是使用 `new` 操作符会产生 `this` 的绑定。\n在理解 `new` 操作符对 `this` 的影响，首先要理解 `new` 的原理。\n在 JavaScript 中，`new` 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。\n在 JavaScript 中，所有的函数都可以被 `new` 调用，这时候这个函数一般会被称为「构造函数」，实际上并不存在所谓「构造函数」，更确切的理解应该是对于函数的「构造调用」。\n\n使用 `new` 来调用函数，会自动执行下面操作：\n\n1. 创建一个全新的对象。\n2. 这个新对象会被执行 [[Prototype]] 连接。\n3. 这个新对象会绑定到函数调用的 this。\n4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。\n\n所以如果 `new` 是一个函数的话，会是这样子的：\n\n```javascript\nfunction New(Constructor, ...args){\n    let obj = {};   // 创建一个新对象\n    Object.setPrototypeOf(obj, Constructor.prototype);  // 连接新对象与函数的原型\n    return Constructor.apply(obj, args) || obj;   // 执行函数，改变 this 指向新的对象\n}\n\nfunction Foo(a){\n    this.a = a;\n}\n\nNew(Foo, 1);  // Foo { a: 1 }\n```\n\n所以，在使用 `new` 来调用函数时候，我们会构造一个新对象并把它绑定到函数调用中的 `this` 上。\n\n# 优先级\n\n如果一个位置发生了多条改变 this 的规则，那么优先级是如何的呢？\n\n看几段代码：\n\n```javascript\n// 显式绑定 > 隐式绑定\nfunction foo() {\n    console.log(this.a);\n}\n\nlet obj1 = {\n    a: 2,\n    foo,\n}\n\nobj1.foo();     // 输出 2\nobj1.foo.call({a: 1});      // 输出 1\n```\n\n这说明「显式绑定」的优先级大于「隐式绑定」\n\n```javascript\n// new 绑定 > 显式绑定\nfunction foo(a) {\n    this.a = a;\n}\n\nlet obj1 = {};\n\nlet bar = foo.bind(obj1);\nbar(2);\nconsole.log(obj1); // 输出 {a:2}\n\nlet obj2 = new bar(3);\nconsole.log(obj1); // 输出 {a:2}\nconsole.log(obj2); // 输出 foo { a: 3 }\n```\n\n这说明「new 绑定」的优先级大于「显式绑定」\n而「默认绑定」，毫无疑问是优先级最低的。\n所以优先级顺序为：\n\n**「new 绑定」 > 「显式绑定」 > 「隐式绑定」 > 「默认绑定。」**\n\n# 所以，this 到底是什么\n\n`this` 并不是在编写的时候绑定的，而是在运行时绑定的。它的上下文取决于函数调用时的各种条件。\n`this` 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n当一个函数被调用时，会创建一个「执行上下文」，这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。`this` 就是这个记录的一个属性，会在函数执行的过程中用到。\n\n# 参考\n[《You Dont Know JS》- this & Object Prototypes](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes)","source":"_posts/understand-this-of-javascript.md","raw":"---\ntitle: 加深对 JavaScript This 的理解\ncategory: 搬砖码农\ndate: 2017-07-15 10:40:00\ntags: \n- javascript\n---\n\n我相信你已经看过很多关于 JavaScript 的 `this`  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 `this` 的理解。\n\n最近在看 [《You Dont Know JS》](https://github.com/getify/You-Dont-Know-JS) 这本书，不得感叹，就算用了 JS 很多年的老前端来看这本书，我觉得还是会有不少的收获。\n\n其中关于 `this` 的讲解，更是加深了我对 `this` 的理解，故整理知识点，再加上自身的理解，以自己的语言来描述。\n对读者来说，算是二手知识，这本书是开源的，可以到本书的 Github 项目地址学习一手的知识。\n\n首先有一句大家都明白的话，我还是要强调一遍：\n**「`this` 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。」**\n\n这句话很重要，这是理解 `this` 原理的基础。\n而在讲解 `this` 之前，先要理解一下作用域的相关概念。\n\n# 「词法作用域」与「动态作用域」\n通常来说，作用域一共有两种主要的工作模型。\n\n* 词法作用域\n* 动态作用域\n\n词法作用域是大多数编程语言所采用的模式，而动态作用域仍有一些编程语言在用，例如 Bash 脚本。\n而 JavaScript 就是采用的词法作用域，也就是在编程阶段，作用域就已经明确下来了。\n\n思考下面代码：\n\n```JavaScript\nfunction foo(){\n  console.log(a);   // 输出 2\n}\n\nfunction bar(){\n  let a = 3;\n  foo();\n}\n\nlet a = 2;\n\nbar()\n```\n\n因为 JavaScript 所用的是词法作用域，自然 `foo()` 声明的阶段，就已经确定了变量 `a` 的作用域了。\n\n倘若，JavaScript 是采用的动态作用域，`foo()` 中打印的将是 `3`\n\n```JavaScript\nfunction foo(){\n  console.log(a);   // 输出 3 （不是 2）\n}\n\nfunction bar(){\n  let a = 3;\n  foo();\n}\n\nlet a = 2;\n\nbar()\n```\n\n而 JavaScript 的 `this` 机制跟动态作用域很相似，是在运行时在被调用的地方动态绑定的。\n\n# this 的四种绑定规则\n\n在 JavaScript 中，影响 this 指向的绑定规则有四种：\n\n* 默认绑定\n* 隐式绑定\n* 显式绑定\n* new 绑定\n\n## 默认绑定\n这是最直接的一种方式，就是不加任何的修饰符直接调用函数，如：\n\n```javascript\nfunction foo() {\n  console.log(this.a)   // 输出 a\n}\n\nvar a = 2;  //  变量声明到全局对象中\n\nfoo();\n```\n\n使用 `var` 声明的变量 `a`，被绑定到全局对象中，如果是浏览器，则是在 `window` 对象。\n`foo()` 调用时，引用了默认绑定，`this` 指向了全局对象。\n\n## 隐式绑定\n这种情况会发生在调用位置存在「上下文对象」的情况，如：\n\n```javascript\nfunction foo() {\n  console.log(this.a);\n}\n\nlet obj1 = {\n  a: 1,\n  foo,\n};\n\nlet obj2 = {\n  a: 2,\n  foo,\n}\n\nobj1.foo();   // 输出 1\nobj2.foo();   // 输出 2\n```\n\n当函数调用的时候，拥有上下文对象的时候，`this` 会被绑定到该上下文对象。\n正如上面的代码，\n`obj1.foo()` 被调用时，`this` 绑定到了 `obj1`, \n而 `obj2.foo()` 被调用时，`this` 绑定到了 `obj2`。\n\n## 显式绑定\n这种就是使用 `Function.prototype` 中的三个方法 `call()`, `apply()`, `bind()` 了。\n这三个函数，都可以改变函数的 `this` 指向到指定的对象，\n不同之处在于，`call()` 和 `apply()` 是立即执行函数，并且接受的参数的形式不同：\n\n* `call(this, arg1, arg2, ...)`\n* `apply(this, [arg1, arg2, ...])`\n\n而 `bind()` 则是创建一个新的包装函数，并且返回，而不是立刻执行。\n\n* `bind(this, [arg1, arg2, ...])`\n\n`bind()` 和 `apply()` 接收参数的形式，有助于函数嵌套函数的时候，把 `arguments` 变量传递到下一层函数中。\n\n思考下面代码：\n\n```javascript\nfunction foo() {\n  console.log(this.a);  // 输出 1\n  bar.apply({a: 2}, arguments);\n}\n\nfunction bar(b) {\n  console.log(this.a + b);  // 输出 5\n}\n\nvar a = 1;\nfoo(3);\n```\n\n上面代码中， `foo()` 内部的 `this` 遵循默认绑定规则，绑定到全局变量中。\n而 `bar()` 在调用的时候，调用了 `apply()` 函数，把 `this` 绑定到了一个新的对象中 `{a: 2}`，而且原封不动的接收 `foo()` 接收的函数。\n\n## new 绑定\n最后一种，则是使用 `new` 操作符会产生 `this` 的绑定。\n在理解 `new` 操作符对 `this` 的影响，首先要理解 `new` 的原理。\n在 JavaScript 中，`new` 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。\n在 JavaScript 中，所有的函数都可以被 `new` 调用，这时候这个函数一般会被称为「构造函数」，实际上并不存在所谓「构造函数」，更确切的理解应该是对于函数的「构造调用」。\n\n使用 `new` 来调用函数，会自动执行下面操作：\n\n1. 创建一个全新的对象。\n2. 这个新对象会被执行 [[Prototype]] 连接。\n3. 这个新对象会绑定到函数调用的 this。\n4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。\n\n所以如果 `new` 是一个函数的话，会是这样子的：\n\n```javascript\nfunction New(Constructor, ...args){\n    let obj = {};   // 创建一个新对象\n    Object.setPrototypeOf(obj, Constructor.prototype);  // 连接新对象与函数的原型\n    return Constructor.apply(obj, args) || obj;   // 执行函数，改变 this 指向新的对象\n}\n\nfunction Foo(a){\n    this.a = a;\n}\n\nNew(Foo, 1);  // Foo { a: 1 }\n```\n\n所以，在使用 `new` 来调用函数时候，我们会构造一个新对象并把它绑定到函数调用中的 `this` 上。\n\n# 优先级\n\n如果一个位置发生了多条改变 this 的规则，那么优先级是如何的呢？\n\n看几段代码：\n\n```javascript\n// 显式绑定 > 隐式绑定\nfunction foo() {\n    console.log(this.a);\n}\n\nlet obj1 = {\n    a: 2,\n    foo,\n}\n\nobj1.foo();     // 输出 2\nobj1.foo.call({a: 1});      // 输出 1\n```\n\n这说明「显式绑定」的优先级大于「隐式绑定」\n\n```javascript\n// new 绑定 > 显式绑定\nfunction foo(a) {\n    this.a = a;\n}\n\nlet obj1 = {};\n\nlet bar = foo.bind(obj1);\nbar(2);\nconsole.log(obj1); // 输出 {a:2}\n\nlet obj2 = new bar(3);\nconsole.log(obj1); // 输出 {a:2}\nconsole.log(obj2); // 输出 foo { a: 3 }\n```\n\n这说明「new 绑定」的优先级大于「显式绑定」\n而「默认绑定」，毫无疑问是优先级最低的。\n所以优先级顺序为：\n\n**「new 绑定」 > 「显式绑定」 > 「隐式绑定」 > 「默认绑定。」**\n\n# 所以，this 到底是什么\n\n`this` 并不是在编写的时候绑定的，而是在运行时绑定的。它的上下文取决于函数调用时的各种条件。\n`this` 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n当一个函数被调用时，会创建一个「执行上下文」，这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。`this` 就是这个记录的一个属性，会在函数执行的过程中用到。\n\n# 参考\n[《You Dont Know JS》- this & Object Prototypes](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes)","slug":"understand-this-of-javascript","published":1,"updated":"2017-07-15T14:41:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj55eh5y40000cthlgw8s90yl","content":"<p>我相信你已经看过很多关于 JavaScript 的 <code>this</code>  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 <code>this</code> 的理解。</p>\n<p>最近在看 <a href=\"https://github.com/getify/You-Dont-Know-JS\" target=\"_blank\" rel=\"external\">《You Dont Know JS》</a> 这本书，不得感叹，就算用了 JS 很多年的老前端来看这本书，我觉得还是会有不少的收获。</p>\n<p>其中关于 <code>this</code> 的讲解，更是加深了我对 <code>this</code> 的理解，故整理知识点，再加上自身的理解，以自己的语言来描述。<br>对读者来说，算是二手知识，这本书是开源的，可以到本书的 Github 项目地址学习一手的知识。</p>\n<p>首先有一句大家都明白的话，我还是要强调一遍：<br><strong>「<code>this</code> 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。」</strong></p>\n<p>这句话很重要，这是理解 <code>this</code> 原理的基础。<br>而在讲解 <code>this</code> 之前，先要理解一下作用域的相关概念。</p>\n<h1 id=\"「词法作用域」与「动态作用域」\"><a href=\"#「词法作用域」与「动态作用域」\" class=\"headerlink\" title=\"「词法作用域」与「动态作用域」\"></a>「词法作用域」与「动态作用域」</h1><p>通常来说，作用域一共有两种主要的工作模型。</p>\n<ul>\n<li>词法作用域</li>\n<li>动态作用域</li>\n</ul>\n<p>词法作用域是大多数编程语言所采用的模式，而动态作用域仍有一些编程语言在用，例如 Bash 脚本。<br>而 JavaScript 就是采用的词法作用域，也就是在编程阶段，作用域就已经明确下来了。</p>\n<p>思考下面代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(a);   <span class=\"comment\">// 输出 2</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</div><div class=\"line\">  foo();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">bar()</div></pre></td></tr></table></figure>\n<p>因为 JavaScript 所用的是词法作用域，自然 <code>foo()</code> 声明的阶段，就已经确定了变量 <code>a</code> 的作用域了。</p>\n<p>倘若，JavaScript 是采用的动态作用域，<code>foo()</code> 中打印的将是 <code>3</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(a);   <span class=\"comment\">// 输出 3 （不是 2）</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</div><div class=\"line\">  foo();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">bar()</div></pre></td></tr></table></figure>\n<p>而 JavaScript 的 <code>this</code> 机制跟动态作用域很相似，是在运行时在被调用的地方动态绑定的。</p>\n<h1 id=\"this-的四种绑定规则\"><a href=\"#this-的四种绑定规则\" class=\"headerlink\" title=\"this 的四种绑定规则\"></a>this 的四种绑定规则</h1><p>在 JavaScript 中，影响 this 指向的绑定规则有四种：</p>\n<ul>\n<li>默认绑定</li>\n<li>隐式绑定</li>\n<li>显式绑定</li>\n<li>new 绑定</li>\n</ul>\n<h2 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h2><p>这是最直接的一种方式，就是不加任何的修饰符直接调用函数，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)   <span class=\"comment\">// 输出 a</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;  <span class=\"comment\">//  变量声明到全局对象中</span></div><div class=\"line\"></div><div class=\"line\">foo();</div></pre></td></tr></table></figure>\n<p>使用 <code>var</code> 声明的变量 <code>a</code>，被绑定到全局对象中，如果是浏览器，则是在 <code>window</code> 对象。<br><code>foo()</code> 调用时，引用了默认绑定，<code>this</code> 指向了全局对象。</p>\n<h2 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h2><p>这种情况会发生在调用位置存在「上下文对象」的情况，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;</div><div class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">  foo,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;</div><div class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</div><div class=\"line\">  foo,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">obj1.foo();   <span class=\"comment\">// 输出 1</span></div><div class=\"line\">obj2.foo();   <span class=\"comment\">// 输出 2</span></div></pre></td></tr></table></figure>\n<p>当函数调用的时候，拥有上下文对象的时候，<code>this</code> 会被绑定到该上下文对象。<br>正如上面的代码，<br><code>obj1.foo()</code> 被调用时，<code>this</code> 绑定到了 <code>obj1</code>,<br>而 <code>obj2.foo()</code> 被调用时，<code>this</code> 绑定到了 <code>obj2</code>。</p>\n<h2 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h2><p>这种就是使用 <code>Function.prototype</code> 中的三个方法 <code>call()</code>, <code>apply()</code>, <code>bind()</code> 了。<br>这三个函数，都可以改变函数的 <code>this</code> 指向到指定的对象，<br>不同之处在于，<code>call()</code> 和 <code>apply()</code> 是立即执行函数，并且接受的参数的形式不同：</p>\n<ul>\n<li><code>call(this, arg1, arg2, ...)</code></li>\n<li><code>apply(this, [arg1, arg2, ...])</code></li>\n</ul>\n<p>而 <code>bind()</code> 则是创建一个新的包装函数，并且返回，而不是立刻执行。</p>\n<ul>\n<li><code>bind(this, [arg1, arg2, ...])</code></li>\n</ul>\n<p><code>bind()</code> 和 <code>apply()</code> 接收参数的形式，有助于函数嵌套函数的时候，把 <code>arguments</code> 变量传递到下一层函数中。</p>\n<p>思考下面代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);  <span class=\"comment\">// 输出 1</span></div><div class=\"line\">  bar.apply(&#123;<span class=\"attr\">a</span>: <span class=\"number\">2</span>&#125;, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a + b);  <span class=\"comment\">// 输出 5</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\">foo(<span class=\"number\">3</span>);</div></pre></td></tr></table></figure>\n<p>上面代码中， <code>foo()</code> 内部的 <code>this</code> 遵循默认绑定规则，绑定到全局变量中。<br>而 <code>bar()</code> 在调用的时候，调用了 <code>apply()</code> 函数，把 <code>this</code> 绑定到了一个新的对象中 <code>{a: 2}</code>，而且原封不动的接收 <code>foo()</code> 接收的函数。</p>\n<h2 id=\"new-绑定\"><a href=\"#new-绑定\" class=\"headerlink\" title=\"new 绑定\"></a>new 绑定</h2><p>最后一种，则是使用 <code>new</code> 操作符会产生 <code>this</code> 的绑定。<br>在理解 <code>new</code> 操作符对 <code>this</code> 的影响，首先要理解 <code>new</code> 的原理。<br>在 JavaScript 中，<code>new</code> 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。<br>在 JavaScript 中，所有的函数都可以被 <code>new</code> 调用，这时候这个函数一般会被称为「构造函数」，实际上并不存在所谓「构造函数」，更确切的理解应该是对于函数的「构造调用」。</p>\n<p>使用 <code>new</code> 来调用函数，会自动执行下面操作：</p>\n<ol>\n<li>创建一个全新的对象。</li>\n<li>这个新对象会被执行 [[Prototype]] 连接。</li>\n<li>这个新对象会绑定到函数调用的 this。</li>\n<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>所以如果 <code>new</code> 是一个函数的话，会是这样子的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">New</span>(<span class=\"params\">Constructor, ...args</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> obj = &#123;&#125;;   <span class=\"comment\">// 创建一个新对象</span></div><div class=\"line\">    <span class=\"built_in\">Object</span>.setPrototypeOf(obj, Constructor.prototype);  <span class=\"comment\">// 连接新对象与函数的原型</span></div><div class=\"line\">    <span class=\"keyword\">return</span> Constructor.apply(obj, args) || obj;   <span class=\"comment\">// 执行函数，改变 this 指向新的对象</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.a = a;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">New(Foo, <span class=\"number\">1</span>);  <span class=\"comment\">// Foo &#123; a: 1 &#125;</span></div></pre></td></tr></table></figure>\n<p>所以，在使用 <code>new</code> 来调用函数时候，我们会构造一个新对象并把它绑定到函数调用中的 <code>this</code> 上。</p>\n<h1 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h1><p>如果一个位置发生了多条改变 this 的规则，那么优先级是如何的呢？</p>\n<p>看几段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 显式绑定 &gt; 隐式绑定</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    foo,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">obj1.foo();     <span class=\"comment\">// 输出 2</span></div><div class=\"line\">obj1.foo.call(&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;);      <span class=\"comment\">// 输出 1</span></div></pre></td></tr></table></figure>\n<p>这说明「显式绑定」的优先级大于「隐式绑定」</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// new 绑定 &gt; 显式绑定</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.a = a;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> bar = foo.bind(obj1);</div><div class=\"line\">bar(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj1); <span class=\"comment\">// 输出 &#123;a:2&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> obj2 = <span class=\"keyword\">new</span> bar(<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj1); <span class=\"comment\">// 输出 &#123;a:2&#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj2); <span class=\"comment\">// 输出 foo &#123; a: 3 &#125;</span></div></pre></td></tr></table></figure>\n<p>这说明「new 绑定」的优先级大于「显式绑定」<br>而「默认绑定」，毫无疑问是优先级最低的。<br>所以优先级顺序为：</p>\n<p><strong>「new 绑定」 &gt; 「显式绑定」 &gt; 「隐式绑定」 &gt; 「默认绑定。」</strong></p>\n<h1 id=\"所以，this-到底是什么\"><a href=\"#所以，this-到底是什么\" class=\"headerlink\" title=\"所以，this 到底是什么\"></a>所以，this 到底是什么</h1><p><code>this</code> 并不是在编写的时候绑定的，而是在运行时绑定的。它的上下文取决于函数调用时的各种条件。<br><code>this</code> 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>当一个函数被调用时，会创建一个「执行上下文」，这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。<code>this</code> 就是这个记录的一个属性，会在函数执行的过程中用到。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes\" target=\"_blank\" rel=\"external\">《You Dont Know JS》- this &amp; Object Prototypes</a></p>\n","excerpt":"","more":"<p>我相信你已经看过很多关于 JavaScript 的 <code>this</code>  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 <code>this</code> 的理解。</p>\n<p>最近在看 <a href=\"https://github.com/getify/You-Dont-Know-JS\">《You Dont Know JS》</a> 这本书，不得感叹，就算用了 JS 很多年的老前端来看这本书，我觉得还是会有不少的收获。</p>\n<p>其中关于 <code>this</code> 的讲解，更是加深了我对 <code>this</code> 的理解，故整理知识点，再加上自身的理解，以自己的语言来描述。<br>对读者来说，算是二手知识，这本书是开源的，可以到本书的 Github 项目地址学习一手的知识。</p>\n<p>首先有一句大家都明白的话，我还是要强调一遍：<br><strong>「<code>this</code> 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。」</strong></p>\n<p>这句话很重要，这是理解 <code>this</code> 原理的基础。<br>而在讲解 <code>this</code> 之前，先要理解一下作用域的相关概念。</p>\n<h1 id=\"「词法作用域」与「动态作用域」\"><a href=\"#「词法作用域」与「动态作用域」\" class=\"headerlink\" title=\"「词法作用域」与「动态作用域」\"></a>「词法作用域」与「动态作用域」</h1><p>通常来说，作用域一共有两种主要的工作模型。</p>\n<ul>\n<li>词法作用域</li>\n<li>动态作用域</li>\n</ul>\n<p>词法作用域是大多数编程语言所采用的模式，而动态作用域仍有一些编程语言在用，例如 Bash 脚本。<br>而 JavaScript 就是采用的词法作用域，也就是在编程阶段，作用域就已经明确下来了。</p>\n<p>思考下面代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(a);   <span class=\"comment\">// 输出 2</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</div><div class=\"line\">  foo();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">bar()</div></pre></td></tr></table></figure>\n<p>因为 JavaScript 所用的是词法作用域，自然 <code>foo()</code> 声明的阶段，就已经确定了变量 <code>a</code> 的作用域了。</p>\n<p>倘若，JavaScript 是采用的动态作用域，<code>foo()</code> 中打印的将是 <code>3</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(a);   <span class=\"comment\">// 输出 3 （不是 2）</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">3</span>;</div><div class=\"line\">  foo();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">bar()</div></pre></td></tr></table></figure>\n<p>而 JavaScript 的 <code>this</code> 机制跟动态作用域很相似，是在运行时在被调用的地方动态绑定的。</p>\n<h1 id=\"this-的四种绑定规则\"><a href=\"#this-的四种绑定规则\" class=\"headerlink\" title=\"this 的四种绑定规则\"></a>this 的四种绑定规则</h1><p>在 JavaScript 中，影响 this 指向的绑定规则有四种：</p>\n<ul>\n<li>默认绑定</li>\n<li>隐式绑定</li>\n<li>显式绑定</li>\n<li>new 绑定</li>\n</ul>\n<h2 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h2><p>这是最直接的一种方式，就是不加任何的修饰符直接调用函数，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)   <span class=\"comment\">// 输出 a</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;  <span class=\"comment\">//  变量声明到全局对象中</span></div><div class=\"line\"></div><div class=\"line\">foo();</div></pre></td></tr></table></figure>\n<p>使用 <code>var</code> 声明的变量 <code>a</code>，被绑定到全局对象中，如果是浏览器，则是在 <code>window</code> 对象。<br><code>foo()</code> 调用时，引用了默认绑定，<code>this</code> 指向了全局对象。</p>\n<h2 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h2><p>这种情况会发生在调用位置存在「上下文对象」的情况，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;</div><div class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</div><div class=\"line\">  foo,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;</div><div class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</div><div class=\"line\">  foo,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">obj1.foo();   <span class=\"comment\">// 输出 1</span></div><div class=\"line\">obj2.foo();   <span class=\"comment\">// 输出 2</span></div></pre></td></tr></table></figure>\n<p>当函数调用的时候，拥有上下文对象的时候，<code>this</code> 会被绑定到该上下文对象。<br>正如上面的代码，<br><code>obj1.foo()</code> 被调用时，<code>this</code> 绑定到了 <code>obj1</code>,<br>而 <code>obj2.foo()</code> 被调用时，<code>this</code> 绑定到了 <code>obj2</code>。</p>\n<h2 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h2><p>这种就是使用 <code>Function.prototype</code> 中的三个方法 <code>call()</code>, <code>apply()</code>, <code>bind()</code> 了。<br>这三个函数，都可以改变函数的 <code>this</code> 指向到指定的对象，<br>不同之处在于，<code>call()</code> 和 <code>apply()</code> 是立即执行函数，并且接受的参数的形式不同：</p>\n<ul>\n<li><code>call(this, arg1, arg2, ...)</code></li>\n<li><code>apply(this, [arg1, arg2, ...])</code></li>\n</ul>\n<p>而 <code>bind()</code> 则是创建一个新的包装函数，并且返回，而不是立刻执行。</p>\n<ul>\n<li><code>bind(this, [arg1, arg2, ...])</code></li>\n</ul>\n<p><code>bind()</code> 和 <code>apply()</code> 接收参数的形式，有助于函数嵌套函数的时候，把 <code>arguments</code> 变量传递到下一层函数中。</p>\n<p>思考下面代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);  <span class=\"comment\">// 输出 1</span></div><div class=\"line\">  bar.apply(&#123;<span class=\"attr\">a</span>: <span class=\"number\">2</span>&#125;, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a + b);  <span class=\"comment\">// 输出 5</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\">foo(<span class=\"number\">3</span>);</div></pre></td></tr></table></figure>\n<p>上面代码中， <code>foo()</code> 内部的 <code>this</code> 遵循默认绑定规则，绑定到全局变量中。<br>而 <code>bar()</code> 在调用的时候，调用了 <code>apply()</code> 函数，把 <code>this</code> 绑定到了一个新的对象中 <code>{a: 2}</code>，而且原封不动的接收 <code>foo()</code> 接收的函数。</p>\n<h2 id=\"new-绑定\"><a href=\"#new-绑定\" class=\"headerlink\" title=\"new 绑定\"></a>new 绑定</h2><p>最后一种，则是使用 <code>new</code> 操作符会产生 <code>this</code> 的绑定。<br>在理解 <code>new</code> 操作符对 <code>this</code> 的影响，首先要理解 <code>new</code> 的原理。<br>在 JavaScript 中，<code>new</code> 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。<br>在 JavaScript 中，所有的函数都可以被 <code>new</code> 调用，这时候这个函数一般会被称为「构造函数」，实际上并不存在所谓「构造函数」，更确切的理解应该是对于函数的「构造调用」。</p>\n<p>使用 <code>new</code> 来调用函数，会自动执行下面操作：</p>\n<ol>\n<li>创建一个全新的对象。</li>\n<li>这个新对象会被执行 [[Prototype]] 连接。</li>\n<li>这个新对象会绑定到函数调用的 this。</li>\n<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>所以如果 <code>new</code> 是一个函数的话，会是这样子的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">New</span>(<span class=\"params\">Constructor, ...args</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> obj = &#123;&#125;;   <span class=\"comment\">// 创建一个新对象</span></div><div class=\"line\">    <span class=\"built_in\">Object</span>.setPrototypeOf(obj, Constructor.prototype);  <span class=\"comment\">// 连接新对象与函数的原型</span></div><div class=\"line\">    <span class=\"keyword\">return</span> Constructor.apply(obj, args) || obj;   <span class=\"comment\">// 执行函数，改变 this 指向新的对象</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.a = a;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">New(Foo, <span class=\"number\">1</span>);  <span class=\"comment\">// Foo &#123; a: 1 &#125;</span></div></pre></td></tr></table></figure>\n<p>所以，在使用 <code>new</code> 来调用函数时候，我们会构造一个新对象并把它绑定到函数调用中的 <code>this</code> 上。</p>\n<h1 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h1><p>如果一个位置发生了多条改变 this 的规则，那么优先级是如何的呢？</p>\n<p>看几段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 显式绑定 &gt; 隐式绑定</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    foo,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">obj1.foo();     <span class=\"comment\">// 输出 2</span></div><div class=\"line\">obj1.foo.call(&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;);      <span class=\"comment\">// 输出 1</span></div></pre></td></tr></table></figure>\n<p>这说明「显式绑定」的优先级大于「隐式绑定」</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// new 绑定 &gt; 显式绑定</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.a = a;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> bar = foo.bind(obj1);</div><div class=\"line\">bar(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj1); <span class=\"comment\">// 输出 &#123;a:2&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> obj2 = <span class=\"keyword\">new</span> bar(<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj1); <span class=\"comment\">// 输出 &#123;a:2&#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj2); <span class=\"comment\">// 输出 foo &#123; a: 3 &#125;</span></div></pre></td></tr></table></figure>\n<p>这说明「new 绑定」的优先级大于「显式绑定」<br>而「默认绑定」，毫无疑问是优先级最低的。<br>所以优先级顺序为：</p>\n<p><strong>「new 绑定」 &gt; 「显式绑定」 &gt; 「隐式绑定」 &gt; 「默认绑定。」</strong></p>\n<h1 id=\"所以，this-到底是什么\"><a href=\"#所以，this-到底是什么\" class=\"headerlink\" title=\"所以，this 到底是什么\"></a>所以，this 到底是什么</h1><p><code>this</code> 并不是在编写的时候绑定的，而是在运行时绑定的。它的上下文取决于函数调用时的各种条件。<br><code>this</code> 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>当一个函数被调用时，会创建一个「执行上下文」，这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。<code>this</code> 就是这个记录的一个属性，会在函数执行的过程中用到。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes\">《You Dont Know JS》- this &amp; Object Prototypes</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj2otnwp9000815hl5lf9kjo2","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwpg000e15hludh5f4ax"},{"post_id":"cj2otnwox000015hl2u8zcx2g","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwpi000i15hlcwedf3cr"},{"post_id":"cj2otnwpf000d15hlunfoh66h","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwpj000k15hli5om7xwm"},{"post_id":"cj2otnwp1000215hl433625yg","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwpj000o15hl063cbuge"},{"post_id":"cj2otnwpg000f15hlccmghe2f","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwpn000q15hln9t6s2lk"},{"post_id":"cj2otnwpi000j15hl6uf80wp4","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwpp000s15hlg5k8j1h8"},{"post_id":"cj2otnwp6000615hlqmqzfqdj","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwpq000w15hlpv1aqxrd"},{"post_id":"cj2otnwpj000l15hljf5uqez2","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwps000z15hlbcszypri"},{"post_id":"cj2otnwpk000p15hlf6h0ez8g","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwpv001415hl2rpv7jmo"},{"post_id":"cj2otnwpc000a15hlpfgc67om","category_id":"cj2otnwpj000m15hldae35rnx","_id":"cj2otnwpy001715hl6a7p0f8u"},{"post_id":"cj2otnwpn000r15hl5c4qi0vu","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwq0001b15hlua55a5qg"},{"post_id":"cj2otnwpp000u15hl2ehnuttw","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwq2001d15hlquodj9eg"},{"post_id":"cj2otnwpt001115hlov73itr4","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwq4001g15hlztyxyyuv"},{"post_id":"cj2otnwpv001515hloeygbxoh","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwq5001i15hlmlnxj2f5"},{"post_id":"cj2otnwpy001815hlhpy5upw0","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwq6001l15hlq5cndynm"},{"post_id":"cj2otnwpr000x15hlxm4syngb","category_id":"cj2otnwpu001315hlw8em19vw","_id":"cj2otnwq8001o15hltgqk5jkt"},{"post_id":"cj2otnwq1001c15hlj5yc928u","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqb001s15hlinbryrhg"},{"post_id":"cj2otnwq2001e15hlua7dg015","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqc001v15hlg19nigee"},{"post_id":"cj2otnwq4001h15hlpkg6brw0","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqd001y15hlunvow5hn"},{"post_id":"cj2otnwq5001j15hlni12pfx0","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqf002115hl9si8yb3s"},{"post_id":"cj2otnwq7001m15hl16ruk1dx","category_id":"cj2otnwpu001315hlw8em19vw","_id":"cj2otnwqg002315hlpocxgusi"},{"post_id":"cj2otnwq9001p15hlvl8zgw0h","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqi002715hlbnx1k2ms"},{"post_id":"cj2otnwqb001t15hl5jflzero","category_id":"cj2otnwpu001315hlw8em19vw","_id":"cj2otnwqk002a15hlag2wfqfj"},{"post_id":"cj2otnwqd001w15hl0afb02b2","category_id":"cj2otnwpu001315hlw8em19vw","_id":"cj2otnwql002e15hl2h2f5ri9"},{"post_id":"cj2otnwqe002015hloto4hiko","category_id":"cj2otnwpu001315hlw8em19vw","_id":"cj2otnwqm002h15hlz29z83ng"},{"post_id":"cj2otnwqf002215hlrjxf7h6i","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqn002k15hlq8j5e9hi"},{"post_id":"cj2otnwqg002515hlpia7ek45","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqn002m15hl6wbn7dvf"},{"post_id":"cj2otnwqi002815hlwf5wlejx","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqo002p15hlah5uj53n"},{"post_id":"cj2otnwql002c15hlak36388n","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqp002r15hlu6tp15s1"},{"post_id":"cj2otnwql002f15hllv2kxddz","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqq002u15hl9i4iobhw"},{"post_id":"cj2otnwqm002j15hlefx13l6i","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqr002x15hlsmxkoxir"},{"post_id":"cj2otnwqn002l15hln820y3xs","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqt003115hl9nb2lyej"},{"post_id":"cj2otnwqo002o15hlylkgg25s","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqt003415hlww4i9gaq"},{"post_id":"cj2otnwqo002q15hl30c6kmfq","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqu003715hlq4kskjtb"},{"post_id":"cj2otnwqp002s15hlf2zjqpyb","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqv003a15hl1a5jjiva"},{"post_id":"cj2otnwqq002w15hldmzugqsv","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqw003e15hl53wsgn1i"},{"post_id":"cj2otnwqr002z15hlpkbhjhvg","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqw003g15hlo0dej353"},{"post_id":"cj2otnwqt003315hl5pypmien","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqx003h15hlvjqnw77i"},{"post_id":"cj2otnwqu003515hla6ptz6o7","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2otnwqy003k15hlvyc9xg30"},{"post_id":"cj2otnwqu003815hl1fp35sgk","category_id":"cj2otnwpj000m15hldae35rnx","_id":"cj2otnwqz003m15hlq57tb896"},{"post_id":"cj2otnwqv003b15hlhxrcihyk","category_id":"cj2otnwpu001315hlw8em19vw","_id":"cj2otnwr0003p15hl89ffh749"},{"post_id":"cj2ybed9700004rhlnrypz9bc","category_id":"cj2otnwp3000415hla2del9if","_id":"cj2ybed9e00024rhlhspyryqk"},{"post_id":"cj55eh5y40000cthlgw8s90yl","category_id":"cj2otnwp3000415hla2del9if","_id":"cj55eh5yg0002cthlwocwd4cu"}],"PostTag":[{"post_id":"cj2otnwox000015hl2u8zcx2g","tag_id":"cj2otnwp6000515hltvva0dx5","_id":"cj2otnwpq000v15hlk0500zm7"},{"post_id":"cj2otnwox000015hl2u8zcx2g","tag_id":"cj2otnwpd000c15hls61kf7l9","_id":"cj2otnwps000y15hlov8ioavs"},{"post_id":"cj2otnwox000015hl2u8zcx2g","tag_id":"cj2otnwph000h15hlsmmz9bv6","_id":"cj2otnwpu001215hl31la8r8f"},{"post_id":"cj2otnwox000015hl2u8zcx2g","tag_id":"cj2otnwpj000n15hl12iaj3n4","_id":"cj2otnwpx001615hlolspvl7s"},{"post_id":"cj2otnwp1000215hl433625yg","tag_id":"cj2otnwph000h15hlsmmz9bv6","_id":"cj2otnwq0001a15hlx1uetra7"},{"post_id":"cj2otnwp6000615hlqmqzfqdj","tag_id":"cj2otnwps001015hlrgq6b5wj","_id":"cj2otnwq8001n15hllcc6u3vv"},{"post_id":"cj2otnwp6000615hlqmqzfqdj","tag_id":"cj2otnwpz001915hlxq6ztj7q","_id":"cj2otnwqa001q15hlwg6h45w7"},{"post_id":"cj2otnwp6000615hlqmqzfqdj","tag_id":"cj2otnwq3001f15hl2g830lws","_id":"cj2otnwqc001u15hlw4m0ow07"},{"post_id":"cj2otnwp9000815hl5lf9kjo2","tag_id":"cj2otnwps001015hlrgq6b5wj","_id":"cj2otnwqd001x15hlouzow2pv"},{"post_id":"cj2otnwpc000a15hlpfgc67om","tag_id":"cj2otnwqa001r15hl2q28jex5","_id":"cj2otnwqi002615hlarz1slm6"},{"post_id":"cj2otnwpc000a15hlpfgc67om","tag_id":"cj2otnwph000h15hlsmmz9bv6","_id":"cj2otnwqk002915hlwv5pfq15"},{"post_id":"cj2otnwqg002515hlpia7ek45","tag_id":"cj2otnwph000h15hlsmmz9bv6","_id":"cj2otnwql002d15hlekqjlq06"},{"post_id":"cj2otnwpf000d15hlunfoh66h","tag_id":"cj2otnwps001015hlrgq6b5wj","_id":"cj2otnwqm002g15hls1vjdnah"},{"post_id":"cj2otnwpg000f15hlccmghe2f","tag_id":"cj2otnwpz001915hlxq6ztj7q","_id":"cj2otnwqq002v15hl80xynyo7"},{"post_id":"cj2otnwpg000f15hlccmghe2f","tag_id":"cj2otnwph000h15hlsmmz9bv6","_id":"cj2otnwqr002y15hlm64kucfr"},{"post_id":"cj2otnwpg000f15hlccmghe2f","tag_id":"cj2otnwqo002n15hl8iocijyn","_id":"cj2otnwqt003215hlqfcmiqni"},{"post_id":"cj2otnwpi000j15hl6uf80wp4","tag_id":"cj2otnwpz001915hlxq6ztj7q","_id":"cj2otnwqv003915hltea902tg"},{"post_id":"cj2otnwpi000j15hl6uf80wp4","tag_id":"cj2otnwph000h15hlsmmz9bv6","_id":"cj2otnwqv003c15hlaxe0p0us"},{"post_id":"cj2otnwpi000j15hl6uf80wp4","tag_id":"cj2otnwqs003015hlvo7ouqpm","_id":"cj2otnwqw003f15hl9q1cn3cx"},{"post_id":"cj2otnwpj000l15hljf5uqez2","tag_id":"cj2otnwqu003615hlsst7dtmi","_id":"cj2otnwqy003j15hl86iyo4bj"},{"post_id":"cj2otnwpj000l15hljf5uqez2","tag_id":"cj2otnwqw003d15hlu2da1r2r","_id":"cj2otnwqy003l15hlxzeqtp1w"},{"post_id":"cj2otnwpk000p15hlf6h0ez8g","tag_id":"cj2otnwps001015hlrgq6b5wj","_id":"cj2otnwr0003o15hlc19wktrt"},{"post_id":"cj2otnwpn000r15hl5c4qi0vu","tag_id":"cj2otnwr0003n15hl14xmuq0t","_id":"cj2otnwr2003s15hlfr7nrqcm"},{"post_id":"cj2otnwpn000r15hl5c4qi0vu","tag_id":"cj2otnwr1003q15hlpsitn57v","_id":"cj2otnwr2003t15hlj527072l"},{"post_id":"cj2otnwpp000u15hl2ehnuttw","tag_id":"cj2otnwps001015hlrgq6b5wj","_id":"cj2otnwr2003v15hl1t58ux7z"},{"post_id":"cj2otnwpt001115hlov73itr4","tag_id":"cj2otnwpz001915hlxq6ztj7q","_id":"cj2otnwr4003y15hlx1lvk1p3"},{"post_id":"cj2otnwpt001115hlov73itr4","tag_id":"cj2otnwph000h15hlsmmz9bv6","_id":"cj2otnwr4003z15hlx5gf0s2z"},{"post_id":"cj2otnwpt001115hlov73itr4","tag_id":"cj2otnwqo002n15hl8iocijyn","_id":"cj2otnwr4004115hlr0y9mx3n"},{"post_id":"cj2otnwpv001515hloeygbxoh","tag_id":"cj2otnwr3003x15hlwh0kaac1","_id":"cj2otnwr4004215hl6f5q1u9k"},{"post_id":"cj2otnwpy001815hlhpy5upw0","tag_id":"cj2otnwph000h15hlsmmz9bv6","_id":"cj2otnwr4004515hlze230ei4"},{"post_id":"cj2otnwpy001815hlhpy5upw0","tag_id":"cj2otnwr4004015hlkc3w85xk","_id":"cj2otnwr5004615hlmfboezgh"},{"post_id":"cj2otnwpy001815hlhpy5upw0","tag_id":"cj2otnwr4004315hlbqrx2e7i","_id":"cj2otnwr5004815hl85qg5brw"},{"post_id":"cj2otnwq1001c15hlj5yc928u","tag_id":"cj2otnwr4004415hle2huokza","_id":"cj2otnwr5004a15hl5ouo1amh"},{"post_id":"cj2otnwq1001c15hlj5yc928u","tag_id":"cj2otnwr5004715hltvcrf8yb","_id":"cj2otnwr5004b15hlin17e5kt"},{"post_id":"cj2otnwq2001e15hlua7dg015","tag_id":"cj2otnwr5004915hlhii8i0hi","_id":"cj2otnwr5004e15hlvaqcylpl"},{"post_id":"cj2otnwq2001e15hlua7dg015","tag_id":"cj2otnwr5004c15hlvamytdpc","_id":"cj2otnwr6004f15hlgbyk6cie"},{"post_id":"cj2otnwq4001h15hlpkg6brw0","tag_id":"cj2otnwr5004d15hlbsvroufk","_id":"cj2otnwr6004h15hlrpqpr3al"},{"post_id":"cj2otnwq5001j15hlni12pfx0","tag_id":"cj2otnwr6004g15hl8gvc16o0","_id":"cj2otnwr7004j15hl9rgssb43"},{"post_id":"cj2otnwq9001p15hlvl8zgw0h","tag_id":"cj2otnwr7004i15hl2mbgod7a","_id":"cj2otnwr7004l15hlkw7y3u8h"},{"post_id":"cj2otnwq9001p15hlvl8zgw0h","tag_id":"cj2otnwpz001915hlxq6ztj7q","_id":"cj2otnwr7004m15hlsb1mb4go"},{"post_id":"cj2otnwqf002215hlrjxf7h6i","tag_id":"cj2otnwr7004k15hlnuvnmte2","_id":"cj2otnwr7004o15hlwaxruk5c"},{"post_id":"cj2otnwqi002815hlwf5wlejx","tag_id":"cj2otnwr7004n15hl2ybmanuc","_id":"cj2otnwr9004t15hl8mig1a56"},{"post_id":"cj2otnwqi002815hlwf5wlejx","tag_id":"cj2otnwqw003d15hlu2da1r2r","_id":"cj2otnwr9004u15hl4ypre0s4"},{"post_id":"cj2otnwqi002815hlwf5wlejx","tag_id":"cj2otnwqu003615hlsst7dtmi","_id":"cj2otnwr9004w15hlwnfi6opr"},{"post_id":"cj2otnwqi002815hlwf5wlejx","tag_id":"cj2otnwr8004r15hl1su7alu1","_id":"cj2otnwr9004x15hlxrbvirmw"},{"post_id":"cj2otnwql002c15hlak36388n","tag_id":"cj2otnwr8004s15hlt420i4ps","_id":"cj2otnwra005015hl5gyhe8h8"},{"post_id":"cj2otnwql002c15hlak36388n","tag_id":"cj2otnwr9004v15hlsf029pxy","_id":"cj2otnwra005115hlo84ytf64"},{"post_id":"cj2otnwql002c15hlak36388n","tag_id":"cj2otnwr8004r15hl1su7alu1","_id":"cj2otnwrb005315hl3oihcar8"},{"post_id":"cj2otnwql002f15hllv2kxddz","tag_id":"cj2otnwqs003015hlvo7ouqpm","_id":"cj2otnwrb005415hlxuuibyfm"},{"post_id":"cj2otnwqm002j15hlefx13l6i","tag_id":"cj2otnwqs003015hlvo7ouqpm","_id":"cj2otnwrc005615hlryu0efln"},{"post_id":"cj2otnwqn002l15hln820y3xs","tag_id":"cj2otnwrb005515hlriy92z19","_id":"cj2otnwrc005915hlddu998l8"},{"post_id":"cj2otnwqn002l15hln820y3xs","tag_id":"cj2otnwrc005715hludircska","_id":"cj2otnwrc005a15hlnra7ytxu"},{"post_id":"cj2otnwqn002l15hln820y3xs","tag_id":"cj2otnwpz001915hlxq6ztj7q","_id":"cj2otnwrd005c15hlysgqt9xt"},{"post_id":"cj2otnwqo002q15hl30c6kmfq","tag_id":"cj2otnwpz001915hlxq6ztj7q","_id":"cj2otnwrd005d15hlmxankb13"},{"post_id":"cj2otnwqo002q15hl30c6kmfq","tag_id":"cj2otnwqs003015hlvo7ouqpm","_id":"cj2otnwrd005f15hl0cau1lsg"},{"post_id":"cj2otnwqp002s15hlf2zjqpyb","tag_id":"cj2otnwr8004r15hl1su7alu1","_id":"cj2otnwre005h15hlpa5e2nwn"},{"post_id":"cj2otnwqp002s15hlf2zjqpyb","tag_id":"cj2otnwrd005e15hlvdf9w064","_id":"cj2otnwre005i15hlgcq4k7yp"},{"post_id":"cj2otnwqq002w15hldmzugqsv","tag_id":"cj2otnwr8004r15hl1su7alu1","_id":"cj2otnwrg005l15hl2cmy2i29"},{"post_id":"cj2otnwqq002w15hldmzugqsv","tag_id":"cj2otnwrd005e15hlvdf9w064","_id":"cj2otnwrg005m15hlutklf3fp"},{"post_id":"cj2otnwqr002z15hlpkbhjhvg","tag_id":"cj2otnwrf005k15hluzo3qabw","_id":"cj2otnwrg005o15hlcomezz7c"},{"post_id":"cj2otnwqt003315hl5pypmien","tag_id":"cj2otnwr7004n15hl2ybmanuc","_id":"cj2otnwrh005s15hl18a0e4qb"},{"post_id":"cj2otnwqt003315hl5pypmien","tag_id":"cj2otnwqw003d15hlu2da1r2r","_id":"cj2otnwri005t15hl37tplv1s"},{"post_id":"cj2otnwqt003315hl5pypmien","tag_id":"cj2otnwqu003615hlsst7dtmi","_id":"cj2otnwri005v15hl67lzvdsq"},{"post_id":"cj2otnwqt003315hl5pypmien","tag_id":"cj2otnwpz001915hlxq6ztj7q","_id":"cj2otnwri005w15hljn3h7uqj"},{"post_id":"cj2otnwqu003515hla6ptz6o7","tag_id":"cj2otnwr5004d15hlbsvroufk","_id":"cj2otnwri005y15hltufbouct"},{"post_id":"cj2otnwqu003515hla6ptz6o7","tag_id":"cj2otnwri005u15hlde4i0xmm","_id":"cj2otnwri005z15hlz4lrabn2"},{"post_id":"cj2otnwqu003815hl1fp35sgk","tag_id":"cj2otnwri005x15hlxs2swezj","_id":"cj2otnwri006015hlfjakuv7e"},{"post_id":"cj2ybed9700004rhlnrypz9bc","tag_id":"cj2otnwps001015hlrgq6b5wj","_id":"cj2ybed9d00014rhl98lnavpi"},{"post_id":"cj55eh5y40000cthlgw8s90yl","tag_id":"cj55eh5y90001cthlly1zbzhq","_id":"cj55eh5yh0003cthlnr569hx7"}],"Tag":[{"name":"HTML","_id":"cj2otnwp6000515hltvva0dx5"},{"name":"CSS","_id":"cj2otnwpd000c15hls61kf7l9"},{"name":"Javascript","_id":"cj2otnwph000h15hlsmmz9bv6"},{"name":"node webkit","_id":"cj2otnwpj000n15hl12iaj3n4"},{"name":"前端","_id":"cj2otnwps001015hlrgq6b5wj"},{"name":"Nodejs","_id":"cj2otnwpz001915hlxq6ztj7q"},{"name":"内存","_id":"cj2otnwq3001f15hl2g830lws"},{"name":"书籍","_id":"cj2otnwqa001r15hl2q28jex5"},{"name":"SOAP","_id":"cj2otnwqo002n15hl8iocijyn"},{"name":"Tool Kit","_id":"cj2otnwqs003015hlvo7ouqpm"},{"name":"session","_id":"cj2otnwqu003615hlsst7dtmi"},{"name":"cookie","_id":"cj2otnwqw003d15hlu2da1r2r"},{"name":"编译","_id":"cj2otnwr0003n15hl14xmuq0t"},{"name":"解释","_id":"cj2otnwr1003q15hlpsitn57v"},{"name":"前端构建","_id":"cj2otnwr3003x15hlwh0kaac1"},{"name":"v8","_id":"cj2otnwr4004015hlkc3w85xk"},{"name":"NodeJS","_id":"cj2otnwr4004315hlbqrx2e7i"},{"name":"babel","_id":"cj2otnwr4004415hle2huokza"},{"name":"ES6","_id":"cj2otnwr5004715hltvcrf8yb"},{"name":"效率","_id":"cj2otnwr5004915hlhii8i0hi"},{"name":"专注","_id":"cj2otnwr5004c15hlvamytdpc"},{"name":"http","_id":"cj2otnwr5004d15hlbsvroufk"},{"name":"Nginx","_id":"cj2otnwr6004g15hl8gvc16o0"},{"name":"SailsJS","_id":"cj2otnwr7004i15hl2mbgod7a"},{"name":"语法树","_id":"cj2otnwr7004k15hlnuvnmte2"},{"name":"单点登录","_id":"cj2otnwr7004n15hl2ybmanuc"},{"name":"架构","_id":"cj2otnwr8004r15hl1su7alu1"},{"name":"RESTful","_id":"cj2otnwr8004s15hlt420i4ps"},{"name":"权限系统","_id":"cj2otnwr9004v15hlsf029pxy"},{"name":"mocha","_id":"cj2otnwrb005515hlriy92z19"},{"name":"unit test","_id":"cj2otnwrc005715hludircska"},{"name":"消息系统","_id":"cj2otnwrd005e15hlvdf9w064"},{"name":"ROM","_id":"cj2otnwrf005k15hluzo3qabw"},{"name":"cors","_id":"cj2otnwri005u15hlde4i0xmm"},{"name":"读书笔记","_id":"cj2otnwri005x15hlxs2swezj"},{"name":"javascript","_id":"cj55eh5y90001cthlly1zbzhq"}]}}